/* Generated from Java with JSweet 2.2.0-SNAPSHOT - http://www.jsweet.org */
namespace org.jbox2d.callbacks {
    /**
     * Implement this class to provide collision filtering. In other words, you can implement
     * this class if you want finer control over contact creation.
     * @author Daniel Murphy
     * @class
     */
    export class ContactFilter {
        /**
         * Return true if contact calculations should be performed between these two shapes.
         * @warning for performance reasons this is only called when the AABBs begin to overlap.
         * @param {org.jbox2d.dynamics.Fixture} fixtureA
         * @param {org.jbox2d.dynamics.Fixture} fixtureB
         * @return
         * @return {boolean}
         */
        public shouldCollide(fixtureA : org.jbox2d.dynamics.Fixture, fixtureB : org.jbox2d.dynamics.Fixture) : boolean {
            let filterA : org.jbox2d.dynamics.Filter = fixtureA.getFilterData();
            let filterB : org.jbox2d.dynamics.Filter = fixtureB.getFilterData();
            if(filterA.groupIndex === filterB.groupIndex && filterA.groupIndex !== 0) {
                return filterA.groupIndex > 0;
            }
            let collide : boolean = (filterA.maskBits & filterB.categoryBits) !== 0 && (filterA.categoryBits & filterB.maskBits) !== 0;
            return collide;
        }
    }
    ContactFilter["__class"] = "org.jbox2d.callbacks.ContactFilter";

}
namespace org.jbox2d.callbacks {
    /**
     * Contact impulses for reporting. Impulses are used instead of forces because sub-step forces may
     * approach infinity for rigid body collisions. These match up one-to-one with the contact points in
     * b2Manifold.
     * 
     * @author Daniel Murphy
     * @class
     */
    export class ContactImpulse {
        public normalImpulses : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);

        public tangentImpulses : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);

        public count : number;

        constructor() {
            if(this.count===undefined) this.count = 0;
        }
    }
    ContactImpulse["__class"] = "org.jbox2d.callbacks.ContactImpulse";

}
namespace org.jbox2d.callbacks {
    /**
     * Implement this class to get contact information. You can use these results for
     * things like sounds and game logic. You can also get contact results by
     * traversing the contact lists after the time step. However, you might miss
     * some contacts because continuous physics leads to sub-stepping.
     * Additionally you may receive multiple callbacks for the same contact in a
     * single time step.
     * You should strive to make your callbacks efficient because there may be
     * many callbacks per time step.
     * @warning You cannot create/destroy Box2D entities inside these callbacks.
     * @author Daniel Murphy
     * @class
     */
    export interface ContactListener {
        /**
         * Called when two fixtures begin to touch.
         * @param {org.jbox2d.dynamics.contacts.Contact} contact
         */
        beginContact(contact : org.jbox2d.dynamics.contacts.Contact);

        /**
         * Called when two fixtures cease to touch.
         * @param {org.jbox2d.dynamics.contacts.Contact} contact
         */
        endContact(contact : org.jbox2d.dynamics.contacts.Contact);

        /**
         * This is called after a contact is updated. This allows you to inspect a
         * contact before it goes to the solver. If you are careful, you can modify the
         * contact manifold (e.g. disable contact).
         * A copy of the old manifold is provided so that you can detect changes.
         * Note: this is called only for awake bodies.
         * Note: this is called even when the number of contact points is zero.
         * Note: this is not called for sensors.
         * Note: if you set the number of contact points to zero, you will not
         * get an EndContact callback. However, you may get a BeginContact callback
         * the next step.
         * Note: the oldManifold parameter is pooled, so it will be the same object for every callback
         * for each thread.
         * @param {org.jbox2d.dynamics.contacts.Contact} contact
         * @param {org.jbox2d.collision.Manifold} oldManifold
         */
        preSolve(contact : org.jbox2d.dynamics.contacts.Contact, oldManifold : org.jbox2d.collision.Manifold);

        /**
         * This lets you inspect a contact after the solver is finished. This is useful
         * for inspecting impulses.
         * Note: the contact manifold does not include time of impact impulses, which can be
         * arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly
         * in a separate data structure.
         * Note: this is only called for contacts that are touching, solid, and awake.
         * @param {org.jbox2d.dynamics.contacts.Contact} contact
         * @param {org.jbox2d.callbacks.ContactImpulse} impulse this is usually a pooled variable, so it will be modified after
         * this call
         */
        postSolve(contact : org.jbox2d.dynamics.contacts.Contact, impulse : org.jbox2d.callbacks.ContactImpulse);
    }
}
namespace org.jbox2d.callbacks {
    /**
     * Implement this abstract class to allow JBox2d to automatically draw your physics for debugging
     * purposes. Not intended to replace your own custom rendering routines!
     * 
     * @author Daniel Murphy
     * @param {*} viewport
     * @class
     */
    export abstract class DebugDraw {
        /**
         * Draw shapes
         */
        public static e_shapeBit : number; public static e_shapeBit_$LI$() : number { if(DebugDraw.e_shapeBit == null) DebugDraw.e_shapeBit = 1 << 1; return DebugDraw.e_shapeBit; };

        /**
         * Draw joint connections
         */
        public static e_jointBit : number; public static e_jointBit_$LI$() : number { if(DebugDraw.e_jointBit == null) DebugDraw.e_jointBit = 1 << 2; return DebugDraw.e_jointBit; };

        /**
         * Draw axis aligned bounding boxes
         */
        public static e_aabbBit : number; public static e_aabbBit_$LI$() : number { if(DebugDraw.e_aabbBit == null) DebugDraw.e_aabbBit = 1 << 3; return DebugDraw.e_aabbBit; };

        /**
         * Draw pairs of connected objects
         */
        public static e_pairBit : number; public static e_pairBit_$LI$() : number { if(DebugDraw.e_pairBit == null) DebugDraw.e_pairBit = 1 << 4; return DebugDraw.e_pairBit; };

        /**
         * Draw center of mass frame
         */
        public static e_centerOfMassBit : number; public static e_centerOfMassBit_$LI$() : number { if(DebugDraw.e_centerOfMassBit == null) DebugDraw.e_centerOfMassBit = 1 << 5; return DebugDraw.e_centerOfMassBit; };

        /**
         * Draw dynamic tree
         */
        public static e_dynamicTreeBit : number; public static e_dynamicTreeBit_$LI$() : number { if(DebugDraw.e_dynamicTreeBit == null) DebugDraw.e_dynamicTreeBit = 1 << 6; return DebugDraw.e_dynamicTreeBit; };

        /**
         * Draw only the wireframe for drawing performance
         */
        public static e_wireframeDrawingBit : number; public static e_wireframeDrawingBit_$LI$() : number { if(DebugDraw.e_wireframeDrawingBit == null) DebugDraw.e_wireframeDrawingBit = 1 << 7; return DebugDraw.e_wireframeDrawingBit; };

        m_drawFlags : number;

        viewportTransform : org.jbox2d.common.IViewportTransform;

        public constructor(viewport? : any) {
            if(((viewport != null && (viewport["__interfaces"] != null && viewport["__interfaces"].indexOf("org.jbox2d.common.IViewportTransform") >= 0 || viewport.constructor != null && viewport.constructor["__interfaces"] != null && viewport.constructor["__interfaces"].indexOf("org.jbox2d.common.IViewportTransform") >= 0)) || viewport === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.m_drawFlags===undefined) this.m_drawFlags = 0;
                if(this.viewportTransform===undefined) this.viewportTransform = null;
                if(this.m_drawFlags===undefined) this.m_drawFlags = 0;
                if(this.viewportTransform===undefined) this.viewportTransform = null;
                (() => {
                    this.m_drawFlags = 0;
                    this.viewportTransform = viewport;
                })();
            } else if(viewport === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let viewport : any = null;
                    if(this.m_drawFlags===undefined) this.m_drawFlags = 0;
                    if(this.viewportTransform===undefined) this.viewportTransform = null;
                    if(this.m_drawFlags===undefined) this.m_drawFlags = 0;
                    if(this.viewportTransform===undefined) this.viewportTransform = null;
                    (() => {
                        this.m_drawFlags = 0;
                        this.viewportTransform = viewport;
                    })();
                }
            } else throw new Error('invalid overload');
        }

        public setViewportTransform(viewportTransform : org.jbox2d.common.IViewportTransform) {
            this.viewportTransform = viewportTransform;
        }

        public setFlags(flags : number) {
            this.m_drawFlags = flags;
        }

        public getFlags() : number {
            return this.m_drawFlags;
        }

        public appendFlags(flags : number) {
            this.m_drawFlags |= flags;
        }

        public clearFlags(flags : number) {
            this.m_drawFlags &= ~flags;
        }

        /**
         * Draw a closed polygon provided in CCW order. This implementation uses
         * {@link #drawSegment(Vec2, Vec2, Color3f)} to draw each side of the polygon.
         * 
         * @param {Array} vertices
         * @param {number} vertexCount
         * @param {org.jbox2d.common.Color3f} color
         */
        public drawPolygon(vertices : org.jbox2d.common.Vec2[], vertexCount : number, color : org.jbox2d.common.Color3f) {
            if(vertexCount === 1) {
                this.drawSegment(vertices[0], vertices[0], color);
                return;
            }
            for(let i : number = 0; i < vertexCount - 1; i += 1) {
                this.drawSegment(vertices[i], vertices[i + 1], color);
            };
            if(vertexCount > 2) {
                this.drawSegment(vertices[vertexCount - 1], vertices[0], color);
            }
        }

        public abstract drawPoint(argPoint : org.jbox2d.common.Vec2, argRadiusOnScreen : number, argColor : org.jbox2d.common.Color3f);

        /**
         * Draw a solid closed polygon provided in CCW order.
         * 
         * @param {Array} vertices
         * @param {number} vertexCount
         * @param {org.jbox2d.common.Color3f} color
         */
        public abstract drawSolidPolygon(vertices : org.jbox2d.common.Vec2[], vertexCount : number, color : org.jbox2d.common.Color3f);

        public drawCircle$org_jbox2d_common_Vec2$float$org_jbox2d_common_Color3f(center : org.jbox2d.common.Vec2, radius : number, color : org.jbox2d.common.Color3f) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }

        public drawCircle$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2$org_jbox2d_common_Color3f(center : org.jbox2d.common.Vec2, radius : number, axis : org.jbox2d.common.Vec2, color : org.jbox2d.common.Color3f) {
            this.drawCircle$org_jbox2d_common_Vec2$float$org_jbox2d_common_Color3f(center, radius, color);
        }

        /**
         * Draws a circle with an axis
         * @param {org.jbox2d.common.Vec2} center
         * @param {number} radius
         * @param {org.jbox2d.common.Vec2} axis
         * @param {org.jbox2d.common.Color3f} color
         */
        public drawCircle(center? : any, radius? : any, axis? : any, color? : any) : any {
            if(((center != null && center instanceof <any>org.jbox2d.common.Vec2) || center === null) && ((typeof radius === 'number') || radius === null) && ((axis != null && axis instanceof <any>org.jbox2d.common.Vec2) || axis === null) && ((color != null && color instanceof <any>org.jbox2d.common.Color3f) || color === null)) {
                return <any>this.drawCircle$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2$org_jbox2d_common_Color3f(center, radius, axis, color);
            } else if(((center != null && center instanceof <any>org.jbox2d.common.Vec2) || center === null) && ((typeof radius === 'number') || radius === null) && ((axis != null && axis instanceof <any>org.jbox2d.common.Color3f) || axis === null) && color === undefined) {
                return <any>this.drawCircle$org_jbox2d_common_Vec2$float$org_jbox2d_common_Color3f(center, radius, axis);
            } else throw new Error('invalid overload');
        }

        /**
         * Draw a solid circle.
         * 
         * @param {org.jbox2d.common.Vec2} center
         * @param {number} radius
         * @param {org.jbox2d.common.Vec2} axis
         * @param {org.jbox2d.common.Color3f} color
         */
        public abstract drawSolidCircle(center : org.jbox2d.common.Vec2, radius : number, axis : org.jbox2d.common.Vec2, color : org.jbox2d.common.Color3f);

        /**
         * Draw a line segment.
         * 
         * @param {org.jbox2d.common.Vec2} p1
         * @param {org.jbox2d.common.Vec2} p2
         * @param {org.jbox2d.common.Color3f} color
         */
        public abstract drawSegment(p1 : org.jbox2d.common.Vec2, p2 : org.jbox2d.common.Vec2, color : org.jbox2d.common.Color3f);

        /**
         * Draw a transform. Choose your own length scale
         * 
         * @param {org.jbox2d.common.Transform} xf
         */
        public abstract drawTransform(xf : org.jbox2d.common.Transform);

        public drawString$float$float$java_lang_String$org_jbox2d_common_Color3f(x : number, y : number, s : string, color : org.jbox2d.common.Color3f) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }

        /**
         * Draw a string.
         * 
         * @param {number} x
         * @param {number} y
         * @param {string} s
         * @param {org.jbox2d.common.Color3f} color
         */
        public drawString(x? : any, y? : any, s? : any, color? : any) : any {
            if(((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof s === 'string') || s === null) && ((color != null && color instanceof <any>org.jbox2d.common.Color3f) || color === null)) {
                return <any>this.drawString$float$float$java_lang_String$org_jbox2d_common_Color3f(x, y, s, color);
            } else if(((x != null && x instanceof <any>org.jbox2d.common.Vec2) || x === null) && ((typeof y === 'string') || y === null) && ((s != null && s instanceof <any>org.jbox2d.common.Color3f) || s === null) && color === undefined) {
                return <any>this.drawString$org_jbox2d_common_Vec2$java_lang_String$org_jbox2d_common_Color3f(x, y, s);
            } else throw new Error('invalid overload');
        }

        /**
         * Draw a particle array
         * 
         * @param {Array} colors can be null
         * @param {Array} centers
         * @param {number} radius
         * @param {number} count
         */
        public abstract drawParticles(centers : org.jbox2d.common.Vec2[], radius : number, colors : org.jbox2d.particle.ParticleColor[], count : number);

        /**
         * Draw a particle array
         * 
         * @param {Array} colors can be null
         * @param {Array} centers
         * @param {number} radius
         * @param {number} count
         */
        public abstract drawParticlesWireframe(centers : org.jbox2d.common.Vec2[], radius : number, colors : org.jbox2d.particle.ParticleColor[], count : number);

        /**
         * Called at the end of drawing a world
         */
        public flush() {
        }

        public drawString$org_jbox2d_common_Vec2$java_lang_String$org_jbox2d_common_Color3f(pos : org.jbox2d.common.Vec2, s : string, color : org.jbox2d.common.Color3f) {
            this.drawString$float$float$java_lang_String$org_jbox2d_common_Color3f(pos.x, pos.y, s, color);
        }

        public getViewportTranform() : org.jbox2d.common.IViewportTransform {
            return this.viewportTransform;
        }

        /**
         * @param {number} x
         * @param {number} y
         * @param {number} scale
         * @deprecated use the viewport transform in {@link #getViewportTranform()}
         */
        public setCamera(x : number, y : number, scale : number) {
            this.viewportTransform.setCamera(x, y, scale);
        }

        public getScreenToWorldToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen : org.jbox2d.common.Vec2, argWorld : org.jbox2d.common.Vec2) {
            this.viewportTransform.getScreenToWorld(argScreen, argWorld);
        }

        public getWorldToScreenToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld : org.jbox2d.common.Vec2, argScreen : org.jbox2d.common.Vec2) {
            this.viewportTransform.getWorldToScreen(argWorld, argScreen);
        }

        public getWorldToScreenToOut$float$float$org_jbox2d_common_Vec2(worldX : number, worldY : number, argScreen : org.jbox2d.common.Vec2) {
            argScreen.set$float$float(worldX, worldY);
            this.viewportTransform.getWorldToScreen(argScreen, argScreen);
        }

        /**
         * Takes the world coordinates and puts the corresponding screen coordinates in argScreen.
         * 
         * @param {number} worldX
         * @param {number} worldY
         * @param {org.jbox2d.common.Vec2} argScreen
         */
        public getWorldToScreenToOut(worldX? : any, worldY? : any, argScreen? : any) : any {
            if(((typeof worldX === 'number') || worldX === null) && ((typeof worldY === 'number') || worldY === null) && ((argScreen != null && argScreen instanceof <any>org.jbox2d.common.Vec2) || argScreen === null)) {
                return <any>this.getWorldToScreenToOut$float$float$org_jbox2d_common_Vec2(worldX, worldY, argScreen);
            } else if(((worldX != null && worldX instanceof <any>org.jbox2d.common.Vec2) || worldX === null) && ((worldY != null && worldY instanceof <any>org.jbox2d.common.Vec2) || worldY === null) && argScreen === undefined) {
                return <any>this.getWorldToScreenToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(worldX, worldY);
            } else throw new Error('invalid overload');
        }

        public getWorldToScreen$org_jbox2d_common_Vec2(argWorld : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let screen : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.viewportTransform.getWorldToScreen(argWorld, screen);
            return screen;
        }

        public getWorldToScreen$float$float(worldX : number, worldY : number) : org.jbox2d.common.Vec2 {
            let argScreen : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(worldX, worldY);
            this.viewportTransform.getWorldToScreen(argScreen, argScreen);
            return argScreen;
        }

        /**
         * Takes the world coordinates and returns the screen coordinates.
         * 
         * @param {number} worldX
         * @param {number} worldY
         * @return {org.jbox2d.common.Vec2}
         */
        public getWorldToScreen(worldX? : any, worldY? : any) : any {
            if(((typeof worldX === 'number') || worldX === null) && ((typeof worldY === 'number') || worldY === null)) {
                return <any>this.getWorldToScreen$float$float(worldX, worldY);
            } else if(((worldX != null && worldX instanceof <any>org.jbox2d.common.Vec2) || worldX === null) && worldY === undefined) {
                return <any>this.getWorldToScreen$org_jbox2d_common_Vec2(worldX);
            } else throw new Error('invalid overload');
        }

        public getScreenToWorldToOut$float$float$org_jbox2d_common_Vec2(screenX : number, screenY : number, argWorld : org.jbox2d.common.Vec2) {
            argWorld.set$float$float(screenX, screenY);
            this.viewportTransform.getScreenToWorld(argWorld, argWorld);
        }

        /**
         * takes the screen coordinates and puts the corresponding world coordinates in argWorld.
         * 
         * @param {number} screenX
         * @param {number} screenY
         * @param {org.jbox2d.common.Vec2} argWorld
         */
        public getScreenToWorldToOut(screenX? : any, screenY? : any, argWorld? : any) : any {
            if(((typeof screenX === 'number') || screenX === null) && ((typeof screenY === 'number') || screenY === null) && ((argWorld != null && argWorld instanceof <any>org.jbox2d.common.Vec2) || argWorld === null)) {
                return <any>this.getScreenToWorldToOut$float$float$org_jbox2d_common_Vec2(screenX, screenY, argWorld);
            } else if(((screenX != null && screenX instanceof <any>org.jbox2d.common.Vec2) || screenX === null) && ((screenY != null && screenY instanceof <any>org.jbox2d.common.Vec2) || screenY === null) && argWorld === undefined) {
                return <any>this.getScreenToWorldToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(screenX, screenY);
            } else throw new Error('invalid overload');
        }

        public getScreenToWorld$org_jbox2d_common_Vec2(argScreen : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let world : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.viewportTransform.getScreenToWorld(argScreen, world);
            return world;
        }

        public getScreenToWorld$float$float(screenX : number, screenY : number) : org.jbox2d.common.Vec2 {
            let screen : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(screenX, screenY);
            this.viewportTransform.getScreenToWorld(screen, screen);
            return screen;
        }

        /**
         * takes the screen coordinates and returns the world coordinates.
         * 
         * @param {number} screenX
         * @param {number} screenY
         * @return {org.jbox2d.common.Vec2}
         */
        public getScreenToWorld(screenX? : any, screenY? : any) : any {
            if(((typeof screenX === 'number') || screenX === null) && ((typeof screenY === 'number') || screenY === null)) {
                return <any>this.getScreenToWorld$float$float(screenX, screenY);
            } else if(((screenX != null && screenX instanceof <any>org.jbox2d.common.Vec2) || screenX === null) && screenY === undefined) {
                return <any>this.getScreenToWorld$org_jbox2d_common_Vec2(screenX);
            } else throw new Error('invalid overload');
        }
    }
    DebugDraw["__class"] = "org.jbox2d.callbacks.DebugDraw";

}
namespace org.jbox2d.callbacks {
    /**
     * Joints and fixtures are destroyed when their associated
     * body is destroyed. Implement this listener so that you
     * may nullify references to these joints and shapes.
     * @author Daniel Murphy
     * @class
     */
    export interface DestructionListener {
        /**
         * Called when any joint is about to be destroyed due
         * to the destruction of one of its attached bodies.
         * @param {org.jbox2d.dynamics.joints.Joint} joint
         */
        sayGoodbye(joint? : any) : any;
    }
}
namespace org.jbox2d.callbacks {
    export interface PairCallback {
        addPair(userDataA : any, userDataB : any);
    }
}
namespace org.jbox2d.callbacks {
    export interface ParticleDestructionListener {
        /**
         * Called when any particle group is about to be destroyed.
         * @param {org.jbox2d.particle.ParticleGroup} group
         */
        sayGoodbye(group? : any) : any;
    }
}
namespace org.jbox2d.callbacks {
    /**
     * Callback class for AABB queries. See
     * {@link World#queryAABB(QueryCallback, org.jbox2d.collision.AABB)}.
     * 
     * @author dmurph
     * 
     * @class
     */
    export interface ParticleQueryCallback {
        /**
         * Called for each particle found in the query AABB.
         * 
         * @return {boolean} false to terminate the query.
         * @param {number} index
         */
        reportParticle(index : number) : boolean;
    }
}
namespace org.jbox2d.callbacks {
    export interface ParticleRaycastCallback {
        /**
         * Called for each particle found in the query. See
         * {@link RayCastCallback#reportFixture(org.jbox2d.dynamics.Fixture, Vec2, Vec2, float)} for
         * argument info.
         * 
         * @param {number} index
         * @param {org.jbox2d.common.Vec2} point
         * @param {org.jbox2d.common.Vec2} normal
         * @param {number} fraction
         * @return
         * @return {number}
         */
        reportParticle(index : number, point : org.jbox2d.common.Vec2, normal : org.jbox2d.common.Vec2, fraction : number) : number;
    }
}
namespace org.jbox2d.callbacks {
    /**
     * Callback class for AABB queries.
     * See {@link World#queryAABB(QueryCallback, org.jbox2d.collision.AABB)}.
     * @author Daniel Murphy
     * @class
     */
    export interface QueryCallback {
        /**
         * Called for each fixture found in the query AABB.
         * @param {org.jbox2d.dynamics.Fixture} fixture
         * @return {boolean} false to terminate the query.
         */
        reportFixture(fixture : org.jbox2d.dynamics.Fixture) : boolean;
    }
}
namespace org.jbox2d.callbacks {
    /**
     * Callback class for ray casts.
     * See {@link World#raycast(RayCastCallback, Vec2, Vec2)}
     * @author Daniel Murphy
     * @class
     */
    export interface RayCastCallback {
        /**
         * Called for each fixture found in the query. You control how the ray cast
         * proceeds by returning a float:
         * return -1: ignore this fixture and continue
         * return 0: terminate the ray cast
         * return fraction: clip the ray to this point
         * return 1: don't clip the ray and continue
         * @param {org.jbox2d.dynamics.Fixture} fixture the fixture hit by the ray
         * @param {org.jbox2d.common.Vec2} point the point of initial intersection
         * @param {org.jbox2d.common.Vec2} normal the normal vector at the point of intersection
         * @return {number} -1 to filter, 0 to terminate, fraction to clip the ray for
         * closest hit, 1 to continue
         * @param {number} fraction
         */
        reportFixture(fixture : org.jbox2d.dynamics.Fixture, point : org.jbox2d.common.Vec2, normal : org.jbox2d.common.Vec2, fraction : number) : number;
    }
}
namespace org.jbox2d.callbacks {
    /**
     * callback for {@link DynamicTree}
     * @author Daniel Murphy
     * @class
     */
    export interface TreeCallback {
        /**
         * Callback from a query request.
         * @param {number} proxyId the id of the proxy
         * @return {boolean} if the query should be continued
         */
        treeCallback(proxyId : number) : boolean;
    }
}
namespace org.jbox2d.callbacks {
    /**
     * callback for {@link DynamicTree}
     * @author Daniel Murphy
     * @class
     */
    export interface TreeRayCastCallback {
        /**
         * 
         * @param {org.jbox2d.collision.RayCastInput} input
         * @param {number} nodeId
         * @return {number} the fraction to the node
         */
        raycastCallback(input : org.jbox2d.collision.RayCastInput, nodeId : number) : number;
    }
}
namespace org.jbox2d.collision {
    /**
     * Creates an AABB object using the given bounding vertices.
     * 
     * @param {org.jbox2d.common.Vec2} lowerVertex the bottom left vertex of the bounding box
     * @param maxVertex the top right vertex of the bounding box
     * @param {org.jbox2d.common.Vec2} upperVertex
     * @class
     */
    export class AABB {
        /**
         * Bottom left vertex of bounding box.
         */
        public lowerBound : org.jbox2d.common.Vec2;

        /**
         * Top right vertex of bounding box.
         */
        public upperBound : org.jbox2d.common.Vec2;

        public constructor(lowerVertex? : any, upperVertex? : any) {
            if(((lowerVertex != null && lowerVertex instanceof <any>org.jbox2d.common.Vec2) || lowerVertex === null) && ((upperVertex != null && upperVertex instanceof <any>org.jbox2d.common.Vec2) || upperVertex === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.lowerBound===undefined) this.lowerBound = null;
                if(this.upperBound===undefined) this.upperBound = null;
                if(this.lowerBound===undefined) this.lowerBound = null;
                if(this.upperBound===undefined) this.upperBound = null;
                (() => {
                    this.lowerBound = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(lowerVertex);
                    this.upperBound = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(upperVertex);
                })();
            } else if(((lowerVertex != null && lowerVertex instanceof <any>org.jbox2d.collision.AABB) || lowerVertex === null) && upperVertex === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let copy : any = __args[0];
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let lowerVertex : any = copy.lowerBound;
                    let upperVertex : any = copy.upperBound;
                    if(this.lowerBound===undefined) this.lowerBound = null;
                    if(this.upperBound===undefined) this.upperBound = null;
                    if(this.lowerBound===undefined) this.lowerBound = null;
                    if(this.upperBound===undefined) this.upperBound = null;
                    (() => {
                        this.lowerBound = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(lowerVertex);
                        this.upperBound = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(upperVertex);
                    })();
                }
            } else if(lowerVertex === undefined && upperVertex === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.lowerBound===undefined) this.lowerBound = null;
                if(this.upperBound===undefined) this.upperBound = null;
                if(this.lowerBound===undefined) this.lowerBound = null;
                if(this.upperBound===undefined) this.upperBound = null;
                (() => {
                    this.lowerBound = new org.jbox2d.common.Vec2();
                    this.upperBound = new org.jbox2d.common.Vec2();
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * Sets this object from the given object
         * 
         * @param {org.jbox2d.collision.AABB} aabb the object to copy from
         */
        public set(aabb : AABB) {
            let v : org.jbox2d.common.Vec2 = aabb.lowerBound;
            this.lowerBound.x = v.x;
            this.lowerBound.y = v.y;
            let v1 : org.jbox2d.common.Vec2 = aabb.upperBound;
            this.upperBound.x = v1.x;
            this.upperBound.y = v1.y;
        }

        /**
         * Verify that the bounds are sorted
         * @return {boolean}
         */
        public isValid() : boolean {
            let dx : number = (<any>Math).fround(this.upperBound.x - this.lowerBound.x);
            if(dx < 0.0) {
                return false;
            }
            let dy : number = (<any>Math).fround(this.upperBound.y - this.lowerBound.y);
            if(dy < 0) {
                return false;
            }
            return this.lowerBound.isValid() && this.upperBound.isValid();
        }

        /**
         * Get the center of the AABB
         * 
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public getCenter() : org.jbox2d.common.Vec2 {
            let center : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(this.lowerBound);
            center.addLocal$org_jbox2d_common_Vec2(this.upperBound);
            center.mulLocal(0.5);
            return center;
        }

        public getCenterToOut(out : org.jbox2d.common.Vec2) {
            out.x = (<any>Math).fround(((<any>Math).fround(this.lowerBound.x + this.upperBound.x)) * 0.5);
            out.y = (<any>Math).fround(((<any>Math).fround(this.lowerBound.y + this.upperBound.y)) * 0.5);
        }

        /**
         * Get the extents of the AABB (half-widths).
         * 
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public getExtents() : org.jbox2d.common.Vec2 {
            let center : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(this.upperBound);
            center.subLocal(this.lowerBound);
            center.mulLocal(0.5);
            return center;
        }

        public getExtentsToOut(out : org.jbox2d.common.Vec2) {
            out.x = (<any>Math).fround(((<any>Math).fround(this.upperBound.x - this.lowerBound.x)) * 0.5);
            out.y = (<any>Math).fround(((<any>Math).fround(this.upperBound.y - this.lowerBound.y)) * 0.5);
        }

        public getVertices(argRay : org.jbox2d.common.Vec2[]) {
            argRay[0].set$org_jbox2d_common_Vec2(this.lowerBound);
            argRay[1].set$org_jbox2d_common_Vec2(this.lowerBound);
            argRay[1].x += (<any>Math).fround(this.upperBound.x - this.lowerBound.x);
            argRay[2].set$org_jbox2d_common_Vec2(this.upperBound);
            argRay[3].set$org_jbox2d_common_Vec2(this.upperBound);
            argRay[3].x -= (<any>Math).fround(this.upperBound.x - this.lowerBound.x);
        }

        public combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(aabb1 : AABB, aab : AABB) {
            this.lowerBound.x = aabb1.lowerBound.x < aab.lowerBound.x?aabb1.lowerBound.x:aab.lowerBound.x;
            this.lowerBound.y = aabb1.lowerBound.y < aab.lowerBound.y?aabb1.lowerBound.y:aab.lowerBound.y;
            this.upperBound.x = aabb1.upperBound.x > aab.upperBound.x?aabb1.upperBound.x:aab.upperBound.x;
            this.upperBound.y = aabb1.upperBound.y > aab.upperBound.y?aabb1.upperBound.y:aab.upperBound.y;
        }

        /**
         * Combine two AABBs into this one.
         * 
         * @param {org.jbox2d.collision.AABB} aabb1
         * @param {org.jbox2d.collision.AABB} aab
         */
        public combine(aabb1? : any, aab? : any) : any {
            if(((aabb1 != null && aabb1 instanceof <any>org.jbox2d.collision.AABB) || aabb1 === null) && ((aab != null && aab instanceof <any>org.jbox2d.collision.AABB) || aab === null)) {
                return <any>this.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(aabb1, aab);
            } else if(((aabb1 != null && aabb1 instanceof <any>org.jbox2d.collision.AABB) || aabb1 === null) && aab === undefined) {
                return <any>this.combine$org_jbox2d_collision_AABB(aabb1);
            } else throw new Error('invalid overload');
        }

        /**
         * Gets the perimeter length
         * 
         * @return
         * @return {number}
         */
        public getPerimeter() : number {
            return (<any>Math).fround(2.0 * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.upperBound.x - this.lowerBound.x) + this.upperBound.y) - this.lowerBound.y)));
        }

        public combine$org_jbox2d_collision_AABB(aabb : AABB) {
            this.lowerBound.x = this.lowerBound.x < aabb.lowerBound.x?this.lowerBound.x:aabb.lowerBound.x;
            this.lowerBound.y = this.lowerBound.y < aabb.lowerBound.y?this.lowerBound.y:aabb.lowerBound.y;
            this.upperBound.x = this.upperBound.x > aabb.upperBound.x?this.upperBound.x:aabb.upperBound.x;
            this.upperBound.y = this.upperBound.y > aabb.upperBound.y?this.upperBound.y:aabb.upperBound.y;
        }

        /**
         * Does this aabb contain the provided AABB.
         * 
         * @return
         * @param {org.jbox2d.collision.AABB} aabb
         * @return {boolean}
         */
        public contains(aabb : AABB) : boolean {
            return this.lowerBound.x <= aabb.lowerBound.x && this.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= this.upperBound.x && aabb.upperBound.y <= this.upperBound.y;
        }

        public raycast$org_jbox2d_collision_RayCastOutput$org_jbox2d_collision_RayCastInput(output : org.jbox2d.collision.RayCastOutput, input : org.jbox2d.collision.RayCastInput) : boolean {
            return this.raycast$org_jbox2d_collision_RayCastOutput$org_jbox2d_collision_RayCastInput$org_jbox2d_pooling_IWorldPool(output, input, new org.jbox2d.pooling.normal.DefaultWorldPool(4, 4));
        }

        public raycast$org_jbox2d_collision_RayCastOutput$org_jbox2d_collision_RayCastInput$org_jbox2d_pooling_IWorldPool(output : org.jbox2d.collision.RayCastOutput, input : org.jbox2d.collision.RayCastInput, argPool : org.jbox2d.pooling.IWorldPool) : boolean {
            let tmin : number = -Number.MAX_VALUE;
            let tmax : number = Number.MAX_VALUE;
            let p : org.jbox2d.common.Vec2 = argPool.popVec2();
            let d : org.jbox2d.common.Vec2 = argPool.popVec2();
            let absD : org.jbox2d.common.Vec2 = argPool.popVec2();
            let normal : org.jbox2d.common.Vec2 = argPool.popVec2();
            p.set$org_jbox2d_common_Vec2(input.p1);
            d.set$org_jbox2d_common_Vec2(input.p2).subLocal(input.p1);
            org.jbox2d.common.Vec2.absToOut(d, absD);
            if(absD.x < org.jbox2d.common.Settings.EPSILON) {
                if(p.x < this.lowerBound.x || this.upperBound.x < p.x) {
                    argPool.pushVec2(4);
                    return false;
                }
            } else {
                let inv_d : number = (<any>Math).fround(1.0 / d.x);
                let t1 : number = (<any>Math).fround(((<any>Math).fround(this.lowerBound.x - p.x)) * inv_d);
                let t2 : number = (<any>Math).fround(((<any>Math).fround(this.upperBound.x - p.x)) * inv_d);
                let s : number = -1.0;
                if(t1 > t2) {
                    let temp : number = t1;
                    t1 = t2;
                    t2 = temp;
                    s = 1.0;
                }
                if(t1 > tmin) {
                    normal.setZero();
                    normal.x = s;
                    tmin = t1;
                }
                tmax = org.jbox2d.common.MathUtils.min$float$float(tmax, t2);
                if(tmin > tmax) {
                    argPool.pushVec2(4);
                    return false;
                }
            }
            if(absD.y < org.jbox2d.common.Settings.EPSILON) {
                if(p.y < this.lowerBound.y || this.upperBound.y < p.y) {
                    argPool.pushVec2(4);
                    return false;
                }
            } else {
                let inv_d : number = (<any>Math).fround(1.0 / d.y);
                let t1 : number = (<any>Math).fround(((<any>Math).fround(this.lowerBound.y - p.y)) * inv_d);
                let t2 : number = (<any>Math).fround(((<any>Math).fround(this.upperBound.y - p.y)) * inv_d);
                let s : number = -1.0;
                if(t1 > t2) {
                    let temp : number = t1;
                    t1 = t2;
                    t2 = temp;
                    s = 1.0;
                }
                if(t1 > tmin) {
                    normal.setZero();
                    normal.y = s;
                    tmin = t1;
                }
                tmax = org.jbox2d.common.MathUtils.min$float$float(tmax, t2);
                if(tmin > tmax) {
                    argPool.pushVec2(4);
                    return false;
                }
            }
            if(tmin < 0.0 || input.maxFraction < tmin) {
                argPool.pushVec2(4);
                return false;
            }
            output.fraction = tmin;
            output.normal.x = normal.x;
            output.normal.y = normal.y;
            argPool.pushVec2(4);
            return true;
        }

        /**
         * From Real-time Collision Detection, p179.
         * 
         * @param {org.jbox2d.collision.RayCastOutput} output
         * @param {org.jbox2d.collision.RayCastInput} input
         * @param {*} argPool
         * @return {boolean}
         */
        public raycast(output? : any, input? : any, argPool? : any) : any {
            if(((output != null && output instanceof <any>org.jbox2d.collision.RayCastOutput) || output === null) && ((input != null && input instanceof <any>org.jbox2d.collision.RayCastInput) || input === null) && ((argPool != null && (argPool["__interfaces"] != null && argPool["__interfaces"].indexOf("org.jbox2d.pooling.IWorldPool") >= 0 || argPool.constructor != null && argPool.constructor["__interfaces"] != null && argPool.constructor["__interfaces"].indexOf("org.jbox2d.pooling.IWorldPool") >= 0)) || argPool === null)) {
                return <any>this.raycast$org_jbox2d_collision_RayCastOutput$org_jbox2d_collision_RayCastInput$org_jbox2d_pooling_IWorldPool(output, input, argPool);
            } else if(((output != null && output instanceof <any>org.jbox2d.collision.RayCastOutput) || output === null) && ((input != null && input instanceof <any>org.jbox2d.collision.RayCastInput) || input === null) && argPool === undefined) {
                return <any>this.raycast$org_jbox2d_collision_RayCastOutput$org_jbox2d_collision_RayCastInput(output, input);
            } else throw new Error('invalid overload');
        }

        public static testOverlap(a : AABB, b : AABB) : boolean {
            if((<any>Math).fround(b.lowerBound.x - a.upperBound.x) > 0.0 || (<any>Math).fround(b.lowerBound.y - a.upperBound.y) > 0.0) {
                return false;
            }
            if((<any>Math).fround(a.lowerBound.x - b.upperBound.x) > 0.0 || (<any>Math).fround(a.lowerBound.y - b.upperBound.y) > 0.0) {
                return false;
            }
            return true;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let s : string = "AABB[" + this.lowerBound + " . " + this.upperBound + "]";
            return s;
        }
    }
    AABB["__class"] = "org.jbox2d.collision.AABB";

}
namespace org.jbox2d.collision.broadphase {
    export interface BroadPhase {
        /**
         * Create a proxy with an initial AABB. Pairs are not reported until updatePairs is called.
         * 
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {*} userData
         * @return
         * @return {number}
         */
        createProxy(aabb : org.jbox2d.collision.AABB, userData : any) : number;

        /**
         * Destroy a proxy. It is up to the client to remove any pairs.
         * 
         * @param {number} proxyId
         */
        destroyProxy(proxyId : number);

        /**
         * Call MoveProxy as many times as you like, then when you are done call UpdatePairs to finalized
         * the proxy pairs (for your time step).
         * @param {number} proxyId
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.Vec2} displacement
         */
        moveProxy(proxyId : number, aabb : org.jbox2d.collision.AABB, displacement : org.jbox2d.common.Vec2);

        touchProxy(proxyId : number);

        getUserData(proxyId : number) : any;

        getFatAABB(proxyId : number) : org.jbox2d.collision.AABB;

        testOverlap(proxyIdA : number, proxyIdB : number) : boolean;

        /**
         * Get the number of proxies.
         * 
         * @return
         * @return {number}
         */
        getProxyCount() : number;

        drawTree(argDraw : org.jbox2d.callbacks.DebugDraw);

        /**
         * Update the pairs. This results in pair callbacks. This can only add pairs.
         * 
         * @param {*} callback
         */
        updatePairs(callback : org.jbox2d.callbacks.PairCallback);

        /**
         * Query an AABB for overlapping proxies. The callback class is called for each proxy that
         * overlaps the supplied AABB.
         * 
         * @param {*} callback
         * @param {org.jbox2d.collision.AABB} aabb
         */
        query(callback : org.jbox2d.callbacks.TreeCallback, aabb : org.jbox2d.collision.AABB);

        /**
         * Ray-cast against the proxies in the tree. This relies on the callback to perform a exact
         * ray-cast in the case were the proxy contains a shape. The callback also performs the any
         * collision filtering. This has performance roughly equal to k * log(n), where k is the number of
         * collisions and n is the number of proxies in the tree.
         * 
         * @param {org.jbox2d.collision.RayCastInput} input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
         * @param {*} callback a callback class that is called for each proxy that is hit by the ray.
         */
        raycast(callback : org.jbox2d.callbacks.TreeRayCastCallback, input : org.jbox2d.collision.RayCastInput);

        /**
         * Get the height of the embedded tree.
         * 
         * @return
         * @return {number}
         */
        getTreeHeight() : number;

        getTreeBalance() : number;

        getTreeQuality() : number;
    }

    export namespace BroadPhase {

        export let NULL_PROXY : number = -1;
    }

}
namespace org.jbox2d.collision.broadphase {
    export interface BroadPhaseStrategy {
        /**
         * Create a proxy. Provide a tight fitting AABB and a userData pointer.
         * 
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {*} userData
         * @return
         * @return {number}
         */
        createProxy(aabb : org.jbox2d.collision.AABB, userData : any) : number;

        /**
         * Destroy a proxy
         * 
         * @param {number} proxyId
         */
        destroyProxy(proxyId : number);

        /**
         * Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB, then the
         * proxy is removed from the tree and re-inserted. Otherwise the function returns immediately.
         * 
         * @return {boolean} true if the proxy was re-inserted.
         * @param {number} proxyId
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.Vec2} displacement
         */
        moveProxy(proxyId : number, aabb : org.jbox2d.collision.AABB, displacement : org.jbox2d.common.Vec2) : boolean;

        getUserData(proxyId : number) : any;

        getFatAABB(proxyId : number) : org.jbox2d.collision.AABB;

        /**
         * Query an AABB for overlapping proxies. The callback class is called for each proxy that
         * overlaps the supplied AABB.
         * 
         * @param {*} callback
         * @param araabbgAABB
         * @param {org.jbox2d.collision.AABB} aabb
         */
        query(callback : org.jbox2d.callbacks.TreeCallback, aabb : org.jbox2d.collision.AABB);

        /**
         * Ray-cast against the proxies in the tree. This relies on the callback to perform a exact
         * ray-cast in the case were the proxy contains a shape. The callback also performs the any
         * collision filtering. This has performance roughly equal to k * log(n), where k is the number of
         * collisions and n is the number of proxies in the tree.
         * 
         * @param {org.jbox2d.collision.RayCastInput} input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
         * @param {*} callback a callback class that is called for each proxy that is hit by the ray.
         */
        raycast(callback : org.jbox2d.callbacks.TreeRayCastCallback, input : org.jbox2d.collision.RayCastInput);

        computeHeight(node? : any) : any;

        /**
         * Compute the height of the binary tree in O(N) time. Should not be called often.
         * 
         * @return
         * @return {number}
         */
        getHeight() : number;

        /**
         * Get the maximum balance of an node in the tree. The balance is the difference in height of the
         * two children of a node.
         * 
         * @return
         * @return {number}
         */
        getMaxBalance() : number;

        /**
         * Get the ratio of the sum of the node areas to the root area.
         * 
         * @return
         * @return {number}
         */
        getAreaRatio() : number;

        drawTree(argDraw? : any, node? : any, spot? : any, height? : any) : any;
    }
}
namespace org.jbox2d.collision.broadphase {
    /**
     * The broad-phase is used for computing pairs and performing volume queries and ray casts. This
     * broad-phase does not persist pairs. Instead, this reports potentially new pairs. It is up to the
     * client to consume the new pairs and to track subsequent overlap.
     * 
     * @author Daniel Murphy
     * @param {*} strategy
     * @class
     */
    export class DefaultBroadPhaseBuffer implements org.jbox2d.callbacks.TreeCallback, org.jbox2d.collision.broadphase.BroadPhase {
        /*private*/ m_tree : org.jbox2d.collision.broadphase.BroadPhaseStrategy;

        /*private*/ m_proxyCount : number;

        /*private*/ m_moveBuffer : number[];

        /*private*/ m_moveCapacity : number;

        /*private*/ m_moveCount : number;

        /*private*/ m_pairBuffer : org.jbox2d.collision.broadphase.Pair[];

        /*private*/ m_pairCapacity : number;

        /*private*/ m_pairCount : number;

        /*private*/ m_queryProxyId : number;

        public constructor(strategy : org.jbox2d.collision.broadphase.BroadPhaseStrategy) {
            if(this.m_tree===undefined) this.m_tree = null;
            if(this.m_proxyCount===undefined) this.m_proxyCount = 0;
            if(this.m_moveBuffer===undefined) this.m_moveBuffer = null;
            if(this.m_moveCapacity===undefined) this.m_moveCapacity = 0;
            if(this.m_moveCount===undefined) this.m_moveCount = 0;
            if(this.m_pairBuffer===undefined) this.m_pairBuffer = null;
            if(this.m_pairCapacity===undefined) this.m_pairCapacity = 0;
            if(this.m_pairCount===undefined) this.m_pairCount = 0;
            if(this.m_queryProxyId===undefined) this.m_queryProxyId = 0;
            this.m_proxyCount = 0;
            this.m_pairCapacity = 16;
            this.m_pairCount = 0;
            this.m_pairBuffer = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_pairCapacity);
            for(let i : number = 0; i < this.m_pairCapacity; i++) {
                this.m_pairBuffer[i] = new org.jbox2d.collision.broadphase.Pair();
            };
            this.m_moveCapacity = 16;
            this.m_moveCount = 0;
            this.m_moveBuffer = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.m_moveCapacity);
            this.m_tree = strategy;
            this.m_queryProxyId = org.jbox2d.collision.broadphase.BroadPhase.NULL_PROXY;
        }

        /**
         * 
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {*} userData
         * @return {number}
         */
        public createProxy(aabb : org.jbox2d.collision.AABB, userData : any) : number {
            let proxyId : number = this.m_tree.createProxy(aabb, userData);
            ++this.m_proxyCount;
            this.bufferMove(proxyId);
            return proxyId;
        }

        /**
         * 
         * @param {number} proxyId
         */
        public destroyProxy(proxyId : number) {
            this.unbufferMove(proxyId);
            --this.m_proxyCount;
            this.m_tree.destroyProxy(proxyId);
        }

        /**
         * 
         * @param {number} proxyId
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.Vec2} displacement
         */
        public moveProxy(proxyId : number, aabb : org.jbox2d.collision.AABB, displacement : org.jbox2d.common.Vec2) {
            let buffer : boolean = this.m_tree.moveProxy(proxyId, aabb, displacement);
            if(buffer) {
                this.bufferMove(proxyId);
            }
        }

        /**
         * 
         * @param {number} proxyId
         */
        public touchProxy(proxyId : number) {
            this.bufferMove(proxyId);
        }

        /**
         * 
         * @param {number} proxyId
         * @return {*}
         */
        public getUserData(proxyId : number) : any {
            return this.m_tree.getUserData(proxyId);
        }

        /**
         * 
         * @param {number} proxyId
         * @return {org.jbox2d.collision.AABB}
         */
        public getFatAABB(proxyId : number) : org.jbox2d.collision.AABB {
            return this.m_tree.getFatAABB(proxyId);
        }

        /**
         * 
         * @param {number} proxyIdA
         * @param {number} proxyIdB
         * @return {boolean}
         */
        public testOverlap(proxyIdA : number, proxyIdB : number) : boolean {
            let a : org.jbox2d.collision.AABB = this.m_tree.getFatAABB(proxyIdA);
            let b : org.jbox2d.collision.AABB = this.m_tree.getFatAABB(proxyIdB);
            if((<any>Math).fround(b.lowerBound.x - a.upperBound.x) > 0.0 || (<any>Math).fround(b.lowerBound.y - a.upperBound.y) > 0.0) {
                return false;
            }
            if((<any>Math).fround(a.lowerBound.x - b.upperBound.x) > 0.0 || (<any>Math).fround(a.lowerBound.y - b.upperBound.y) > 0.0) {
                return false;
            }
            return true;
        }

        /**
         * 
         * @return {number}
         */
        public getProxyCount() : number {
            return this.m_proxyCount;
        }

        /**
         * 
         * @param {org.jbox2d.callbacks.DebugDraw} argDraw
         */
        public drawTree(argDraw : org.jbox2d.callbacks.DebugDraw) {
            this.m_tree['drawTree$org_jbox2d_callbacks_DebugDraw'](argDraw);
        }

        /**
         * 
         * @param {*} callback
         */
        public updatePairs(callback : org.jbox2d.callbacks.PairCallback) {
            this.m_pairCount = 0;
            for(let i : number = 0; i < this.m_moveCount; ++i) {
                this.m_queryProxyId = this.m_moveBuffer[i];
                if(this.m_queryProxyId === org.jbox2d.collision.broadphase.BroadPhase.NULL_PROXY) {
                    continue;
                }
                let fatAABB : org.jbox2d.collision.AABB = this.m_tree.getFatAABB(this.m_queryProxyId);
                this.m_tree.query(this, fatAABB);
            };
            this.m_moveCount = 0;
            /* sort */((arr, start, end, f?) => ((arr1, arr2) => arr1.splice.apply(arr1, (<any[]>[start, arr2.length]).concat(arr2)))(this.m_pairBuffer, this.m_pairBuffer.slice(start, end).sort(f)))(this.m_pairBuffer, 0, this.m_pairCount);
            let i : number = 0;
            while((i < this.m_pairCount)) {
                let primaryPair : org.jbox2d.collision.broadphase.Pair = this.m_pairBuffer[i];
                let userDataA : any = this.m_tree.getUserData(primaryPair.proxyIdA);
                let userDataB : any = this.m_tree.getUserData(primaryPair.proxyIdB);
                callback.addPair(userDataA, userDataB);
                ++i;
                while((i < this.m_pairCount)) {
                    let pair : org.jbox2d.collision.broadphase.Pair = this.m_pairBuffer[i];
                    if(pair.proxyIdA !== primaryPair.proxyIdA || pair.proxyIdB !== primaryPair.proxyIdB) {
                        break;
                    }
                    ++i;
                };
            };
        }

        /**
         * 
         * @param {*} callback
         * @param {org.jbox2d.collision.AABB} aabb
         */
        public query(callback : org.jbox2d.callbacks.TreeCallback, aabb : org.jbox2d.collision.AABB) {
            this.m_tree.query(callback, aabb);
        }

        /**
         * 
         * @param {*} callback
         * @param {org.jbox2d.collision.RayCastInput} input
         */
        public raycast(callback : org.jbox2d.callbacks.TreeRayCastCallback, input : org.jbox2d.collision.RayCastInput) {
            this.m_tree.raycast(callback, input);
        }

        /**
         * 
         * @return {number}
         */
        public getTreeHeight() : number {
            return this.m_tree.getHeight();
        }

        /**
         * 
         * @return {number}
         */
        public getTreeBalance() : number {
            return this.m_tree.getMaxBalance();
        }

        /**
         * 
         * @return {number}
         */
        public getTreeQuality() : number {
            return this.m_tree.getAreaRatio();
        }

        bufferMove(proxyId : number) {
            if(this.m_moveCount === this.m_moveCapacity) {
                let old : number[] = this.m_moveBuffer;
                this.m_moveCapacity *= 2;
                this.m_moveBuffer = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.m_moveCapacity);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(old, 0, this.m_moveBuffer, 0, old.length);
            }
            this.m_moveBuffer[this.m_moveCount] = proxyId;
            ++this.m_moveCount;
        }

        unbufferMove(proxyId : number) {
            for(let i : number = 0; i < this.m_moveCount; i++) {
                if(this.m_moveBuffer[i] === proxyId) {
                    this.m_moveBuffer[i] = org.jbox2d.collision.broadphase.BroadPhase.NULL_PROXY;
                }
            };
        }

        /**
         * This is called from DynamicTree::query when we are gathering pairs.
         * @param {number} proxyId
         * @return {boolean}
         */
        public treeCallback(proxyId : number) : boolean {
            if(proxyId === this.m_queryProxyId) {
                return true;
            }
            if(this.m_pairCount === this.m_pairCapacity) {
                let oldBuffer : org.jbox2d.collision.broadphase.Pair[] = this.m_pairBuffer;
                this.m_pairCapacity *= 2;
                this.m_pairBuffer = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_pairCapacity);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(oldBuffer, 0, this.m_pairBuffer, 0, oldBuffer.length);
                for(let i : number = oldBuffer.length; i < this.m_pairCapacity; i++) {
                    this.m_pairBuffer[i] = new org.jbox2d.collision.broadphase.Pair();
                };
            }
            if(proxyId < this.m_queryProxyId) {
                this.m_pairBuffer[this.m_pairCount].proxyIdA = proxyId;
                this.m_pairBuffer[this.m_pairCount].proxyIdB = this.m_queryProxyId;
            } else {
                this.m_pairBuffer[this.m_pairCount].proxyIdA = this.m_queryProxyId;
                this.m_pairBuffer[this.m_pairCount].proxyIdB = proxyId;
            }
            ++this.m_pairCount;
            return true;
        }
    }
    DefaultBroadPhaseBuffer["__class"] = "org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer";
    DefaultBroadPhaseBuffer["__interfaces"] = ["org.jbox2d.collision.broadphase.BroadPhase","org.jbox2d.callbacks.TreeCallback"];


}
namespace org.jbox2d.collision.broadphase {
    /**
     * A dynamic tree arranges data in a binary tree to accelerate queries such as volume queries and
     * ray casts. Leafs are proxies with an AABB. In the tree we expand the proxy AABB by _fatAABBFactor
     * so that the proxy AABB is bigger than the client object. This allows the client object to move by
     * small amounts without triggering a tree update.
     * 
     * @author daniel
     * @class
     */
    export class DynamicTree implements org.jbox2d.collision.broadphase.BroadPhaseStrategy {
        public static MAX_STACK_SIZE : number = 64;

        public static NULL_NODE : number = -1;

        /*private*/ m_root : org.jbox2d.collision.broadphase.DynamicTreeNode;

        /*private*/ m_nodes : org.jbox2d.collision.broadphase.DynamicTreeNode[];

        /*private*/ m_nodeCount : number;

        /*private*/ m_nodeCapacity : number;

        /*private*/ m_freeList : number;

        /*private*/ drawVecs : org.jbox2d.common.Vec2[] = [null, null, null, null];

        /*private*/ nodeStack : org.jbox2d.collision.broadphase.DynamicTreeNode[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(20);

        /*private*/ nodeStackIndex : number = 0;

        public constructor() {
            if(this.m_root===undefined) this.m_root = null;
            if(this.m_nodes===undefined) this.m_nodes = null;
            if(this.m_nodeCount===undefined) this.m_nodeCount = 0;
            if(this.m_nodeCapacity===undefined) this.m_nodeCapacity = 0;
            if(this.m_freeList===undefined) this.m_freeList = 0;
            this.m_root = null;
            this.m_nodeCount = 0;
            this.m_nodeCapacity = 16;
            this.m_nodes = (s => { let a=[]; while(s-->0) a.push(null); return a; })(16);
            for(let i : number = this.m_nodeCapacity - 1; i >= 0; i--) {
                this.m_nodes[i] = new org.jbox2d.collision.broadphase.DynamicTreeNode(i);
                this.m_nodes[i].parent = (i === this.m_nodeCapacity - 1)?null:this.m_nodes[i + 1];
                this.m_nodes[i].height = -1;
            };
            this.m_freeList = 0;
            for(let i : number = 0; i < this.drawVecs.length; i++) {
                this.drawVecs[i] = new org.jbox2d.common.Vec2();
            };
        }

        /**
         * 
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {*} userData
         * @return {number}
         */
        public createProxy(aabb : org.jbox2d.collision.AABB, userData : any) : number {
            let node : org.jbox2d.collision.broadphase.DynamicTreeNode = this.allocateNode();
            let proxyId : number = node.id;
            let nodeAABB : org.jbox2d.collision.AABB = node.aabb;
            nodeAABB.lowerBound.x = (<any>Math).fround(aabb.lowerBound.x - org.jbox2d.common.Settings.aabbExtension);
            nodeAABB.lowerBound.y = (<any>Math).fround(aabb.lowerBound.y - org.jbox2d.common.Settings.aabbExtension);
            nodeAABB.upperBound.x = (<any>Math).fround(aabb.upperBound.x + org.jbox2d.common.Settings.aabbExtension);
            nodeAABB.upperBound.y = (<any>Math).fround(aabb.upperBound.y + org.jbox2d.common.Settings.aabbExtension);
            node.userData = userData;
            this.insertLeaf(proxyId);
            return proxyId;
        }

        /**
         * 
         * @param {number} proxyId
         */
        public destroyProxy(proxyId : number) {
            let node : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_nodes[proxyId];
            this.removeLeaf(node);
            this.freeNode(node);
        }

        /**
         * 
         * @param {number} proxyId
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.Vec2} displacement
         * @return {boolean}
         */
        public moveProxy(proxyId : number, aabb : org.jbox2d.collision.AABB, displacement : org.jbox2d.common.Vec2) : boolean {
            let node : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_nodes[proxyId];
            let nodeAABB : org.jbox2d.collision.AABB = node.aabb;
            if(nodeAABB.lowerBound.x <= aabb.lowerBound.x && nodeAABB.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= nodeAABB.upperBound.x && aabb.upperBound.y <= nodeAABB.upperBound.y) {
                return false;
            }
            this.removeLeaf(node);
            let lowerBound : org.jbox2d.common.Vec2 = nodeAABB.lowerBound;
            let upperBound : org.jbox2d.common.Vec2 = nodeAABB.upperBound;
            lowerBound.x = (<any>Math).fround(aabb.lowerBound.x - org.jbox2d.common.Settings.aabbExtension);
            lowerBound.y = (<any>Math).fround(aabb.lowerBound.y - org.jbox2d.common.Settings.aabbExtension);
            upperBound.x = (<any>Math).fround(aabb.upperBound.x + org.jbox2d.common.Settings.aabbExtension);
            upperBound.y = (<any>Math).fround(aabb.upperBound.y + org.jbox2d.common.Settings.aabbExtension);
            let dx : number = (<any>Math).fround(displacement.x * org.jbox2d.common.Settings.aabbMultiplier);
            let dy : number = (<any>Math).fround(displacement.y * org.jbox2d.common.Settings.aabbMultiplier);
            if(dx < 0.0) {
                lowerBound.x += dx;
            } else {
                upperBound.x += dx;
            }
            if(dy < 0.0) {
                lowerBound.y += dy;
            } else {
                upperBound.y += dy;
            }
            this.insertLeaf(proxyId);
            return true;
        }

        /**
         * 
         * @param {number} proxyId
         * @return {*}
         */
        public getUserData(proxyId : number) : any {
            return this.m_nodes[proxyId].userData;
        }

        /**
         * 
         * @param {number} proxyId
         * @return {org.jbox2d.collision.AABB}
         */
        public getFatAABB(proxyId : number) : org.jbox2d.collision.AABB {
            return this.m_nodes[proxyId].aabb;
        }

        /**
         * 
         * @param {*} callback
         * @param {org.jbox2d.collision.AABB} aabb
         */
        public query(callback : org.jbox2d.callbacks.TreeCallback, aabb : org.jbox2d.collision.AABB) {
            this.nodeStackIndex = 0;
            this.nodeStack[this.nodeStackIndex++] = this.m_root;
            while((this.nodeStackIndex > 0)) {
                let node : org.jbox2d.collision.broadphase.DynamicTreeNode = this.nodeStack[--this.nodeStackIndex];
                if(node == null) {
                    continue;
                }
                if(org.jbox2d.collision.AABB.testOverlap(node.aabb, aabb)) {
                    if(node.child1 == null) {
                        let proceed : boolean = callback.treeCallback(node.id);
                        if(!proceed) {
                            return;
                        }
                    } else {
                        if(this.nodeStack.length - this.nodeStackIndex - 2 <= 0) {
                            let newBuffer : org.jbox2d.collision.broadphase.DynamicTreeNode[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.nodeStack.length * 2);
                            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.nodeStack, 0, newBuffer, 0, this.nodeStack.length);
                            this.nodeStack = newBuffer;
                        }
                        this.nodeStack[this.nodeStackIndex++] = node.child1;
                        this.nodeStack[this.nodeStackIndex++] = node.child2;
                    }
                }
            };
        }

        /*private*/ r : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ aabb : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ subInput : org.jbox2d.collision.RayCastInput = new org.jbox2d.collision.RayCastInput();

        /**
         * 
         * @param {*} callback
         * @param {org.jbox2d.collision.RayCastInput} input
         */
        public raycast(callback : org.jbox2d.callbacks.TreeRayCastCallback, input : org.jbox2d.collision.RayCastInput) {
            let p1 : org.jbox2d.common.Vec2 = input.p1;
            let p2 : org.jbox2d.common.Vec2 = input.p2;
            let p1x : number = p1.x;
            let p2x : number = p2.x;
            let p1y : number = p1.y;
            let p2y : number = p2.y;
            let vx : number;
            let vy : number;
            let rx : number;
            let ry : number;
            let absVx : number;
            let absVy : number;
            let cx : number;
            let cy : number;
            let hx : number;
            let hy : number;
            let tempx : number;
            let tempy : number;
            this.r.x = (<any>Math).fround(p2x - p1x);
            this.r.y = (<any>Math).fround(p2y - p1y);
            this.r.normalize();
            rx = this.r.x;
            ry = this.r.y;
            vx = (<any>Math).fround(-1.0 * ry);
            vy = (<any>Math).fround(1.0 * rx);
            absVx = org.jbox2d.common.MathUtils.abs$float(vx);
            absVy = org.jbox2d.common.MathUtils.abs$float(vy);
            let maxFraction : number = input.maxFraction;
            let segAABB : org.jbox2d.collision.AABB = this.aabb;
            tempx = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(p2x - p1x)) * maxFraction) + p1x);
            tempy = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(p2y - p1y)) * maxFraction) + p1y);
            segAABB.lowerBound.x = p1x < tempx?p1x:tempx;
            segAABB.lowerBound.y = p1y < tempy?p1y:tempy;
            segAABB.upperBound.x = p1x > tempx?p1x:tempx;
            segAABB.upperBound.y = p1y > tempy?p1y:tempy;
            this.nodeStackIndex = 0;
            this.nodeStack[this.nodeStackIndex++] = this.m_root;
            while((this.nodeStackIndex > 0)) {
                let node : org.jbox2d.collision.broadphase.DynamicTreeNode = this.nodeStack[--this.nodeStackIndex];
                if(node == null) {
                    continue;
                }
                let nodeAABB : org.jbox2d.collision.AABB = node.aabb;
                if(!org.jbox2d.collision.AABB.testOverlap(nodeAABB, segAABB)) {
                    continue;
                }
                cx = (<any>Math).fround(((<any>Math).fround(nodeAABB.lowerBound.x + nodeAABB.upperBound.x)) * 0.5);
                cy = (<any>Math).fround(((<any>Math).fround(nodeAABB.lowerBound.y + nodeAABB.upperBound.y)) * 0.5);
                hx = (<any>Math).fround(((<any>Math).fround(nodeAABB.upperBound.x - nodeAABB.lowerBound.x)) * 0.5);
                hy = (<any>Math).fround(((<any>Math).fround(nodeAABB.upperBound.y - nodeAABB.lowerBound.y)) * 0.5);
                tempx = (<any>Math).fround(p1x - cx);
                tempy = (<any>Math).fround(p1y - cy);
                let separation : number = (<any>Math).fround(org.jbox2d.common.MathUtils.abs$float((<any>Math).fround((<any>Math).fround(vx * tempx) + (<any>Math).fround(vy * tempy))) - ((<any>Math).fround((<any>Math).fround(absVx * hx) + (<any>Math).fround(absVy * hy))));
                if(separation > 0.0) {
                    continue;
                }
                if(node.child1 == null) {
                    this.subInput.p1.x = p1x;
                    this.subInput.p1.y = p1y;
                    this.subInput.p2.x = p2x;
                    this.subInput.p2.y = p2y;
                    this.subInput.maxFraction = maxFraction;
                    let value : number = callback.raycastCallback(this.subInput, node.id);
                    if(value === 0.0) {
                        return;
                    }
                    if(value > 0.0) {
                        maxFraction = value;
                        tempx = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(p2x - p1x)) * maxFraction) + p1x);
                        tempy = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(p2y - p1y)) * maxFraction) + p1y);
                        segAABB.lowerBound.x = p1x < tempx?p1x:tempx;
                        segAABB.lowerBound.y = p1y < tempy?p1y:tempy;
                        segAABB.upperBound.x = p1x > tempx?p1x:tempx;
                        segAABB.upperBound.y = p1y > tempy?p1y:tempy;
                    }
                } else {
                    if(this.nodeStack.length - this.nodeStackIndex - 2 <= 0) {
                        let newBuffer : org.jbox2d.collision.broadphase.DynamicTreeNode[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.nodeStack.length * 2);
                        /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.nodeStack, 0, newBuffer, 0, this.nodeStack.length);
                        this.nodeStack = newBuffer;
                    }
                    this.nodeStack[this.nodeStackIndex++] = node.child1;
                    this.nodeStack[this.nodeStackIndex++] = node.child2;
                }
            };
        }

        public computeHeight$() : number {
            return this.computeHeight$org_jbox2d_collision_broadphase_DynamicTreeNode(this.m_root);
        }

        public computeHeight$org_jbox2d_collision_broadphase_DynamicTreeNode(node : org.jbox2d.collision.broadphase.DynamicTreeNode) : number {
            if(node.child1 == null) {
                return 0;
            }
            let height1 : number = this.computeHeight$org_jbox2d_collision_broadphase_DynamicTreeNode(node.child1);
            let height2 : number = this.computeHeight$org_jbox2d_collision_broadphase_DynamicTreeNode(node.child2);
            return 1 + org.jbox2d.common.MathUtils.max$int$int(height1, height2);
        }

        public computeHeight(node? : any) : any {
            if(((node != null && node instanceof <any>org.jbox2d.collision.broadphase.DynamicTreeNode) || node === null)) {
                return <any>this.computeHeight$org_jbox2d_collision_broadphase_DynamicTreeNode(node);
            } else if(node === undefined) {
                return <any>this.computeHeight$();
            } else throw new Error('invalid overload');
        }

        /**
         * Validate this tree. For testing.
         */
        public validate() {
            this.validateStructure(this.m_root);
            this.validateMetrics(this.m_root);
            let freeCount : number = 0;
            let freeNode : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_freeList !== DynamicTree.NULL_NODE?this.m_nodes[this.m_freeList]:null;
            while((freeNode != null)) {
                freeNode = freeNode.parent;
                ++freeCount;
            };
        }

        /**
         * 
         * @return {number}
         */
        public getHeight() : number {
            if(this.m_root == null) {
                return 0;
            }
            return this.m_root.height;
        }

        /**
         * 
         * @return {number}
         */
        public getMaxBalance() : number {
            let maxBalance : number = 0;
            for(let i : number = 0; i < this.m_nodeCapacity; ++i) {
                let node : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_nodes[i];
                if(node.height <= 1) {
                    continue;
                }
                let child1 : org.jbox2d.collision.broadphase.DynamicTreeNode = node.child1;
                let child2 : org.jbox2d.collision.broadphase.DynamicTreeNode = node.child2;
                let balance : number = org.jbox2d.common.MathUtils.abs$int(child2.height - child1.height);
                maxBalance = org.jbox2d.common.MathUtils.max$int$int(maxBalance, balance);
            };
            return maxBalance;
        }

        /**
         * 
         * @return {number}
         */
        public getAreaRatio() : number {
            if(this.m_root == null) {
                return 0.0;
            }
            let root : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_root;
            let rootArea : number = root.aabb.getPerimeter();
            let totalArea : number = 0.0;
            for(let i : number = 0; i < this.m_nodeCapacity; ++i) {
                let node : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_nodes[i];
                if(node.height < 0) {
                    continue;
                }
                totalArea += node.aabb.getPerimeter();
            };
            return (<any>Math).fround(totalArea / rootArea);
        }

        /**
         * Build an optimal tree. Very expensive. For testing.
         */
        public rebuildBottomUp() {
            let nodes : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.m_nodeCount);
            let count : number = 0;
            for(let i : number = 0; i < this.m_nodeCapacity; ++i) {
                if(this.m_nodes[i].height < 0) {
                    continue;
                }
                let node : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_nodes[i];
                if(node.child1 == null) {
                    node.parent = null;
                    nodes[count] = i;
                    ++count;
                } else {
                    this.freeNode(node);
                }
            };
            let b : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();
            while((count > 1)) {
                let minCost : number = Number.MAX_VALUE;
                let iMin : number = -1;
                let jMin : number = -1;
                for(let i : number = 0; i < count; ++i) {
                    let aabbi : org.jbox2d.collision.AABB = this.m_nodes[nodes[i]].aabb;
                    for(let j : number = i + 1; j < count; ++j) {
                        let aabbj : org.jbox2d.collision.AABB = this.m_nodes[nodes[j]].aabb;
                        b.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(aabbi, aabbj);
                        let cost : number = b.getPerimeter();
                        if(cost < minCost) {
                            iMin = i;
                            jMin = j;
                            minCost = cost;
                        }
                    };
                };
                let index1 : number = nodes[iMin];
                let index2 : number = nodes[jMin];
                let child1 : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_nodes[index1];
                let child2 : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_nodes[index2];
                let parent : org.jbox2d.collision.broadphase.DynamicTreeNode = this.allocateNode();
                parent.child1 = child1;
                parent.child2 = child2;
                parent.height = 1 + org.jbox2d.common.MathUtils.max$int$int(child1.height, child2.height);
                parent.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(child1.aabb, child2.aabb);
                parent.parent = null;
                child1.parent = parent;
                child2.parent = parent;
                nodes[jMin] = nodes[count - 1];
                nodes[iMin] = parent.id;
                --count;
            };
            this.m_root = this.m_nodes[nodes[0]];
            this.validate();
        }

        /*private*/ allocateNode() : org.jbox2d.collision.broadphase.DynamicTreeNode {
            if(this.m_freeList === DynamicTree.NULL_NODE) {
                let old : org.jbox2d.collision.broadphase.DynamicTreeNode[] = this.m_nodes;
                this.m_nodeCapacity *= 2;
                this.m_nodes = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_nodeCapacity);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(old, 0, this.m_nodes, 0, old.length);
                for(let i : number = this.m_nodeCapacity - 1; i >= this.m_nodeCount; i--) {
                    this.m_nodes[i] = new org.jbox2d.collision.broadphase.DynamicTreeNode(i);
                    this.m_nodes[i].parent = (i === this.m_nodeCapacity - 1)?null:this.m_nodes[i + 1];
                    this.m_nodes[i].height = -1;
                };
                this.m_freeList = this.m_nodeCount;
            }
            let nodeId : number = this.m_freeList;
            let treeNode : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_nodes[nodeId];
            this.m_freeList = treeNode.parent != null?treeNode.parent.id:DynamicTree.NULL_NODE;
            treeNode.parent = null;
            treeNode.child1 = null;
            treeNode.child2 = null;
            treeNode.height = 0;
            treeNode.userData = null;
            ++this.m_nodeCount;
            return treeNode;
        }

        /**
         * returns a node to the pool
         * @param {org.jbox2d.collision.broadphase.DynamicTreeNode} node
         * @private
         */
        /*private*/ freeNode(node : org.jbox2d.collision.broadphase.DynamicTreeNode) {
            node.parent = this.m_freeList !== DynamicTree.NULL_NODE?this.m_nodes[this.m_freeList]:null;
            node.height = -1;
            this.m_freeList = node.id;
            this.m_nodeCount--;
        }

        /*private*/ combinedAABB : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ insertLeaf(leaf_index : number) {
            let leaf : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_nodes[leaf_index];
            if(this.m_root == null) {
                this.m_root = leaf;
                this.m_root.parent = null;
                return;
            }
            let leafAABB : org.jbox2d.collision.AABB = leaf.aabb;
            let index : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_root;
            while((index.child1 != null)) {
                let node : org.jbox2d.collision.broadphase.DynamicTreeNode = index;
                let child1 : org.jbox2d.collision.broadphase.DynamicTreeNode = node.child1;
                let child2 : org.jbox2d.collision.broadphase.DynamicTreeNode = node.child2;
                let area : number = node.aabb.getPerimeter();
                this.combinedAABB.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(node.aabb, leafAABB);
                let combinedArea : number = this.combinedAABB.getPerimeter();
                let cost : number = (<any>Math).fround(2.0 * combinedArea);
                let inheritanceCost : number = (<any>Math).fround(2.0 * ((<any>Math).fround(combinedArea - area)));
                let cost1 : number;
                if(child1.child1 == null) {
                    this.combinedAABB.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(leafAABB, child1.aabb);
                    cost1 = (<any>Math).fround(this.combinedAABB.getPerimeter() + inheritanceCost);
                } else {
                    this.combinedAABB.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(leafAABB, child1.aabb);
                    let oldArea : number = child1.aabb.getPerimeter();
                    let newArea : number = this.combinedAABB.getPerimeter();
                    cost1 = (<any>Math).fround(((<any>Math).fround(newArea - oldArea)) + inheritanceCost);
                }
                let cost2 : number;
                if(child2.child1 == null) {
                    this.combinedAABB.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(leafAABB, child2.aabb);
                    cost2 = (<any>Math).fround(this.combinedAABB.getPerimeter() + inheritanceCost);
                } else {
                    this.combinedAABB.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(leafAABB, child2.aabb);
                    let oldArea : number = child2.aabb.getPerimeter();
                    let newArea : number = this.combinedAABB.getPerimeter();
                    cost2 = (<any>Math).fround((<any>Math).fround(newArea - oldArea) + inheritanceCost);
                }
                if(cost < cost1 && cost < cost2) {
                    break;
                }
                if(cost1 < cost2) {
                    index = child1;
                } else {
                    index = child2;
                }
            };
            let sibling : org.jbox2d.collision.broadphase.DynamicTreeNode = index;
            let oldParent : org.jbox2d.collision.broadphase.DynamicTreeNode = this.m_nodes[sibling.id].parent;
            let newParent : org.jbox2d.collision.broadphase.DynamicTreeNode = this.allocateNode();
            newParent.parent = oldParent;
            newParent.userData = null;
            newParent.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(leafAABB, sibling.aabb);
            newParent.height = sibling.height + 1;
            if(oldParent != null) {
                if(oldParent.child1 === sibling) {
                    oldParent.child1 = newParent;
                } else {
                    oldParent.child2 = newParent;
                }
                newParent.child1 = sibling;
                newParent.child2 = leaf;
                sibling.parent = newParent;
                leaf.parent = newParent;
            } else {
                newParent.child1 = sibling;
                newParent.child2 = leaf;
                sibling.parent = newParent;
                leaf.parent = newParent;
                this.m_root = newParent;
            }
            index = leaf.parent;
            while((index != null)) {
                index = this.balance(index);
                let child1 : org.jbox2d.collision.broadphase.DynamicTreeNode = index.child1;
                let child2 : org.jbox2d.collision.broadphase.DynamicTreeNode = index.child2;
                index.height = 1 + org.jbox2d.common.MathUtils.max$int$int(child1.height, child2.height);
                index.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(child1.aabb, child2.aabb);
                index = index.parent;
            };
        }

        /*private*/ removeLeaf(leaf : org.jbox2d.collision.broadphase.DynamicTreeNode) {
            if(leaf === this.m_root) {
                this.m_root = null;
                return;
            }
            let parent : org.jbox2d.collision.broadphase.DynamicTreeNode = leaf.parent;
            let grandParent : org.jbox2d.collision.broadphase.DynamicTreeNode = parent.parent;
            let sibling : org.jbox2d.collision.broadphase.DynamicTreeNode;
            if(parent.child1 === leaf) {
                sibling = parent.child2;
            } else {
                sibling = parent.child1;
            }
            if(grandParent != null) {
                if(grandParent.child1 === parent) {
                    grandParent.child1 = sibling;
                } else {
                    grandParent.child2 = sibling;
                }
                sibling.parent = grandParent;
                this.freeNode(parent);
                let index : org.jbox2d.collision.broadphase.DynamicTreeNode = grandParent;
                while((index != null)) {
                    index = this.balance(index);
                    let child1 : org.jbox2d.collision.broadphase.DynamicTreeNode = index.child1;
                    let child2 : org.jbox2d.collision.broadphase.DynamicTreeNode = index.child2;
                    index.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(child1.aabb, child2.aabb);
                    index.height = 1 + org.jbox2d.common.MathUtils.max$int$int(child1.height, child2.height);
                    index = index.parent;
                };
            } else {
                this.m_root = sibling;
                sibling.parent = null;
                this.freeNode(parent);
            }
        }

        /*private*/ balance(iA : org.jbox2d.collision.broadphase.DynamicTreeNode) : org.jbox2d.collision.broadphase.DynamicTreeNode {
            let A : org.jbox2d.collision.broadphase.DynamicTreeNode = iA;
            if(A.child1 == null || A.height < 2) {
                return iA;
            }
            let iB : org.jbox2d.collision.broadphase.DynamicTreeNode = A.child1;
            let iC : org.jbox2d.collision.broadphase.DynamicTreeNode = A.child2;
            let B : org.jbox2d.collision.broadphase.DynamicTreeNode = iB;
            let C : org.jbox2d.collision.broadphase.DynamicTreeNode = iC;
            let balance : number = C.height - B.height;
            if(balance > 1) {
                let iF : org.jbox2d.collision.broadphase.DynamicTreeNode = C.child1;
                let iG : org.jbox2d.collision.broadphase.DynamicTreeNode = C.child2;
                let F : org.jbox2d.collision.broadphase.DynamicTreeNode = iF;
                let G : org.jbox2d.collision.broadphase.DynamicTreeNode = iG;
                C.child1 = iA;
                C.parent = A.parent;
                A.parent = iC;
                if(C.parent != null) {
                    if(C.parent.child1 === iA) {
                        C.parent.child1 = iC;
                    } else {
                        C.parent.child2 = iC;
                    }
                } else {
                    this.m_root = iC;
                }
                if(F.height > G.height) {
                    C.child2 = iF;
                    A.child2 = iG;
                    G.parent = iA;
                    A.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(B.aabb, G.aabb);
                    C.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(A.aabb, F.aabb);
                    A.height = 1 + org.jbox2d.common.MathUtils.max$int$int(B.height, G.height);
                    C.height = 1 + org.jbox2d.common.MathUtils.max$int$int(A.height, F.height);
                } else {
                    C.child2 = iG;
                    A.child2 = iF;
                    F.parent = iA;
                    A.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(B.aabb, F.aabb);
                    C.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(A.aabb, G.aabb);
                    A.height = 1 + org.jbox2d.common.MathUtils.max$int$int(B.height, F.height);
                    C.height = 1 + org.jbox2d.common.MathUtils.max$int$int(A.height, G.height);
                }
                return iC;
            }
            if(balance < -1) {
                let iD : org.jbox2d.collision.broadphase.DynamicTreeNode = B.child1;
                let iE : org.jbox2d.collision.broadphase.DynamicTreeNode = B.child2;
                let D : org.jbox2d.collision.broadphase.DynamicTreeNode = iD;
                let E : org.jbox2d.collision.broadphase.DynamicTreeNode = iE;
                B.child1 = iA;
                B.parent = A.parent;
                A.parent = iB;
                if(B.parent != null) {
                    if(B.parent.child1 === iA) {
                        B.parent.child1 = iB;
                    } else {
                        B.parent.child2 = iB;
                    }
                } else {
                    this.m_root = iB;
                }
                if(D.height > E.height) {
                    B.child2 = iD;
                    A.child1 = iE;
                    E.parent = iA;
                    A.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(C.aabb, E.aabb);
                    B.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(A.aabb, D.aabb);
                    A.height = 1 + org.jbox2d.common.MathUtils.max$int$int(C.height, E.height);
                    B.height = 1 + org.jbox2d.common.MathUtils.max$int$int(A.height, D.height);
                } else {
                    B.child2 = iE;
                    A.child1 = iD;
                    D.parent = iA;
                    A.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(C.aabb, D.aabb);
                    B.aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(A.aabb, E.aabb);
                    A.height = 1 + org.jbox2d.common.MathUtils.max$int$int(C.height, D.height);
                    B.height = 1 + org.jbox2d.common.MathUtils.max$int$int(A.height, E.height);
                }
                return iB;
            }
            return iA;
        }

        /*private*/ validateStructure(node : org.jbox2d.collision.broadphase.DynamicTreeNode) {
            if(node == null) {
                return;
            }
            if(node === this.m_root) {
            }
            let child1 : org.jbox2d.collision.broadphase.DynamicTreeNode = node.child1;
            let child2 : org.jbox2d.collision.broadphase.DynamicTreeNode = node.child2;
            if(node.child1 == null) {
                return;
            }
            this.validateStructure(child1);
            this.validateStructure(child2);
        }

        /*private*/ validateMetrics(node : org.jbox2d.collision.broadphase.DynamicTreeNode) {
            if(node == null) {
                return;
            }
            let child1 : org.jbox2d.collision.broadphase.DynamicTreeNode = node.child1;
            let child2 : org.jbox2d.collision.broadphase.DynamicTreeNode = node.child2;
            if(node.child1 == null) {
                return;
            }
            let height1 : number = child1.height;
            let height2 : number = child2.height;
            let height : number;
            height = 1 + org.jbox2d.common.MathUtils.max$int$int(height1, height2);
            let aabb : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();
            aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(child1.aabb, child2.aabb);
            this.validateMetrics(child1);
            this.validateMetrics(child2);
        }

        public drawTree$org_jbox2d_callbacks_DebugDraw(argDraw : org.jbox2d.callbacks.DebugDraw) {
            if(this.m_root == null) {
                return;
            }
            let height : number = this.computeHeight();
            this.drawTree$org_jbox2d_callbacks_DebugDraw$org_jbox2d_collision_broadphase_DynamicTreeNode$int$int(argDraw, this.m_root, 0, height);
        }

        /*private*/ color : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f();

        /*private*/ textVec : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public drawTree$org_jbox2d_callbacks_DebugDraw$org_jbox2d_collision_broadphase_DynamicTreeNode$int$int(argDraw : org.jbox2d.callbacks.DebugDraw, node : org.jbox2d.collision.broadphase.DynamicTreeNode, spot : number, height : number) {
            node.aabb.getVertices(this.drawVecs);
            this.color.set$float$float$float(1, (<any>Math).fround((<any>Math).fround((height - spot) * 1.0) / height), (<any>Math).fround((<any>Math).fround((height - spot) * 1.0) / height));
            argDraw.drawPolygon(this.drawVecs, 4, this.color);
            argDraw.getViewportTranform().getWorldToScreen(node.aabb.upperBound, this.textVec);
            argDraw.drawString$float$float$java_lang_String$org_jbox2d_common_Color3f(this.textVec.x, this.textVec.y, node.id + "-" + (spot + 1) + "/" + height, this.color);
            if(node.child1 != null) {
                this.drawTree$org_jbox2d_callbacks_DebugDraw$org_jbox2d_collision_broadphase_DynamicTreeNode$int$int(argDraw, node.child1, spot + 1, height);
            }
            if(node.child2 != null) {
                this.drawTree$org_jbox2d_callbacks_DebugDraw$org_jbox2d_collision_broadphase_DynamicTreeNode$int$int(argDraw, node.child2, spot + 1, height);
            }
        }

        public drawTree(argDraw? : any, node? : any, spot? : any, height? : any) : any {
            if(((argDraw != null && argDraw instanceof <any>org.jbox2d.callbacks.DebugDraw) || argDraw === null) && ((node != null && node instanceof <any>org.jbox2d.collision.broadphase.DynamicTreeNode) || node === null) && ((typeof spot === 'number') || spot === null) && ((typeof height === 'number') || height === null)) {
                return <any>this.drawTree$org_jbox2d_callbacks_DebugDraw$org_jbox2d_collision_broadphase_DynamicTreeNode$int$int(argDraw, node, spot, height);
            } else if(((argDraw != null && argDraw instanceof <any>org.jbox2d.callbacks.DebugDraw) || argDraw === null) && node === undefined && spot === undefined && height === undefined) {
                return <any>this.drawTree$org_jbox2d_callbacks_DebugDraw(argDraw);
            } else throw new Error('invalid overload');
        }
    }
    DynamicTree["__class"] = "org.jbox2d.collision.broadphase.DynamicTree";
    DynamicTree["__interfaces"] = ["org.jbox2d.collision.broadphase.BroadPhaseStrategy"];


}
namespace org.jbox2d.collision.broadphase {
    export class DynamicTreeFlatNodes implements org.jbox2d.collision.broadphase.BroadPhaseStrategy {
        public static MAX_STACK_SIZE : number = 64;

        public static NULL_NODE : number = -1;

        public static INITIAL_BUFFER_LENGTH : number = 16;

        public m_root : number;

        public m_aabb : org.jbox2d.collision.AABB[];

        public m_userData : any[];

        m_parent : number[];

        m_child1 : number[];

        m_child2 : number[];

        m_height : number[];

        /*private*/ m_nodeCount : number;

        /*private*/ m_nodeCapacity : number;

        /*private*/ m_freeList : number;

        /*private*/ drawVecs : org.jbox2d.common.Vec2[] = [null, null, null, null];

        public constructor() {
            if(this.m_root===undefined) this.m_root = 0;
            if(this.m_aabb===undefined) this.m_aabb = null;
            if(this.m_userData===undefined) this.m_userData = null;
            if(this.m_parent===undefined) this.m_parent = null;
            if(this.m_child1===undefined) this.m_child1 = null;
            if(this.m_child2===undefined) this.m_child2 = null;
            if(this.m_height===undefined) this.m_height = null;
            if(this.m_nodeCount===undefined) this.m_nodeCount = 0;
            if(this.m_nodeCapacity===undefined) this.m_nodeCapacity = 0;
            if(this.m_freeList===undefined) this.m_freeList = 0;
            if(this.nodeStackIndex===undefined) this.nodeStackIndex = 0;
            this.m_root = DynamicTreeFlatNodes.NULL_NODE;
            this.m_nodeCount = 0;
            this.m_nodeCapacity = 16;
            this.expandBuffers(0, this.m_nodeCapacity);
            for(let i : number = 0; i < this.drawVecs.length; i++) {
                this.drawVecs[i] = new org.jbox2d.common.Vec2();
            };
        }

        /*private*/ expandBuffers(oldSize : number, newSize : number) {
            this.m_aabb = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(org.jbox2d.collision.AABB, this.m_aabb, oldSize, newSize);
            this.m_userData = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(Object, this.m_userData, oldSize, newSize);
            this.m_parent = org.jbox2d.common.BufferUtils.reallocateBuffer$int_A$int$int(this.m_parent, oldSize, newSize);
            this.m_child1 = org.jbox2d.common.BufferUtils.reallocateBuffer$int_A$int$int(this.m_child1, oldSize, newSize);
            this.m_child2 = org.jbox2d.common.BufferUtils.reallocateBuffer$int_A$int$int(this.m_child2, oldSize, newSize);
            this.m_height = org.jbox2d.common.BufferUtils.reallocateBuffer$int_A$int$int(this.m_height, oldSize, newSize);
            for(let i : number = oldSize; i < newSize; i++) {
                this.m_aabb[i] = new org.jbox2d.collision.AABB();
                this.m_parent[i] = (i === newSize - 1)?DynamicTreeFlatNodes.NULL_NODE:i + 1;
                this.m_height[i] = -1;
                this.m_child1[i] = -1;
                this.m_child2[i] = -1;
            };
            this.m_freeList = oldSize;
        }

        /**
         * 
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {*} userData
         * @return {number}
         */
        public createProxy(aabb : org.jbox2d.collision.AABB, userData : any) : number {
            let node : number = this.allocateNode();
            let nodeAABB : org.jbox2d.collision.AABB = this.m_aabb[node];
            nodeAABB.lowerBound.x = (<any>Math).fround(aabb.lowerBound.x - org.jbox2d.common.Settings.aabbExtension);
            nodeAABB.lowerBound.y = (<any>Math).fround(aabb.lowerBound.y - org.jbox2d.common.Settings.aabbExtension);
            nodeAABB.upperBound.x = (<any>Math).fround(aabb.upperBound.x + org.jbox2d.common.Settings.aabbExtension);
            nodeAABB.upperBound.y = (<any>Math).fround(aabb.upperBound.y + org.jbox2d.common.Settings.aabbExtension);
            this.m_userData[node] = userData;
            this.insertLeaf(node);
            return node;
        }

        /**
         * 
         * @param {number} proxyId
         */
        public destroyProxy(proxyId : number) {
            this.removeLeaf(proxyId);
            this.freeNode(proxyId);
        }

        /**
         * 
         * @param {number} proxyId
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.Vec2} displacement
         * @return {boolean}
         */
        public moveProxy(proxyId : number, aabb : org.jbox2d.collision.AABB, displacement : org.jbox2d.common.Vec2) : boolean {
            let node : number = proxyId;
            let nodeAABB : org.jbox2d.collision.AABB = this.m_aabb[node];
            if(nodeAABB.lowerBound.x <= aabb.lowerBound.x && nodeAABB.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= nodeAABB.upperBound.x && aabb.upperBound.y <= nodeAABB.upperBound.y) {
                return false;
            }
            this.removeLeaf(node);
            let lowerBound : org.jbox2d.common.Vec2 = nodeAABB.lowerBound;
            let upperBound : org.jbox2d.common.Vec2 = nodeAABB.upperBound;
            lowerBound.x = (<any>Math).fround(aabb.lowerBound.x - org.jbox2d.common.Settings.aabbExtension);
            lowerBound.y = (<any>Math).fround(aabb.lowerBound.y - org.jbox2d.common.Settings.aabbExtension);
            upperBound.x = (<any>Math).fround(aabb.upperBound.x + org.jbox2d.common.Settings.aabbExtension);
            upperBound.y = (<any>Math).fround(aabb.upperBound.y + org.jbox2d.common.Settings.aabbExtension);
            let dx : number = (<any>Math).fround(displacement.x * org.jbox2d.common.Settings.aabbMultiplier);
            let dy : number = (<any>Math).fround(displacement.y * org.jbox2d.common.Settings.aabbMultiplier);
            if(dx < 0.0) {
                lowerBound.x += dx;
            } else {
                upperBound.x += dx;
            }
            if(dy < 0.0) {
                lowerBound.y += dy;
            } else {
                upperBound.y += dy;
            }
            this.insertLeaf(proxyId);
            return true;
        }

        /**
         * 
         * @param {number} proxyId
         * @return {*}
         */
        public getUserData(proxyId : number) : any {
            return this.m_userData[proxyId];
        }

        /**
         * 
         * @param {number} proxyId
         * @return {org.jbox2d.collision.AABB}
         */
        public getFatAABB(proxyId : number) : org.jbox2d.collision.AABB {
            return this.m_aabb[proxyId];
        }

        /*private*/ nodeStack : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(20);

        /*private*/ nodeStackIndex : number;

        /**
         * 
         * @param {*} callback
         * @param {org.jbox2d.collision.AABB} aabb
         */
        public query(callback : org.jbox2d.callbacks.TreeCallback, aabb : org.jbox2d.collision.AABB) {
            this.nodeStackIndex = 0;
            this.nodeStack[this.nodeStackIndex++] = this.m_root;
            while((this.nodeStackIndex > 0)) {
                let node : number = this.nodeStack[--this.nodeStackIndex];
                if(node === DynamicTreeFlatNodes.NULL_NODE) {
                    continue;
                }
                if(org.jbox2d.collision.AABB.testOverlap(this.m_aabb[node], aabb)) {
                    let child1 : number = this.m_child1[node];
                    if(child1 === DynamicTreeFlatNodes.NULL_NODE) {
                        let proceed : boolean = callback.treeCallback(node);
                        if(!proceed) {
                            return;
                        }
                    } else {
                        if(this.nodeStack.length - this.nodeStackIndex - 2 <= 0) {
                            this.nodeStack = org.jbox2d.common.BufferUtils.reallocateBuffer$int_A$int$int(this.nodeStack, this.nodeStack.length, this.nodeStack.length * 2);
                        }
                        this.nodeStack[this.nodeStackIndex++] = child1;
                        this.nodeStack[this.nodeStackIndex++] = this.m_child2[node];
                    }
                }
            };
        }

        /*private*/ r : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ aabb : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ subInput : org.jbox2d.collision.RayCastInput = new org.jbox2d.collision.RayCastInput();

        /**
         * 
         * @param {*} callback
         * @param {org.jbox2d.collision.RayCastInput} input
         */
        public raycast(callback : org.jbox2d.callbacks.TreeRayCastCallback, input : org.jbox2d.collision.RayCastInput) {
            let p1 : org.jbox2d.common.Vec2 = input.p1;
            let p2 : org.jbox2d.common.Vec2 = input.p2;
            let p1x : number = p1.x;
            let p2x : number = p2.x;
            let p1y : number = p1.y;
            let p2y : number = p2.y;
            let vx : number;
            let vy : number;
            let rx : number;
            let ry : number;
            let absVx : number;
            let absVy : number;
            let cx : number;
            let cy : number;
            let hx : number;
            let hy : number;
            let tempx : number;
            let tempy : number;
            this.r.x = (<any>Math).fround(p2x - p1x);
            this.r.y = (<any>Math).fround(p2y - p1y);
            this.r.normalize();
            rx = this.r.x;
            ry = this.r.y;
            vx = (<any>Math).fround(-1.0 * ry);
            vy = (<any>Math).fround(1.0 * rx);
            absVx = org.jbox2d.common.MathUtils.abs$float(vx);
            absVy = org.jbox2d.common.MathUtils.abs$float(vy);
            let maxFraction : number = input.maxFraction;
            let segAABB : org.jbox2d.collision.AABB = this.aabb;
            tempx = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(p2x - p1x)) * maxFraction) + p1x);
            tempy = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(p2y - p1y)) * maxFraction) + p1y);
            segAABB.lowerBound.x = p1x < tempx?p1x:tempx;
            segAABB.lowerBound.y = p1y < tempy?p1y:tempy;
            segAABB.upperBound.x = p1x > tempx?p1x:tempx;
            segAABB.upperBound.y = p1y > tempy?p1y:tempy;
            this.nodeStackIndex = 0;
            this.nodeStack[this.nodeStackIndex++] = this.m_root;
            while((this.nodeStackIndex > 0)) {
                let node : number = this.nodeStack[--this.nodeStackIndex] = this.m_root;
                if(node === DynamicTreeFlatNodes.NULL_NODE) {
                    continue;
                }
                let nodeAABB : org.jbox2d.collision.AABB = this.m_aabb[node];
                if(!org.jbox2d.collision.AABB.testOverlap(nodeAABB, segAABB)) {
                    continue;
                }
                cx = (<any>Math).fround(((<any>Math).fround(nodeAABB.lowerBound.x + nodeAABB.upperBound.x)) * 0.5);
                cy = (<any>Math).fround(((<any>Math).fround(nodeAABB.lowerBound.y + nodeAABB.upperBound.y)) * 0.5);
                hx = (<any>Math).fround(((<any>Math).fround(nodeAABB.upperBound.x - nodeAABB.lowerBound.x)) * 0.5);
                hy = (<any>Math).fround(((<any>Math).fround(nodeAABB.upperBound.y - nodeAABB.lowerBound.y)) * 0.5);
                tempx = (<any>Math).fround(p1x - cx);
                tempy = (<any>Math).fround(p1y - cy);
                let separation : number = (<any>Math).fround(org.jbox2d.common.MathUtils.abs$float((<any>Math).fround((<any>Math).fround(vx * tempx) + (<any>Math).fround(vy * tempy))) - ((<any>Math).fround((<any>Math).fround(absVx * hx) + (<any>Math).fround(absVy * hy))));
                if(separation > 0.0) {
                    continue;
                }
                let child1 : number = this.m_child1[node];
                if(child1 === DynamicTreeFlatNodes.NULL_NODE) {
                    this.subInput.p1.x = p1x;
                    this.subInput.p1.y = p1y;
                    this.subInput.p2.x = p2x;
                    this.subInput.p2.y = p2y;
                    this.subInput.maxFraction = maxFraction;
                    let value : number = callback.raycastCallback(this.subInput, node);
                    if(value === 0.0) {
                        return;
                    }
                    if(value > 0.0) {
                        maxFraction = value;
                        tempx = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(p2x - p1x)) * maxFraction) + p1x);
                        tempy = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(p2y - p1y)) * maxFraction) + p1y);
                        segAABB.lowerBound.x = p1x < tempx?p1x:tempx;
                        segAABB.lowerBound.y = p1y < tempy?p1y:tempy;
                        segAABB.upperBound.x = p1x > tempx?p1x:tempx;
                        segAABB.upperBound.y = p1y > tempy?p1y:tempy;
                    }
                } else {
                    this.nodeStack[this.nodeStackIndex++] = child1;
                    this.nodeStack[this.nodeStackIndex++] = this.m_child2[node];
                }
            };
        }

        public computeHeight(node? : any) : any {
            if(((typeof node === 'number') || node === null)) {
                return <any>this.computeHeight$int(node);
            } else if(node === undefined) {
                return <any>this.computeHeight$();
            } else throw new Error('invalid overload');
        }

        public computeHeight$() : number {
            return this.computeHeight$int(this.m_root);
        }

        /*private*/ computeHeight$int(node : number) : number {
            if(this.m_child1[node] === DynamicTreeFlatNodes.NULL_NODE) {
                return 0;
            }
            let height1 : number = this.computeHeight$int(this.m_child1[node]);
            let height2 : number = this.computeHeight$int(this.m_child2[node]);
            return 1 + org.jbox2d.common.MathUtils.max$int$int(height1, height2);
        }

        /**
         * Validate this tree. For testing.
         */
        public validate() {
            this.validateStructure(this.m_root);
            this.validateMetrics(this.m_root);
            let freeCount : number = 0;
            let freeNode : number = this.m_freeList;
            while((freeNode !== DynamicTreeFlatNodes.NULL_NODE)) {
                freeNode = this.m_parent[freeNode];
                ++freeCount;
            };
        }

        /**
         * 
         * @return {number}
         */
        public getHeight() : number {
            if(this.m_root === DynamicTreeFlatNodes.NULL_NODE) {
                return 0;
            }
            return this.m_height[this.m_root];
        }

        /**
         * 
         * @return {number}
         */
        public getMaxBalance() : number {
            let maxBalance : number = 0;
            for(let i : number = 0; i < this.m_nodeCapacity; ++i) {
                if(this.m_height[i] <= 1) {
                    continue;
                }
                let child1 : number = this.m_child1[i];
                let child2 : number = this.m_child2[i];
                let balance : number = org.jbox2d.common.MathUtils.abs$int(this.m_height[child2] - this.m_height[child1]);
                maxBalance = org.jbox2d.common.MathUtils.max$int$int(maxBalance, balance);
            };
            return maxBalance;
        }

        /**
         * 
         * @return {number}
         */
        public getAreaRatio() : number {
            if(this.m_root === DynamicTreeFlatNodes.NULL_NODE) {
                return 0.0;
            }
            let root : number = this.m_root;
            let rootArea : number = this.m_aabb[root].getPerimeter();
            let totalArea : number = 0.0;
            for(let i : number = 0; i < this.m_nodeCapacity; ++i) {
                if(this.m_height[i] < 0) {
                    continue;
                }
                totalArea += this.m_aabb[i].getPerimeter();
            };
            return (<any>Math).fround(totalArea / rootArea);
        }

        /*private*/ allocateNode() : number {
            if(this.m_freeList === DynamicTreeFlatNodes.NULL_NODE) {
                this.m_nodeCapacity *= 2;
                this.expandBuffers(this.m_nodeCount, this.m_nodeCapacity);
            }
            let node : number = this.m_freeList;
            this.m_freeList = this.m_parent[node];
            this.m_parent[node] = DynamicTreeFlatNodes.NULL_NODE;
            this.m_child1[node] = DynamicTreeFlatNodes.NULL_NODE;
            this.m_height[node] = 0;
            ++this.m_nodeCount;
            return node;
        }

        /**
         * returns a node to the pool
         * @param {number} node
         * @private
         */
        /*private*/ freeNode(node : number) {
            this.m_parent[node] = this.m_freeList !== DynamicTreeFlatNodes.NULL_NODE?this.m_freeList:DynamicTreeFlatNodes.NULL_NODE;
            this.m_height[node] = -1;
            this.m_freeList = node;
            this.m_nodeCount--;
        }

        /*private*/ combinedAABB : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ insertLeaf(leaf : number) {
            if(this.m_root === DynamicTreeFlatNodes.NULL_NODE) {
                this.m_root = leaf;
                this.m_parent[this.m_root] = DynamicTreeFlatNodes.NULL_NODE;
                return;
            }
            let leafAABB : org.jbox2d.collision.AABB = this.m_aabb[leaf];
            let index : number = this.m_root;
            while((this.m_child1[index] !== DynamicTreeFlatNodes.NULL_NODE)) {
                let node : number = index;
                let child1 : number = this.m_child1[node];
                let child2 : number = this.m_child2[node];
                let nodeAABB : org.jbox2d.collision.AABB = this.m_aabb[node];
                let area : number = nodeAABB.getPerimeter();
                this.combinedAABB.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(nodeAABB, leafAABB);
                let combinedArea : number = this.combinedAABB.getPerimeter();
                let cost : number = (<any>Math).fround(2.0 * combinedArea);
                let inheritanceCost : number = (<any>Math).fround(2.0 * ((<any>Math).fround(combinedArea - area)));
                let cost1 : number;
                let child1AABB : org.jbox2d.collision.AABB = this.m_aabb[child1];
                if(this.m_child1[child1] === DynamicTreeFlatNodes.NULL_NODE) {
                    this.combinedAABB.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(leafAABB, child1AABB);
                    cost1 = (<any>Math).fround(this.combinedAABB.getPerimeter() + inheritanceCost);
                } else {
                    this.combinedAABB.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(leafAABB, child1AABB);
                    let oldArea : number = child1AABB.getPerimeter();
                    let newArea : number = this.combinedAABB.getPerimeter();
                    cost1 = (<any>Math).fround(((<any>Math).fround(newArea - oldArea)) + inheritanceCost);
                }
                let cost2 : number;
                let child2AABB : org.jbox2d.collision.AABB = this.m_aabb[child2];
                if(this.m_child1[child2] === DynamicTreeFlatNodes.NULL_NODE) {
                    this.combinedAABB.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(leafAABB, child2AABB);
                    cost2 = (<any>Math).fround(this.combinedAABB.getPerimeter() + inheritanceCost);
                } else {
                    this.combinedAABB.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(leafAABB, child2AABB);
                    let oldArea : number = child2AABB.getPerimeter();
                    let newArea : number = this.combinedAABB.getPerimeter();
                    cost2 = (<any>Math).fround((<any>Math).fround(newArea - oldArea) + inheritanceCost);
                }
                if(cost < cost1 && cost < cost2) {
                    break;
                }
                if(cost1 < cost2) {
                    index = child1;
                } else {
                    index = child2;
                }
            };
            let sibling : number = index;
            let oldParent : number = this.m_parent[sibling];
            let newParent : number = this.allocateNode();
            this.m_parent[newParent] = oldParent;
            this.m_userData[newParent] = null;
            this.m_aabb[newParent].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(leafAABB, this.m_aabb[sibling]);
            this.m_height[newParent] = this.m_height[sibling] + 1;
            if(oldParent !== DynamicTreeFlatNodes.NULL_NODE) {
                if(this.m_child1[oldParent] === sibling) {
                    this.m_child1[oldParent] = newParent;
                } else {
                    this.m_child2[oldParent] = newParent;
                }
                this.m_child1[newParent] = sibling;
                this.m_child2[newParent] = leaf;
                this.m_parent[sibling] = newParent;
                this.m_parent[leaf] = newParent;
            } else {
                this.m_child1[newParent] = sibling;
                this.m_child2[newParent] = leaf;
                this.m_parent[sibling] = newParent;
                this.m_parent[leaf] = newParent;
                this.m_root = newParent;
            }
            index = this.m_parent[leaf];
            while((index !== DynamicTreeFlatNodes.NULL_NODE)) {
                index = this.balance(index);
                let child1 : number = this.m_child1[index];
                let child2 : number = this.m_child2[index];
                this.m_height[index] = 1 + org.jbox2d.common.MathUtils.max$int$int(this.m_height[child1], this.m_height[child2]);
                this.m_aabb[index].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[child1], this.m_aabb[child2]);
                index = this.m_parent[index];
            };
        }

        /*private*/ removeLeaf(leaf : number) {
            if(leaf === this.m_root) {
                this.m_root = DynamicTreeFlatNodes.NULL_NODE;
                return;
            }
            let parent : number = this.m_parent[leaf];
            let grandParent : number = this.m_parent[parent];
            let parentChild1 : number = this.m_child1[parent];
            let parentChild2 : number = this.m_child2[parent];
            let sibling : number;
            if(parentChild1 === leaf) {
                sibling = parentChild2;
            } else {
                sibling = parentChild1;
            }
            if(grandParent !== DynamicTreeFlatNodes.NULL_NODE) {
                if(this.m_child1[grandParent] === parent) {
                    this.m_child1[grandParent] = sibling;
                } else {
                    this.m_child2[grandParent] = sibling;
                }
                this.m_parent[sibling] = grandParent;
                this.freeNode(parent);
                let index : number = grandParent;
                while((index !== DynamicTreeFlatNodes.NULL_NODE)) {
                    index = this.balance(index);
                    let child1 : number = this.m_child1[index];
                    let child2 : number = this.m_child2[index];
                    this.m_aabb[index].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[child1], this.m_aabb[child2]);
                    this.m_height[index] = 1 + org.jbox2d.common.MathUtils.max$int$int(this.m_height[child1], this.m_height[child2]);
                    index = this.m_parent[index];
                };
            } else {
                this.m_root = sibling;
                this.m_parent[sibling] = DynamicTreeFlatNodes.NULL_NODE;
                this.freeNode(parent);
            }
        }

        /*private*/ balance(iA : number) : number {
            let A : number = iA;
            if(this.m_child1[A] === DynamicTreeFlatNodes.NULL_NODE || this.m_height[A] < 2) {
                return iA;
            }
            let iB : number = this.m_child1[A];
            let iC : number = this.m_child2[A];
            let B : number = iB;
            let C : number = iC;
            let balance : number = this.m_height[C] - this.m_height[B];
            if(balance > 1) {
                let iF : number = this.m_child1[C];
                let iG : number = this.m_child2[C];
                let F : number = iF;
                let G : number = iG;
                this.m_child1[C] = iA;
                let cParent : number = this.m_parent[C] = this.m_parent[A];
                this.m_parent[A] = iC;
                if(cParent !== DynamicTreeFlatNodes.NULL_NODE) {
                    if(this.m_child1[cParent] === iA) {
                        this.m_child1[cParent] = iC;
                    } else {
                        this.m_child2[cParent] = iC;
                    }
                } else {
                    this.m_root = iC;
                }
                if(this.m_height[F] > this.m_height[G]) {
                    this.m_child2[C] = iF;
                    this.m_child2[A] = iG;
                    this.m_parent[G] = iA;
                    this.m_aabb[A].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[B], this.m_aabb[G]);
                    this.m_aabb[C].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[A], this.m_aabb[F]);
                    this.m_height[A] = 1 + org.jbox2d.common.MathUtils.max$int$int(this.m_height[B], this.m_height[G]);
                    this.m_height[C] = 1 + org.jbox2d.common.MathUtils.max$int$int(this.m_height[A], this.m_height[F]);
                } else {
                    this.m_child2[C] = iG;
                    this.m_child2[A] = iF;
                    this.m_parent[F] = iA;
                    this.m_aabb[A].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[B], this.m_aabb[F]);
                    this.m_aabb[C].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[A], this.m_aabb[G]);
                    this.m_height[A] = 1 + org.jbox2d.common.MathUtils.max$int$int(this.m_height[B], this.m_height[F]);
                    this.m_height[C] = 1 + org.jbox2d.common.MathUtils.max$int$int(this.m_height[A], this.m_height[G]);
                }
                return iC;
            }
            if(balance < -1) {
                let iD : number = this.m_child1[B];
                let iE : number = this.m_child2[B];
                let D : number = iD;
                let E : number = iE;
                this.m_child1[B] = iA;
                let Bparent : number = this.m_parent[B] = this.m_parent[A];
                this.m_parent[A] = iB;
                if(Bparent !== DynamicTreeFlatNodes.NULL_NODE) {
                    if(this.m_child1[Bparent] === iA) {
                        this.m_child1[Bparent] = iB;
                    } else {
                        this.m_child2[Bparent] = iB;
                    }
                } else {
                    this.m_root = iB;
                }
                if(this.m_height[D] > this.m_height[E]) {
                    this.m_child2[B] = iD;
                    this.m_child1[A] = iE;
                    this.m_parent[E] = iA;
                    this.m_aabb[A].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[C], this.m_aabb[E]);
                    this.m_aabb[B].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[A], this.m_aabb[D]);
                    this.m_height[A] = 1 + org.jbox2d.common.MathUtils.max$int$int(this.m_height[C], this.m_height[E]);
                    this.m_height[B] = 1 + org.jbox2d.common.MathUtils.max$int$int(this.m_height[A], this.m_height[D]);
                } else {
                    this.m_child2[B] = iE;
                    this.m_child1[A] = iD;
                    this.m_parent[D] = iA;
                    this.m_aabb[A].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[C], this.m_aabb[D]);
                    this.m_aabb[B].combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[A], this.m_aabb[E]);
                    this.m_height[A] = 1 + org.jbox2d.common.MathUtils.max$int$int(this.m_height[C], this.m_height[D]);
                    this.m_height[B] = 1 + org.jbox2d.common.MathUtils.max$int$int(this.m_height[A], this.m_height[E]);
                }
                return iB;
            }
            return iA;
        }

        /*private*/ validateStructure(node : number) {
            if(node === DynamicTreeFlatNodes.NULL_NODE) {
                return;
            }
            if(node === this.m_root) {
            }
            let child1 : number = this.m_child1[node];
            let child2 : number = this.m_child2[node];
            if(child1 === DynamicTreeFlatNodes.NULL_NODE) {
                return;
            }
            this.validateStructure(child1);
            this.validateStructure(child2);
        }

        /*private*/ validateMetrics(node : number) {
            if(node === DynamicTreeFlatNodes.NULL_NODE) {
                return;
            }
            let child1 : number = this.m_child1[node];
            let child2 : number = this.m_child2[node];
            if(child1 === DynamicTreeFlatNodes.NULL_NODE) {
                return;
            }
            let height1 : number = this.m_height[child1];
            let height2 : number = this.m_height[child2];
            let height : number;
            height = 1 + org.jbox2d.common.MathUtils.max$int$int(height1, height2);
            let aabb : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();
            aabb.combine$org_jbox2d_collision_AABB$org_jbox2d_collision_AABB(this.m_aabb[child1], this.m_aabb[child2]);
            this.validateMetrics(child1);
            this.validateMetrics(child2);
        }

        public drawTree(argDraw? : any, node? : any, spot? : any, height? : any) : any {
            if(((argDraw != null && argDraw instanceof <any>org.jbox2d.callbacks.DebugDraw) || argDraw === null) && ((typeof node === 'number') || node === null) && ((typeof spot === 'number') || spot === null) && ((typeof height === 'number') || height === null)) {
                return <any>this.drawTree$org_jbox2d_callbacks_DebugDraw$int$int$int(argDraw, node, spot, height);
            } else if(((argDraw != null && argDraw instanceof <any>org.jbox2d.callbacks.DebugDraw) || argDraw === null) && node === undefined && spot === undefined && height === undefined) {
                return <any>this.drawTree$org_jbox2d_callbacks_DebugDraw(argDraw);
            } else throw new Error('invalid overload');
        }

        public drawTree$org_jbox2d_callbacks_DebugDraw(argDraw : org.jbox2d.callbacks.DebugDraw) {
            if(this.m_root === DynamicTreeFlatNodes.NULL_NODE) {
                return;
            }
            let height : number = this.computeHeight();
            this.drawTree$org_jbox2d_callbacks_DebugDraw$int$int$int(argDraw, this.m_root, 0, height);
        }

        /*private*/ color : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f();

        /*private*/ textVec : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public drawTree$org_jbox2d_callbacks_DebugDraw$int$int$int(argDraw : org.jbox2d.callbacks.DebugDraw, node : number, spot : number, height : number) {
            let a : org.jbox2d.collision.AABB = this.m_aabb[node];
            a.getVertices(this.drawVecs);
            this.color.set$float$float$float(1, (<any>Math).fround((<any>Math).fround((height - spot) * 1.0) / height), (<any>Math).fround((<any>Math).fround((height - spot) * 1.0) / height));
            argDraw.drawPolygon(this.drawVecs, 4, this.color);
            argDraw.getViewportTranform().getWorldToScreen(a.upperBound, this.textVec);
            argDraw.drawString$float$float$java_lang_String$org_jbox2d_common_Color3f(this.textVec.x, this.textVec.y, node + "-" + (spot + 1) + "/" + height, this.color);
            let c1 : number = this.m_child1[node];
            let c2 : number = this.m_child2[node];
            if(c1 !== DynamicTreeFlatNodes.NULL_NODE) {
                this.drawTree$org_jbox2d_callbacks_DebugDraw$int$int$int(argDraw, c1, spot + 1, height);
            }
            if(c2 !== DynamicTreeFlatNodes.NULL_NODE) {
                this.drawTree$org_jbox2d_callbacks_DebugDraw$int$int$int(argDraw, c2, spot + 1, height);
            }
        }
    }
    DynamicTreeFlatNodes["__class"] = "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes";
    DynamicTreeFlatNodes["__interfaces"] = ["org.jbox2d.collision.broadphase.BroadPhaseStrategy"];


}
namespace org.jbox2d.collision.broadphase {
    export class DynamicTreeNode {
        /**
         * Enlarged AABB
         */
        public aabb : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        public userData : any;

        parent : DynamicTreeNode;

        child1 : DynamicTreeNode;

        child2 : DynamicTreeNode;

        id : number;

        height : number;

        public getUserData() : any {
            return this.userData;
        }

        public setUserData(argData : any) {
            this.userData = argData;
        }

        constructor(id : number) {
            if(this.userData===undefined) this.userData = null;
            if(this.parent===undefined) this.parent = null;
            if(this.child1===undefined) this.child1 = null;
            if(this.child2===undefined) this.child2 = null;
            if(this.id===undefined) this.id = 0;
            if(this.height===undefined) this.height = 0;
            this.id = id;
        }
    }
    DynamicTreeNode["__class"] = "org.jbox2d.collision.broadphase.DynamicTreeNode";

}
namespace org.jbox2d.collision.broadphase {
    /**
     * Java note: at the "creation" of each node, a random key is given to that node, and that's what we
     * sort from.
     * @class
     */
    export class Pair {
        public proxyIdA : number;

        public proxyIdB : number;

        public compareTo(pair2 : Pair) : number {
            if(this.proxyIdA < pair2.proxyIdA) {
                return -1;
            }
            if(this.proxyIdA === pair2.proxyIdA) {
                return this.proxyIdB < pair2.proxyIdB?-1:this.proxyIdB === pair2.proxyIdB?0:1;
            }
            return 1;
        }

        constructor() {
            if(this.proxyIdA===undefined) this.proxyIdA = 0;
            if(this.proxyIdB===undefined) this.proxyIdB = 0;
        }
    }
    Pair["__class"] = "org.jbox2d.collision.broadphase.Pair";
    Pair["__interfaces"] = ["java.lang.Comparable"];


}
namespace org.jbox2d.collision {
    /**
     * Contact ids to facilitate warm starting. Note: the ContactFeatures class is just embedded in here
     * @param {org.jbox2d.collision.ContactID} c
     * @class
     */
    export class ContactID {
        public indexA : number;

        public indexB : number;

        public typeA : number;

        public typeB : number;

        public getKey() : number {
            return ((<number>this.indexA|0)) << 24 | ((<number>this.indexB|0)) << 16 | ((<number>this.typeA|0)) << 8 | ((<number>this.typeB|0));
        }

        public isEqual(cid : ContactID) : boolean {
            return this.getKey() === cid.getKey();
        }

        public constructor(c? : any) {
            if(((c != null && c instanceof <any>org.jbox2d.collision.ContactID) || c === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.indexA===undefined) this.indexA = 0;
                if(this.indexB===undefined) this.indexB = 0;
                if(this.typeA===undefined) this.typeA = 0;
                if(this.typeB===undefined) this.typeB = 0;
                if(this.indexA===undefined) this.indexA = 0;
                if(this.indexB===undefined) this.indexB = 0;
                if(this.typeA===undefined) this.typeA = 0;
                if(this.typeB===undefined) this.typeB = 0;
                (() => {
                    this.set(c);
                })();
            } else if(c === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.indexA===undefined) this.indexA = 0;
                if(this.indexB===undefined) this.indexB = 0;
                if(this.typeA===undefined) this.typeA = 0;
                if(this.typeB===undefined) this.typeB = 0;
                if(this.indexA===undefined) this.indexA = 0;
                if(this.indexB===undefined) this.indexB = 0;
                if(this.typeA===undefined) this.typeA = 0;
                if(this.typeB===undefined) this.typeB = 0;
            } else throw new Error('invalid overload');
        }

        public set(c : ContactID) {
            this.indexA = c.indexA;
            this.indexB = c.indexB;
            this.typeA = c.typeA;
            this.typeB = c.typeB;
        }

        public flip() {
            let tempA : number = this.indexA;
            this.indexA = this.indexB;
            this.indexB = tempA;
            tempA = this.typeA;
            this.typeA = this.typeB;
            this.typeB = tempA;
        }

        /**
         * zeros out the data
         */
        public zero() {
            this.indexA = 0;
            this.indexB = 0;
            this.typeA = 0;
            this.typeB = 0;
        }

        /**
         * 
         * @param {org.jbox2d.collision.ContactID} o
         * @return {number}
         */
        public compareTo(o : ContactID) : number {
            return this.getKey() - o.getKey();
        }
    }
    ContactID["__class"] = "org.jbox2d.collision.ContactID";
    ContactID["__interfaces"] = ["java.lang.Comparable"];



    export namespace ContactID {

        export enum Type {
            VERTEX, FACE
        }
    }

}
namespace org.jbox2d.collision {
    /**
     * This is non-static for faster pooling. To get an instance, use the {@link SingletonPool}, don't
     * construct a distance object.
     * 
     * @author Daniel Murphy
     * @class
     */
    export class Distance {
        public static MAX_ITERS : number = 20;

        public static GJK_CALLS : number = 0;

        public static GJK_ITERS : number = 0;

        public static GJK_MAX_ITERS : number = 20;

        /*private*/ simplex : Distance.Simplex = new Distance.Simplex(this);

        /*private*/ saveA : number[] = [0, 0, 0];

        /*private*/ saveB : number[] = [0, 0, 0];

        /*private*/ closestPoint : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ d : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ temp : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * Compute the closest points between two shapes. Supports any combination of: CircleShape and
         * PolygonShape. The simplex cache is input/output. On the first call set SimplexCache.count to
         * zero.
         * 
         * @param {org.jbox2d.collision.DistanceOutput} output
         * @param {org.jbox2d.collision.Distance.SimplexCache} cache
         * @param {org.jbox2d.collision.DistanceInput} input
         */
        public distance(output : org.jbox2d.collision.DistanceOutput, cache : Distance.SimplexCache, input : org.jbox2d.collision.DistanceInput) {
            Distance.GJK_CALLS++;
            let proxyA : Distance.DistanceProxy = input.proxyA;
            let proxyB : Distance.DistanceProxy = input.proxyB;
            let transformA : org.jbox2d.common.Transform = input.transformA;
            let transformB : org.jbox2d.common.Transform = input.transformB;
            this.simplex.readCache(cache, proxyA, transformA, proxyB, transformB);
            let vertices : Distance.SimplexVertex[] = this.simplex.vertices;
            let saveCount : number = 0;
            this.simplex.getClosestPoint(this.closestPoint);
            let distanceSqr1 : number = this.closestPoint.lengthSquared();
            let distanceSqr2 : number = distanceSqr1;
            let iter : number = 0;
            while((iter < Distance.MAX_ITERS)) {
                saveCount = this.simplex.m_count;
                for(let i : number = 0; i < saveCount; i++) {
                    this.saveA[i] = vertices[i].indexA;
                    this.saveB[i] = vertices[i].indexB;
                };
                switch((this.simplex.m_count)) {
                case 1:
                    break;
                case 2:
                    this.simplex.solve2();
                    break;
                case 3:
                    this.simplex.solve3();
                    break;
                default:
                    ;
                }
                if(this.simplex.m_count === 3) {
                    break;
                }
                this.simplex.getClosestPoint(this.closestPoint);
                distanceSqr2 = this.closestPoint.lengthSquared();
                if(distanceSqr2 >= distanceSqr1) {
                }
                distanceSqr1 = distanceSqr2;
                this.simplex.getSearchDirection(this.d);
                if(this.d.lengthSquared() < (<any>Math).fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON)) {
                    break;
                }
                let vertex : Distance.SimplexVertex = vertices[this.simplex.m_count];
                org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transformA.q, this.d.negateLocal(), this.temp);
                vertex.indexA = proxyA.getSupport(this.temp);
                org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transformA, proxyA.getVertex(vertex.indexA), vertex.wA);
                org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transformB.q, this.d.negateLocal(), this.temp);
                vertex.indexB = proxyB.getSupport(this.temp);
                org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transformB, proxyB.getVertex(vertex.indexB), vertex.wB);
                vertex.w.set$org_jbox2d_common_Vec2(vertex.wB).subLocal(vertex.wA);
                ++iter;
                ++Distance.GJK_ITERS;
                let duplicate : boolean = false;
                for(let i : number = 0; i < saveCount; ++i) {
                    if(vertex.indexA === this.saveA[i] && vertex.indexB === this.saveB[i]) {
                        duplicate = true;
                        break;
                    }
                };
                if(duplicate) {
                    break;
                }
                ++this.simplex.m_count;
            };
            Distance.GJK_MAX_ITERS = org.jbox2d.common.MathUtils.max$int$int(Distance.GJK_MAX_ITERS, iter);
            this.simplex.getWitnessPoints(output.pointA, output.pointB);
            output.distance = org.jbox2d.common.MathUtils.distance(output.pointA, output.pointB);
            output.iterations = iter;
            this.simplex.writeCache(cache);
            if(input.useRadii) {
                let rA : number = proxyA.m_radius;
                let rB : number = proxyB.m_radius;
                if(output.distance > (<any>Math).fround(rA + rB) && output.distance > org.jbox2d.common.Settings.EPSILON) {
                    output.distance -= (<any>Math).fround(rA + rB);
                    this.normal.set$org_jbox2d_common_Vec2(output.pointB).subLocal(output.pointA);
                    this.normal.normalize();
                    this.temp.set$org_jbox2d_common_Vec2(this.normal).mulLocal(rA);
                    output.pointA.addLocal$org_jbox2d_common_Vec2(this.temp);
                    this.temp.set$org_jbox2d_common_Vec2(this.normal).mulLocal(rB);
                    output.pointB.subLocal(this.temp);
                } else {
                    output.pointA.addLocal$org_jbox2d_common_Vec2(output.pointB).mulLocal(0.5);
                    output.pointB.set$org_jbox2d_common_Vec2(output.pointA);
                    output.distance = 0.0;
                }
            }
        }
    }
    Distance["__class"] = "org.jbox2d.collision.Distance";


    export namespace Distance {

        /**
         * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.
         * @class
         */
        export class SimplexVertex {
            public __parent: any;
            public wA : org.jbox2d.common.Vec2;

            public wB : org.jbox2d.common.Vec2;

            public w : org.jbox2d.common.Vec2;

            public a : number;

            public indexA : number;

            public indexB : number;

            public set(sv : Distance.SimplexVertex) {
                this.wA.set$org_jbox2d_common_Vec2(sv.wA);
                this.wB.set$org_jbox2d_common_Vec2(sv.wB);
                this.w.set$org_jbox2d_common_Vec2(sv.w);
                this.a = sv.a;
                this.indexA = sv.indexA;
                this.indexB = sv.indexB;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
                this.wA = new org.jbox2d.common.Vec2();
                this.wB = new org.jbox2d.common.Vec2();
                this.w = new org.jbox2d.common.Vec2();
                if(this.a===undefined) this.a = 0;
                if(this.indexA===undefined) this.indexA = 0;
                if(this.indexB===undefined) this.indexB = 0;
            }
        }
        SimplexVertex["__class"] = "org.jbox2d.collision.Distance.SimplexVertex";


        /**
         * Used to warm start Distance. Set count to zero on first call.
         * 
         * @author daniel
         * @class
         */
        export class SimplexCache {
            /**
             * length or area
             */
            public metric : number;

            public count : number;

            /**
             * vertices on shape A
             */
            public indexA : number[] = [0, 0, 0];

            /**
             * vertices on shape B
             */
            public indexB : number[] = [0, 0, 0];

            public constructor() {
                if(this.metric===undefined) this.metric = 0;
                if(this.count===undefined) this.count = 0;
                this.metric = 0;
                this.count = 0;
                this.indexA[0] = Number.MAX_VALUE;
                this.indexA[1] = Number.MAX_VALUE;
                this.indexA[2] = Number.MAX_VALUE;
                this.indexB[0] = Number.MAX_VALUE;
                this.indexB[1] = Number.MAX_VALUE;
                this.indexB[2] = Number.MAX_VALUE;
            }

            public set(sc : Distance.SimplexCache) {
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(sc.indexA, 0, this.indexA, 0, this.indexA.length);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(sc.indexB, 0, this.indexB, 0, this.indexB.length);
                this.metric = sc.metric;
                this.count = sc.count;
            }
        }
        SimplexCache["__class"] = "org.jbox2d.collision.Distance.SimplexCache";


        export class Simplex {
            public __parent: any;
            public m_v1 : Distance.SimplexVertex;

            public m_v2 : Distance.SimplexVertex;

            public m_v3 : Distance.SimplexVertex;

            public vertices : Distance.SimplexVertex[];

            public m_count : number;

            public readCache(cache : Distance.SimplexCache, proxyA : Distance.DistanceProxy, transformA : org.jbox2d.common.Transform, proxyB : Distance.DistanceProxy, transformB : org.jbox2d.common.Transform) {
                this.m_count = cache.count;
                for(let i : number = 0; i < this.m_count; ++i) {
                    let v : Distance.SimplexVertex = this.vertices[i];
                    v.indexA = cache.indexA[i];
                    v.indexB = cache.indexB[i];
                    let wALocal : org.jbox2d.common.Vec2 = proxyA.getVertex(v.indexA);
                    let wBLocal : org.jbox2d.common.Vec2 = proxyB.getVertex(v.indexB);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transformA, wALocal, v.wA);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transformB, wBLocal, v.wB);
                    v.w.set$org_jbox2d_common_Vec2(v.wB).subLocal(v.wA);
                    v.a = 0.0;
                };
                if(this.m_count > 1) {
                    let metric1 : number = cache.metric;
                    let metric2 : number = this.getMetric();
                    if(metric2 < (<any>Math).fround(0.5 * metric1) || (<any>Math).fround(2.0 * metric1) < metric2 || metric2 < org.jbox2d.common.Settings.EPSILON) {
                        this.m_count = 0;
                    }
                }
                if(this.m_count === 0) {
                    let v : Distance.SimplexVertex = this.vertices[0];
                    v.indexA = 0;
                    v.indexB = 0;
                    let wALocal : org.jbox2d.common.Vec2 = proxyA.getVertex(0);
                    let wBLocal : org.jbox2d.common.Vec2 = proxyB.getVertex(0);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transformA, wALocal, v.wA);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transformB, wBLocal, v.wB);
                    v.w.set$org_jbox2d_common_Vec2(v.wB).subLocal(v.wA);
                    this.m_count = 1;
                }
            }

            public writeCache(cache : Distance.SimplexCache) {
                cache.metric = this.getMetric();
                cache.count = this.m_count;
                for(let i : number = 0; i < this.m_count; ++i) {
                    cache.indexA[i] = (this.vertices[i].indexA);
                    cache.indexB[i] = (this.vertices[i].indexB);
                };
            }

            e12 : org.jbox2d.common.Vec2;

            public getSearchDirection(out : org.jbox2d.common.Vec2) {
                switch((this.m_count)) {
                case 1:
                    out.set$org_jbox2d_common_Vec2(this.m_v1.w).negateLocal();
                    return;
                case 2:
                    this.e12.set$org_jbox2d_common_Vec2(this.m_v2.w).subLocal(this.m_v1.w);
                    out.set$org_jbox2d_common_Vec2(this.m_v1.w).negateLocal();
                    let sgn : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.e12, out);
                    if(sgn > 0.0) {
                        org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(1.0, this.e12, out);
                        return;
                    } else {
                        org.jbox2d.common.Vec2.crossToOutUnsafe$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(this.e12, 1.0, out);
                        return;
                    }
                default:
                    ;
                    out.setZero();
                    return;
                }
            }

            case2 : org.jbox2d.common.Vec2;

            case22 : org.jbox2d.common.Vec2;

            /**
             * this returns pooled objects. don't keep or modify them
             * 
             * @return
             * @param {org.jbox2d.common.Vec2} out
             */
            public getClosestPoint(out : org.jbox2d.common.Vec2) {
                switch((this.m_count)) {
                case 0:
                    ;
                    out.setZero();
                    return;
                case 1:
                    out.set$org_jbox2d_common_Vec2(this.m_v1.w);
                    return;
                case 2:
                    this.case22.set$org_jbox2d_common_Vec2(this.m_v2.w).mulLocal(this.m_v2.a);
                    this.case2.set$org_jbox2d_common_Vec2(this.m_v1.w).mulLocal(this.m_v1.a).addLocal$org_jbox2d_common_Vec2(this.case22);
                    out.set$org_jbox2d_common_Vec2(this.case2);
                    return;
                case 3:
                    out.setZero();
                    return;
                default:
                    ;
                    out.setZero();
                    return;
                }
            }

            case3 : org.jbox2d.common.Vec2;

            case33 : org.jbox2d.common.Vec2;

            public getWitnessPoints(pA : org.jbox2d.common.Vec2, pB : org.jbox2d.common.Vec2) {
                switch((this.m_count)) {
                case 0:
                    ;
                    break;
                case 1:
                    pA.set$org_jbox2d_common_Vec2(this.m_v1.wA);
                    pB.set$org_jbox2d_common_Vec2(this.m_v1.wB);
                    break;
                case 2:
                    this.case2.set$org_jbox2d_common_Vec2(this.m_v1.wA).mulLocal(this.m_v1.a);
                    pA.set$org_jbox2d_common_Vec2(this.m_v2.wA).mulLocal(this.m_v2.a).addLocal$org_jbox2d_common_Vec2(this.case2);
                    this.case2.set$org_jbox2d_common_Vec2(this.m_v1.wB).mulLocal(this.m_v1.a);
                    pB.set$org_jbox2d_common_Vec2(this.m_v2.wB).mulLocal(this.m_v2.a).addLocal$org_jbox2d_common_Vec2(this.case2);
                    break;
                case 3:
                    pA.set$org_jbox2d_common_Vec2(this.m_v1.wA).mulLocal(this.m_v1.a);
                    this.case3.set$org_jbox2d_common_Vec2(this.m_v2.wA).mulLocal(this.m_v2.a);
                    this.case33.set$org_jbox2d_common_Vec2(this.m_v3.wA).mulLocal(this.m_v3.a);
                    pA.addLocal$org_jbox2d_common_Vec2(this.case3).addLocal$org_jbox2d_common_Vec2(this.case33);
                    pB.set$org_jbox2d_common_Vec2(pA);
                    break;
                default:
                    ;
                    break;
                }
            }

            public getMetric() : number {
                switch((this.m_count)) {
                case 0:
                    ;
                    return 0.0;
                case 1:
                    return 0.0;
                case 2:
                    return org.jbox2d.common.MathUtils.distance(this.m_v1.w, this.m_v2.w);
                case 3:
                    this.case3.set$org_jbox2d_common_Vec2(this.m_v2.w).subLocal(this.m_v1.w);
                    this.case33.set$org_jbox2d_common_Vec2(this.m_v3.w).subLocal(this.m_v1.w);
                    return org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.case3, this.case33);
                default:
                    ;
                    return 0.0;
                }
            }

            /**
             * Solve a line segment using barycentric coordinates.
             */
            public solve2() {
                let w1 : org.jbox2d.common.Vec2 = this.m_v1.w;
                let w2 : org.jbox2d.common.Vec2 = this.m_v2.w;
                this.e12.set$org_jbox2d_common_Vec2(w2).subLocal(w1);
                let d12_2 : number = -org.jbox2d.common.Vec2.dot(w1, this.e12);
                if(d12_2 <= 0.0) {
                    this.m_v1.a = 1.0;
                    this.m_count = 1;
                    return;
                }
                let d12_1 : number = org.jbox2d.common.Vec2.dot(w2, this.e12);
                if(d12_1 <= 0.0) {
                    this.m_v2.a = 1.0;
                    this.m_count = 1;
                    this.m_v1.set(this.m_v2);
                    return;
                }
                let inv_d12 : number = (<any>Math).fround(1.0 / ((<any>Math).fround(d12_1 + d12_2)));
                this.m_v1.a = (<any>Math).fround(d12_1 * inv_d12);
                this.m_v2.a = (<any>Math).fround(d12_2 * inv_d12);
                this.m_count = 2;
            }

            e13 : org.jbox2d.common.Vec2;

            e23 : org.jbox2d.common.Vec2;

            w1 : org.jbox2d.common.Vec2;

            w2 : org.jbox2d.common.Vec2;

            w3 : org.jbox2d.common.Vec2;

            /**
             * Solve a line segment using barycentric coordinates.<br/>
             * Possible regions:<br/>
             * - points[2]<br/>
             * - edge points[0]-points[2]<br/>
             * - edge points[1]-points[2]<br/>
             * - inside the triangle
             */
            public solve3() {
                this.w1.set$org_jbox2d_common_Vec2(this.m_v1.w);
                this.w2.set$org_jbox2d_common_Vec2(this.m_v2.w);
                this.w3.set$org_jbox2d_common_Vec2(this.m_v3.w);
                this.e12.set$org_jbox2d_common_Vec2(this.w2).subLocal(this.w1);
                let w1e12 : number = org.jbox2d.common.Vec2.dot(this.w1, this.e12);
                let w2e12 : number = org.jbox2d.common.Vec2.dot(this.w2, this.e12);
                let d12_1 : number = w2e12;
                let d12_2 : number = -w1e12;
                this.e13.set$org_jbox2d_common_Vec2(this.w3).subLocal(this.w1);
                let w1e13 : number = org.jbox2d.common.Vec2.dot(this.w1, this.e13);
                let w3e13 : number = org.jbox2d.common.Vec2.dot(this.w3, this.e13);
                let d13_1 : number = w3e13;
                let d13_2 : number = -w1e13;
                this.e23.set$org_jbox2d_common_Vec2(this.w3).subLocal(this.w2);
                let w2e23 : number = org.jbox2d.common.Vec2.dot(this.w2, this.e23);
                let w3e23 : number = org.jbox2d.common.Vec2.dot(this.w3, this.e23);
                let d23_1 : number = w3e23;
                let d23_2 : number = -w2e23;
                let n123 : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.e12, this.e13);
                let d123_1 : number = (<any>Math).fround(n123 * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.w2, this.w3));
                let d123_2 : number = (<any>Math).fround(n123 * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.w3, this.w1));
                let d123_3 : number = (<any>Math).fround(n123 * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.w1, this.w2));
                if(d12_2 <= 0.0 && d13_2 <= 0.0) {
                    this.m_v1.a = 1.0;
                    this.m_count = 1;
                    return;
                }
                if(d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
                    let inv_d12 : number = (<any>Math).fround(1.0 / ((<any>Math).fround(d12_1 + d12_2)));
                    this.m_v1.a = (<any>Math).fround(d12_1 * inv_d12);
                    this.m_v2.a = (<any>Math).fround(d12_2 * inv_d12);
                    this.m_count = 2;
                    return;
                }
                if(d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
                    let inv_d13 : number = (<any>Math).fround(1.0 / ((<any>Math).fround(d13_1 + d13_2)));
                    this.m_v1.a = (<any>Math).fround(d13_1 * inv_d13);
                    this.m_v3.a = (<any>Math).fround(d13_2 * inv_d13);
                    this.m_count = 2;
                    this.m_v2.set(this.m_v3);
                    return;
                }
                if(d12_1 <= 0.0 && d23_2 <= 0.0) {
                    this.m_v2.a = 1.0;
                    this.m_count = 1;
                    this.m_v1.set(this.m_v2);
                    return;
                }
                if(d13_1 <= 0.0 && d23_1 <= 0.0) {
                    this.m_v3.a = 1.0;
                    this.m_count = 1;
                    this.m_v1.set(this.m_v3);
                    return;
                }
                if(d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
                    let inv_d23 : number = (<any>Math).fround(1.0 / ((<any>Math).fround(d23_1 + d23_2)));
                    this.m_v2.a = (<any>Math).fround(d23_1 * inv_d23);
                    this.m_v3.a = (<any>Math).fround(d23_2 * inv_d23);
                    this.m_count = 2;
                    this.m_v1.set(this.m_v3);
                    return;
                }
                let inv_d123 : number = (<any>Math).fround(1.0 / ((<any>Math).fround((<any>Math).fround(d123_1 + d123_2) + d123_3)));
                this.m_v1.a = (<any>Math).fround(d123_1 * inv_d123);
                this.m_v2.a = (<any>Math).fround(d123_2 * inv_d123);
                this.m_v3.a = (<any>Math).fround(d123_3 * inv_d123);
                this.m_count = 3;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
                this.m_v1 = new Distance.SimplexVertex(this.__parent);
                this.m_v2 = new Distance.SimplexVertex(this.__parent);
                this.m_v3 = new Distance.SimplexVertex(this.__parent);
                this.vertices = [this.m_v1, this.m_v2, this.m_v3];
                if(this.m_count===undefined) this.m_count = 0;
                this.e12 = new org.jbox2d.common.Vec2();
                this.case2 = new org.jbox2d.common.Vec2();
                this.case22 = new org.jbox2d.common.Vec2();
                this.case3 = new org.jbox2d.common.Vec2();
                this.case33 = new org.jbox2d.common.Vec2();
                this.e13 = new org.jbox2d.common.Vec2();
                this.e23 = new org.jbox2d.common.Vec2();
                this.w1 = new org.jbox2d.common.Vec2();
                this.w2 = new org.jbox2d.common.Vec2();
                this.w3 = new org.jbox2d.common.Vec2();
            }
        }
        Simplex["__class"] = "org.jbox2d.collision.Distance.Simplex";


        /**
         * A distance proxy is used by the GJK algorithm. It encapsulates any shape. TODO: see if we can
         * just do assignments with m_vertices, instead of copying stuff over
         * 
         * @author daniel
         * @class
         */
        export class DistanceProxy {
            public m_vertices : org.jbox2d.common.Vec2[];

            public m_count : number;

            public m_radius : number;

            public m_buffer : org.jbox2d.common.Vec2[];

            public constructor() {
                if(this.m_vertices===undefined) this.m_vertices = null;
                if(this.m_count===undefined) this.m_count = 0;
                if(this.m_radius===undefined) this.m_radius = 0;
                if(this.m_buffer===undefined) this.m_buffer = null;
                this.m_vertices = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxPolygonVertices);
                for(let i : number = 0; i < this.m_vertices.length; i++) {
                    this.m_vertices[i] = new org.jbox2d.common.Vec2();
                };
                this.m_buffer = [null, null];
                this.m_count = 0;
                this.m_radius = 0.0;
            }

            /**
             * Initialize the proxy using the given shape. The shape must remain in scope while the proxy is
             * in use.
             * @param {org.jbox2d.collision.shapes.Shape} shape
             * @param {number} index
             */
            public set(shape : org.jbox2d.collision.shapes.Shape, index : number) {
                switch((shape.getType())) {
                case org.jbox2d.collision.shapes.ShapeType.CIRCLE:
                    let circle : org.jbox2d.collision.shapes.CircleShape = <org.jbox2d.collision.shapes.CircleShape>shape;
                    this.m_vertices[0].set$org_jbox2d_common_Vec2(circle.m_p);
                    this.m_count = 1;
                    this.m_radius = circle.m_radius;
                    break;
                case org.jbox2d.collision.shapes.ShapeType.POLYGON:
                    let poly : org.jbox2d.collision.shapes.PolygonShape = <org.jbox2d.collision.shapes.PolygonShape>shape;
                    this.m_count = poly.m_count;
                    this.m_radius = poly.m_radius;
                    for(let i : number = 0; i < this.m_count; i++) {
                        this.m_vertices[i].set$org_jbox2d_common_Vec2(poly.m_vertices[i]);
                    };
                    break;
                case org.jbox2d.collision.shapes.ShapeType.CHAIN:
                    let chain : org.jbox2d.collision.shapes.ChainShape = <org.jbox2d.collision.shapes.ChainShape>shape;
                    ;
                    this.m_buffer[0] = chain.m_vertices[index];
                    if(index + 1 < chain.m_count) {
                        this.m_buffer[1] = chain.m_vertices[index + 1];
                    } else {
                        this.m_buffer[1] = chain.m_vertices[0];
                    }
                    this.m_vertices[0].set$org_jbox2d_common_Vec2(this.m_buffer[0]);
                    this.m_vertices[1].set$org_jbox2d_common_Vec2(this.m_buffer[1]);
                    this.m_count = 2;
                    this.m_radius = chain.m_radius;
                    break;
                case org.jbox2d.collision.shapes.ShapeType.EDGE:
                    let edge : org.jbox2d.collision.shapes.EdgeShape = <org.jbox2d.collision.shapes.EdgeShape>shape;
                    this.m_vertices[0].set$org_jbox2d_common_Vec2(edge.m_vertex1);
                    this.m_vertices[1].set$org_jbox2d_common_Vec2(edge.m_vertex2);
                    this.m_count = 2;
                    this.m_radius = edge.m_radius;
                    break;
                default:
                    ;
                }
            }

            /**
             * Get the supporting vertex index in the given direction.
             * 
             * @param {org.jbox2d.common.Vec2} d
             * @return
             * @return {number}
             */
            public getSupport(d : org.jbox2d.common.Vec2) : number {
                let bestIndex : number = 0;
                let bestValue : number = org.jbox2d.common.Vec2.dot(this.m_vertices[0], d);
                for(let i : number = 1; i < this.m_count; i++) {
                    let value : number = org.jbox2d.common.Vec2.dot(this.m_vertices[i], d);
                    if(value > bestValue) {
                        bestIndex = i;
                        bestValue = value;
                    }
                };
                return bestIndex;
            }

            /**
             * Get the supporting vertex in the given direction.
             * 
             * @param {org.jbox2d.common.Vec2} d
             * @return
             * @return {org.jbox2d.common.Vec2}
             */
            public getSupportVertex(d : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
                let bestIndex : number = 0;
                let bestValue : number = org.jbox2d.common.Vec2.dot(this.m_vertices[0], d);
                for(let i : number = 1; i < this.m_count; i++) {
                    let value : number = org.jbox2d.common.Vec2.dot(this.m_vertices[i], d);
                    if(value > bestValue) {
                        bestIndex = i;
                        bestValue = value;
                    }
                };
                return this.m_vertices[bestIndex];
            }

            /**
             * Get the vertex count.
             * 
             * @return
             * @return {number}
             */
            public getVertexCount() : number {
                return this.m_count;
            }

            /**
             * Get a vertex by index. Used by Distance.
             * 
             * @param {number} index
             * @return
             * @return {org.jbox2d.common.Vec2}
             */
            public getVertex(index : number) : org.jbox2d.common.Vec2 {
                return this.m_vertices[index];
            }
        }
        DistanceProxy["__class"] = "org.jbox2d.collision.Distance.DistanceProxy";

    }

}
namespace org.jbox2d.collision {
    /**
     * Input for Distance.
     * You have to option to use the shape radii
     * in the computation.
     * @class
     */
    export class DistanceInput {
        public proxyA : org.jbox2d.collision.Distance.DistanceProxy = new org.jbox2d.collision.Distance.DistanceProxy();

        public proxyB : org.jbox2d.collision.Distance.DistanceProxy = new org.jbox2d.collision.Distance.DistanceProxy();

        public transformA : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        public transformB : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        public useRadii : boolean;

        constructor() {
            if(this.useRadii===undefined) this.useRadii = false;
        }
    }
    DistanceInput["__class"] = "org.jbox2d.collision.DistanceInput";

}
namespace org.jbox2d.collision {
    /**
     * Output for Distance.
     * @author Daniel
     * @class
     */
    export class DistanceOutput {
        /**
         * Closest point on shapeA
         */
        public pointA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * Closest point on shapeB
         */
        public pointB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public distance : number;

        /**
         * number of gjk iterations used
         */
        public iterations : number;

        constructor() {
            if(this.distance===undefined) this.distance = 0;
            if(this.iterations===undefined) this.iterations = 0;
        }
    }
    DistanceOutput["__class"] = "org.jbox2d.collision.DistanceOutput";

}
namespace org.jbox2d.collision {
    /**
     * Creates this manifold as a copy of the other
     * 
     * @param {org.jbox2d.collision.Manifold} other
     * @class
     */
    export class Manifold {
        /**
         * The points of contact.
         */
        public points : org.jbox2d.collision.ManifoldPoint[];

        /**
         * not use for Type::e_points
         */
        public localNormal : org.jbox2d.common.Vec2;

        /**
         * usage depends on manifold type
         */
        public localPoint : org.jbox2d.common.Vec2;

        public type : Manifold.ManifoldType;

        /**
         * The number of manifold points.
         */
        public pointCount : number;

        public constructor(other? : any) {
            if(((other != null && other instanceof <any>org.jbox2d.collision.Manifold) || other === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.points===undefined) this.points = null;
                if(this.localNormal===undefined) this.localNormal = null;
                if(this.localPoint===undefined) this.localPoint = null;
                if(this.type===undefined) this.type = null;
                if(this.pointCount===undefined) this.pointCount = 0;
                if(this.points===undefined) this.points = null;
                if(this.localNormal===undefined) this.localNormal = null;
                if(this.localPoint===undefined) this.localPoint = null;
                if(this.type===undefined) this.type = null;
                if(this.pointCount===undefined) this.pointCount = 0;
                (() => {
                    this.points = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);
                    this.localNormal = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(other.localNormal);
                    this.localPoint = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(other.localPoint);
                    this.pointCount = other.pointCount;
                    this.type = other.type;
                    for(let i : number = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; i++) {
                        this.points[i] = new org.jbox2d.collision.ManifoldPoint(other.points[i]);
                    };
                })();
            } else if(other === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.points===undefined) this.points = null;
                if(this.localNormal===undefined) this.localNormal = null;
                if(this.localPoint===undefined) this.localPoint = null;
                if(this.type===undefined) this.type = null;
                if(this.pointCount===undefined) this.pointCount = 0;
                if(this.points===undefined) this.points = null;
                if(this.localNormal===undefined) this.localNormal = null;
                if(this.localPoint===undefined) this.localPoint = null;
                if(this.type===undefined) this.type = null;
                if(this.pointCount===undefined) this.pointCount = 0;
                (() => {
                    this.points = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);
                    for(let i : number = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; i++) {
                        this.points[i] = new org.jbox2d.collision.ManifoldPoint();
                    };
                    this.localNormal = new org.jbox2d.common.Vec2();
                    this.localPoint = new org.jbox2d.common.Vec2();
                    this.pointCount = 0;
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * copies this manifold from the given one
         * 
         * @param {org.jbox2d.collision.Manifold} cp manifold to copy from
         */
        public set(cp : Manifold) {
            for(let i : number = 0; i < cp.pointCount; i++) {
                this.points[i].set(cp.points[i]);
            };
            this.type = cp.type;
            this.localNormal.set$org_jbox2d_common_Vec2(cp.localNormal);
            this.localPoint.set$org_jbox2d_common_Vec2(cp.localPoint);
            this.pointCount = cp.pointCount;
        }
    }
    Manifold["__class"] = "org.jbox2d.collision.Manifold";


    export namespace Manifold {

        export enum ManifoldType {
            CIRCLES, FACE_A, FACE_B
        }
    }

}
namespace org.jbox2d.collision {
    /**
     * Creates a manifold point as a copy of the given point
     * @param {org.jbox2d.collision.ManifoldPoint} cp point to copy from
     * @class
     */
    export class ManifoldPoint {
        /**
         * usage depends on manifold type
         */
        public localPoint : org.jbox2d.common.Vec2;

        /**
         * the non-penetration impulse
         */
        public normalImpulse : number;

        /**
         * the friction impulse
         */
        public tangentImpulse : number;

        /**
         * uniquely identifies a contact point between two shapes
         */
        public id : org.jbox2d.collision.ContactID;

        public constructor(cp? : any) {
            if(((cp != null && cp instanceof <any>org.jbox2d.collision.ManifoldPoint) || cp === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.localPoint===undefined) this.localPoint = null;
                if(this.normalImpulse===undefined) this.normalImpulse = 0;
                if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
                if(this.id===undefined) this.id = null;
                if(this.localPoint===undefined) this.localPoint = null;
                if(this.normalImpulse===undefined) this.normalImpulse = 0;
                if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
                if(this.id===undefined) this.id = null;
                (() => {
                    this.localPoint = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(cp.localPoint);
                    this.normalImpulse = cp.normalImpulse;
                    this.tangentImpulse = cp.tangentImpulse;
                    this.id = new org.jbox2d.collision.ContactID(cp.id);
                })();
            } else if(cp === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.localPoint===undefined) this.localPoint = null;
                if(this.normalImpulse===undefined) this.normalImpulse = 0;
                if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
                if(this.id===undefined) this.id = null;
                if(this.localPoint===undefined) this.localPoint = null;
                if(this.normalImpulse===undefined) this.normalImpulse = 0;
                if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
                if(this.id===undefined) this.id = null;
                (() => {
                    this.localPoint = new org.jbox2d.common.Vec2();
                    this.normalImpulse = this.tangentImpulse = 0.0;
                    this.id = new org.jbox2d.collision.ContactID();
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * Sets this manifold point form the given one
         * @param {org.jbox2d.collision.ManifoldPoint} cp the point to copy from
         */
        public set(cp : ManifoldPoint) {
            this.localPoint.set$org_jbox2d_common_Vec2(cp.localPoint);
            this.normalImpulse = cp.normalImpulse;
            this.tangentImpulse = cp.tangentImpulse;
            this.id.set(cp.id);
        }
    }
    ManifoldPoint["__class"] = "org.jbox2d.collision.ManifoldPoint";

}
namespace org.jbox2d.collision {
    /**
     * Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
     * @class
     */
    export class RayCastInput {
        public p1 : org.jbox2d.common.Vec2;

        public p2 : org.jbox2d.common.Vec2;

        public maxFraction : number;

        public constructor() {
            if(this.p1===undefined) this.p1 = null;
            if(this.p2===undefined) this.p2 = null;
            if(this.maxFraction===undefined) this.maxFraction = 0;
            this.p1 = new org.jbox2d.common.Vec2();
            this.p2 = new org.jbox2d.common.Vec2();
            this.maxFraction = 0;
        }

        public set(rci : RayCastInput) {
            this.p1.set$org_jbox2d_common_Vec2(rci.p1);
            this.p2.set$org_jbox2d_common_Vec2(rci.p2);
            this.maxFraction = rci.maxFraction;
        }
    }
    RayCastInput["__class"] = "org.jbox2d.collision.RayCastInput";

}
namespace org.jbox2d.collision {
    /**
     * Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
     * come from b2RayCastInput.
     * @class
     */
    export class RayCastOutput {
        public normal : org.jbox2d.common.Vec2;

        public fraction : number;

        public constructor() {
            if(this.normal===undefined) this.normal = null;
            if(this.fraction===undefined) this.fraction = 0;
            this.normal = new org.jbox2d.common.Vec2();
            this.fraction = 0;
        }

        public set(rco : RayCastOutput) {
            this.normal.set$org_jbox2d_common_Vec2(rco.normal);
            this.fraction = rco.fraction;
        }
    }
    RayCastOutput["__class"] = "org.jbox2d.collision.RayCastOutput";

}
namespace org.jbox2d.collision.shapes {
    /**
     * Copies from the given mass data
     * 
     * @param {org.jbox2d.collision.shapes.MassData} md
     * mass data to copy from
     * @class
     */
    export class MassData {
        /**
         * The mass of the shape, usually in kilograms.
         */
        public mass : number;

        /**
         * The position of the shape's centroid relative to the shape's origin.
         */
        public center : org.jbox2d.common.Vec2;

        /**
         * The rotational inertia of the shape about the local origin.
         */
        public I : number;

        public constructor(md? : any) {
            if(((md != null && md instanceof <any>org.jbox2d.collision.shapes.MassData) || md === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.mass===undefined) this.mass = 0;
                if(this.center===undefined) this.center = null;
                if(this.I===undefined) this.I = 0;
                if(this.mass===undefined) this.mass = 0;
                if(this.center===undefined) this.center = null;
                if(this.I===undefined) this.I = 0;
                (() => {
                    this.mass = md.mass;
                    this.I = md.I;
                    this.center = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(md.center);
                })();
            } else if(md === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.mass===undefined) this.mass = 0;
                if(this.center===undefined) this.center = null;
                if(this.I===undefined) this.I = 0;
                if(this.mass===undefined) this.mass = 0;
                if(this.center===undefined) this.center = null;
                if(this.I===undefined) this.I = 0;
                (() => {
                    this.mass = this.I = 0.0;
                    this.center = new org.jbox2d.common.Vec2();
                })();
            } else throw new Error('invalid overload');
        }

        public set(md : MassData) {
            this.mass = md.mass;
            this.I = md.I;
            this.center.set$org_jbox2d_common_Vec2(md.center);
        }

        /**
         * Return a copy of this object.
         * @return {org.jbox2d.collision.shapes.MassData}
         */
        public clone() : MassData {
            return new MassData(this);
        }
    }
    MassData["__class"] = "org.jbox2d.collision.shapes.MassData";

}
namespace org.jbox2d.collision.shapes {
    /**
     * A shape is used for collision detection. You can create a shape however you like. Shapes used for
     * simulation in World are created automatically when a Fixture is created. Shapes may encapsulate a
     * one or more child shapes.
     * @param {org.jbox2d.collision.shapes.ShapeType} type
     * @class
     */
    export abstract class Shape {
        public m_type : org.jbox2d.collision.shapes.ShapeType;

        public m_radius : number;

        public constructor(type : org.jbox2d.collision.shapes.ShapeType) {
            if(this.m_type===undefined) this.m_type = null;
            if(this.m_radius===undefined) this.m_radius = 0;
            this.m_type = type;
        }

        /**
         * Get the type of this shape. You can use this to down cast to the concrete shape.
         * 
         * @return {org.jbox2d.collision.shapes.ShapeType} the shape type.
         */
        public getType() : org.jbox2d.collision.shapes.ShapeType {
            return this.m_type;
        }

        /**
         * The radius of the underlying shape. This can refer to different things depending on the shape
         * implementation
         * 
         * @return
         * @return {number}
         */
        public getRadius() : number {
            return this.m_radius;
        }

        /**
         * Sets the radius of the underlying shape. This can refer to different things depending on the
         * implementation
         * 
         * @param {number} radius
         */
        public setRadius(radius : number) {
            this.m_radius = radius;
        }

        /**
         * Get the number of child primitives
         * 
         * @return
         * @return {number}
         */
        public abstract getChildCount() : number;

        /**
         * Test a point for containment in this shape. This only works for convex shapes.
         * 
         * @param {org.jbox2d.common.Transform} xf the shape world transform.
         * @param {org.jbox2d.common.Vec2} p a point in world coordinates.
         * @return {boolean}
         */
        public abstract testPoint(xf : org.jbox2d.common.Transform, p : org.jbox2d.common.Vec2) : boolean;

        /**
         * Cast a ray against a child shape.
         * 
         * @param argOutput the ray-cast results.
         * @param argInput the ray-cast input parameters.
         * @param argTransform the transform to be applied to the shape.
         * @param argChildIndex the child shape index
         * @return {boolean} if hit
         * @param {org.jbox2d.collision.RayCastOutput} output
         * @param {org.jbox2d.collision.RayCastInput} input
         * @param {org.jbox2d.common.Transform} transform
         * @param {number} childIndex
         */
        public abstract raycast(output : org.jbox2d.collision.RayCastOutput, input : org.jbox2d.collision.RayCastInput, transform : org.jbox2d.common.Transform, childIndex : number) : boolean;

        /**
         * Given a transform, compute the associated axis aligned bounding box for a child shape.
         * 
         * @param argAabb returns the axis aligned box.
         * @param argXf the world transform of the shape.
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.Transform} xf
         * @param {number} childIndex
         */
        public abstract computeAABB(aabb : org.jbox2d.collision.AABB, xf : org.jbox2d.common.Transform, childIndex : number);

        /**
         * Compute the mass properties of this shape using its dimensions and density. The inertia tensor
         * is computed about the local origin.
         * 
         * @param {org.jbox2d.collision.shapes.MassData} massData returns the mass data for this shape.
         * @param {number} density the density in kilograms per meter squared.
         */
        public abstract computeMass(massData : org.jbox2d.collision.shapes.MassData, density : number);

        /**
         * Compute the distance from the current shape to the specified point. This only works for convex
         * shapes.
         * 
         * @param {org.jbox2d.common.Transform} xf the shape world transform.
         * @param {org.jbox2d.common.Vec2} p a point in world coordinates.
         * @param {org.jbox2d.common.Vec2} normalOut returns the direction in which the distance increases.
         * @return {number} distance returns the distance from the current shape.
         * @param {number} childIndex
         */
        public abstract computeDistanceToOut(xf : org.jbox2d.common.Transform, p : org.jbox2d.common.Vec2, childIndex : number, normalOut : org.jbox2d.common.Vec2) : number;

        public abstract clone() : Shape;
    }
    Shape["__class"] = "org.jbox2d.collision.shapes.Shape";

}
namespace org.jbox2d.collision.shapes {
    /**
     * Types of shapes
     * @author Daniel
     * @enum
     * @property {org.jbox2d.collision.shapes.ShapeType} CIRCLE
     * @property {org.jbox2d.collision.shapes.ShapeType} EDGE
     * @property {org.jbox2d.collision.shapes.ShapeType} POLYGON
     * @property {org.jbox2d.collision.shapes.ShapeType} CHAIN
     * @class
     */
    export enum ShapeType {
        CIRCLE, EDGE, POLYGON, CHAIN
    }
}
namespace org.jbox2d.collision {
    /**
     * Class used for computing the time of impact. This class should not be constructed usually, just
     * retrieve from the {@link IWorldPool#getTimeOfImpact()}.
     * 
     * @author daniel
     * @param {*} argPool
     * @class
     */
    export class TimeOfImpact {
        public static MAX_ITERATIONS : number = 20;

        public static MAX_ROOT_ITERATIONS : number = 50;

        public static toiCalls : number = 0;

        public static toiIters : number = 0;

        public static toiMaxIters : number = 0;

        public static toiRootIters : number = 0;

        public static toiMaxRootIters : number = 0;

        /*private*/ cache : org.jbox2d.collision.Distance.SimplexCache = new org.jbox2d.collision.Distance.SimplexCache();

        /*private*/ distanceInput : org.jbox2d.collision.DistanceInput = new org.jbox2d.collision.DistanceInput();

        /*private*/ xfA : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /*private*/ xfB : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /*private*/ distanceOutput : org.jbox2d.collision.DistanceOutput = new org.jbox2d.collision.DistanceOutput();

        /*private*/ fcn : org.jbox2d.collision.SeparationFunction = new org.jbox2d.collision.SeparationFunction();

        /*private*/ indexes : number[] = [0, 0];

        /*private*/ sweepA : org.jbox2d.common.Sweep = new org.jbox2d.common.Sweep();

        /*private*/ sweepB : org.jbox2d.common.Sweep = new org.jbox2d.common.Sweep();

        /*private*/ pool : org.jbox2d.pooling.IWorldPool;

        public constructor(argPool : org.jbox2d.pooling.IWorldPool) {
            if(this.pool===undefined) this.pool = null;
            this.pool = argPool;
        }

        /**
         * Compute the upper bound on time before two shapes penetrate. Time is represented as a fraction
         * between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
         * non-tunneling collision. If you change the time interval, you should call this function again.
         * Note: use Distance to compute the contact point and normal at the time of impact.
         * 
         * @param {org.jbox2d.collision.TimeOfImpact.TOIOutput} output
         * @param {org.jbox2d.collision.TimeOfImpact.TOIInput} input
         */
        public timeOfImpact(output : TimeOfImpact.TOIOutput, input : TimeOfImpact.TOIInput) {
            ++TimeOfImpact.toiCalls;
            output.state = TimeOfImpact.TOIOutputState.UNKNOWN;
            output.t = input.tMax;
            let proxyA : org.jbox2d.collision.Distance.DistanceProxy = input.proxyA;
            let proxyB : org.jbox2d.collision.Distance.DistanceProxy = input.proxyB;
            this.sweepA.set(input.sweepA);
            this.sweepB.set(input.sweepB);
            this.sweepA.normalize();
            this.sweepB.normalize();
            let tMax : number = input.tMax;
            let totalRadius : number = (<any>Math).fround(proxyA.m_radius + proxyB.m_radius);
            let target : number = org.jbox2d.common.MathUtils.max$float$float(org.jbox2d.common.Settings.linearSlop, (<any>Math).fround(totalRadius - (<any>Math).fround(3.0 * org.jbox2d.common.Settings.linearSlop)));
            let tolerance : number = (<any>Math).fround(0.25 * org.jbox2d.common.Settings.linearSlop);
            let t1 : number = 0.0;
            let iter : number = 0;
            this.cache.count = 0;
            this.distanceInput.proxyA = input.proxyA;
            this.distanceInput.proxyB = input.proxyB;
            this.distanceInput.useRadii = false;
            for(; ; ) {
                this.sweepA.getTransform(this.xfA, t1);
                this.sweepB.getTransform(this.xfB, t1);
                this.distanceInput.transformA = this.xfA;
                this.distanceInput.transformB = this.xfB;
                this.pool.getDistance().distance(this.distanceOutput, this.cache, this.distanceInput);
                if(this.distanceOutput.distance <= 0.0) {
                    output.state = TimeOfImpact.TOIOutputState.OVERLAPPED;
                    output.t = 0.0;
                    break;
                }
                if(this.distanceOutput.distance < (<any>Math).fround(target + tolerance)) {
                    output.state = TimeOfImpact.TOIOutputState.TOUCHING;
                    output.t = t1;
                    break;
                }
                this.fcn.initialize(this.cache, proxyA, this.sweepA, proxyB, this.sweepB, t1);
                let done : boolean = false;
                let t2 : number = tMax;
                let pushBackIter : number = 0;
                for(; ; ) {
                    let s2 : number = this.fcn.findMinSeparation(this.indexes, t2);
                    if(s2 > (<any>Math).fround(target + tolerance)) {
                        output.state = TimeOfImpact.TOIOutputState.SEPARATED;
                        output.t = tMax;
                        done = true;
                        break;
                    }
                    if(s2 > (<any>Math).fround(target - tolerance)) {
                        t1 = t2;
                        break;
                    }
                    let s1 : number = this.fcn.evaluate(this.indexes[0], this.indexes[1], t1);
                    if(s1 < (<any>Math).fround(target - tolerance)) {
                        output.state = TimeOfImpact.TOIOutputState.FAILED;
                        output.t = t1;
                        done = true;
                        break;
                    }
                    if(s1 <= (<any>Math).fround(target + tolerance)) {
                        output.state = TimeOfImpact.TOIOutputState.TOUCHING;
                        output.t = t1;
                        done = true;
                        break;
                    }
                    let rootIterCount : number = 0;
                    let a1 : number = t1;
                    let a2 : number = t2;
                    for(; ; ) {
                        let t : number;
                        if((rootIterCount & 1) === 1) {
                            t = (<any>Math).fround(a1 + (<any>Math).fround((<any>Math).fround(((<any>Math).fround(target - s1)) * ((<any>Math).fround(a2 - a1))) / ((<any>Math).fround(s2 - s1))));
                        } else {
                            t = (<any>Math).fround(0.5 * ((<any>Math).fround(a1 + a2)));
                        }
                        ++rootIterCount;
                        ++TimeOfImpact.toiRootIters;
                        let s : number = this.fcn.evaluate(this.indexes[0], this.indexes[1], t);
                        if(org.jbox2d.common.MathUtils.abs$float((<any>Math).fround(s - target)) < tolerance) {
                            t2 = t;
                            break;
                        }
                        if(s > target) {
                            a1 = t;
                            s1 = s;
                        } else {
                            a2 = t;
                            s2 = s;
                        }
                        if(rootIterCount === TimeOfImpact.MAX_ROOT_ITERATIONS) {
                            break;
                        }
                    };
                    TimeOfImpact.toiMaxRootIters = org.jbox2d.common.MathUtils.max$int$int(TimeOfImpact.toiMaxRootIters, rootIterCount);
                    ++pushBackIter;
                    if(pushBackIter === org.jbox2d.common.Settings.maxPolygonVertices || rootIterCount === TimeOfImpact.MAX_ROOT_ITERATIONS) {
                        break;
                    }
                };
                ++iter;
                ++TimeOfImpact.toiIters;
                if(done) {
                    break;
                }
                if(iter === TimeOfImpact.MAX_ITERATIONS) {
                    output.state = TimeOfImpact.TOIOutputState.FAILED;
                    output.t = t1;
                    break;
                }
            };
            TimeOfImpact.toiMaxIters = org.jbox2d.common.MathUtils.max$int$int(TimeOfImpact.toiMaxIters, iter);
        }
    }
    TimeOfImpact["__class"] = "org.jbox2d.collision.TimeOfImpact";


    export namespace TimeOfImpact {

        /**
         * Input parameters for TOI
         * 
         * @author Daniel Murphy
         * @class
         */
        export class TOIInput {
            public proxyA : org.jbox2d.collision.Distance.DistanceProxy = new org.jbox2d.collision.Distance.DistanceProxy();

            public proxyB : org.jbox2d.collision.Distance.DistanceProxy = new org.jbox2d.collision.Distance.DistanceProxy();

            public sweepA : org.jbox2d.common.Sweep = new org.jbox2d.common.Sweep();

            public sweepB : org.jbox2d.common.Sweep = new org.jbox2d.common.Sweep();

            /**
             * defines sweep interval [0, tMax]
             */
            public tMax : number;

            constructor() {
                if(this.tMax===undefined) this.tMax = 0;
            }
        }
        TOIInput["__class"] = "org.jbox2d.collision.TimeOfImpact.TOIInput";


        export enum TOIOutputState {
            UNKNOWN, FAILED, OVERLAPPED, TOUCHING, SEPARATED
        }

        /**
         * Output parameters for TimeOfImpact
         * 
         * @author daniel
         * @class
         */
        export class TOIOutput {
            public state : TimeOfImpact.TOIOutputState;

            public t : number;

            constructor() {
                if(this.state===undefined) this.state = null;
                if(this.t===undefined) this.t = 0;
            }
        }
        TOIOutput["__class"] = "org.jbox2d.collision.TimeOfImpact.TOIOutput";

    }


    export enum Type {
        POINTS, FACE_A, FACE_B
    }

    export class SeparationFunction {
        public m_proxyA : org.jbox2d.collision.Distance.DistanceProxy;

        public m_proxyB : org.jbox2d.collision.Distance.DistanceProxy;

        public m_type : org.jbox2d.collision.Type;

        public m_localPoint : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public m_axis : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public m_sweepA : org.jbox2d.common.Sweep;

        public m_sweepB : org.jbox2d.common.Sweep;

        /*private*/ localPointA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ localPointB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ pointA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ pointB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ localPointA1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ localPointA2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ localPointB1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ localPointB2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ temp : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ xfa : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /*private*/ xfb : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        public initialize(cache : org.jbox2d.collision.Distance.SimplexCache, proxyA : org.jbox2d.collision.Distance.DistanceProxy, sweepA : org.jbox2d.common.Sweep, proxyB : org.jbox2d.collision.Distance.DistanceProxy, sweepB : org.jbox2d.common.Sweep, t1 : number) : number {
            this.m_proxyA = proxyA;
            this.m_proxyB = proxyB;
            let count : number = cache.count;
            this.m_sweepA = sweepA;
            this.m_sweepB = sweepB;
            this.m_sweepA.getTransform(this.xfa, t1);
            this.m_sweepB.getTransform(this.xfb, t1);
            if(count === 1) {
                this.m_type = org.jbox2d.collision.Type.POINTS;
                this.localPointA.set$org_jbox2d_common_Vec2(this.m_proxyA.getVertex(cache.indexA[0]));
                this.localPointB.set$org_jbox2d_common_Vec2(this.m_proxyB.getVertex(cache.indexB[0]));
                org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa, this.localPointA, this.pointA);
                org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb, this.localPointB, this.pointB);
                this.m_axis.set$org_jbox2d_common_Vec2(this.pointB).subLocal(this.pointA);
                let s : number = this.m_axis.normalize();
                return s;
            } else if(cache.indexA[0] === cache.indexA[1]) {
                this.m_type = org.jbox2d.collision.Type.FACE_B;
                this.localPointB1.set$org_jbox2d_common_Vec2(this.m_proxyB.getVertex(cache.indexB[0]));
                this.localPointB2.set$org_jbox2d_common_Vec2(this.m_proxyB.getVertex(cache.indexB[1]));
                this.temp.set$org_jbox2d_common_Vec2(this.localPointB2).subLocal(this.localPointB1);
                org.jbox2d.common.Vec2.crossToOutUnsafe$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(this.temp, 1.0, this.m_axis);
                this.m_axis.normalize();
                org.jbox2d.common.Rot.mulToOutUnsafe(this.xfb.q, this.m_axis, this.normal);
                this.m_localPoint.set$org_jbox2d_common_Vec2(this.localPointB1).addLocal$org_jbox2d_common_Vec2(this.localPointB2).mulLocal(0.5);
                org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb, this.m_localPoint, this.pointB);
                this.localPointA.set$org_jbox2d_common_Vec2(proxyA.getVertex(cache.indexA[0]));
                org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa, this.localPointA, this.pointA);
                this.temp.set$org_jbox2d_common_Vec2(this.pointA).subLocal(this.pointB);
                let s : number = org.jbox2d.common.Vec2.dot(this.temp, this.normal);
                if(s < 0.0) {
                    this.m_axis.negateLocal();
                    s = -s;
                }
                return s;
            } else {
                this.m_type = org.jbox2d.collision.Type.FACE_A;
                this.localPointA1.set$org_jbox2d_common_Vec2(this.m_proxyA.getVertex(cache.indexA[0]));
                this.localPointA2.set$org_jbox2d_common_Vec2(this.m_proxyA.getVertex(cache.indexA[1]));
                this.temp.set$org_jbox2d_common_Vec2(this.localPointA2).subLocal(this.localPointA1);
                org.jbox2d.common.Vec2.crossToOutUnsafe$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(this.temp, 1.0, this.m_axis);
                this.m_axis.normalize();
                org.jbox2d.common.Rot.mulToOutUnsafe(this.xfa.q, this.m_axis, this.normal);
                this.m_localPoint.set$org_jbox2d_common_Vec2(this.localPointA1).addLocal$org_jbox2d_common_Vec2(this.localPointA2).mulLocal(0.5);
                org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa, this.m_localPoint, this.pointA);
                this.localPointB.set$org_jbox2d_common_Vec2(this.m_proxyB.getVertex(cache.indexB[0]));
                org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb, this.localPointB, this.pointB);
                this.temp.set$org_jbox2d_common_Vec2(this.pointB).subLocal(this.pointA);
                let s : number = org.jbox2d.common.Vec2.dot(this.temp, this.normal);
                if(s < 0.0) {
                    this.m_axis.negateLocal();
                    s = -s;
                }
                return s;
            }
        }

        /*private*/ axisA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ axisB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public findMinSeparation(indexes : number[], t : number) : number {
            this.m_sweepA.getTransform(this.xfa, t);
            this.m_sweepB.getTransform(this.xfb, t);
            switch((this.m_type)) {
            case org.jbox2d.collision.Type.POINTS:
                {
                    org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa.q, this.m_axis, this.axisA);
                    org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb.q, this.m_axis.negateLocal(), this.axisB);
                    this.m_axis.negateLocal();
                    indexes[0] = this.m_proxyA.getSupport(this.axisA);
                    indexes[1] = this.m_proxyB.getSupport(this.axisB);
                    this.localPointA.set$org_jbox2d_common_Vec2(this.m_proxyA.getVertex(indexes[0]));
                    this.localPointB.set$org_jbox2d_common_Vec2(this.m_proxyB.getVertex(indexes[1]));
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa, this.localPointA, this.pointA);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb, this.localPointB, this.pointB);
                    let separation : number = org.jbox2d.common.Vec2.dot(this.pointB.subLocal(this.pointA), this.m_axis);
                    return separation;
                };
            case org.jbox2d.collision.Type.FACE_A:
                {
                    org.jbox2d.common.Rot.mulToOutUnsafe(this.xfa.q, this.m_axis, this.normal);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa, this.m_localPoint, this.pointA);
                    org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb.q, this.normal.negateLocal(), this.axisB);
                    this.normal.negateLocal();
                    indexes[0] = -1;
                    indexes[1] = this.m_proxyB.getSupport(this.axisB);
                    this.localPointB.set$org_jbox2d_common_Vec2(this.m_proxyB.getVertex(indexes[1]));
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb, this.localPointB, this.pointB);
                    let separation : number = org.jbox2d.common.Vec2.dot(this.pointB.subLocal(this.pointA), this.normal);
                    return separation;
                };
            case org.jbox2d.collision.Type.FACE_B:
                {
                    org.jbox2d.common.Rot.mulToOutUnsafe(this.xfb.q, this.m_axis, this.normal);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb, this.m_localPoint, this.pointB);
                    org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa.q, this.normal.negateLocal(), this.axisA);
                    this.normal.negateLocal();
                    indexes[1] = -1;
                    indexes[0] = this.m_proxyA.getSupport(this.axisA);
                    this.localPointA.set$org_jbox2d_common_Vec2(this.m_proxyA.getVertex(indexes[0]));
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa, this.localPointA, this.pointA);
                    let separation : number = org.jbox2d.common.Vec2.dot(this.pointA.subLocal(this.pointB), this.normal);
                    return separation;
                };
            default:
                ;
                indexes[0] = -1;
                indexes[1] = -1;
                return 0.0;
            }
        }

        public evaluate(indexA : number, indexB : number, t : number) : number {
            this.m_sweepA.getTransform(this.xfa, t);
            this.m_sweepB.getTransform(this.xfb, t);
            switch((this.m_type)) {
            case org.jbox2d.collision.Type.POINTS:
                {
                    this.localPointA.set$org_jbox2d_common_Vec2(this.m_proxyA.getVertex(indexA));
                    this.localPointB.set$org_jbox2d_common_Vec2(this.m_proxyB.getVertex(indexB));
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa, this.localPointA, this.pointA);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb, this.localPointB, this.pointB);
                    let separation : number = org.jbox2d.common.Vec2.dot(this.pointB.subLocal(this.pointA), this.m_axis);
                    return separation;
                };
            case org.jbox2d.collision.Type.FACE_A:
                {
                    org.jbox2d.common.Rot.mulToOutUnsafe(this.xfa.q, this.m_axis, this.normal);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa, this.m_localPoint, this.pointA);
                    this.localPointB.set$org_jbox2d_common_Vec2(this.m_proxyB.getVertex(indexB));
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb, this.localPointB, this.pointB);
                    let separation : number = org.jbox2d.common.Vec2.dot(this.pointB.subLocal(this.pointA), this.normal);
                    return separation;
                };
            case org.jbox2d.collision.Type.FACE_B:
                {
                    org.jbox2d.common.Rot.mulToOutUnsafe(this.xfb.q, this.m_axis, this.normal);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfb, this.m_localPoint, this.pointB);
                    this.localPointA.set$org_jbox2d_common_Vec2(this.m_proxyA.getVertex(indexA));
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xfa, this.localPointA, this.pointA);
                    let separation : number = org.jbox2d.common.Vec2.dot(this.pointA.subLocal(this.pointB), this.normal);
                    return separation;
                };
            default:
                ;
                return 0.0;
            }
        }

        constructor() {
            if(this.m_proxyA===undefined) this.m_proxyA = null;
            if(this.m_proxyB===undefined) this.m_proxyB = null;
            if(this.m_type===undefined) this.m_type = null;
            if(this.m_sweepA===undefined) this.m_sweepA = null;
            if(this.m_sweepB===undefined) this.m_sweepB = null;
        }
    }
    SeparationFunction["__class"] = "org.jbox2d.collision.SeparationFunction";

}
namespace org.jbox2d.collision {
    /**
     * This is used to compute the current state of a contact manifold.
     * 
     * @author daniel
     * @class
     */
    export class WorldManifold {
        /**
         * World vector pointing from A to B
         */
        public normal : org.jbox2d.common.Vec2;

        /**
         * World contact point (point of intersection)
         */
        public points : org.jbox2d.common.Vec2[];

        /**
         * A negative value indicates overlap, in meters.
         */
        public separations : number[];

        public constructor() {
            if(this.normal===undefined) this.normal = null;
            if(this.points===undefined) this.points = null;
            if(this.separations===undefined) this.separations = null;
            this.normal = new org.jbox2d.common.Vec2();
            this.points = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);
            this.separations = (s => { let a=[]; while(s-->0) a.push(0); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);
            for(let i : number = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; i++) {
                this.points[i] = new org.jbox2d.common.Vec2();
            };
        }

        /*private*/ pool3 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ pool4 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public initialize(manifold : org.jbox2d.collision.Manifold, xfA : org.jbox2d.common.Transform, radiusA : number, xfB : org.jbox2d.common.Transform, radiusB : number) {
            if(manifold.pointCount === 0) {
                return;
            }
            switch((manifold.type)) {
            case org.jbox2d.collision.Manifold.ManifoldType.CIRCLES:
                {
                    let pointA : org.jbox2d.common.Vec2 = this.pool3;
                    let pointB : org.jbox2d.common.Vec2 = this.pool4;
                    this.normal.x = 1;
                    this.normal.y = 0;
                    let v : org.jbox2d.common.Vec2 = manifold.localPoint;
                    pointA.x = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfA.q.c * v.x) - (<any>Math).fround(xfA.q.s * v.y))) + xfA.p.x);
                    pointA.y = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfA.q.s * v.x) + (<any>Math).fround(xfA.q.c * v.y))) + xfA.p.y);
                    let mp0p : org.jbox2d.common.Vec2 = manifold.points[0].localPoint;
                    pointB.x = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfB.q.c * mp0p.x) - (<any>Math).fround(xfB.q.s * mp0p.y))) + xfB.p.x);
                    pointB.y = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfB.q.s * mp0p.x) + (<any>Math).fround(xfB.q.c * mp0p.y))) + xfB.p.y);
                    if(org.jbox2d.common.MathUtils.distanceSquared(pointA, pointB) > (<any>Math).fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON)) {
                        this.normal.x = (<any>Math).fround(pointB.x - pointA.x);
                        this.normal.y = (<any>Math).fround(pointB.y - pointA.y);
                        this.normal.normalize();
                    }
                    let cAx : number = (<any>Math).fround((<any>Math).fround(this.normal.x * radiusA) + pointA.x);
                    let cAy : number = (<any>Math).fround((<any>Math).fround(this.normal.y * radiusA) + pointA.y);
                    let cBx : number = (<any>Math).fround((<any>Math).fround(-this.normal.x * radiusB) + pointB.x);
                    let cBy : number = (<any>Math).fround((<any>Math).fround(-this.normal.y * radiusB) + pointB.y);
                    this.points[0].x = (<any>Math).fround(((<any>Math).fround(cAx + cBx)) * 0.5);
                    this.points[0].y = (<any>Math).fround(((<any>Math).fround(cAy + cBy)) * 0.5);
                    this.separations[0] = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(cBx - cAx)) * this.normal.x) + (<any>Math).fround(((<any>Math).fround(cBy - cAy)) * this.normal.y));
                };
                break;
            case org.jbox2d.collision.Manifold.ManifoldType.FACE_A:
                {
                    let planePoint : org.jbox2d.common.Vec2 = this.pool3;
                    org.jbox2d.common.Rot.mulToOutUnsafe(xfA.q, manifold.localNormal, this.normal);
                    org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xfA, manifold.localPoint, planePoint);
                    let clipPoint : org.jbox2d.common.Vec2 = this.pool4;
                    for(let i : number = 0; i < manifold.pointCount; i++) {
                        org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xfB, manifold.points[i].localPoint, clipPoint);
                        let scalar : number = (<any>Math).fround(radiusA - ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(clipPoint.x - planePoint.x)) * this.normal.x) + (<any>Math).fround(((<any>Math).fround(clipPoint.y - planePoint.y)) * this.normal.y))));
                        let cAx : number = (<any>Math).fround((<any>Math).fround(this.normal.x * scalar) + clipPoint.x);
                        let cAy : number = (<any>Math).fround((<any>Math).fround(this.normal.y * scalar) + clipPoint.y);
                        let cBx : number = (<any>Math).fround((<any>Math).fround(-this.normal.x * radiusB) + clipPoint.x);
                        let cBy : number = (<any>Math).fround((<any>Math).fround(-this.normal.y * radiusB) + clipPoint.y);
                        this.points[i].x = (<any>Math).fround(((<any>Math).fround(cAx + cBx)) * 0.5);
                        this.points[i].y = (<any>Math).fround(((<any>Math).fround(cAy + cBy)) * 0.5);
                        this.separations[i] = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(cBx - cAx)) * this.normal.x) + (<any>Math).fround(((<any>Math).fround(cBy - cAy)) * this.normal.y));
                    };
                };
                break;
            case org.jbox2d.collision.Manifold.ManifoldType.FACE_B:
                let planePoint : org.jbox2d.common.Vec2 = this.pool3;
                org.jbox2d.common.Rot.mulToOutUnsafe(xfB.q, manifold.localNormal, this.normal);
                org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xfB, manifold.localPoint, planePoint);
                let clipPoint : org.jbox2d.common.Vec2 = this.pool4;
                for(let i : number = 0; i < manifold.pointCount; i++) {
                    org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xfA, manifold.points[i].localPoint, clipPoint);
                    let scalar : number = (<any>Math).fround(radiusB - ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(clipPoint.x - planePoint.x)) * this.normal.x) + (<any>Math).fround(((<any>Math).fround(clipPoint.y - planePoint.y)) * this.normal.y))));
                    let cBx : number = (<any>Math).fround((<any>Math).fround(this.normal.x * scalar) + clipPoint.x);
                    let cBy : number = (<any>Math).fround((<any>Math).fround(this.normal.y * scalar) + clipPoint.y);
                    let cAx : number = (<any>Math).fround((<any>Math).fround(-this.normal.x * radiusA) + clipPoint.x);
                    let cAy : number = (<any>Math).fround((<any>Math).fround(-this.normal.y * radiusA) + clipPoint.y);
                    this.points[i].x = (<any>Math).fround(((<any>Math).fround(cAx + cBx)) * 0.5);
                    this.points[i].y = (<any>Math).fround(((<any>Math).fround(cAy + cBy)) * 0.5);
                    this.separations[i] = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(cAx - cBx)) * this.normal.x) + (<any>Math).fround(((<any>Math).fround(cAy - cBy)) * this.normal.y));
                };
                this.normal.x = -this.normal.x;
                this.normal.y = -this.normal.y;
                break;
            }
        }
    }
    WorldManifold["__class"] = "org.jbox2d.collision.WorldManifold";

}
namespace org.jbox2d.common {
    export class BufferUtils {
        public static reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int<T>(klass : any, oldBuffer : T[], oldCapacity : number, newCapacity : number) : T[] {
            let newBuffer : T[] = <T[]>/* newInstance */new Array<any>(newCapacity);
            if(oldBuffer != null) {
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(oldBuffer, 0, newBuffer, 0, oldCapacity);
            }
            for(let i : number = oldCapacity; i < newCapacity; i++) {
                try {
                    newBuffer[i] = /* newInstance */new (klass)();
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            };
            return newBuffer;
        }

        public static reallocateBuffer$int_A$int$int(oldBuffer : number[], oldCapacity : number, newCapacity : number) : number[] {
            let newBuffer : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(newCapacity);
            if(oldBuffer != null) {
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(oldBuffer, 0, newBuffer, 0, oldCapacity);
            }
            return newBuffer;
        }

        public static reallocateBuffer$float_A$int$int(oldBuffer : number[], oldCapacity : number, newCapacity : number) : number[] {
            let newBuffer : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(newCapacity);
            if(oldBuffer != null) {
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(oldBuffer, 0, newBuffer, 0, oldCapacity);
            }
            return newBuffer;
        }

        public static reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int$int$boolean<T>(klass : any, buffer : T[], userSuppliedCapacity : number, oldCapacity : number, newCapacity : number, deferred : boolean) : T[] {
            if((!deferred || buffer != null) && userSuppliedCapacity === 0) {
                buffer = BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(klass, buffer, oldCapacity, newCapacity);
            }
            return buffer;
        }

        /**
         * Reallocate a buffer. A 'deferred' buffer is reallocated only if it is not NULL. If
         * 'userSuppliedCapacity' is not zero, buffer is user supplied and must be kept.
         * @param {*} klass
         * @param {Array} buffer
         * @param {number} userSuppliedCapacity
         * @param {number} oldCapacity
         * @param {number} newCapacity
         * @param {boolean} deferred
         * @return {Array}
         */
        public static reallocateBuffer<T>(klass? : any, buffer? : any, userSuppliedCapacity? : any, oldCapacity? : any, newCapacity? : any, deferred? : any) : any {
            if(((klass != null) || klass === null) && ((buffer != null && buffer instanceof <any>Array && (buffer.length==0 || buffer[0] == null ||(buffer[0] != null))) || buffer === null) && ((typeof userSuppliedCapacity === 'number') || userSuppliedCapacity === null) && ((typeof oldCapacity === 'number') || oldCapacity === null) && ((typeof newCapacity === 'number') || newCapacity === null) && ((typeof deferred === 'boolean') || deferred === null)) {
                return <any>org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int$int$boolean(klass, buffer, userSuppliedCapacity, oldCapacity, newCapacity, deferred);
            } else if(((klass != null && klass instanceof <any>Array && (klass.length==0 || klass[0] == null ||(typeof klass[0] === 'number'))) || klass === null) && ((typeof buffer === 'number') || buffer === null) && ((typeof userSuppliedCapacity === 'number') || userSuppliedCapacity === null) && ((typeof oldCapacity === 'number') || oldCapacity === null) && ((typeof newCapacity === 'boolean') || newCapacity === null) && deferred === undefined) {
                return <any>org.jbox2d.common.BufferUtils.reallocateBuffer$int_A$int$int$int$boolean(klass, buffer, userSuppliedCapacity, oldCapacity, newCapacity);
            } else if(((klass != null && klass instanceof <any>Array && (klass.length==0 || klass[0] == null ||(typeof klass[0] === 'number'))) || klass === null) && ((typeof buffer === 'number') || buffer === null) && ((typeof userSuppliedCapacity === 'number') || userSuppliedCapacity === null) && ((typeof oldCapacity === 'number') || oldCapacity === null) && ((typeof newCapacity === 'boolean') || newCapacity === null) && deferred === undefined) {
                return <any>org.jbox2d.common.BufferUtils.reallocateBuffer$float_A$int$int$int$boolean(klass, buffer, userSuppliedCapacity, oldCapacity, newCapacity);
            } else if(((klass != null) || klass === null) && ((buffer != null && buffer instanceof <any>Array && (buffer.length==0 || buffer[0] == null ||(buffer[0] != null))) || buffer === null) && ((typeof userSuppliedCapacity === 'number') || userSuppliedCapacity === null) && ((typeof oldCapacity === 'number') || oldCapacity === null) && newCapacity === undefined && deferred === undefined) {
                return <any>org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(klass, buffer, userSuppliedCapacity, oldCapacity);
            } else if(((klass != null && klass instanceof <any>Array && (klass.length==0 || klass[0] == null ||(typeof klass[0] === 'number'))) || klass === null) && ((typeof buffer === 'number') || buffer === null) && ((typeof userSuppliedCapacity === 'number') || userSuppliedCapacity === null) && oldCapacity === undefined && newCapacity === undefined && deferred === undefined) {
                return <any>org.jbox2d.common.BufferUtils.reallocateBuffer$int_A$int$int(klass, buffer, userSuppliedCapacity);
            } else if(((klass != null && klass instanceof <any>Array && (klass.length==0 || klass[0] == null ||(typeof klass[0] === 'number'))) || klass === null) && ((typeof buffer === 'number') || buffer === null) && ((typeof userSuppliedCapacity === 'number') || userSuppliedCapacity === null) && oldCapacity === undefined && newCapacity === undefined && deferred === undefined) {
                return <any>org.jbox2d.common.BufferUtils.reallocateBuffer$float_A$int$int(klass, buffer, userSuppliedCapacity);
            } else throw new Error('invalid overload');
        }

        public static reallocateBuffer$int_A$int$int$int$boolean(buffer : number[], userSuppliedCapacity : number, oldCapacity : number, newCapacity : number, deferred : boolean) : number[] {
            if((!deferred || buffer != null) && userSuppliedCapacity === 0) {
                buffer = BufferUtils.reallocateBuffer$int_A$int$int(buffer, oldCapacity, newCapacity);
            }
            return buffer;
        }

        public static reallocateBuffer$float_A$int$int$int$boolean(buffer : number[], userSuppliedCapacity : number, oldCapacity : number, newCapacity : number, deferred : boolean) : number[] {
            if((!deferred || buffer != null) && userSuppliedCapacity === 0) {
                buffer = BufferUtils.reallocateBuffer$float_A$int$int(buffer, oldCapacity, newCapacity);
            }
            return buffer;
        }

        public static rotate$java_lang_Object_A$int$int$int<T>(ray : T[], first : number, new_first : number, last : number) {
            let next : number = new_first;
            while((next !== first)) {
                let temp : T = ray[first];
                ray[first] = ray[next];
                ray[next] = temp;
                first++;
                next++;
                if(next === last) {
                    next = new_first;
                } else if(first === new_first) {
                    new_first = next;
                }
            };
        }

        /**
         * Rotate an array, see std::rotate
         * @param {Array} ray
         * @param {number} first
         * @param {number} new_first
         * @param {number} last
         */
        public static rotate<T>(ray? : any, first? : any, new_first? : any, last? : any) : any {
            if(((ray != null && ray instanceof <any>Array && (ray.length==0 || ray[0] == null ||(ray[0] != null))) || ray === null) && ((typeof first === 'number') || first === null) && ((typeof new_first === 'number') || new_first === null) && ((typeof last === 'number') || last === null)) {
                return <any>org.jbox2d.common.BufferUtils.rotate$java_lang_Object_A$int$int$int(ray, first, new_first, last);
            } else if(((ray != null && ray instanceof <any>Array && (ray.length==0 || ray[0] == null ||(typeof ray[0] === 'number'))) || ray === null) && ((typeof first === 'number') || first === null) && ((typeof new_first === 'number') || new_first === null) && ((typeof last === 'number') || last === null)) {
                return <any>org.jbox2d.common.BufferUtils.rotate$int_A$int$int$int(ray, first, new_first, last);
            } else if(((ray != null && ray instanceof <any>Array && (ray.length==0 || ray[0] == null ||(typeof ray[0] === 'number'))) || ray === null) && ((typeof first === 'number') || first === null) && ((typeof new_first === 'number') || new_first === null) && ((typeof last === 'number') || last === null)) {
                return <any>org.jbox2d.common.BufferUtils.rotate$float_A$int$int$int(ray, first, new_first, last);
            } else throw new Error('invalid overload');
        }

        public static rotate$int_A$int$int$int(ray : number[], first : number, new_first : number, last : number) {
            let next : number = new_first;
            while((next !== first)) {
                let temp : number = ray[first];
                ray[first] = ray[next];
                ray[next] = temp;
                first++;
                next++;
                if(next === last) {
                    next = new_first;
                } else if(first === new_first) {
                    new_first = next;
                }
            };
        }

        public static rotate$float_A$int$int$int(ray : number[], first : number, new_first : number, last : number) {
            let next : number = new_first;
            while((next !== first)) {
                let temp : number = ray[first];
                ray[first] = ray[next];
                ray[next] = temp;
                first++;
                next++;
                if(next === last) {
                    next = new_first;
                } else if(first === new_first) {
                    new_first = next;
                }
            };
        }
    }
    BufferUtils["__class"] = "org.jbox2d.common.BufferUtils";

}
namespace org.jbox2d.common {
    /**
     * Similar to javax.vecmath.Color3f holder
     * @author ewjordan
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @class
     */
    export class Color3f {
        public static WHITE : Color3f; public static WHITE_$LI$() : Color3f { if(Color3f.WHITE == null) Color3f.WHITE = new Color3f(1, 1, 1); return Color3f.WHITE; };

        public static BLACK : Color3f; public static BLACK_$LI$() : Color3f { if(Color3f.BLACK == null) Color3f.BLACK = new Color3f(0, 0, 0); return Color3f.BLACK; };

        public static BLUE : Color3f; public static BLUE_$LI$() : Color3f { if(Color3f.BLUE == null) Color3f.BLUE = new Color3f(0, 0, 1); return Color3f.BLUE; };

        public static GREEN : Color3f; public static GREEN_$LI$() : Color3f { if(Color3f.GREEN == null) Color3f.GREEN = new Color3f(0, 1, 0); return Color3f.GREEN; };

        public static RED : Color3f; public static RED_$LI$() : Color3f { if(Color3f.RED == null) Color3f.RED = new Color3f(1, 0, 0); return Color3f.RED; };

        public x : number;

        public y : number;

        public z : number;

        public constructor(r? : any, g? : any, b? : any) {
            if(((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                (() => {
                    this.x = r;
                    this.y = g;
                    this.z = b;
                })();
            } else if(r === undefined && g === undefined && b === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                (() => {
                    this.x = this.y = this.z = 0;
                })();
            } else throw new Error('invalid overload');
        }

        public set$float$float$float(r : number, g : number, b : number) {
            this.x = r;
            this.y = g;
            this.z = b;
        }

        public set(r? : any, g? : any, b? : any) : any {
            if(((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null)) {
                return <any>this.set$float$float$float(r, g, b);
            } else if(((r != null && r instanceof <any>org.jbox2d.common.Color3f) || r === null) && g === undefined && b === undefined) {
                return <any>this.set$org_jbox2d_common_Color3f(r);
            } else throw new Error('invalid overload');
        }

        public set$org_jbox2d_common_Color3f(argColor : Color3f) {
            this.x = argColor.x;
            this.y = argColor.y;
            this.z = argColor.z;
        }
    }
    Color3f["__class"] = "org.jbox2d.common.Color3f";

}
namespace org.jbox2d.common {
    /**
     * This is the viewport transform used from drawing. Use yFlip if you are drawing from the top-left
     * corner.
     * 
     * @author Daniel
     * @class
     */
    export interface IViewportTransform {
        /**
         * @return {boolean} if the transform flips the y axis
         */
        isYFlip() : boolean;

        /**
         * @param {boolean} yFlip if we flip the y axis when transforming
         */
        setYFlip(yFlip : boolean);

        /**
         * This is the half-width and half-height. This should be the actual half-width and half-height,
         * not anything transformed or scaled. Not a copy.
         * @return {org.jbox2d.common.Vec2}
         */
        getExtents() : org.jbox2d.common.Vec2;

        /**
         * This sets the half-width and half-height of the viewport. This should be the actual half-width
         * and half-height, not anything transformed or scaled.
         * @param {number} halfWidth
         * @param {number} halfHeight
         */
        setExtents(halfWidth? : any, halfHeight? : any) : any;

        /**
         * center of the viewport. Not a copy.
         * @return {org.jbox2d.common.Vec2}
         */
        getCenter() : org.jbox2d.common.Vec2;

        /**
         * sets the center of the viewport.
         * @param {number} x
         * @param {number} y
         */
        setCenter(x? : any, y? : any) : any;

        /**
         * Sets the transform's center to the given x and y coordinates, and using the given scale.
         * @param {number} x
         * @param {number} y
         * @param {number} scale
         */
        setCamera(x : number, y : number, scale : number);

        /**
         * Transforms the given directional vector by the viewport transform (not positional)
         * @param {org.jbox2d.common.Vec2} world
         * @param {org.jbox2d.common.Vec2} screen
         */
        getWorldVectorToScreen(world : org.jbox2d.common.Vec2, screen : org.jbox2d.common.Vec2);

        /**
         * Transforms the given directional screen vector back to the world direction.
         * @param {org.jbox2d.common.Vec2} screen
         * @param {org.jbox2d.common.Vec2} world
         */
        getScreenVectorToWorld(screen : org.jbox2d.common.Vec2, world : org.jbox2d.common.Vec2);

        getMat22Representation() : org.jbox2d.common.Mat22;

        /**
         * takes the world coordinate (world) puts the corresponding screen coordinate in screen. It
         * should be safe to give the same object as both parameters.
         * @param {org.jbox2d.common.Vec2} world
         * @param {org.jbox2d.common.Vec2} screen
         */
        getWorldToScreen(world : org.jbox2d.common.Vec2, screen : org.jbox2d.common.Vec2);

        /**
         * takes the screen coordinates (screen) and puts the corresponding world coordinates in world. It
         * should be safe to give the same object as both parameters.
         * @param {org.jbox2d.common.Vec2} screen
         * @param {org.jbox2d.common.Vec2} world
         */
        getScreenToWorld(screen : org.jbox2d.common.Vec2, world : org.jbox2d.common.Vec2);

        /**
         * Multiplies the viewport transform by the given Mat22
         * @param {org.jbox2d.common.Mat22} transform
         */
        mulByTransform(transform : org.jbox2d.common.Mat22);
    }
}
namespace org.jbox2d.common {
    /**
     * Create a matrix from four floats.
     * 
     * @param {number} exx
     * @param {number} col2x
     * @param {number} exy
     * @param {number} col2y
     * @class
     */
    export class Mat22 {
        static serialVersionUID : number = 2;

        public ex : org.jbox2d.common.Vec2;

        public ey : org.jbox2d.common.Vec2;

        /**
         * Convert the matrix to printable format.
         * @return {string}
         */
        public toString() : string {
            let s : string = "";
            s += "[" + this.ex.x + "," + this.ey.x + "]\n";
            s += "[" + this.ex.y + "," + this.ey.y + "]";
            return s;
        }

        public constructor(exx? : any, col2x? : any, exy? : any, col2y? : any) {
            if(((typeof exx === 'number') || exx === null) && ((typeof col2x === 'number') || col2x === null) && ((typeof exy === 'number') || exy === null) && ((typeof col2y === 'number') || col2y === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                (() => {
                    this.ex = new org.jbox2d.common.Vec2(exx, exy);
                    this.ey = new org.jbox2d.common.Vec2(col2x, col2y);
                })();
            } else if(((exx != null && exx instanceof <any>org.jbox2d.common.Vec2) || exx === null) && ((col2x != null && col2x instanceof <any>org.jbox2d.common.Vec2) || col2x === null) && exy === undefined && col2y === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let c1 : any = __args[0];
                let c2 : any = __args[1];
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                (() => {
                    this.ex = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(c1);
                    this.ey = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(c2);
                })();
            } else if(exx === undefined && col2x === undefined && exy === undefined && col2y === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                (() => {
                    this.ex = new org.jbox2d.common.Vec2();
                    this.ey = new org.jbox2d.common.Vec2();
                })();
            } else throw new Error('invalid overload');
        }

        public set$org_jbox2d_common_Mat22(m : Mat22) : Mat22 {
            this.ex.x = m.ex.x;
            this.ex.y = m.ex.y;
            this.ey.x = m.ey.x;
            this.ey.y = m.ey.y;
            return this;
        }

        public set$float$float$float$float(exx : number, col2x : number, exy : number, col2y : number) : Mat22 {
            this.ex.x = exx;
            this.ex.y = exy;
            this.ey.x = col2x;
            this.ey.y = col2y;
            return this;
        }

        public set(exx? : any, col2x? : any, exy? : any, col2y? : any) : any {
            if(((typeof exx === 'number') || exx === null) && ((typeof col2x === 'number') || col2x === null) && ((typeof exy === 'number') || exy === null) && ((typeof col2y === 'number') || col2y === null)) {
                return <any>this.set$float$float$float$float(exx, col2x, exy, col2y);
            } else if(((exx != null && exx instanceof <any>org.jbox2d.common.Vec2) || exx === null) && ((col2x != null && col2x instanceof <any>org.jbox2d.common.Vec2) || col2x === null) && exy === undefined && col2y === undefined) {
                return <any>this.set$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(exx, col2x);
            } else if(((exx != null && exx instanceof <any>org.jbox2d.common.Mat22) || exx === null) && col2x === undefined && exy === undefined && col2y === undefined) {
                return <any>this.set$org_jbox2d_common_Mat22(exx);
            } else if(((typeof exx === 'number') || exx === null) && col2x === undefined && exy === undefined && col2y === undefined) {
                return <any>this.set$float(exx);
            } else throw new Error('invalid overload');
        }

        /**
         * Return a clone of this matrix. djm fixed double allocation
         * @return {org.jbox2d.common.Mat22}
         */
        public clone() : Mat22 {
            return new Mat22(this.ex, this.ey);
        }

        public set$float(angle : number) {
            let c : number = org.jbox2d.common.MathUtils.cos(angle);
            let s : number = org.jbox2d.common.MathUtils.sin(angle);
            this.ex.x = c;
            this.ey.x = -s;
            this.ex.y = s;
            this.ey.y = c;
        }

        /**
         * Set as the identity matrix.
         */
        public setIdentity() {
            this.ex.x = 1.0;
            this.ey.x = 0.0;
            this.ex.y = 0.0;
            this.ey.y = 1.0;
        }

        /**
         * Set as the zero matrix.
         */
        public setZero() {
            this.ex.x = 0.0;
            this.ey.x = 0.0;
            this.ex.y = 0.0;
            this.ey.y = 0.0;
        }

        /**
         * Extract the angle from this matrix (assumed to be a rotation matrix).
         * 
         * @return
         * @return {number}
         */
        public getAngle() : number {
            return org.jbox2d.common.MathUtils.atan2(this.ex.y, this.ex.x);
        }

        public set$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(c1 : org.jbox2d.common.Vec2, c2 : org.jbox2d.common.Vec2) {
            this.ex.x = c1.x;
            this.ey.x = c2.x;
            this.ex.y = c1.y;
            this.ey.y = c2.y;
        }

        /**
         * Returns the inverted Mat22 - does NOT invert the matrix locally!
         * @return {org.jbox2d.common.Mat22}
         */
        public invert() : Mat22 {
            let a : number = this.ex.x;
            let b : number = this.ey.x;
            let c : number = this.ex.y;
            let d : number = this.ey.y;
            let B : Mat22 = new Mat22();
            let det : number = (<any>Math).fround((<any>Math).fround(a * d) - (<any>Math).fround(b * c));
            if(det !== 0) {
                det = (<any>Math).fround(1.0 / det);
            }
            B.ex.x = (<any>Math).fround(det * d);
            B.ey.x = (<any>Math).fround(-det * b);
            B.ex.y = (<any>Math).fround(-det * c);
            B.ey.y = (<any>Math).fround(det * a);
            return B;
        }

        public invertLocal() : Mat22 {
            let a : number = this.ex.x;
            let b : number = this.ey.x;
            let c : number = this.ex.y;
            let d : number = this.ey.y;
            let det : number = (<any>Math).fround((<any>Math).fround(a * d) - (<any>Math).fround(b * c));
            if(det !== 0) {
                det = (<any>Math).fround(1.0 / det);
            }
            this.ex.x = (<any>Math).fround(det * d);
            this.ey.x = (<any>Math).fround(-det * b);
            this.ex.y = (<any>Math).fround(-det * c);
            this.ey.y = (<any>Math).fround(det * a);
            return this;
        }

        public invertToOut(out : Mat22) {
            let a : number = this.ex.x;
            let b : number = this.ey.x;
            let c : number = this.ex.y;
            let d : number = this.ey.y;
            let det : number = (<any>Math).fround((<any>Math).fround(a * d) - (<any>Math).fround(b * c));
            det = (<any>Math).fround(1.0 / det);
            out.ex.x = (<any>Math).fround(det * d);
            out.ey.x = (<any>Math).fround(-det * b);
            out.ex.y = (<any>Math).fround(-det * c);
            out.ey.y = (<any>Math).fround(det * a);
        }

        /**
         * Return the matrix composed of the absolute values of all elements. djm: fixed double allocation
         * 
         * @return {org.jbox2d.common.Mat22} Absolute value matrix
         */
        public abs() : Mat22 {
            return new Mat22(org.jbox2d.common.MathUtils.abs$float(this.ex.x), org.jbox2d.common.MathUtils.abs$float(this.ey.x), org.jbox2d.common.MathUtils.abs$float(this.ex.y), org.jbox2d.common.MathUtils.abs$float(this.ey.y));
        }

        public absLocal() {
            this.ex.absLocal();
            this.ey.absLocal();
        }

        /**
         * Return the matrix composed of the absolute values of all elements.
         * 
         * @return {org.jbox2d.common.Mat22} Absolute value matrix
         * @param {org.jbox2d.common.Mat22} R
         */
        public static abs(R : Mat22) : Mat22 {
            return R.abs();
        }

        public static absToOut(R : Mat22, out : Mat22) {
            out.ex.x = org.jbox2d.common.MathUtils.abs$float(R.ex.x);
            out.ex.y = org.jbox2d.common.MathUtils.abs$float(R.ex.y);
            out.ey.x = org.jbox2d.common.MathUtils.abs$float(R.ey.x);
            out.ey.y = org.jbox2d.common.MathUtils.abs$float(R.ey.y);
        }

        public mul$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2((<any>Math).fround((<any>Math).fround(this.ex.x * v.x) + (<any>Math).fround(this.ey.x * v.y)), (<any>Math).fround((<any>Math).fround(this.ex.y * v.x) + (<any>Math).fround(this.ey.y * v.y)));
        }

        /**
         * Multiply a vector by this matrix.
         * 
         * @param {org.jbox2d.common.Vec2} v Vector to multiply by matrix.
         * @return {org.jbox2d.common.Vec2} Resulting vector
         */
        public mul(v? : any) : any {
            if(((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null)) {
                return <any>this.mul$org_jbox2d_common_Vec2(v);
            } else if(((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null)) {
                return <any>this.mul$org_jbox2d_common_Mat22(v);
            } else throw new Error('invalid overload');
        }

        public mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempy : number = (<any>Math).fround((<any>Math).fround(this.ex.y * v.x) + (<any>Math).fround(this.ey.y * v.y));
            out.x = (<any>Math).fround((<any>Math).fround(this.ex.x * v.x) + (<any>Math).fround(this.ey.x * v.y));
            out.y = tempy;
        }

        public mulToOut(v? : any, out? : any) : any {
            if(((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>this.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v, out);
            } else if(((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>this.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(v, out);
            } else throw new Error('invalid overload');
        }

        public mulToOutUnsafe$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            out.x = (<any>Math).fround((<any>Math).fround(this.ex.x * v.x) + (<any>Math).fround(this.ey.x * v.y));
            out.y = (<any>Math).fround((<any>Math).fround(this.ex.y * v.x) + (<any>Math).fround(this.ey.y * v.y));
        }

        public mulToOutUnsafe(v? : any, out? : any) : any {
            if(((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>this.mulToOutUnsafe$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v, out);
            } else if(((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>this.mulToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(v, out);
            } else throw new Error('invalid overload');
        }

        public mul$org_jbox2d_common_Mat22(R : Mat22) : Mat22 {
            let C : Mat22 = new Mat22();
            C.ex.x = (<any>Math).fround((<any>Math).fround(this.ex.x * R.ex.x) + (<any>Math).fround(this.ey.x * R.ex.y));
            C.ex.y = (<any>Math).fround((<any>Math).fround(this.ex.y * R.ex.x) + (<any>Math).fround(this.ey.y * R.ex.y));
            C.ey.x = (<any>Math).fround((<any>Math).fround(this.ex.x * R.ey.x) + (<any>Math).fround(this.ey.x * R.ey.y));
            C.ey.y = (<any>Math).fround((<any>Math).fround(this.ex.y * R.ey.x) + (<any>Math).fround(this.ey.y * R.ey.y));
            return C;
        }

        public mulLocal(R : Mat22) : Mat22 {
            this.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, this);
            return this;
        }

        public mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R : Mat22, out : Mat22) {
            let tempy1 : number = (<any>Math).fround((<any>Math).fround(this.ex.y * R.ex.x) + (<any>Math).fround(this.ey.y * R.ex.y));
            let tempx1 : number = (<any>Math).fround((<any>Math).fround(this.ex.x * R.ex.x) + (<any>Math).fround(this.ey.x * R.ex.y));
            out.ex.x = tempx1;
            out.ex.y = tempy1;
            let tempy2 : number = (<any>Math).fround((<any>Math).fround(this.ex.y * R.ey.x) + (<any>Math).fround(this.ey.y * R.ey.y));
            let tempx2 : number = (<any>Math).fround((<any>Math).fround(this.ex.x * R.ey.x) + (<any>Math).fround(this.ey.x * R.ey.y));
            out.ey.x = tempx2;
            out.ey.y = tempy2;
        }

        public mulToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R : Mat22, out : Mat22) {
            out.ex.x = (<any>Math).fround((<any>Math).fround(this.ex.x * R.ex.x) + (<any>Math).fround(this.ey.x * R.ex.y));
            out.ex.y = (<any>Math).fround((<any>Math).fround(this.ex.y * R.ex.x) + (<any>Math).fround(this.ey.y * R.ex.y));
            out.ey.x = (<any>Math).fround((<any>Math).fround(this.ex.x * R.ey.x) + (<any>Math).fround(this.ey.x * R.ey.y));
            out.ey.y = (<any>Math).fround((<any>Math).fround(this.ex.y * R.ey.x) + (<any>Math).fround(this.ey.y * R.ey.y));
        }

        public mulTrans$org_jbox2d_common_Mat22(B : Mat22) : Mat22 {
            let C : Mat22 = new Mat22();
            C.ex.x = org.jbox2d.common.Vec2.dot(this.ex, B.ex);
            C.ex.y = org.jbox2d.common.Vec2.dot(this.ey, B.ex);
            C.ey.x = org.jbox2d.common.Vec2.dot(this.ex, B.ey);
            C.ey.y = org.jbox2d.common.Vec2.dot(this.ey, B.ey);
            return C;
        }

        /**
         * Multiply another matrix by the transpose of this one (transpose of this one on left). djm:
         * optimized
         * 
         * @param {org.jbox2d.common.Mat22} B
         * @return
         * @return {org.jbox2d.common.Mat22}
         */
        public mulTrans(B? : any) : any {
            if(((B != null && B instanceof <any>org.jbox2d.common.Mat22) || B === null)) {
                return <any>this.mulTrans$org_jbox2d_common_Mat22(B);
            } else if(((B != null && B instanceof <any>org.jbox2d.common.Vec2) || B === null)) {
                return <any>this.mulTrans$org_jbox2d_common_Vec2(B);
            } else throw new Error('invalid overload');
        }

        public mulTransLocal(B : Mat22) : Mat22 {
            this.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(B, this);
            return this;
        }

        public mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(B : Mat22, out : Mat22) {
            let x1 : number = (<any>Math).fround((<any>Math).fround(this.ex.x * B.ex.x) + (<any>Math).fround(this.ex.y * B.ex.y));
            let y1 : number = (<any>Math).fround((<any>Math).fround(this.ey.x * B.ex.x) + (<any>Math).fround(this.ey.y * B.ex.y));
            let x2 : number = (<any>Math).fround((<any>Math).fround(this.ex.x * B.ey.x) + (<any>Math).fround(this.ex.y * B.ey.y));
            let y2 : number = (<any>Math).fround((<any>Math).fround(this.ey.x * B.ey.x) + (<any>Math).fround(this.ey.y * B.ey.y));
            out.ex.x = x1;
            out.ey.x = x2;
            out.ex.y = y1;
            out.ey.y = y2;
        }

        public mulTransToOut(B? : any, out? : any) : any {
            if(((B != null && B instanceof <any>org.jbox2d.common.Mat22) || B === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>this.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(B, out);
            } else if(((B != null && B instanceof <any>org.jbox2d.common.Vec2) || B === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>this.mulTransToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(B, out);
            } else throw new Error('invalid overload');
        }

        public mulTransToOutUnsafe(B : Mat22, out : Mat22) {
            out.ex.x = (<any>Math).fround((<any>Math).fround(this.ex.x * B.ex.x) + (<any>Math).fround(this.ex.y * B.ex.y));
            out.ey.x = (<any>Math).fround((<any>Math).fround(this.ex.x * B.ey.x) + (<any>Math).fround(this.ex.y * B.ey.y));
            out.ex.y = (<any>Math).fround((<any>Math).fround(this.ey.x * B.ex.x) + (<any>Math).fround(this.ey.y * B.ex.y));
            out.ey.y = (<any>Math).fround((<any>Math).fround(this.ey.x * B.ey.x) + (<any>Math).fround(this.ey.y * B.ey.y));
        }

        public mulTrans$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2(((<any>Math).fround((<any>Math).fround(v.x * this.ex.x) + (<any>Math).fround(v.y * this.ex.y))), ((<any>Math).fround((<any>Math).fround(v.x * this.ey.x) + (<any>Math).fround(v.y * this.ey.y))));
        }

        public mulTransToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempx : number = (<any>Math).fround((<any>Math).fround(v.x * this.ex.x) + (<any>Math).fround(v.y * this.ex.y));
            out.y = (<any>Math).fround((<any>Math).fround(v.x * this.ey.x) + (<any>Math).fround(v.y * this.ey.y));
            out.x = tempx;
        }

        /**
         * Add this matrix to B, return the result.
         * 
         * @param {org.jbox2d.common.Mat22} B
         * @return
         * @return {org.jbox2d.common.Mat22}
         */
        public add(B : Mat22) : Mat22 {
            let m : Mat22 = new Mat22();
            m.ex.x = (<any>Math).fround(this.ex.x + B.ex.x);
            m.ex.y = (<any>Math).fround(this.ex.y + B.ex.y);
            m.ey.x = (<any>Math).fround(this.ey.x + B.ey.x);
            m.ey.y = (<any>Math).fround(this.ey.y + B.ey.y);
            return m;
        }

        /**
         * Add B to this matrix locally.
         * 
         * @param {org.jbox2d.common.Mat22} B
         * @return
         * @return {org.jbox2d.common.Mat22}
         */
        public addLocal(B : Mat22) : Mat22 {
            this.ex.x += B.ex.x;
            this.ex.y += B.ex.y;
            this.ey.x += B.ey.x;
            this.ey.y += B.ey.y;
            return this;
        }

        /**
         * Solve A * x = b where A = this matrix.
         * 
         * @return {org.jbox2d.common.Vec2} The vector x that solves the above equation.
         * @param {org.jbox2d.common.Vec2} b
         */
        public solve(b : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let a11 : number = this.ex.x;
            let a12 : number = this.ey.x;
            let a21 : number = this.ex.y;
            let a22 : number = this.ey.y;
            let det : number = (<any>Math).fround((<any>Math).fround(a11 * a22) - (<any>Math).fround(a12 * a21));
            if(det !== 0.0) {
                det = (<any>Math).fround(1.0 / det);
            }
            let x : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a22 * b.x) - (<any>Math).fround(a12 * b.y)))), (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a11 * b.y) - (<any>Math).fround(a21 * b.x)))));
            return x;
        }

        public solveToOut(b : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let a11 : number = this.ex.x;
            let a12 : number = this.ey.x;
            let a21 : number = this.ex.y;
            let a22 : number = this.ey.y;
            let det : number = (<any>Math).fround((<any>Math).fround(a11 * a22) - (<any>Math).fround(a12 * a21));
            if(det !== 0.0) {
                det = (<any>Math).fround(1.0 / det);
            }
            let tempy : number = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a11 * b.y) - (<any>Math).fround(a21 * b.x))));
            out.x = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a22 * b.x) - (<any>Math).fround(a12 * b.y))));
            out.y = tempy;
        }

        public static mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R : Mat22, v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2((<any>Math).fround((<any>Math).fround(R.ex.x * v.x) + (<any>Math).fround(R.ey.x * v.y)), (<any>Math).fround((<any>Math).fround(R.ex.y * v.x) + (<any>Math).fround(R.ey.y * v.y)));
        }

        public static mul(R? : any, v? : any) : any {
            if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null)) {
                return <any>org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R, v);
            } else if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null)) {
                return <any>org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v);
            } else throw new Error('invalid overload');
        }

        public static mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R : Mat22, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempy : number = (<any>Math).fround((<any>Math).fround(R.ex.y * v.x) + (<any>Math).fround(R.ey.y * v.y));
            out.x = (<any>Math).fround((<any>Math).fround(R.ex.x * v.x) + (<any>Math).fround(R.ey.x * v.y));
            out.y = tempy;
        }

        public static mulToOut(R? : any, v? : any, out? : any) : any {
            if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R, v, out);
            } else if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v, out);
            } else throw new Error('invalid overload');
        }

        public static mulToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R : Mat22, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            out.x = (<any>Math).fround((<any>Math).fround(R.ex.x * v.x) + (<any>Math).fround(R.ey.x * v.y));
            out.y = (<any>Math).fround((<any>Math).fround(R.ex.y * v.x) + (<any>Math).fround(R.ey.y * v.y));
        }

        public static mulToOutUnsafe(R? : any, v? : any, out? : any) : any {
            if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R, v, out);
            } else if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v, out);
            } else throw new Error('invalid overload');
        }

        public static mul$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A : Mat22, B : Mat22) : Mat22 {
            let C : Mat22 = new Mat22();
            C.ex.x = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ex.x) + (<any>Math).fround(A.ey.x * B.ex.y));
            C.ex.y = (<any>Math).fround((<any>Math).fround(A.ex.y * B.ex.x) + (<any>Math).fround(A.ey.y * B.ex.y));
            C.ey.x = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ey.x) + (<any>Math).fround(A.ey.x * B.ey.y));
            C.ey.y = (<any>Math).fround((<any>Math).fround(A.ex.y * B.ey.x) + (<any>Math).fround(A.ey.y * B.ey.y));
            return C;
        }

        public static mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A : Mat22, B : Mat22, out : Mat22) {
            let tempy1 : number = (<any>Math).fround((<any>Math).fround(A.ex.y * B.ex.x) + (<any>Math).fround(A.ey.y * B.ex.y));
            let tempx1 : number = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ex.x) + (<any>Math).fround(A.ey.x * B.ex.y));
            let tempy2 : number = (<any>Math).fround((<any>Math).fround(A.ex.y * B.ey.x) + (<any>Math).fround(A.ey.y * B.ey.y));
            let tempx2 : number = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ey.x) + (<any>Math).fround(A.ey.x * B.ey.y));
            out.ex.x = tempx1;
            out.ex.y = tempy1;
            out.ey.x = tempx2;
            out.ey.y = tempy2;
        }

        public static mulToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A : Mat22, B : Mat22, out : Mat22) {
            out.ex.x = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ex.x) + (<any>Math).fround(A.ey.x * B.ex.y));
            out.ex.y = (<any>Math).fround((<any>Math).fround(A.ex.y * B.ex.x) + (<any>Math).fround(A.ey.y * B.ex.y));
            out.ey.x = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ey.x) + (<any>Math).fround(A.ey.x * B.ey.y));
            out.ey.y = (<any>Math).fround((<any>Math).fround(A.ex.y * B.ey.x) + (<any>Math).fround(A.ey.y * B.ey.y));
        }

        public static mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R : Mat22, v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2(((<any>Math).fround((<any>Math).fround(v.x * R.ex.x) + (<any>Math).fround(v.y * R.ex.y))), ((<any>Math).fround((<any>Math).fround(v.x * R.ey.x) + (<any>Math).fround(v.y * R.ey.y))));
        }

        public static mulTrans(R? : any, v? : any) : any {
            if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null)) {
                return <any>org.jbox2d.common.Mat22.mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R, v);
            } else if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null)) {
                return <any>org.jbox2d.common.Mat22.mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v);
            } else throw new Error('invalid overload');
        }

        public static mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R : Mat22, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let outx : number = (<any>Math).fround((<any>Math).fround(v.x * R.ex.x) + (<any>Math).fround(v.y * R.ex.y));
            out.y = (<any>Math).fround((<any>Math).fround(v.x * R.ey.x) + (<any>Math).fround(v.y * R.ey.y));
            out.x = outx;
        }

        public static mulTransToOut(R? : any, v? : any, out? : any) : any {
            if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R, v, out);
            } else if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v, out);
            } else throw new Error('invalid overload');
        }

        public static mulTransToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R : Mat22, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            out.y = (<any>Math).fround((<any>Math).fround(v.x * R.ey.x) + (<any>Math).fround(v.y * R.ey.y));
            out.x = (<any>Math).fround((<any>Math).fround(v.x * R.ex.x) + (<any>Math).fround(v.y * R.ex.y));
        }

        public static mulTransToOutUnsafe(R? : any, v? : any, out? : any) : any {
            if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulTransToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R, v, out);
            } else if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulTransToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v, out);
            } else throw new Error('invalid overload');
        }

        public static mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A : Mat22, B : Mat22) : Mat22 {
            let C : Mat22 = new Mat22();
            C.ex.x = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ex.x) + (<any>Math).fround(A.ex.y * B.ex.y));
            C.ex.y = (<any>Math).fround((<any>Math).fround(A.ey.x * B.ex.x) + (<any>Math).fround(A.ey.y * B.ex.y));
            C.ey.x = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ey.x) + (<any>Math).fround(A.ex.y * B.ey.y));
            C.ey.y = (<any>Math).fround((<any>Math).fround(A.ey.x * B.ey.x) + (<any>Math).fround(A.ey.y * B.ey.y));
            return C;
        }

        public static mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A : Mat22, B : Mat22, out : Mat22) {
            let x1 : number = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ex.x) + (<any>Math).fround(A.ex.y * B.ex.y));
            let y1 : number = (<any>Math).fround((<any>Math).fround(A.ey.x * B.ex.x) + (<any>Math).fround(A.ey.y * B.ex.y));
            let x2 : number = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ey.x) + (<any>Math).fround(A.ex.y * B.ey.y));
            let y2 : number = (<any>Math).fround((<any>Math).fround(A.ey.x * B.ey.x) + (<any>Math).fround(A.ey.y * B.ey.y));
            out.ex.x = x1;
            out.ex.y = y1;
            out.ey.x = x2;
            out.ey.y = y2;
        }

        public static mulTransToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A : Mat22, B : Mat22, out : Mat22) {
            out.ex.x = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ex.x) + (<any>Math).fround(A.ex.y * B.ex.y));
            out.ex.y = (<any>Math).fround((<any>Math).fround(A.ey.x * B.ex.x) + (<any>Math).fround(A.ey.y * B.ex.y));
            out.ey.x = (<any>Math).fround((<any>Math).fround(A.ex.x * B.ey.x) + (<any>Math).fround(A.ex.y * B.ey.y));
            out.ey.y = (<any>Math).fround((<any>Math).fround(A.ey.x * B.ey.x) + (<any>Math).fround(A.ey.y * B.ey.y));
        }

        public static createRotationalTransform$float(angle : number) : Mat22 {
            let mat : Mat22 = new Mat22();
            let c : number = org.jbox2d.common.MathUtils.cos(angle);
            let s : number = org.jbox2d.common.MathUtils.sin(angle);
            mat.ex.x = c;
            mat.ey.x = -s;
            mat.ex.y = s;
            mat.ey.y = c;
            return mat;
        }

        public static createRotationalTransform$float$org_jbox2d_common_Mat22(angle : number, out : Mat22) {
            let c : number = org.jbox2d.common.MathUtils.cos(angle);
            let s : number = org.jbox2d.common.MathUtils.sin(angle);
            out.ex.x = c;
            out.ey.x = -s;
            out.ex.y = s;
            out.ey.y = c;
        }

        public static createRotationalTransform(angle? : any, out? : any) : any {
            if(((typeof angle === 'number') || angle === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>org.jbox2d.common.Mat22.createRotationalTransform$float$org_jbox2d_common_Mat22(angle, out);
            } else if(((typeof angle === 'number') || angle === null) && out === undefined) {
                return <any>org.jbox2d.common.Mat22.createRotationalTransform$float(angle);
            } else throw new Error('invalid overload');
        }

        public static createScaleTransform$float(scale : number) : Mat22 {
            let mat : Mat22 = new Mat22();
            mat.ex.x = scale;
            mat.ey.y = scale;
            return mat;
        }

        public static createScaleTransform$float$org_jbox2d_common_Mat22(scale : number, out : Mat22) {
            out.ex.x = scale;
            out.ey.y = scale;
        }

        public static createScaleTransform(scale? : any, out? : any) : any {
            if(((typeof scale === 'number') || scale === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>org.jbox2d.common.Mat22.createScaleTransform$float$org_jbox2d_common_Mat22(scale, out);
            } else if(((typeof scale === 'number') || scale === null) && out === undefined) {
                return <any>org.jbox2d.common.Mat22.createScaleTransform$float(scale);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            let prime : number = 31;
            let result : number = 1;
            result = prime * result + ((this.ex == null)?0:/* hashCode */(<any>((o: any) => { if(o.hashCode) { return o.hashCode(); } else { return o.toString(); } })(this.ex)));
            result = prime * result + ((this.ey == null)?0:/* hashCode */(<any>((o: any) => { if(o.hashCode) { return o.hashCode(); } else { return o.toString(); } })(this.ey)));
            return result;
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj : any) : boolean {
            if(this === obj) return true;
            if(obj == null) return false;
            if((<any>this.constructor) !== (<any>obj.constructor)) return false;
            let other : Mat22 = <Mat22>obj;
            if(this.ex == null) {
                if(other.ex != null) return false;
            } else if(!this.ex.equals(other.ex)) return false;
            if(this.ey == null) {
                if(other.ey != null) return false;
            } else if(!this.ey.equals(other.ey)) return false;
            return true;
        }
    }
    Mat22["__class"] = "org.jbox2d.common.Mat22";
    Mat22["__interfaces"] = ["java.io.Serializable"];


}
namespace org.jbox2d.common {
    /**
     * Orientated bounding box viewport transform
     * 
     * @author Daniel Murphy
     * @class
     */
    export class OBBViewportTransform implements org.jbox2d.common.IViewportTransform {
        box : OBBViewportTransform.OBB = new OBBViewportTransform.OBB();

        /*private*/ yFlip : boolean = false;

        /*private*/ yFlipMat : org.jbox2d.common.Mat22 = new org.jbox2d.common.Mat22(1, 0, 0, -1);

        public constructor() {
            this.box.R.setIdentity();
        }

        public set(vpt : OBBViewportTransform) {
            this.box.center.set$org_jbox2d_common_Vec2(vpt.box.center);
            this.box.extents.set$org_jbox2d_common_Vec2(vpt.box.extents);
            this.box.R.set$org_jbox2d_common_Mat22(vpt.box.R);
            this.yFlip = vpt.yFlip;
        }

        public setCamera(x : number, y : number, scale : number) {
            this.box.center.set$float$float(x, y);
            org.jbox2d.common.Mat22.createScaleTransform$float$org_jbox2d_common_Mat22(scale, this.box.R);
        }

        public getExtents() : org.jbox2d.common.Vec2 {
            return this.box.extents;
        }

        /**
         * 
         * @return {org.jbox2d.common.Mat22}
         */
        public getMat22Representation() : org.jbox2d.common.Mat22 {
            return this.box.R;
        }

        public setExtents$org_jbox2d_common_Vec2(argExtents : org.jbox2d.common.Vec2) {
            this.box.extents.set$org_jbox2d_common_Vec2(argExtents);
        }

        public setExtents$float$float(halfWidth : number, halfHeight : number) {
            this.box.extents.set$float$float(halfWidth, halfHeight);
        }

        public setExtents(halfWidth? : any, halfHeight? : any) : any {
            if(((typeof halfWidth === 'number') || halfWidth === null) && ((typeof halfHeight === 'number') || halfHeight === null)) {
                return <any>this.setExtents$float$float(halfWidth, halfHeight);
            } else if(((halfWidth != null && halfWidth instanceof <any>org.jbox2d.common.Vec2) || halfWidth === null) && halfHeight === undefined) {
                return <any>this.setExtents$org_jbox2d_common_Vec2(halfWidth);
            } else throw new Error('invalid overload');
        }

        public getCenter() : org.jbox2d.common.Vec2 {
            return this.box.center;
        }

        public setCenter$org_jbox2d_common_Vec2(argPos : org.jbox2d.common.Vec2) {
            this.box.center.set$org_jbox2d_common_Vec2(argPos);
        }

        public setCenter$float$float(x : number, y : number) {
            this.box.center.set$float$float(x, y);
        }

        public setCenter(x? : any, y? : any) : any {
            if(((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return <any>this.setCenter$float$float(x, y);
            } else if(((x != null && x instanceof <any>org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                return <any>this.setCenter$org_jbox2d_common_Vec2(x);
            } else throw new Error('invalid overload');
        }

        /**
         * Gets the transform of the viewport, transforms around the center. Not a copy.
         * @return {org.jbox2d.common.Mat22}
         */
        public getTransform() : org.jbox2d.common.Mat22 {
            return this.box.R;
        }

        /**
         * Sets the transform of the viewport. Transforms about the center.
         * @param {org.jbox2d.common.Mat22} transform
         */
        public setTransform(transform : org.jbox2d.common.Mat22) {
            this.box.R.set$org_jbox2d_common_Mat22(transform);
        }

        /**
         * Multiplies the obb transform by the given transform
         * @param {org.jbox2d.common.Mat22} transform
         */
        public mulByTransform(transform : org.jbox2d.common.Mat22) {
            this.box.R.mulLocal(transform);
        }

        public isYFlip() : boolean {
            return this.yFlip;
        }

        public setYFlip(yFlip : boolean) {
            this.yFlip = yFlip;
        }

        /*private*/ inv : org.jbox2d.common.Mat22 = new org.jbox2d.common.Mat22();

        public getScreenVectorToWorld(screen : org.jbox2d.common.Vec2, world : org.jbox2d.common.Vec2) {
            this.box.R.invertToOut(this.inv);
            this.inv.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(screen, world);
            if(this.yFlip) {
                this.yFlipMat.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(world, world);
            }
        }

        public getWorldVectorToScreen(world : org.jbox2d.common.Vec2, screen : org.jbox2d.common.Vec2) {
            this.box.R.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(world, screen);
            if(this.yFlip) {
                this.yFlipMat.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(screen, screen);
            }
        }

        public getWorldToScreen(world : org.jbox2d.common.Vec2, screen : org.jbox2d.common.Vec2) {
            screen.x = (<any>Math).fround(world.x - this.box.center.x);
            screen.y = (<any>Math).fround(world.y - this.box.center.y);
            this.box.R.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(screen, screen);
            if(this.yFlip) {
                this.yFlipMat.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(screen, screen);
            }
            screen.x += this.box.extents.x;
            screen.y += this.box.extents.y;
        }

        /*private*/ inv2 : org.jbox2d.common.Mat22 = new org.jbox2d.common.Mat22();

        public getScreenToWorld(screen : org.jbox2d.common.Vec2, world : org.jbox2d.common.Vec2) {
            world.x = (<any>Math).fround(screen.x - this.box.extents.x);
            world.y = (<any>Math).fround(screen.y - this.box.extents.y);
            if(this.yFlip) {
                this.yFlipMat.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(world, world);
            }
            this.box.R.invertToOut(this.inv2);
            this.inv2.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(world, world);
            world.x += this.box.center.x;
            world.y += this.box.center.y;
        }
    }
    OBBViewportTransform["__class"] = "org.jbox2d.common.OBBViewportTransform";
    OBBViewportTransform["__interfaces"] = ["org.jbox2d.common.IViewportTransform"];



    export namespace OBBViewportTransform {

        export class OBB {
            public R : org.jbox2d.common.Mat22 = new org.jbox2d.common.Mat22();

            public center : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            public extents : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            constructor() {
            }
        }
        OBB["__class"] = "org.jbox2d.common.OBBViewportTransform.OBB";

    }

}
namespace org.jbox2d.common {
    /**
     * Contains methods from MathUtils that rely on JVM features. These are separated out from
     * MathUtils so that they can be overridden when compiling for GWT.
     * @class
     */
    export class PlatformMathUtils {
        static SHIFT23 : number; public static SHIFT23_$LI$() : number { if(PlatformMathUtils.SHIFT23 == null) PlatformMathUtils.SHIFT23 = 1 << 23; return PlatformMathUtils.SHIFT23; };

        static INV_SHIFT23 : number; public static INV_SHIFT23_$LI$() : number { if(PlatformMathUtils.INV_SHIFT23 == null) PlatformMathUtils.INV_SHIFT23 = (<any>Math).fround(1.0 / PlatformMathUtils.SHIFT23_$LI$()); return PlatformMathUtils.INV_SHIFT23; };

        public static fastPow(a : number, b : number) : number {
            let x : number = /* floatToRawIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(a);
            x *= PlatformMathUtils.INV_SHIFT23_$LI$();
            x -= 127;
            let y : number = (<any>Math).fround(x - (x >= 0?(<number>x|0):(<number>x|0) - 1));
            b *= (<any>Math).fround(x + (<any>Math).fround(((<any>Math).fround(y - (<any>Math).fround(y * y))) * 0.346607));
            y = (<any>Math).fround(b - (b >= 0?(<number>b|0):(<number>b|0) - 1));
            y = (<any>Math).fround(((<any>Math).fround(y - (<any>Math).fround(y * y))) * 0.33971);
            return ((v) => { let buf = new ArrayBuffer(4); (new Uint32Array(buf))[0]=v; return (new Float32Array(buf))[0]; })((<number>((<any>Math).fround(((<any>Math).fround((<any>Math).fround(b + 127) - y)) * PlatformMathUtils.SHIFT23_$LI$()))|0));
        }
    }
    PlatformMathUtils["__class"] = "org.jbox2d.common.PlatformMathUtils";

}
namespace org.jbox2d.common {
    export class RaycastResult {
        public lambda : number = 0.0;

        public normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public set(argOther : RaycastResult) : RaycastResult {
            this.lambda = argOther.lambda;
            this.normal.set$org_jbox2d_common_Vec2(argOther.normal);
            return this;
        }
    }
    RaycastResult["__class"] = "org.jbox2d.common.RaycastResult";

}
namespace org.jbox2d.common {
    /**
     * Represents a rotation
     * 
     * @author Daniel
     * @param {number} angle
     * @class
     */
    export class Rot {
        static serialVersionUID : number = 1;

        public s : number;

        public c : number;

        public constructor(angle? : any) {
            if(((typeof angle === 'number') || angle === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.s===undefined) this.s = 0;
                if(this.c===undefined) this.c = 0;
                if(this.s===undefined) this.s = 0;
                if(this.c===undefined) this.c = 0;
                (() => {
                    this.set$float(angle);
                })();
            } else if(angle === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.s===undefined) this.s = 0;
                if(this.c===undefined) this.c = 0;
                if(this.s===undefined) this.s = 0;
                if(this.c===undefined) this.c = 0;
                (() => {
                    this.setIdentity();
                })();
            } else throw new Error('invalid overload');
        }

        public getSin() : number {
            return this.s;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            return "Rot(s:" + this.s + ", c:" + this.c + ")";
        }

        public getCos() : number {
            return this.c;
        }

        public set$float(angle : number) : Rot {
            this.s = org.jbox2d.common.MathUtils.sin(angle);
            this.c = org.jbox2d.common.MathUtils.cos(angle);
            return this;
        }

        public set$org_jbox2d_common_Rot(other : Rot) : Rot {
            this.s = other.s;
            this.c = other.c;
            return this;
        }

        public set(other? : any) : any {
            if(((other != null && other instanceof <any>org.jbox2d.common.Rot) || other === null)) {
                return <any>this.set$org_jbox2d_common_Rot(other);
            } else if(((typeof other === 'number') || other === null)) {
                return <any>this.set$float(other);
            } else throw new Error('invalid overload');
        }

        public setIdentity() : Rot {
            this.s = 0;
            this.c = 1;
            return this;
        }

        public getAngle() : number {
            return org.jbox2d.common.MathUtils.atan2(this.s, this.c);
        }

        public getXAxis(xAxis : org.jbox2d.common.Vec2) {
            xAxis.set$float$float(this.c, this.s);
        }

        public getYAxis(yAxis : org.jbox2d.common.Vec2) {
            yAxis.set$float$float(-this.s, this.c);
        }

        public clone() : Rot {
            let copy : Rot = new Rot();
            copy.s = this.s;
            copy.c = this.c;
            return copy;
        }

        public static mul(q : Rot, r : Rot, out : Rot) {
            let tempc : number = (<any>Math).fround((<any>Math).fround(q.c * r.c) - (<any>Math).fround(q.s * r.s));
            out.s = (<any>Math).fround((<any>Math).fround(q.s * r.c) + (<any>Math).fround(q.c * r.s));
            out.c = tempc;
        }

        public static mulUnsafe(q : Rot, r : Rot, out : Rot) {
            out.s = (<any>Math).fround((<any>Math).fround(q.s * r.c) + (<any>Math).fround(q.c * r.s));
            out.c = (<any>Math).fround((<any>Math).fround(q.c * r.c) - (<any>Math).fround(q.s * r.s));
        }

        public static mulTrans$org_jbox2d_common_Rot$org_jbox2d_common_Rot$org_jbox2d_common_Rot(q : Rot, r : Rot, out : Rot) {
            let tempc : number = (<any>Math).fround((<any>Math).fround(q.c * r.c) + (<any>Math).fround(q.s * r.s));
            out.s = (<any>Math).fround((<any>Math).fround(q.c * r.s) - (<any>Math).fround(q.s * r.c));
            out.c = tempc;
        }

        public static mulTrans(q? : any, r? : any, out? : any) : any {
            if(((q != null && q instanceof <any>org.jbox2d.common.Rot) || q === null) && ((r != null && r instanceof <any>org.jbox2d.common.Rot) || r === null) && ((out != null && out instanceof <any>org.jbox2d.common.Rot) || out === null)) {
                return <any>org.jbox2d.common.Rot.mulTrans$org_jbox2d_common_Rot$org_jbox2d_common_Rot$org_jbox2d_common_Rot(q, r, out);
            } else if(((q != null && q instanceof <any>org.jbox2d.common.Rot) || q === null) && ((r != null && r instanceof <any>org.jbox2d.common.Vec2) || r === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Rot.mulTrans$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(q, r, out);
            } else throw new Error('invalid overload');
        }

        public static mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Rot$org_jbox2d_common_Rot(q : Rot, r : Rot, out : Rot) {
            out.s = (<any>Math).fround((<any>Math).fround(q.c * r.s) - (<any>Math).fround(q.s * r.c));
            out.c = (<any>Math).fround((<any>Math).fround(q.c * r.c) + (<any>Math).fround(q.s * r.s));
        }

        public static mulTransUnsafe(q? : any, r? : any, out? : any) : any {
            if(((q != null && q instanceof <any>org.jbox2d.common.Rot) || q === null) && ((r != null && r instanceof <any>org.jbox2d.common.Rot) || r === null) && ((out != null && out instanceof <any>org.jbox2d.common.Rot) || out === null)) {
                return <any>org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Rot$org_jbox2d_common_Rot(q, r, out);
            } else if(((q != null && q instanceof <any>org.jbox2d.common.Rot) || q === null) && ((r != null && r instanceof <any>org.jbox2d.common.Vec2) || r === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(q, r, out);
            } else throw new Error('invalid overload');
        }

        public static mulToOut(q : Rot, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempy : number = (<any>Math).fround((<any>Math).fround(q.s * v.x) + (<any>Math).fround(q.c * v.y));
            out.x = (<any>Math).fround((<any>Math).fround(q.c * v.x) - (<any>Math).fround(q.s * v.y));
            out.y = tempy;
        }

        public static mulToOutUnsafe(q : Rot, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            out.x = (<any>Math).fround((<any>Math).fround(q.c * v.x) - (<any>Math).fround(q.s * v.y));
            out.y = (<any>Math).fround((<any>Math).fround(q.s * v.x) + (<any>Math).fround(q.c * v.y));
        }

        public static mulTrans$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(q : Rot, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempy : number = (<any>Math).fround((<any>Math).fround(-q.s * v.x) + (<any>Math).fround(q.c * v.y));
            out.x = (<any>Math).fround((<any>Math).fround(q.c * v.x) + (<any>Math).fround(q.s * v.y));
            out.y = tempy;
        }

        public static mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(q : Rot, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            out.x = (<any>Math).fround((<any>Math).fround(q.c * v.x) + (<any>Math).fround(q.s * v.y));
            out.y = (<any>Math).fround((<any>Math).fround(-q.s * v.x) + (<any>Math).fround(q.c * v.y));
        }
    }
    Rot["__class"] = "org.jbox2d.common.Rot";
    Rot["__interfaces"] = ["java.io.Serializable"];


}
namespace org.jbox2d.common {
    /**
     * Global tuning constants based on MKS units and various integer maximums (vertices per shape,
     * pairs, etc.).
     * @class
     */
    export class Settings {
        /**
         * A "close to zero" float epsilon value for use
         */
        public static EPSILON : number = 1.1920929E-7;

        /**
         * Pi.
         */
        public static PI : number; public static PI_$LI$() : number { if(Settings.PI == null) Settings.PI = (<any>Math).fround(Math.PI); return Settings.PI; };

        public static FAST_ABS : boolean = true;

        public static FAST_FLOOR : boolean = true;

        public static FAST_CEIL : boolean = true;

        public static FAST_ROUND : boolean = true;

        public static FAST_ATAN2 : boolean = true;

        public static FAST_POW : boolean = true;

        public static CONTACT_STACK_INIT_SIZE : number = 10;

        public static SINCOS_LUT_ENABLED : boolean = true;

        /**
         * smaller the precision, the larger the table. If a small table is used (eg, precision is .006 or
         * greater), make sure you set the table to lerp it's results. Accuracy chart is in the MathUtils
         * source. Or, run the tests yourself in {@link SinCosTest}.</br> </br> Good lerp precision
         * values:
         * <ul>
         * <li>.0092</li>
         * <li>.008201</li>
         * <li>.005904</li>
         * <li>.005204</li>
         * <li>.004305</li>
         * <li>.002807</li>
         * <li>.001508</li>
         * <li>9.32500E-4</li>
         * <li>7.48000E-4</li>
         * <li>8.47000E-4</li>
         * <li>.0005095</li>
         * <li>.0001098</li>
         * <li>9.50499E-5</li>
         * <li>6.08500E-5</li>
         * <li>3.07000E-5</li>
         * <li>1.53999E-5</li>
         * </ul>
         */
        public static SINCOS_LUT_PRECISION : number = 1.1E-4;

        public static SINCOS_LUT_LENGTH : number; public static SINCOS_LUT_LENGTH_$LI$() : number { if(Settings.SINCOS_LUT_LENGTH == null) Settings.SINCOS_LUT_LENGTH = (<number>Math.ceil(Math.PI * 2 / Settings.SINCOS_LUT_PRECISION)|0); return Settings.SINCOS_LUT_LENGTH; };

        /**
         * Use if the table's precision is large (eg .006 or greater). Although it is more expensive, it
         * greatly increases accuracy. Look in the MathUtils source for some test results on the accuracy
         * and speed of lerp vs non lerp. Or, run the tests yourself in {@link SinCosTest}.
         */
        public static SINCOS_LUT_LERP : boolean = false;

        /**
         * The maximum number of contact points between two convex shapes.
         */
        public static maxManifoldPoints : number = 2;

        /**
         * The maximum number of vertices on a convex polygon.
         */
        public static maxPolygonVertices : number = 8;

        /**
         * This is used to fatten AABBs in the dynamic tree. This allows proxies to move by a small amount
         * without triggering a tree adjustment. This is in meters.
         */
        public static aabbExtension : number = 0.1;

        /**
         * This is used to fatten AABBs in the dynamic tree. This is used to predict the future position
         * based on the current displacement. This is a dimensionless multiplier.
         */
        public static aabbMultiplier : number = 2.0;

        /**
         * A small length used as a collision and constraint tolerance. Usually it is chosen to be
         * numerically significant, but visually insignificant.
         */
        public static linearSlop : number = 0.005;

        /**
         * A small angle used as a collision and constraint tolerance. Usually it is chosen to be
         * numerically significant, but visually insignificant.
         */
        public static angularSlop : number; public static angularSlop_$LI$() : number { if(Settings.angularSlop == null) Settings.angularSlop = ((<any>Math).fround((<any>Math).fround(2.0 / 180.0) * Settings.PI_$LI$())); return Settings.angularSlop; };

        /**
         * The radius of the polygon/edge shape skin. This should not be modified. Making this smaller
         * means polygons will have and insufficient for continuous collision. Making it larger may create
         * artifacts for vertex collision.
         */
        public static polygonRadius : number; public static polygonRadius_$LI$() : number { if(Settings.polygonRadius == null) Settings.polygonRadius = ((<any>Math).fround(2.0 * Settings.linearSlop)); return Settings.polygonRadius; };

        /**
         * Maximum number of sub-steps per contact in continuous physics simulation.
         */
        public static maxSubSteps : number = 8;

        /**
         * Maximum number of contacts to be handled to solve a TOI island.
         */
        public static maxTOIContacts : number = 32;

        /**
         * A velocity threshold for elastic collisions. Any collision with a relative linear velocity
         * below this threshold will be treated as inelastic.
         */
        public static velocityThreshold : number = 1.0;

        /**
         * The maximum linear position correction used when solving constraints. This helps to prevent
         * overshoot.
         */
        public static maxLinearCorrection : number = 0.2;

        /**
         * The maximum angular position correction used when solving constraints. This helps to prevent
         * overshoot.
         */
        public static maxAngularCorrection : number; public static maxAngularCorrection_$LI$() : number { if(Settings.maxAngularCorrection == null) Settings.maxAngularCorrection = ((<any>Math).fround((<any>Math).fround(8.0 / 180.0) * Settings.PI_$LI$())); return Settings.maxAngularCorrection; };

        /**
         * The maximum linear velocity of a body. This limit is very large and is used to prevent
         * numerical problems. You shouldn't need to adjust this.
         */
        public static maxTranslation : number = 2.0;

        public static maxTranslationSquared : number; public static maxTranslationSquared_$LI$() : number { if(Settings.maxTranslationSquared == null) Settings.maxTranslationSquared = ((<any>Math).fround(Settings.maxTranslation * Settings.maxTranslation)); return Settings.maxTranslationSquared; };

        /**
         * The maximum angular velocity of a body. This limit is very large and is used to prevent
         * numerical problems. You shouldn't need to adjust this.
         */
        public static maxRotation : number; public static maxRotation_$LI$() : number { if(Settings.maxRotation == null) Settings.maxRotation = ((<any>Math).fround(0.5 * Settings.PI_$LI$())); return Settings.maxRotation; };

        public static maxRotationSquared : number; public static maxRotationSquared_$LI$() : number { if(Settings.maxRotationSquared == null) Settings.maxRotationSquared = ((<any>Math).fround(Settings.maxRotation_$LI$() * Settings.maxRotation_$LI$())); return Settings.maxRotationSquared; };

        /**
         * This scale factor controls how fast overlap is resolved. Ideally this would be 1 so that
         * overlap is removed in one time step. However using values close to 1 often lead to overshoot.
         */
        public static baumgarte : number = 0.2;

        public static toiBaugarte : number = 0.75;

        /**
         * The time that a body must be still before it will go to sleep.
         */
        public static timeToSleep : number = 0.5;

        /**
         * A body cannot sleep if its linear velocity is above this tolerance.
         */
        public static linearSleepTolerance : number = 0.01;

        /**
         * A body cannot sleep if its angular velocity is above this tolerance.
         */
        public static angularSleepTolerance : number; public static angularSleepTolerance_$LI$() : number { if(Settings.angularSleepTolerance == null) Settings.angularSleepTolerance = ((<any>Math).fround((<any>Math).fround(2.0 / 180.0) * Settings.PI_$LI$())); return Settings.angularSleepTolerance; };

        /**
         * A symbolic constant that stands for particle allocation error.
         */
        public static invalidParticleIndex : number; public static invalidParticleIndex_$LI$() : number { if(Settings.invalidParticleIndex == null) Settings.invalidParticleIndex = (-1); return Settings.invalidParticleIndex; };

        /**
         * The standard distance between particles, divided by the particle radius.
         */
        public static particleStride : number = 0.75;

        /**
         * The minimum particle weight that produces pressure.
         */
        public static minParticleWeight : number = 1.0;

        /**
         * The upper limit for particle weight used in pressure calculation.
         */
        public static maxParticleWeight : number = 5.0;

        /**
         * The maximum distance between particles in a triad, divided by the particle radius.
         */
        public static maxTriadDistance : number = 2;

        public static maxTriadDistanceSquared : number; public static maxTriadDistanceSquared_$LI$() : number { if(Settings.maxTriadDistanceSquared == null) Settings.maxTriadDistanceSquared = (Settings.maxTriadDistance * Settings.maxTriadDistance); return Settings.maxTriadDistanceSquared; };

        /**
         * The initial size of particle data buffers.
         */
        public static minParticleBufferCapacity : number = 256;

        /**
         * Friction mixing law. Feel free to customize this. TODO djm: add customization
         * 
         * @param {number} friction1
         * @param {number} friction2
         * @return
         * @return {number}
         */
        public static mixFriction(friction1 : number, friction2 : number) : number {
            return org.jbox2d.common.MathUtils.sqrt((<any>Math).fround(friction1 * friction2));
        }

        /**
         * Restitution mixing law. Feel free to customize this. TODO djm: add customization
         * 
         * @param {number} restitution1
         * @param {number} restitution2
         * @return
         * @return {number}
         */
        public static mixRestitution(restitution1 : number, restitution2 : number) : number {
            return restitution1 > restitution2?restitution1:restitution2;
        }
    }
    Settings["__class"] = "org.jbox2d.common.Settings";

}
namespace org.jbox2d.common {
    /**
     * This describes the motion of a body/shape for TOI computation. Shapes are defined with respect to
     * the body origin, which may not coincide with the center of mass. However, to support dynamics we
     * must interpolate the center of mass position.
     * @class
     */
    export class Sweep {
        static serialVersionUID : number = 1;

        /**
         * Local center of mass position
         */
        public localCenter : org.jbox2d.common.Vec2;

        /**
         * Center world positions
         */
        public c0 : org.jbox2d.common.Vec2;

        /**
         * Center world positions
         */
        public c : org.jbox2d.common.Vec2;

        /**
         * World angles
         */
        public a0 : number;

        /**
         * World angles
         */
        public a : number;

        /**
         * Fraction of the current time step in the range [0,1] c0 and a0 are the positions at alpha0.
         */
        public alpha0 : number;

        public toString() : string {
            let s : string = "Sweep:\nlocalCenter: " + this.localCenter + "\n";
            s += "c0: " + this.c0 + ", c: " + this.c + "\n";
            s += "a0: " + this.a0 + ", a: " + this.a + "\n";
            s += "alpha0: " + this.alpha0;
            return s;
        }

        public constructor() {
            if(this.localCenter===undefined) this.localCenter = null;
            if(this.c0===undefined) this.c0 = null;
            if(this.c===undefined) this.c = null;
            if(this.a0===undefined) this.a0 = 0;
            if(this.a===undefined) this.a = 0;
            if(this.alpha0===undefined) this.alpha0 = 0;
            this.localCenter = new org.jbox2d.common.Vec2();
            this.c0 = new org.jbox2d.common.Vec2();
            this.c = new org.jbox2d.common.Vec2();
        }

        public normalize() {
            let d : number = (<any>Math).fround(org.jbox2d.common.MathUtils.TWOPI_$LI$() * org.jbox2d.common.MathUtils.floor((<any>Math).fround(this.a0 / org.jbox2d.common.MathUtils.TWOPI_$LI$())));
            this.a0 -= d;
            this.a -= d;
        }

        public set(other : Sweep) : Sweep {
            this.localCenter.set$org_jbox2d_common_Vec2(other.localCenter);
            this.c0.set$org_jbox2d_common_Vec2(other.c0);
            this.c.set$org_jbox2d_common_Vec2(other.c);
            this.a0 = other.a0;
            this.a = other.a;
            this.alpha0 = other.alpha0;
            return this;
        }

        /**
         * Get the interpolated transform at a specific time.
         * 
         * @param {org.jbox2d.common.Transform} xf the result is placed here - must not be null
         * @param t the normalized time in [0,1].
         * @param {number} beta
         */
        public getTransform(xf : org.jbox2d.common.Transform, beta : number) {
            xf.p.x = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - beta)) * this.c0.x) + (<any>Math).fround(beta * this.c.x));
            xf.p.y = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - beta)) * this.c0.y) + (<any>Math).fround(beta * this.c.y));
            let angle : number = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - beta)) * this.a0) + (<any>Math).fround(beta * this.a));
            xf.q.set$float(angle);
            let q : org.jbox2d.common.Rot = xf.q;
            xf.p.x -= (<any>Math).fround((<any>Math).fround(q.c * this.localCenter.x) - (<any>Math).fround(q.s * this.localCenter.y));
            xf.p.y -= (<any>Math).fround((<any>Math).fround(q.s * this.localCenter.x) + (<any>Math).fround(q.c * this.localCenter.y));
        }

        /**
         * Advance the sweep forward, yielding a new initial state.
         * 
         * @param {number} alpha the new initial time.
         */
        public advance(alpha : number) {
            let beta : number = (<any>Math).fround(((<any>Math).fround(alpha - this.alpha0)) / ((<any>Math).fround(1.0 - this.alpha0)));
            this.c0.x += (<any>Math).fround(beta * ((<any>Math).fround(this.c.x - this.c0.x)));
            this.c0.y += (<any>Math).fround(beta * ((<any>Math).fround(this.c.y - this.c0.y)));
            this.a0 += (<any>Math).fround(beta * ((<any>Math).fround(this.a - this.a0)));
            this.alpha0 = alpha;
        }
    }
    Sweep["__class"] = "org.jbox2d.common.Sweep";
    Sweep["__interfaces"] = ["java.io.Serializable"];


}
namespace org.jbox2d.common {
    /**
     * Timer for profiling
     * 
     * @author Daniel
     * @class
     */
    export class Timer {
        /*private*/ resetNanos : number;

        public constructor() {
            if(this.resetNanos===undefined) this.resetNanos = 0;
            this.reset();
        }

        public reset() {
            this.resetNanos = /* nanoTime */(Date.now() * 1000000);
        }

        public getMilliseconds() : number {
            return (<any>Math).fround((<any>Math).fround((n => n<0?Math.ceil(n):Math.floor(n))((/* nanoTime */(Date.now() * 1000000) - this.resetNanos) / 1000) * 1.0) / 1000);
        }
    }
    Timer["__class"] = "org.jbox2d.common.Timer";

}
namespace org.jbox2d.common {
    /**
     * A 2D column vector
     * @param {number} x
     * @param {number} y
     * @class
     */
    export class Vec2 {
        static serialVersionUID : number = 1;

        public x : number;

        public y : number;

        public constructor(x? : any, y? : any) {
            if(((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                (() => {
                    this.x = x;
                    this.y = y;
                })();
            } else if(((x != null && x instanceof <any>org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let toCopy : any = __args[0];
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let x : any = toCopy.x;
                    let y : any = toCopy.y;
                    if(this.x===undefined) this.x = 0;
                    if(this.y===undefined) this.y = 0;
                    if(this.x===undefined) this.x = 0;
                    if(this.y===undefined) this.y = 0;
                    (() => {
                        this.x = x;
                        this.y = y;
                    })();
                }
            } else if(x === undefined && y === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let x : any = 0;
                    let y : any = 0;
                    if(this.x===undefined) this.x = 0;
                    if(this.y===undefined) this.y = 0;
                    if(this.x===undefined) this.x = 0;
                    if(this.y===undefined) this.y = 0;
                    (() => {
                        this.x = x;
                        this.y = y;
                    })();
                }
            } else throw new Error('invalid overload');
        }

        /**
         * Zero out this vector.
         */
        public setZero() {
            this.x = 0.0;
            this.y = 0.0;
        }

        public set$float$float(x : number, y : number) : Vec2 {
            this.x = x;
            this.y = y;
            return this;
        }

        /**
         * Set the vector component-wise.
         * @param {number} x
         * @param {number} y
         * @return {org.jbox2d.common.Vec2}
         */
        public set(x? : any, y? : any) : any {
            if(((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return <any>this.set$float$float(x, y);
            } else if(((x != null && x instanceof <any>org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                return <any>this.set$org_jbox2d_common_Vec2(x);
            } else throw new Error('invalid overload');
        }

        public set$org_jbox2d_common_Vec2(v : Vec2) : Vec2 {
            this.x = v.x;
            this.y = v.y;
            return this;
        }

        /**
         * Return the sum of this vector and another; does not alter either one.
         * @param {org.jbox2d.common.Vec2} v
         * @return {org.jbox2d.common.Vec2}
         */
        public add(v : Vec2) : Vec2 {
            return new Vec2((<any>Math).fround(this.x + v.x), (<any>Math).fround(this.y + v.y));
        }

        /**
         * Return the difference of this vector and another; does not alter either one.
         * @param {org.jbox2d.common.Vec2} v
         * @return {org.jbox2d.common.Vec2}
         */
        public sub(v : Vec2) : Vec2 {
            return new Vec2((<any>Math).fround(this.x - v.x), (<any>Math).fround(this.y - v.y));
        }

        /**
         * Return this vector multiplied by a scalar; does not alter this vector.
         * @param {number} a
         * @return {org.jbox2d.common.Vec2}
         */
        public mul(a : number) : Vec2 {
            return new Vec2((<any>Math).fround(this.x * a), (<any>Math).fround(this.y * a));
        }

        /**
         * Return the negation of this vector; does not alter this vector.
         * @return {org.jbox2d.common.Vec2}
         */
        public negate() : Vec2 {
            return new Vec2(-this.x, -this.y);
        }

        /**
         * Flip the vector and return it - alters this vector.
         * @return {org.jbox2d.common.Vec2}
         */
        public negateLocal() : Vec2 {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        }

        public addLocal$org_jbox2d_common_Vec2(v : Vec2) : Vec2 {
            this.x += v.x;
            this.y += v.y;
            return this;
        }

        public addLocal$float$float(x : number, y : number) : Vec2 {
            this.x += x;
            this.y += y;
            return this;
        }

        /**
         * Adds values to this vector and returns result - alters this vector.
         * @param {number} x
         * @param {number} y
         * @return {org.jbox2d.common.Vec2}
         */
        public addLocal(x? : any, y? : any) : any {
            if(((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return <any>this.addLocal$float$float(x, y);
            } else if(((x != null && x instanceof <any>org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                return <any>this.addLocal$org_jbox2d_common_Vec2(x);
            } else throw new Error('invalid overload');
        }

        /**
         * Subtract another vector from this one and return result - alters this vector.
         * @param {org.jbox2d.common.Vec2} v
         * @return {org.jbox2d.common.Vec2}
         */
        public subLocal(v : Vec2) : Vec2 {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        }

        /**
         * Multiply this vector by a number and return result - alters this vector.
         * @param {number} a
         * @return {org.jbox2d.common.Vec2}
         */
        public mulLocal(a : number) : Vec2 {
            this.x *= a;
            this.y *= a;
            return this;
        }

        public skew$() : Vec2 {
            return new Vec2(-this.y, this.x);
        }

        public skew$org_jbox2d_common_Vec2(out : Vec2) {
            out.x = -this.y;
            out.y = this.x;
        }

        /**
         * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
         * @param {org.jbox2d.common.Vec2} out
         */
        public skew(out? : any) : any {
            if(((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>this.skew$org_jbox2d_common_Vec2(out);
            } else if(out === undefined) {
                return <any>this.skew$();
            } else throw new Error('invalid overload');
        }

        /**
         * Return the length of this vector.
         * @return {number}
         */
        public length() : number {
            return org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(this.x * this.x) + (<any>Math).fround(this.y * this.y)));
        }

        /**
         * Return the squared length of this vector.
         * @return {number}
         */
        public lengthSquared() : number {
            return ((<any>Math).fround((<any>Math).fround(this.x * this.x) + (<any>Math).fround(this.y * this.y)));
        }

        /**
         * Normalize this vector and return the length before normalization. Alters this vector.
         * @return {number}
         */
        public normalize() : number {
            let length : number = this.length();
            if(length < org.jbox2d.common.Settings.EPSILON) {
                return 0.0;
            }
            let invLength : number = (<any>Math).fround(1.0 / length);
            this.x *= invLength;
            this.y *= invLength;
            return length;
        }

        /**
         * True if the vector represents a pair of valid, non-infinite floating point numbers.
         * @return {boolean}
         */
        public isValid() : boolean {
            return !/* isNaN */isNaN(this.x) && !/* isInfinite */((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(this.x) && !/* isNaN */isNaN(this.y) && !/* isInfinite */((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(this.y);
        }

        /**
         * Return a new vector that has positive components.
         * @return {org.jbox2d.common.Vec2}
         */
        public abs() : Vec2 {
            return new Vec2(org.jbox2d.common.MathUtils.abs$float(this.x), org.jbox2d.common.MathUtils.abs$float(this.y));
        }

        public absLocal() {
            this.x = org.jbox2d.common.MathUtils.abs$float(this.x);
            this.y = org.jbox2d.common.MathUtils.abs$float(this.y);
        }

        /**
         * Return a copy of this vector.
         * @return {org.jbox2d.common.Vec2}
         */
        public clone() : Vec2 {
            return new Vec2(this.x, this.y);
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            return "(" + this.x + "," + this.y + ")";
        }

        public static abs(a : Vec2) : Vec2 {
            return new Vec2(org.jbox2d.common.MathUtils.abs$float(a.x), org.jbox2d.common.MathUtils.abs$float(a.y));
        }

        public static absToOut(a : Vec2, out : Vec2) {
            out.x = org.jbox2d.common.MathUtils.abs$float(a.x);
            out.y = org.jbox2d.common.MathUtils.abs$float(a.y);
        }

        public static dot(a : Vec2, b : Vec2) : number {
            return (<any>Math).fround((<any>Math).fround(a.x * b.x) + (<any>Math).fround(a.y * b.y));
        }

        public static cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a : Vec2, b : Vec2) : number {
            return (<any>Math).fround((<any>Math).fround(a.x * b.y) - (<any>Math).fround(a.y * b.x));
        }

        public static cross(a? : any, b? : any) : any {
            if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && ((b != null && b instanceof <any>org.jbox2d.common.Vec2) || b === null)) {
                return <any>org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, b);
            } else if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && ((typeof b === 'number') || b === null)) {
                return <any>org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(a, b);
            } else if(((typeof a === 'number') || a === null) && ((b != null && b instanceof <any>org.jbox2d.common.Vec2) || b === null)) {
                return <any>org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(a, b);
            } else throw new Error('invalid overload');
        }

        public static cross$org_jbox2d_common_Vec2$float(a : Vec2, s : number) : Vec2 {
            return new Vec2((<any>Math).fround(s * a.y), (<any>Math).fround(-s * a.x));
        }

        public static crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(a : Vec2, s : number, out : Vec2) {
            let tempy : number = (<any>Math).fround(-s * a.x);
            out.x = (<any>Math).fround(s * a.y);
            out.y = tempy;
        }

        public static crossToOut(a? : any, s? : any, out? : any) : any {
            if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && ((typeof s === 'number') || s === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Vec2.crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(a, s, out);
            } else if(((typeof a === 'number') || a === null) && ((s != null && s instanceof <any>org.jbox2d.common.Vec2) || s === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, s, out);
            } else throw new Error('invalid overload');
        }

        public static crossToOutUnsafe$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(a : Vec2, s : number, out : Vec2) {
            out.x = (<any>Math).fround(s * a.y);
            out.y = (<any>Math).fround(-s * a.x);
        }

        public static crossToOutUnsafe(a? : any, s? : any, out? : any) : any {
            if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && ((typeof s === 'number') || s === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Vec2.crossToOutUnsafe$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(a, s, out);
            } else if(((typeof a === 'number') || a === null) && ((s != null && s instanceof <any>org.jbox2d.common.Vec2) || s === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, s, out);
            } else throw new Error('invalid overload');
        }

        public static cross$float$org_jbox2d_common_Vec2(s : number, a : Vec2) : Vec2 {
            return new Vec2((<any>Math).fround(-s * a.y), (<any>Math).fround(s * a.x));
        }

        public static crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(s : number, a : Vec2, out : Vec2) {
            let tempY : number = (<any>Math).fround(s * a.x);
            out.x = (<any>Math).fround(-s * a.y);
            out.y = tempY;
        }

        public static crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(s : number, a : Vec2, out : Vec2) {
            out.x = (<any>Math).fround(-s * a.y);
            out.y = (<any>Math).fround(s * a.x);
        }

        public static negateToOut(a : Vec2, out : Vec2) {
            out.x = -a.x;
            out.y = -a.y;
        }

        public static min(a : Vec2, b : Vec2) : Vec2 {
            return new Vec2(a.x < b.x?a.x:b.x, a.y < b.y?a.y:b.y);
        }

        public static max(a : Vec2, b : Vec2) : Vec2 {
            return new Vec2(a.x > b.x?a.x:b.x, a.y > b.y?a.y:b.y);
        }

        public static minToOut(a : Vec2, b : Vec2, out : Vec2) {
            out.x = a.x < b.x?a.x:b.x;
            out.y = a.y < b.y?a.y:b.y;
        }

        public static maxToOut(a : Vec2, b : Vec2, out : Vec2) {
            out.x = a.x > b.x?a.x:b.x;
            out.y = a.y > b.y?a.y:b.y;
        }

        /**
         * @see java.lang.Object#hashCode()
         * @return {number}
         */
        public hashCode() : number {
            let prime : number = 31;
            let result : number = 1;
            result = prime * result + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.x);
            result = prime * result + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.y);
            return result;
        }

        /**
         * @see java.lang.Object#equals(java.lang.Object)
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj : any) : boolean {
            if(this === obj) return true;
            if(obj == null) return false;
            if((<any>this.constructor) !== (<any>obj.constructor)) return false;
            let other : Vec2 = <Vec2>obj;
            if(/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.x) !== /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(other.x)) return false;
            if(/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.y) !== /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(other.y)) return false;
            return true;
        }
    }
    Vec2["__class"] = "org.jbox2d.common.Vec2";
    Vec2["__interfaces"] = ["java.io.Serializable"];


}
namespace org.jbox2d.common {
    /**
     * @author Daniel Murphy
     * @param {number} argX
     * @param {number} argY
     * @param {number} argZ
     * @class
     */
    export class Vec3 {
        static serialVersionUID : number = 1;

        public x : number;

        public y : number;

        public z : number;

        public constructor(argX? : any, argY? : any, argZ? : any) {
            if(((typeof argX === 'number') || argX === null) && ((typeof argY === 'number') || argY === null) && ((typeof argZ === 'number') || argZ === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                (() => {
                    this.x = argX;
                    this.y = argY;
                    this.z = argZ;
                })();
            } else if(((argX != null && argX instanceof <any>org.jbox2d.common.Vec3) || argX === null) && argY === undefined && argZ === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let copy : any = __args[0];
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                (() => {
                    this.x = copy.x;
                    this.y = copy.y;
                    this.z = copy.z;
                })();
            } else if(argX === undefined && argY === undefined && argZ === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                (() => {
                    this.x = this.y = this.z = 0.0;
                })();
            } else throw new Error('invalid overload');
        }

        public set$org_jbox2d_common_Vec3(vec : Vec3) : Vec3 {
            this.x = vec.x;
            this.y = vec.y;
            this.z = vec.z;
            return this;
        }

        public set$float$float$float(argX : number, argY : number, argZ : number) : Vec3 {
            this.x = argX;
            this.y = argY;
            this.z = argZ;
            return this;
        }

        public set(argX? : any, argY? : any, argZ? : any) : any {
            if(((typeof argX === 'number') || argX === null) && ((typeof argY === 'number') || argY === null) && ((typeof argZ === 'number') || argZ === null)) {
                return <any>this.set$float$float$float(argX, argY, argZ);
            } else if(((argX != null && argX instanceof <any>org.jbox2d.common.Vec3) || argX === null) && argY === undefined && argZ === undefined) {
                return <any>this.set$org_jbox2d_common_Vec3(argX);
            } else throw new Error('invalid overload');
        }

        public addLocal(argVec : Vec3) : Vec3 {
            this.x += argVec.x;
            this.y += argVec.y;
            this.z += argVec.z;
            return this;
        }

        public add(argVec : Vec3) : Vec3 {
            return new Vec3((<any>Math).fround(this.x + argVec.x), (<any>Math).fround(this.y + argVec.y), (<any>Math).fround(this.z + argVec.z));
        }

        public subLocal(argVec : Vec3) : Vec3 {
            this.x -= argVec.x;
            this.y -= argVec.y;
            this.z -= argVec.z;
            return this;
        }

        public sub(argVec : Vec3) : Vec3 {
            return new Vec3((<any>Math).fround(this.x - argVec.x), (<any>Math).fround(this.y - argVec.y), (<any>Math).fround(this.z - argVec.z));
        }

        public mulLocal(argScalar : number) : Vec3 {
            this.x *= argScalar;
            this.y *= argScalar;
            this.z *= argScalar;
            return this;
        }

        public mul(argScalar : number) : Vec3 {
            return new Vec3((<any>Math).fround(this.x * argScalar), (<any>Math).fround(this.y * argScalar), (<any>Math).fround(this.z * argScalar));
        }

        public negate() : Vec3 {
            return new Vec3(-this.x, -this.y, -this.z);
        }

        public negateLocal() : Vec3 {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        }

        public setZero() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }

        public clone() : Vec3 {
            return new Vec3(this);
        }

        public toString() : string {
            return "(" + this.x + "," + this.y + "," + this.z + ")";
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            let prime : number = 31;
            let result : number = 1;
            result = prime * result + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.x);
            result = prime * result + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.y);
            result = prime * result + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.z);
            return result;
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj : any) : boolean {
            if(this === obj) return true;
            if(obj == null) return false;
            if((<any>this.constructor) !== (<any>obj.constructor)) return false;
            let other : Vec3 = <Vec3>obj;
            if(/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.x) !== /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(other.x)) return false;
            if(/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.y) !== /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(other.y)) return false;
            if(/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.z) !== /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(other.z)) return false;
            return true;
        }

        public static dot(a : Vec3, b : Vec3) : number {
            return (<any>Math).fround((<any>Math).fround((<any>Math).fround(a.x * b.x) + (<any>Math).fround(a.y * b.y)) + (<any>Math).fround(a.z * b.z));
        }

        public static cross(a : Vec3, b : Vec3) : Vec3 {
            return new Vec3((<any>Math).fround((<any>Math).fround(a.y * b.z) - (<any>Math).fround(a.z * b.y)), (<any>Math).fround((<any>Math).fround(a.z * b.x) - (<any>Math).fround(a.x * b.z)), (<any>Math).fround((<any>Math).fround(a.x * b.y) - (<any>Math).fround(a.y * b.x)));
        }

        public static crossToOut(a : Vec3, b : Vec3, out : Vec3) {
            let tempy : number = (<any>Math).fround((<any>Math).fround(a.z * b.x) - (<any>Math).fround(a.x * b.z));
            let tempz : number = (<any>Math).fround((<any>Math).fround(a.x * b.y) - (<any>Math).fround(a.y * b.x));
            out.x = (<any>Math).fround((<any>Math).fround(a.y * b.z) - (<any>Math).fround(a.z * b.y));
            out.y = tempy;
            out.z = tempz;
        }

        public static crossToOutUnsafe(a : Vec3, b : Vec3, out : Vec3) {
            out.x = (<any>Math).fround((<any>Math).fround(a.y * b.z) - (<any>Math).fround(a.z * b.y));
            out.y = (<any>Math).fround((<any>Math).fround(a.z * b.x) - (<any>Math).fround(a.x * b.z));
            out.z = (<any>Math).fround((<any>Math).fround(a.x * b.y) - (<any>Math).fround(a.y * b.x));
        }
    }
    Vec3["__class"] = "org.jbox2d.common.Vec3";
    Vec3["__interfaces"] = ["java.io.Serializable"];


}
namespace org.jbox2d.dynamics {
    /**
     * A rigid body. These are created via World.createBody.
     * 
     * @author Daniel Murphy
     * @param {org.jbox2d.dynamics.BodyDef} bd
     * @param {org.jbox2d.dynamics.World} world
     * @class
     */
    export class Body {
        public static e_islandFlag : number = 1;

        public static e_awakeFlag : number = 2;

        public static e_autoSleepFlag : number = 4;

        public static e_bulletFlag : number = 8;

        public static e_fixedRotationFlag : number = 16;

        public static e_activeFlag : number = 32;

        public static e_toiFlag : number = 64;

        public m_type : org.jbox2d.dynamics.BodyType;

        public m_flags : number;

        public m_islandIndex : number;

        /**
         * The body origin transform.
         */
        public m_xf : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /**
         * The previous transform for particle simulation
         */
        public m_xf0 : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /**
         * The swept motion for CCD
         */
        public m_sweep : org.jbox2d.common.Sweep = new org.jbox2d.common.Sweep();

        public m_linearVelocity : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public m_angularVelocity : number = 0;

        public m_force : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public m_torque : number = 0;

        public m_world : org.jbox2d.dynamics.World;

        public m_prev : Body;

        public m_next : Body;

        public m_fixtureList : org.jbox2d.dynamics.Fixture;

        public m_fixtureCount : number;

        public m_jointList : org.jbox2d.dynamics.joints.JointEdge;

        public m_contactList : org.jbox2d.dynamics.contacts.ContactEdge;

        public m_mass : number;

        public m_invMass : number;

        public m_I : number;

        public m_invI : number;

        public m_linearDamping : number;

        public m_angularDamping : number;

        public m_gravityScale : number;

        public m_sleepTime : number;

        public m_userData : any;

        public constructor(bd : org.jbox2d.dynamics.BodyDef, world : org.jbox2d.dynamics.World) {
            if(this.m_type===undefined) this.m_type = null;
            if(this.m_flags===undefined) this.m_flags = 0;
            if(this.m_islandIndex===undefined) this.m_islandIndex = 0;
            if(this.m_world===undefined) this.m_world = null;
            if(this.m_prev===undefined) this.m_prev = null;
            if(this.m_next===undefined) this.m_next = null;
            if(this.m_fixtureList===undefined) this.m_fixtureList = null;
            if(this.m_fixtureCount===undefined) this.m_fixtureCount = 0;
            if(this.m_jointList===undefined) this.m_jointList = null;
            if(this.m_contactList===undefined) this.m_contactList = null;
            if(this.m_mass===undefined) this.m_mass = 0;
            if(this.m_invMass===undefined) this.m_invMass = 0;
            if(this.m_I===undefined) this.m_I = 0;
            if(this.m_invI===undefined) this.m_invI = 0;
            if(this.m_linearDamping===undefined) this.m_linearDamping = 0;
            if(this.m_angularDamping===undefined) this.m_angularDamping = 0;
            if(this.m_gravityScale===undefined) this.m_gravityScale = 0;
            if(this.m_sleepTime===undefined) this.m_sleepTime = 0;
            if(this.m_userData===undefined) this.m_userData = null;
            this.m_flags = 0;
            if(bd.bullet) {
                this.m_flags |= Body.e_bulletFlag;
            }
            if(bd.fixedRotation) {
                this.m_flags |= Body.e_fixedRotationFlag;
            }
            if(bd.allowSleep) {
                this.m_flags |= Body.e_autoSleepFlag;
            }
            if(bd.awake) {
                this.m_flags |= Body.e_awakeFlag;
            }
            if(bd.active) {
                this.m_flags |= Body.e_activeFlag;
            }
            this.m_world = world;
            this.m_xf.p.set$org_jbox2d_common_Vec2(bd.position);
            this.m_xf.q.set$float(bd.angle);
            this.m_sweep.localCenter.setZero();
            this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_xf.p);
            this.m_sweep.c.set$org_jbox2d_common_Vec2(this.m_xf.p);
            this.m_sweep.a0 = bd.angle;
            this.m_sweep.a = bd.angle;
            this.m_sweep.alpha0 = 0.0;
            this.m_jointList = null;
            this.m_contactList = null;
            this.m_prev = null;
            this.m_next = null;
            this.m_linearVelocity.set$org_jbox2d_common_Vec2(bd.linearVelocity);
            this.m_angularVelocity = bd.angularVelocity;
            this.m_linearDamping = bd.linearDamping;
            this.m_angularDamping = bd.angularDamping;
            this.m_gravityScale = bd.gravityScale;
            this.m_force.setZero();
            this.m_torque = 0.0;
            this.m_sleepTime = 0.0;
            this.m_type = bd.type;
            if(this.m_type === org.jbox2d.dynamics.BodyType.DYNAMIC) {
                this.m_mass = 1.0;
                this.m_invMass = 1.0;
            } else {
                this.m_mass = 0.0;
                this.m_invMass = 0.0;
            }
            this.m_I = 0.0;
            this.m_invI = 0.0;
            this.m_userData = bd.userData;
            this.m_fixtureList = null;
            this.m_fixtureCount = 0;
        }

        public createFixture$org_jbox2d_dynamics_FixtureDef(def : org.jbox2d.dynamics.FixtureDef) : org.jbox2d.dynamics.Fixture {
            if(this.m_world.isLocked() === true) {
                return null;
            }
            let fixture : org.jbox2d.dynamics.Fixture = new org.jbox2d.dynamics.Fixture();
            fixture.create(this, def);
            if((this.m_flags & Body.e_activeFlag) === Body.e_activeFlag) {
                let broadPhase : org.jbox2d.collision.broadphase.BroadPhase = this.m_world.m_contactManager.m_broadPhase;
                fixture.createProxies(broadPhase, this.m_xf);
            }
            fixture.m_next = this.m_fixtureList;
            this.m_fixtureList = fixture;
            ++this.m_fixtureCount;
            fixture.m_body = this;
            if(fixture.m_density > 0.0) {
                this.resetMassData();
            }
            this.m_world.m_flags |= org.jbox2d.dynamics.World.NEW_FIXTURE;
            return fixture;
        }

        /*private*/ fixDef : org.jbox2d.dynamics.FixtureDef = new org.jbox2d.dynamics.FixtureDef();

        public createFixture$org_jbox2d_collision_shapes_Shape$float(shape : org.jbox2d.collision.shapes.Shape, density : number) : org.jbox2d.dynamics.Fixture {
            this.fixDef.shape = shape;
            this.fixDef.density = density;
            return this.createFixture$org_jbox2d_dynamics_FixtureDef(this.fixDef);
        }

        /**
         * Creates a fixture from a shape and attach it to this body. This is a convenience function. Use
         * FixtureDef if you need to set parameters like friction, restitution, user data, or filtering.
         * If the density is non-zero, this function automatically updates the mass of the body.
         * 
         * @param {org.jbox2d.collision.shapes.Shape} shape the shape to be cloned.
         * @param {number} density the shape density (set to zero for static bodies).
         * @warning This function is locked during callbacks.
         * @return {org.jbox2d.dynamics.Fixture}
         */
        public createFixture(shape? : any, density? : any) : any {
            if(((shape != null && shape instanceof <any>org.jbox2d.collision.shapes.Shape) || shape === null) && ((typeof density === 'number') || density === null)) {
                return <any>this.createFixture$org_jbox2d_collision_shapes_Shape$float(shape, density);
            } else if(((shape != null && shape instanceof <any>org.jbox2d.dynamics.FixtureDef) || shape === null) && density === undefined) {
                return <any>this.createFixture$org_jbox2d_dynamics_FixtureDef(shape);
            } else throw new Error('invalid overload');
        }

        /**
         * Destroy a fixture. This removes the fixture from the broad-phase and destroys all contacts
         * associated with this fixture. This will automatically adjust the mass of the body if the body
         * is dynamic and the fixture has positive density. All fixtures attached to a body are implicitly
         * destroyed when the body is destroyed.
         * 
         * @param {org.jbox2d.dynamics.Fixture} fixture the fixture to be removed.
         * @warning This function is locked during callbacks.
         */
        public destroyFixture(fixture : org.jbox2d.dynamics.Fixture) {
            if(this.m_world.isLocked() === true) {
                return;
            }
            let node : org.jbox2d.dynamics.Fixture = this.m_fixtureList;
            let last : org.jbox2d.dynamics.Fixture = null;
            let found : boolean = false;
            while((node != null)) {
                if(node === fixture) {
                    node = fixture.m_next;
                    found = true;
                    break;
                }
                last = node;
                node = node.m_next;
            };
            if(last == null) {
                this.m_fixtureList = fixture.m_next;
            } else {
                last.m_next = fixture.m_next;
            }
            let edge : org.jbox2d.dynamics.contacts.ContactEdge = this.m_contactList;
            while((edge != null)) {
                let c : org.jbox2d.dynamics.contacts.Contact = edge.contact;
                edge = edge.next;
                let fixtureA : org.jbox2d.dynamics.Fixture = c.getFixtureA();
                let fixtureB : org.jbox2d.dynamics.Fixture = c.getFixtureB();
                if(fixture === fixtureA || fixture === fixtureB) {
                    this.m_world.m_contactManager.destroy(c);
                }
            };
            if((this.m_flags & Body.e_activeFlag) === Body.e_activeFlag) {
                let broadPhase : org.jbox2d.collision.broadphase.BroadPhase = this.m_world.m_contactManager.m_broadPhase;
                fixture.destroyProxies(broadPhase);
            }
            fixture.destroy();
            fixture.m_body = null;
            fixture.m_next = null;
            fixture = null;
            --this.m_fixtureCount;
            this.resetMassData();
        }

        /**
         * Set the position of the body's origin and rotation. This breaks any contacts and wakes the
         * other bodies. Manipulating a body's transform may cause non-physical behavior. Note: contacts
         * are updated on the next call to World.step().
         * 
         * @param {org.jbox2d.common.Vec2} position the world position of the body's local origin.
         * @param {number} angle the world rotation in radians.
         */
        public setTransform(position : org.jbox2d.common.Vec2, angle : number) {
            if(this.m_world.isLocked() === true) {
                return;
            }
            this.m_xf.q.set$float(angle);
            this.m_xf.p.set$org_jbox2d_common_Vec2(position);
            org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
            this.m_sweep.a = angle;
            this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
            this.m_sweep.a0 = this.m_sweep.a;
            let broadPhase : org.jbox2d.collision.broadphase.BroadPhase = this.m_world.m_contactManager.m_broadPhase;
            for(let f : org.jbox2d.dynamics.Fixture = this.m_fixtureList; f != null; f = f.m_next) {
                f.synchronize(broadPhase, this.m_xf, this.m_xf);
            };
        }

        /**
         * Get the body transform for the body's origin.
         * 
         * @return {org.jbox2d.common.Transform} the world transform of the body's origin.
         */
        public getTransform() : org.jbox2d.common.Transform {
            return this.m_xf;
        }

        /**
         * Get the world body origin position. Do not modify.
         * 
         * @return {org.jbox2d.common.Vec2} the world position of the body's origin.
         */
        public getPosition() : org.jbox2d.common.Vec2 {
            return this.m_xf.p;
        }

        /**
         * Get the angle in radians.
         * 
         * @return {number} the current world rotation angle in radians.
         */
        public getAngle() : number {
            return this.m_sweep.a;
        }

        /**
         * Get the world position of the center of mass. Do not modify.
         * @return {org.jbox2d.common.Vec2}
         */
        public getWorldCenter() : org.jbox2d.common.Vec2 {
            return this.m_sweep.c;
        }

        /**
         * Get the local position of the center of mass. Do not modify.
         * @return {org.jbox2d.common.Vec2}
         */
        public getLocalCenter() : org.jbox2d.common.Vec2 {
            return this.m_sweep.localCenter;
        }

        /**
         * Set the linear velocity of the center of mass.
         * 
         * @param {org.jbox2d.common.Vec2} v the new linear velocity of the center of mass.
         */
        public setLinearVelocity(v : org.jbox2d.common.Vec2) {
            if(this.m_type === org.jbox2d.dynamics.BodyType.STATIC) {
                return;
            }
            if(org.jbox2d.common.Vec2.dot(v, v) > 0.0) {
                this.setAwake(true);
            }
            this.m_linearVelocity.set$org_jbox2d_common_Vec2(v);
        }

        /**
         * Get the linear velocity of the center of mass. Do not modify, instead use
         * {@link #setLinearVelocity(Vec2)}.
         * 
         * @return {org.jbox2d.common.Vec2} the linear velocity of the center of mass.
         */
        public getLinearVelocity() : org.jbox2d.common.Vec2 {
            return this.m_linearVelocity;
        }

        /**
         * Set the angular velocity.
         * 
         * @param omega the new angular velocity in radians/second.
         * @param {number} w
         */
        public setAngularVelocity(w : number) {
            if(this.m_type === org.jbox2d.dynamics.BodyType.STATIC) {
                return;
            }
            if((<any>Math).fround(w * w) > 0.0) {
                this.setAwake(true);
            }
            this.m_angularVelocity = w;
        }

        /**
         * Get the angular velocity.
         * 
         * @return {number} the angular velocity in radians/second.
         */
        public getAngularVelocity() : number {
            return this.m_angularVelocity;
        }

        /**
         * Get the gravity scale of the body.
         * 
         * @return
         * @return {number}
         */
        public getGravityScale() : number {
            return this.m_gravityScale;
        }

        /**
         * Set the gravity scale of the body.
         * 
         * @param {number} gravityScale
         */
        public setGravityScale(gravityScale : number) {
            this.m_gravityScale = gravityScale;
        }

        /**
         * Apply a force at a world point. If the force is not applied at the center of mass, it will
         * generate a torque and affect the angular velocity. This wakes up the body.
         * 
         * @param {org.jbox2d.common.Vec2} force the world force vector, usually in Newtons (N).
         * @param {org.jbox2d.common.Vec2} point the world position of the point of application.
         */
        public applyForce(force : org.jbox2d.common.Vec2, point : org.jbox2d.common.Vec2) {
            if(this.m_type !== org.jbox2d.dynamics.BodyType.DYNAMIC) {
                return;
            }
            if(this.isAwake() === false) {
                this.setAwake(true);
            }
            this.m_force.x += force.x;
            this.m_force.y += force.y;
            this.m_torque += (<any>Math).fround((<any>Math).fround(((<any>Math).fround(point.x - this.m_sweep.c.x)) * force.y) - (<any>Math).fround(((<any>Math).fround(point.y - this.m_sweep.c.y)) * force.x));
        }

        /**
         * Apply a force to the center of mass. This wakes up the body.
         * 
         * @param {org.jbox2d.common.Vec2} force the world force vector, usually in Newtons (N).
         */
        public applyForceToCenter(force : org.jbox2d.common.Vec2) {
            if(this.m_type !== org.jbox2d.dynamics.BodyType.DYNAMIC) {
                return;
            }
            if(this.isAwake() === false) {
                this.setAwake(true);
            }
            this.m_force.x += force.x;
            this.m_force.y += force.y;
        }

        /**
         * Apply a torque. This affects the angular velocity without affecting the linear velocity of the
         * center of mass. This wakes up the body.
         * 
         * @param {number} torque about the z-axis (out of the screen), usually in N-m.
         */
        public applyTorque(torque : number) {
            if(this.m_type !== org.jbox2d.dynamics.BodyType.DYNAMIC) {
                return;
            }
            if(this.isAwake() === false) {
                this.setAwake(true);
            }
            this.m_torque += torque;
        }

        /**
         * Apply an impulse at a point. This immediately modifies the velocity. It also modifies the
         * angular velocity if the point of application is not at the center of mass. This wakes up the
         * body if 'wake' is set to true. If the body is sleeping and 'wake' is false, then there is no
         * effect.
         * 
         * @param {org.jbox2d.common.Vec2} impulse the world impulse vector, usually in N-seconds or kg-m/s.
         * @param {org.jbox2d.common.Vec2} point the world position of the point of application.
         * @param {boolean} wake also wake up the body
         */
        public applyLinearImpulse(impulse : org.jbox2d.common.Vec2, point : org.jbox2d.common.Vec2, wake : boolean) {
            if(this.m_type !== org.jbox2d.dynamics.BodyType.DYNAMIC) {
                return;
            }
            if(!this.isAwake()) {
                if(wake) {
                    this.setAwake(true);
                } else {
                    return;
                }
            }
            this.m_linearVelocity.x += (<any>Math).fround(impulse.x * this.m_invMass);
            this.m_linearVelocity.y += (<any>Math).fround(impulse.y * this.m_invMass);
            this.m_angularVelocity += (<any>Math).fround(this.m_invI * ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(point.x - this.m_sweep.c.x)) * impulse.y) - (<any>Math).fround(((<any>Math).fround(point.y - this.m_sweep.c.y)) * impulse.x))));
        }

        /**
         * Apply an angular impulse.
         * 
         * @param {number} impulse the angular impulse in units of kg*m*m/s
         */
        public applyAngularImpulse(impulse : number) {
            if(this.m_type !== org.jbox2d.dynamics.BodyType.DYNAMIC) {
                return;
            }
            if(this.isAwake() === false) {
                this.setAwake(true);
            }
            this.m_angularVelocity += (<any>Math).fround(this.m_invI * impulse);
        }

        /**
         * Get the total mass of the body.
         * 
         * @return {number} the mass, usually in kilograms (kg).
         */
        public getMass() : number {
            return this.m_mass;
        }

        /**
         * Get the central rotational inertia of the body.
         * 
         * @return {number} the rotational inertia, usually in kg-m^2.
         */
        public getInertia() : number {
            return (<any>Math).fround(this.m_I + (<any>Math).fround(this.m_mass * ((<any>Math).fround((<any>Math).fround(this.m_sweep.localCenter.x * this.m_sweep.localCenter.x) + (<any>Math).fround(this.m_sweep.localCenter.y * this.m_sweep.localCenter.y)))));
        }

        /**
         * Get the mass data of the body. The rotational inertia is relative to the center of mass.
         * 
         * @return {void} a struct containing the mass, inertia and center of the body.
         * @param {org.jbox2d.collision.shapes.MassData} data
         */
        public getMassData(data : org.jbox2d.collision.shapes.MassData) {
            data.mass = this.m_mass;
            data.I = (<any>Math).fround(this.m_I + (<any>Math).fround(this.m_mass * ((<any>Math).fround((<any>Math).fround(this.m_sweep.localCenter.x * this.m_sweep.localCenter.x) + (<any>Math).fround(this.m_sweep.localCenter.y * this.m_sweep.localCenter.y)))));
            data.center.x = this.m_sweep.localCenter.x;
            data.center.y = this.m_sweep.localCenter.y;
        }

        /**
         * Set the mass properties to override the mass properties of the fixtures. Note that this changes
         * the center of mass position. Note that creating or destroying fixtures can also alter the mass.
         * This function has no effect if the body isn't dynamic.
         * 
         * @param {org.jbox2d.collision.shapes.MassData} massData the mass properties.
         */
        public setMassData(massData : org.jbox2d.collision.shapes.MassData) {
            if(this.m_world.isLocked() === true) {
                return;
            }
            if(this.m_type !== org.jbox2d.dynamics.BodyType.DYNAMIC) {
                return;
            }
            this.m_invMass = 0.0;
            this.m_I = 0.0;
            this.m_invI = 0.0;
            this.m_mass = massData.mass;
            if(this.m_mass <= 0.0) {
                this.m_mass = 1.0;
            }
            this.m_invMass = (<any>Math).fround(1.0 / this.m_mass);
            if(massData.I > 0.0 && (this.m_flags & Body.e_fixedRotationFlag) === 0) {
                this.m_I = (<any>Math).fround(massData.I - (<any>Math).fround(this.m_mass * org.jbox2d.common.Vec2.dot(massData.center, massData.center)));
                this.m_invI = (<any>Math).fround(1.0 / this.m_I);
            }
            let oldCenter : org.jbox2d.common.Vec2 = this.m_world.getPool().popVec2();
            oldCenter.set$org_jbox2d_common_Vec2(this.m_sweep.c);
            this.m_sweep.localCenter.set$org_jbox2d_common_Vec2(massData.center);
            org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c0);
            this.m_sweep.c.set$org_jbox2d_common_Vec2(this.m_sweep.c0);
            let temp : org.jbox2d.common.Vec2 = this.m_world.getPool().popVec2();
            temp.set$org_jbox2d_common_Vec2(this.m_sweep.c).subLocal(oldCenter);
            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_angularVelocity, temp, temp);
            this.m_linearVelocity.addLocal$org_jbox2d_common_Vec2(temp);
            this.m_world.getPool().pushVec2(2);
        }

        /*private*/ pmd : org.jbox2d.collision.shapes.MassData = new org.jbox2d.collision.shapes.MassData();

        /**
         * This resets the mass properties to the sum of the mass properties of the fixtures. This
         * normally does not need to be called unless you called setMassData to override the mass and you
         * later want to reset the mass.
         */
        public resetMassData() {
            this.m_mass = 0.0;
            this.m_invMass = 0.0;
            this.m_I = 0.0;
            this.m_invI = 0.0;
            this.m_sweep.localCenter.setZero();
            if(this.m_type === org.jbox2d.dynamics.BodyType.STATIC || this.m_type === org.jbox2d.dynamics.BodyType.KINEMATIC) {
                this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_xf.p);
                this.m_sweep.c.set$org_jbox2d_common_Vec2(this.m_xf.p);
                this.m_sweep.a0 = this.m_sweep.a;
                return;
            }
            let localCenter : org.jbox2d.common.Vec2 = this.m_world.getPool().popVec2();
            localCenter.setZero();
            let temp : org.jbox2d.common.Vec2 = this.m_world.getPool().popVec2();
            let massData : org.jbox2d.collision.shapes.MassData = this.pmd;
            for(let f : org.jbox2d.dynamics.Fixture = this.m_fixtureList; f != null; f = f.m_next) {
                if(f.m_density === 0.0) {
                    continue;
                }
                f.getMassData(massData);
                this.m_mass += massData.mass;
                temp.set$org_jbox2d_common_Vec2(massData.center).mulLocal(massData.mass);
                localCenter.addLocal$org_jbox2d_common_Vec2(temp);
                this.m_I += massData.I;
            };
            if(this.m_mass > 0.0) {
                this.m_invMass = (<any>Math).fround(1.0 / this.m_mass);
                localCenter.mulLocal(this.m_invMass);
            } else {
                this.m_mass = 1.0;
                this.m_invMass = 1.0;
            }
            if(this.m_I > 0.0 && (this.m_flags & Body.e_fixedRotationFlag) === 0) {
                this.m_I -= (<any>Math).fround(this.m_mass * org.jbox2d.common.Vec2.dot(localCenter, localCenter));
                this.m_invI = (<any>Math).fround(1.0 / this.m_I);
            } else {
                this.m_I = 0.0;
                this.m_invI = 0.0;
            }
            let oldCenter : org.jbox2d.common.Vec2 = this.m_world.getPool().popVec2();
            oldCenter.set$org_jbox2d_common_Vec2(this.m_sweep.c);
            this.m_sweep.localCenter.set$org_jbox2d_common_Vec2(localCenter);
            org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c0);
            this.m_sweep.c.set$org_jbox2d_common_Vec2(this.m_sweep.c0);
            temp.set$org_jbox2d_common_Vec2(this.m_sweep.c).subLocal(oldCenter);
            let temp2 : org.jbox2d.common.Vec2 = oldCenter;
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_angularVelocity, temp, temp2);
            this.m_linearVelocity.addLocal$org_jbox2d_common_Vec2(temp2);
            this.m_world.getPool().pushVec2(3);
        }

        /**
         * Get the world coordinates of a point given the local coordinates.
         * 
         * @param {org.jbox2d.common.Vec2} localPoint a point on the body measured relative the the body's origin.
         * @return {org.jbox2d.common.Vec2} the same point expressed in world coordinates.
         */
        public getWorldPoint(localPoint : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let v : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.getWorldPointToOut(localPoint, v);
            return v;
        }

        public getWorldPointToOut(localPoint : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf, localPoint, out);
        }

        /**
         * Get the world coordinates of a vector given the local coordinates.
         * 
         * @param {org.jbox2d.common.Vec2} localVector a vector fixed in the body.
         * @return {org.jbox2d.common.Vec2} the same vector expressed in world coordinates.
         */
        public getWorldVector(localVector : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let out : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.getWorldVectorToOut(localVector, out);
            return out;
        }

        public getWorldVectorToOut(localVector : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.Rot.mulToOut(this.m_xf.q, localVector, out);
        }

        public getWorldVectorToOutUnsafe(localVector : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.Rot.mulToOutUnsafe(this.m_xf.q, localVector, out);
        }

        /**
         * Gets a local point relative to the body's origin given a world point.
         * 
         * @param a point in world coordinates.
         * @return {org.jbox2d.common.Vec2} the corresponding local point relative to the body's origin.
         * @param {org.jbox2d.common.Vec2} worldPoint
         */
        public getLocalPoint(worldPoint : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let out : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.getLocalPointToOut(worldPoint, out);
            return out;
        }

        public getLocalPointToOut(worldPoint : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.Transform.mulTransToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf, worldPoint, out);
        }

        /**
         * Gets a local vector given a world vector.
         * 
         * @param a vector in world coordinates.
         * @return {org.jbox2d.common.Vec2} the corresponding local vector.
         * @param {org.jbox2d.common.Vec2} worldVector
         */
        public getLocalVector(worldVector : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let out : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.getLocalVectorToOut(worldVector, out);
            return out;
        }

        public getLocalVectorToOut(worldVector : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.Rot.mulTrans$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf.q, worldVector, out);
        }

        public getLocalVectorToOutUnsafe(worldVector : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf.q, worldVector, out);
        }

        /**
         * Get the world linear velocity of a world point attached to this body.
         * 
         * @param a point in world coordinates.
         * @return {org.jbox2d.common.Vec2} the world velocity of a point.
         * @param {org.jbox2d.common.Vec2} worldPoint
         */
        public getLinearVelocityFromWorldPoint(worldPoint : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let out : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.getLinearVelocityFromWorldPointToOut(worldPoint, out);
            return out;
        }

        public getLinearVelocityFromWorldPointToOut(worldPoint : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempX : number = (<any>Math).fround(worldPoint.x - this.m_sweep.c.x);
            let tempY : number = (<any>Math).fround(worldPoint.y - this.m_sweep.c.y);
            out.x = (<any>Math).fround((<any>Math).fround(-this.m_angularVelocity * tempY) + this.m_linearVelocity.x);
            out.y = (<any>Math).fround((<any>Math).fround(this.m_angularVelocity * tempX) + this.m_linearVelocity.y);
        }

        /**
         * Get the world velocity of a local point.
         * 
         * @param a point in local coordinates.
         * @return {org.jbox2d.common.Vec2} the world velocity of a point.
         * @param {org.jbox2d.common.Vec2} localPoint
         */
        public getLinearVelocityFromLocalPoint(localPoint : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let out : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.getLinearVelocityFromLocalPointToOut(localPoint, out);
            return out;
        }

        public getLinearVelocityFromLocalPointToOut(localPoint : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            this.getWorldPointToOut(localPoint, out);
            this.getLinearVelocityFromWorldPointToOut(out, out);
        }

        /**
         * Get the linear damping of the body.
         * @return {number}
         */
        public getLinearDamping() : number {
            return this.m_linearDamping;
        }

        /**
         * Set the linear damping of the body.
         * @param {number} linearDamping
         */
        public setLinearDamping(linearDamping : number) {
            this.m_linearDamping = linearDamping;
        }

        /**
         * Get the angular damping of the body.
         * @return {number}
         */
        public getAngularDamping() : number {
            return this.m_angularDamping;
        }

        /**
         * Set the angular damping of the body.
         * @param {number} angularDamping
         */
        public setAngularDamping(angularDamping : number) {
            this.m_angularDamping = angularDamping;
        }

        public getType() : org.jbox2d.dynamics.BodyType {
            return this.m_type;
        }

        /**
         * Set the type of this body. This may alter the mass and velocity.
         * 
         * @param {org.jbox2d.dynamics.BodyType} type
         */
        public setType(type : org.jbox2d.dynamics.BodyType) {
            if(this.m_world.isLocked() === true) {
                return;
            }
            if(this.m_type === type) {
                return;
            }
            this.m_type = type;
            this.resetMassData();
            if(this.m_type === org.jbox2d.dynamics.BodyType.STATIC) {
                this.m_linearVelocity.setZero();
                this.m_angularVelocity = 0.0;
                this.m_sweep.a0 = this.m_sweep.a;
                this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
                this.synchronizeFixtures();
            }
            this.setAwake(true);
            this.m_force.setZero();
            this.m_torque = 0.0;
            let ce : org.jbox2d.dynamics.contacts.ContactEdge = this.m_contactList;
            while((ce != null)) {
                let ce0 : org.jbox2d.dynamics.contacts.ContactEdge = ce;
                ce = ce.next;
                this.m_world.m_contactManager.destroy(ce0.contact);
            };
            this.m_contactList = null;
            let broadPhase : org.jbox2d.collision.broadphase.BroadPhase = this.m_world.m_contactManager.m_broadPhase;
            for(let f : org.jbox2d.dynamics.Fixture = this.m_fixtureList; f != null; f = f.m_next) {
                let proxyCount : number = f.m_proxyCount;
                for(let i : number = 0; i < proxyCount; ++i) {
                    broadPhase.touchProxy(f.m_proxies[i].proxyId);
                };
            };
        }

        /**
         * Is this body treated like a bullet for continuous collision detection?
         * @return {boolean}
         */
        public isBullet() : boolean {
            return (this.m_flags & Body.e_bulletFlag) === Body.e_bulletFlag;
        }

        /**
         * Should this body be treated like a bullet for continuous collision detection?
         * @param {boolean} flag
         */
        public setBullet(flag : boolean) {
            if(flag) {
                this.m_flags |= Body.e_bulletFlag;
            } else {
                this.m_flags &= ~Body.e_bulletFlag;
            }
        }

        /**
         * You can disable sleeping on this body. If you disable sleeping, the body will be woken.
         * 
         * @param {boolean} flag
         */
        public setSleepingAllowed(flag : boolean) {
            if(flag) {
                this.m_flags |= Body.e_autoSleepFlag;
            } else {
                this.m_flags &= ~Body.e_autoSleepFlag;
                this.setAwake(true);
            }
        }

        /**
         * Is this body allowed to sleep
         * 
         * @return
         * @return {boolean}
         */
        public isSleepingAllowed() : boolean {
            return (this.m_flags & Body.e_autoSleepFlag) === Body.e_autoSleepFlag;
        }

        /**
         * Set the sleep state of the body. A sleeping body has very low CPU cost.
         * 
         * @param {boolean} flag set to true to put body to sleep, false to wake it.
         * @param {boolean} flag
         */
        public setAwake(flag : boolean) {
            if(flag) {
                if((this.m_flags & Body.e_awakeFlag) === 0) {
                    this.m_flags |= Body.e_awakeFlag;
                    this.m_sleepTime = 0.0;
                }
            } else {
                this.m_flags &= ~Body.e_awakeFlag;
                this.m_sleepTime = 0.0;
                this.m_linearVelocity.setZero();
                this.m_angularVelocity = 0.0;
                this.m_force.setZero();
                this.m_torque = 0.0;
            }
        }

        /**
         * Get the sleeping state of this body.
         * 
         * @return {boolean} true if the body is awake.
         */
        public isAwake() : boolean {
            return (this.m_flags & Body.e_awakeFlag) === Body.e_awakeFlag;
        }

        /**
         * Set the active state of the body. An inactive body is not simulated and cannot be collided with
         * or woken up. If you pass a flag of true, all fixtures will be added to the broad-phase. If you
         * pass a flag of false, all fixtures will be removed from the broad-phase and all contacts will
         * be destroyed. Fixtures and joints are otherwise unaffected. You may continue to create/destroy
         * fixtures and joints on inactive bodies. Fixtures on an inactive body are implicitly inactive
         * and will not participate in collisions, ray-casts, or queries. Joints connected to an inactive
         * body are implicitly inactive. An inactive body is still owned by a World object and remains in
         * the body list.
         * 
         * @param {boolean} flag
         */
        public setActive(flag : boolean) {
            if(flag === this.isActive()) {
                return;
            }
            if(flag) {
                this.m_flags |= Body.e_activeFlag;
                let broadPhase : org.jbox2d.collision.broadphase.BroadPhase = this.m_world.m_contactManager.m_broadPhase;
                for(let f : org.jbox2d.dynamics.Fixture = this.m_fixtureList; f != null; f = f.m_next) {
                    f.createProxies(broadPhase, this.m_xf);
                };
            } else {
                this.m_flags &= ~Body.e_activeFlag;
                let broadPhase : org.jbox2d.collision.broadphase.BroadPhase = this.m_world.m_contactManager.m_broadPhase;
                for(let f : org.jbox2d.dynamics.Fixture = this.m_fixtureList; f != null; f = f.m_next) {
                    f.destroyProxies(broadPhase);
                };
                let ce : org.jbox2d.dynamics.contacts.ContactEdge = this.m_contactList;
                while((ce != null)) {
                    let ce0 : org.jbox2d.dynamics.contacts.ContactEdge = ce;
                    ce = ce.next;
                    this.m_world.m_contactManager.destroy(ce0.contact);
                };
                this.m_contactList = null;
            }
        }

        /**
         * Get the active state of the body.
         * 
         * @return
         * @return {boolean}
         */
        public isActive() : boolean {
            return (this.m_flags & Body.e_activeFlag) === Body.e_activeFlag;
        }

        /**
         * Set this body to have fixed rotation. This causes the mass to be reset.
         * 
         * @param {boolean} flag
         */
        public setFixedRotation(flag : boolean) {
            if(flag) {
                this.m_flags |= Body.e_fixedRotationFlag;
            } else {
                this.m_flags &= ~Body.e_fixedRotationFlag;
            }
            this.resetMassData();
        }

        /**
         * Does this body have fixed rotation?
         * 
         * @return
         * @return {boolean}
         */
        public isFixedRotation() : boolean {
            return (this.m_flags & Body.e_fixedRotationFlag) === Body.e_fixedRotationFlag;
        }

        /**
         * Get the list of all fixtures attached to this body.
         * @return {org.jbox2d.dynamics.Fixture}
         */
        public getFixtureList() : org.jbox2d.dynamics.Fixture {
            return this.m_fixtureList;
        }

        /**
         * Get the list of all joints attached to this body.
         * @return {org.jbox2d.dynamics.joints.JointEdge}
         */
        public getJointList() : org.jbox2d.dynamics.joints.JointEdge {
            return this.m_jointList;
        }

        /**
         * Get the list of all contacts attached to this body.
         * 
         * @warning this list changes during the time step and you may miss some collisions if you don't
         * use ContactListener.
         * @return {org.jbox2d.dynamics.contacts.ContactEdge}
         */
        public getContactList() : org.jbox2d.dynamics.contacts.ContactEdge {
            return this.m_contactList;
        }

        /**
         * Get the next body in the world's body list.
         * @return {org.jbox2d.dynamics.Body}
         */
        public getNext() : Body {
            return this.m_next;
        }

        /**
         * Get the user data pointer that was provided in the body definition.
         * @return {*}
         */
        public getUserData() : any {
            return this.m_userData;
        }

        /**
         * Set the user data. Use this to store your application specific data.
         * @param {*} data
         */
        public setUserData(data : any) {
            this.m_userData = data;
        }

        /**
         * Get the parent world of this body.
         * @return {org.jbox2d.dynamics.World}
         */
        public getWorld() : org.jbox2d.dynamics.World {
            return this.m_world;
        }

        /*private*/ pxf : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        synchronizeFixtures() {
            let xf1 : org.jbox2d.common.Transform = this.pxf;
            xf1.q.s = org.jbox2d.common.MathUtils.sin(this.m_sweep.a0);
            xf1.q.c = org.jbox2d.common.MathUtils.cos(this.m_sweep.a0);
            xf1.p.x = (<any>Math).fround((<any>Math).fround(this.m_sweep.c0.x - (<any>Math).fround(xf1.q.c * this.m_sweep.localCenter.x)) + (<any>Math).fround(xf1.q.s * this.m_sweep.localCenter.y));
            xf1.p.y = (<any>Math).fround((<any>Math).fround(this.m_sweep.c0.y - (<any>Math).fround(xf1.q.s * this.m_sweep.localCenter.x)) - (<any>Math).fround(xf1.q.c * this.m_sweep.localCenter.y));
            for(let f : org.jbox2d.dynamics.Fixture = this.m_fixtureList; f != null; f = f.m_next) {
                f.synchronize(this.m_world.m_contactManager.m_broadPhase, xf1, this.m_xf);
            };
        }

        public synchronizeTransform() {
            this.m_xf.q.s = org.jbox2d.common.MathUtils.sin(this.m_sweep.a);
            this.m_xf.q.c = org.jbox2d.common.MathUtils.cos(this.m_sweep.a);
            let q : org.jbox2d.common.Rot = this.m_xf.q;
            let v : org.jbox2d.common.Vec2 = this.m_sweep.localCenter;
            this.m_xf.p.x = (<any>Math).fround((<any>Math).fround(this.m_sweep.c.x - (<any>Math).fround(q.c * v.x)) + (<any>Math).fround(q.s * v.y));
            this.m_xf.p.y = (<any>Math).fround((<any>Math).fround(this.m_sweep.c.y - (<any>Math).fround(q.s * v.x)) - (<any>Math).fround(q.c * v.y));
        }

        /**
         * This is used to prevent connected bodies from colliding. It may lie, depending on the
         * collideConnected flag.
         * 
         * @param {org.jbox2d.dynamics.Body} other
         * @return
         * @return {boolean}
         */
        public shouldCollide(other : Body) : boolean {
            if(this.m_type !== org.jbox2d.dynamics.BodyType.DYNAMIC && other.m_type !== org.jbox2d.dynamics.BodyType.DYNAMIC) {
                return false;
            }
            for(let jn : org.jbox2d.dynamics.joints.JointEdge = this.m_jointList; jn != null; jn = jn.next) {
                if(jn.other === other) {
                    if(jn.joint.getCollideConnected() === false) {
                        return false;
                    }
                }
            };
            return true;
        }

        advance(t : number) {
            this.m_sweep.advance(t);
            this.m_sweep.c.set$org_jbox2d_common_Vec2(this.m_sweep.c0);
            this.m_sweep.a = this.m_sweep.a0;
            this.m_xf.q.set$float(this.m_sweep.a);
            org.jbox2d.common.Rot.mulToOutUnsafe(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
            this.m_xf.p.mulLocal(-1).addLocal$org_jbox2d_common_Vec2(this.m_sweep.c);
        }
    }
    Body["__class"] = "org.jbox2d.dynamics.Body";

}
namespace org.jbox2d.dynamics {
    /**
     * A body definition holds all the data needed to construct a rigid body. You can safely re-use body
     * definitions. Shapes are added to a body after construction.
     * 
     * @author daniel
     * @class
     */
    export class BodyDef {
        /**
         * The body type: static, kinematic, or dynamic. Note: if a dynamic body would have zero mass, the
         * mass is set to one.
         */
        public type : org.jbox2d.dynamics.BodyType;

        /**
         * Use this to store application specific body data.
         */
        public userData : any;

        /**
         * The world position of the body. Avoid creating bodies at the origin since this can lead to many
         * overlapping shapes.
         */
        public position : org.jbox2d.common.Vec2;

        /**
         * The world angle of the body in radians.
         */
        public angle : number;

        /**
         * The linear velocity of the body in world co-ordinates.
         */
        public linearVelocity : org.jbox2d.common.Vec2;

        /**
         * The angular velocity of the body.
         */
        public angularVelocity : number;

        /**
         * Linear damping is use to reduce the linear velocity. The damping parameter can be larger than
         * 1.0f but the damping effect becomes sensitive to the time step when the damping parameter is
         * large.
         */
        public linearDamping : number;

        /**
         * Angular damping is use to reduce the angular velocity. The damping parameter can be larger than
         * 1.0f but the damping effect becomes sensitive to the time step when the damping parameter is
         * large.
         */
        public angularDamping : number;

        /**
         * Set this flag to false if this body should never fall asleep. Note that this increases CPU
         * usage.
         */
        public allowSleep : boolean;

        /**
         * Is this body initially sleeping?
         */
        public awake : boolean;

        /**
         * Should this body be prevented from rotating? Useful for characters.
         */
        public fixedRotation : boolean;

        /**
         * Is this a fast moving body that should be prevented from tunneling through other moving bodies?
         * Note that all bodies are prevented from tunneling through kinematic and static bodies. This
         * setting is only considered on dynamic bodies.
         * 
         * @warning You should use this flag sparingly since it increases processing time.
         */
        public bullet : boolean;

        /**
         * Does this body start out active?
         */
        public active : boolean;

        /**
         * Experimental: scales the inertia tensor.
         */
        public gravityScale : number;

        public constructor() {
            if(this.type===undefined) this.type = null;
            if(this.userData===undefined) this.userData = null;
            if(this.position===undefined) this.position = null;
            if(this.angle===undefined) this.angle = 0;
            if(this.linearVelocity===undefined) this.linearVelocity = null;
            if(this.angularVelocity===undefined) this.angularVelocity = 0;
            if(this.linearDamping===undefined) this.linearDamping = 0;
            if(this.angularDamping===undefined) this.angularDamping = 0;
            if(this.allowSleep===undefined) this.allowSleep = false;
            if(this.awake===undefined) this.awake = false;
            if(this.fixedRotation===undefined) this.fixedRotation = false;
            if(this.bullet===undefined) this.bullet = false;
            if(this.active===undefined) this.active = false;
            if(this.gravityScale===undefined) this.gravityScale = 0;
            this.userData = null;
            this.position = new org.jbox2d.common.Vec2();
            this.angle = 0.0;
            this.linearVelocity = new org.jbox2d.common.Vec2();
            this.angularVelocity = 0.0;
            this.linearDamping = 0.0;
            this.angularDamping = 0.0;
            this.allowSleep = true;
            this.awake = true;
            this.fixedRotation = false;
            this.bullet = false;
            this.type = org.jbox2d.dynamics.BodyType.STATIC;
            this.active = true;
            this.gravityScale = 1.0;
        }

        /**
         * The body type: static, kinematic, or dynamic. Note: if a dynamic body would have zero mass, the
         * mass is set to one.
         * @return {org.jbox2d.dynamics.BodyType}
         */
        public getType() : org.jbox2d.dynamics.BodyType {
            return this.type;
        }

        /**
         * The body type: static, kinematic, or dynamic. Note: if a dynamic body would have zero mass, the
         * mass is set to one.
         * @param {org.jbox2d.dynamics.BodyType} type
         */
        public setType(type : org.jbox2d.dynamics.BodyType) {
            this.type = type;
        }

        /**
         * Use this to store application specific body data.
         * @return {*}
         */
        public getUserData() : any {
            return this.userData;
        }

        /**
         * Use this to store application specific body data.
         * @param {*} userData
         */
        public setUserData(userData : any) {
            this.userData = userData;
        }

        /**
         * The world position of the body. Avoid creating bodies at the origin since this can lead to many
         * overlapping shapes.
         * @return {org.jbox2d.common.Vec2}
         */
        public getPosition() : org.jbox2d.common.Vec2 {
            return this.position;
        }

        /**
         * The world position of the body. Avoid creating bodies at the origin since this can lead to many
         * overlapping shapes.
         * @param {org.jbox2d.common.Vec2} position
         */
        public setPosition(position : org.jbox2d.common.Vec2) {
            this.position = position;
        }

        /**
         * The world angle of the body in radians.
         * @return {number}
         */
        public getAngle() : number {
            return this.angle;
        }

        /**
         * The world angle of the body in radians.
         * @param {number} angle
         */
        public setAngle(angle : number) {
            this.angle = angle;
        }

        /**
         * The linear velocity of the body in world co-ordinates.
         * @return {org.jbox2d.common.Vec2}
         */
        public getLinearVelocity() : org.jbox2d.common.Vec2 {
            return this.linearVelocity;
        }

        /**
         * The linear velocity of the body in world co-ordinates.
         * @param {org.jbox2d.common.Vec2} linearVelocity
         */
        public setLinearVelocity(linearVelocity : org.jbox2d.common.Vec2) {
            this.linearVelocity = linearVelocity;
        }

        /**
         * The angular velocity of the body.
         * @return {number}
         */
        public getAngularVelocity() : number {
            return this.angularVelocity;
        }

        /**
         * The angular velocity of the body.
         * @param {number} angularVelocity
         */
        public setAngularVelocity(angularVelocity : number) {
            this.angularVelocity = angularVelocity;
        }

        /**
         * Linear damping is use to reduce the linear velocity. The damping parameter can be larger than
         * 1.0f but the damping effect becomes sensitive to the time step when the damping parameter is
         * large.
         * @return {number}
         */
        public getLinearDamping() : number {
            return this.linearDamping;
        }

        /**
         * Linear damping is use to reduce the linear velocity. The damping parameter can be larger than
         * 1.0f but the damping effect becomes sensitive to the time step when the damping parameter is
         * large.
         * @param {number} linearDamping
         */
        public setLinearDamping(linearDamping : number) {
            this.linearDamping = linearDamping;
        }

        /**
         * Angular damping is use to reduce the angular velocity. The damping parameter can be larger than
         * 1.0f but the damping effect becomes sensitive to the time step when the damping parameter is
         * large.
         * @return {number}
         */
        public getAngularDamping() : number {
            return this.angularDamping;
        }

        /**
         * Angular damping is use to reduce the angular velocity. The damping parameter can be larger than
         * 1.0f but the damping effect becomes sensitive to the time step when the damping parameter is
         * large.
         * @param {number} angularDamping
         */
        public setAngularDamping(angularDamping : number) {
            this.angularDamping = angularDamping;
        }

        /**
         * Set this flag to false if this body should never fall asleep. Note that this increases CPU
         * usage.
         * @return {boolean}
         */
        public isAllowSleep() : boolean {
            return this.allowSleep;
        }

        /**
         * Set this flag to false if this body should never fall asleep. Note that this increases CPU
         * usage.
         * @param {boolean} allowSleep
         */
        public setAllowSleep(allowSleep : boolean) {
            this.allowSleep = allowSleep;
        }

        /**
         * Is this body initially sleeping?
         * @return {boolean}
         */
        public isAwake() : boolean {
            return this.awake;
        }

        /**
         * Is this body initially sleeping?
         * @param {boolean} awake
         */
        public setAwake(awake : boolean) {
            this.awake = awake;
        }

        /**
         * Should this body be prevented from rotating? Useful for characters.
         * @return {boolean}
         */
        public isFixedRotation() : boolean {
            return this.fixedRotation;
        }

        /**
         * Should this body be prevented from rotating? Useful for characters.
         * @param {boolean} fixedRotation
         */
        public setFixedRotation(fixedRotation : boolean) {
            this.fixedRotation = fixedRotation;
        }

        /**
         * Is this a fast moving body that should be prevented from tunneling through other moving bodies?
         * Note that all bodies are prevented from tunneling through kinematic and static bodies. This
         * setting is only considered on dynamic bodies.
         * 
         * @warning You should use this flag sparingly since it increases processing time.
         * @return {boolean}
         */
        public isBullet() : boolean {
            return this.bullet;
        }

        /**
         * Is this a fast moving body that should be prevented from tunneling through other moving bodies?
         * Note that all bodies are prevented from tunneling through kinematic and static bodies. This
         * setting is only considered on dynamic bodies.
         * 
         * @warning You should use this flag sparingly since it increases processing time.
         * @param {boolean} bullet
         */
        public setBullet(bullet : boolean) {
            this.bullet = bullet;
        }

        /**
         * Does this body start out active?
         * @return {boolean}
         */
        public isActive() : boolean {
            return this.active;
        }

        /**
         * Does this body start out active?
         * @param {boolean} active
         */
        public setActive(active : boolean) {
            this.active = active;
        }

        /**
         * Experimental: scales the inertia tensor.
         * @return {number}
         */
        public getGravityScale() : number {
            return this.gravityScale;
        }

        /**
         * Experimental: scales the inertia tensor.
         * @param {number} gravityScale
         */
        public setGravityScale(gravityScale : number) {
            this.gravityScale = gravityScale;
        }
    }
    BodyDef["__class"] = "org.jbox2d.dynamics.BodyDef";

}
namespace org.jbox2d.dynamics {
    /**
     * The body type.
     * static: zero mass, zero velocity, may be manually moved
     * kinematic: zero mass, non-zero velocity set by user, moved by solver
     * dynamic: positive mass, non-zero velocity determined by forces, moved by solver
     * 
     * @author daniel
     * @enum
     * @property {org.jbox2d.dynamics.BodyType} STATIC
     * @property {org.jbox2d.dynamics.BodyType} KINEMATIC
     * @property {org.jbox2d.dynamics.BodyType} DYNAMIC
     * @class
     */
    export enum BodyType {
        STATIC, KINEMATIC, DYNAMIC
    }
}
namespace org.jbox2d.dynamics {
    /**
     * Delegate of World.
     * 
     * @author Daniel Murphy
     * @param {org.jbox2d.dynamics.World} argPool
     * @param {*} broadPhase
     * @class
     */
    export class ContactManager implements org.jbox2d.callbacks.PairCallback {
        public m_broadPhase : org.jbox2d.collision.broadphase.BroadPhase;

        public m_contactList : org.jbox2d.dynamics.contacts.Contact;

        public m_contactCount : number;

        public m_contactFilter : org.jbox2d.callbacks.ContactFilter;

        public m_contactListener : org.jbox2d.callbacks.ContactListener;

        /*private*/ pool : org.jbox2d.dynamics.World;

        public constructor(argPool : org.jbox2d.dynamics.World, broadPhase : org.jbox2d.collision.broadphase.BroadPhase) {
            if(this.m_broadPhase===undefined) this.m_broadPhase = null;
            if(this.m_contactList===undefined) this.m_contactList = null;
            if(this.m_contactCount===undefined) this.m_contactCount = 0;
            if(this.m_contactFilter===undefined) this.m_contactFilter = null;
            if(this.m_contactListener===undefined) this.m_contactListener = null;
            if(this.pool===undefined) this.pool = null;
            this.m_contactList = null;
            this.m_contactCount = 0;
            this.m_contactFilter = new org.jbox2d.callbacks.ContactFilter();
            this.m_contactListener = null;
            this.m_broadPhase = broadPhase;
            this.pool = argPool;
        }

        /**
         * Broad-phase callback.
         * 
         * @param {*} proxyUserDataA
         * @param {*} proxyUserDataB
         */
        public addPair(proxyUserDataA : any, proxyUserDataB : any) {
            let proxyA : org.jbox2d.dynamics.FixtureProxy = <org.jbox2d.dynamics.FixtureProxy>proxyUserDataA;
            let proxyB : org.jbox2d.dynamics.FixtureProxy = <org.jbox2d.dynamics.FixtureProxy>proxyUserDataB;
            let fixtureA : org.jbox2d.dynamics.Fixture = proxyA.fixture;
            let fixtureB : org.jbox2d.dynamics.Fixture = proxyB.fixture;
            let indexA : number = proxyA.childIndex;
            let indexB : number = proxyB.childIndex;
            let bodyA : org.jbox2d.dynamics.Body = fixtureA.getBody();
            let bodyB : org.jbox2d.dynamics.Body = fixtureB.getBody();
            if(bodyA === bodyB) {
                return;
            }
            let edge : org.jbox2d.dynamics.contacts.ContactEdge = bodyB.getContactList();
            while((edge != null)) {
                if(edge.other === bodyA) {
                    let fA : org.jbox2d.dynamics.Fixture = edge.contact.getFixtureA();
                    let fB : org.jbox2d.dynamics.Fixture = edge.contact.getFixtureB();
                    let iA : number = edge.contact.getChildIndexA();
                    let iB : number = edge.contact.getChildIndexB();
                    if(fA === fixtureA && iA === indexA && fB === fixtureB && iB === indexB) {
                        return;
                    }
                    if(fA === fixtureB && iA === indexB && fB === fixtureA && iB === indexA) {
                        return;
                    }
                }
                edge = edge.next;
            };
            if(bodyB.shouldCollide(bodyA) === false) {
                return;
            }
            if(this.m_contactFilter != null && this.m_contactFilter.shouldCollide(fixtureA, fixtureB) === false) {
                return;
            }
            let c : org.jbox2d.dynamics.contacts.Contact = this.pool.popContact(fixtureA, indexA, fixtureB, indexB);
            if(c == null) {
                return;
            }
            fixtureA = c.getFixtureA();
            fixtureB = c.getFixtureB();
            indexA = c.getChildIndexA();
            indexB = c.getChildIndexB();
            bodyA = fixtureA.getBody();
            bodyB = fixtureB.getBody();
            c.m_prev = null;
            c.m_next = this.m_contactList;
            if(this.m_contactList != null) {
                this.m_contactList.m_prev = c;
            }
            this.m_contactList = c;
            c.m_nodeA.contact = c;
            c.m_nodeA.other = bodyB;
            c.m_nodeA.prev = null;
            c.m_nodeA.next = bodyA.m_contactList;
            if(bodyA.m_contactList != null) {
                bodyA.m_contactList.prev = c.m_nodeA;
            }
            bodyA.m_contactList = c.m_nodeA;
            c.m_nodeB.contact = c;
            c.m_nodeB.other = bodyA;
            c.m_nodeB.prev = null;
            c.m_nodeB.next = bodyB.m_contactList;
            if(bodyB.m_contactList != null) {
                bodyB.m_contactList.prev = c.m_nodeB;
            }
            bodyB.m_contactList = c.m_nodeB;
            if(!fixtureA.isSensor() && !fixtureB.isSensor()) {
                bodyA.setAwake(true);
                bodyB.setAwake(true);
            }
            ++this.m_contactCount;
        }

        public findNewContacts() {
            this.m_broadPhase.updatePairs(this);
        }

        public destroy(c : org.jbox2d.dynamics.contacts.Contact) {
            let fixtureA : org.jbox2d.dynamics.Fixture = c.getFixtureA();
            let fixtureB : org.jbox2d.dynamics.Fixture = c.getFixtureB();
            let bodyA : org.jbox2d.dynamics.Body = fixtureA.getBody();
            let bodyB : org.jbox2d.dynamics.Body = fixtureB.getBody();
            if(this.m_contactListener != null && c.isTouching()) {
                this.m_contactListener.endContact(c);
            }
            if(c.m_prev != null) {
                c.m_prev.m_next = c.m_next;
            }
            if(c.m_next != null) {
                c.m_next.m_prev = c.m_prev;
            }
            if(c === this.m_contactList) {
                this.m_contactList = c.m_next;
            }
            if(c.m_nodeA.prev != null) {
                c.m_nodeA.prev.next = c.m_nodeA.next;
            }
            if(c.m_nodeA.next != null) {
                c.m_nodeA.next.prev = c.m_nodeA.prev;
            }
            if(c.m_nodeA === bodyA.m_contactList) {
                bodyA.m_contactList = c.m_nodeA.next;
            }
            if(c.m_nodeB.prev != null) {
                c.m_nodeB.prev.next = c.m_nodeB.next;
            }
            if(c.m_nodeB.next != null) {
                c.m_nodeB.next.prev = c.m_nodeB.prev;
            }
            if(c.m_nodeB === bodyB.m_contactList) {
                bodyB.m_contactList = c.m_nodeB.next;
            }
            this.pool.pushContact(c);
            --this.m_contactCount;
        }

        /**
         * This is the top level collision call for the time step. Here all the narrow phase collision is
         * processed for the world contact list.
         */
        public collide() {
            let c : org.jbox2d.dynamics.contacts.Contact = this.m_contactList;
            while((c != null)) {
                let fixtureA : org.jbox2d.dynamics.Fixture = c.getFixtureA();
                let fixtureB : org.jbox2d.dynamics.Fixture = c.getFixtureB();
                let indexA : number = c.getChildIndexA();
                let indexB : number = c.getChildIndexB();
                let bodyA : org.jbox2d.dynamics.Body = fixtureA.getBody();
                let bodyB : org.jbox2d.dynamics.Body = fixtureB.getBody();
                if((c.m_flags & org.jbox2d.dynamics.contacts.Contact.FILTER_FLAG) === org.jbox2d.dynamics.contacts.Contact.FILTER_FLAG) {
                    if(bodyB.shouldCollide(bodyA) === false) {
                        let cNuke : org.jbox2d.dynamics.contacts.Contact = c;
                        c = cNuke.getNext();
                        this.destroy(cNuke);
                        continue;
                    }
                    if(this.m_contactFilter != null && this.m_contactFilter.shouldCollide(fixtureA, fixtureB) === false) {
                        let cNuke : org.jbox2d.dynamics.contacts.Contact = c;
                        c = cNuke.getNext();
                        this.destroy(cNuke);
                        continue;
                    }
                    c.m_flags &= ~org.jbox2d.dynamics.contacts.Contact.FILTER_FLAG;
                }
                let activeA : boolean = bodyA.isAwake() && bodyA.m_type !== org.jbox2d.dynamics.BodyType.STATIC;
                let activeB : boolean = bodyB.isAwake() && bodyB.m_type !== org.jbox2d.dynamics.BodyType.STATIC;
                if(activeA === false && activeB === false) {
                    c = c.getNext();
                    continue;
                }
                let proxyIdA : number = fixtureA.m_proxies[indexA].proxyId;
                let proxyIdB : number = fixtureB.m_proxies[indexB].proxyId;
                let overlap : boolean = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);
                if(overlap === false) {
                    let cNuke : org.jbox2d.dynamics.contacts.Contact = c;
                    c = cNuke.getNext();
                    this.destroy(cNuke);
                    continue;
                }
                c.update(this.m_contactListener);
                c = c.getNext();
            };
        }
    }
    ContactManager["__class"] = "org.jbox2d.dynamics.ContactManager";
    ContactManager["__interfaces"] = ["org.jbox2d.callbacks.PairCallback"];


}
namespace org.jbox2d.dynamics.contacts {
    /**
     * The class manages contact between two shapes. A contact exists for each overlapping AABB in the
     * broad-phase (except if filtered). Therefore a contact object may exist that has no contact
     * points.
     * 
     * @author daniel
     * @class
     */
    export abstract class Contact {
        public static ISLAND_FLAG : number = 1;

        public static TOUCHING_FLAG : number = 2;

        public static ENABLED_FLAG : number = 4;

        public static FILTER_FLAG : number = 8;

        public static BULLET_HIT_FLAG : number = 16;

        public static TOI_FLAG : number = 32;

        public m_flags : number;

        public m_prev : Contact;

        public m_next : Contact;

        public m_nodeA : org.jbox2d.dynamics.contacts.ContactEdge = null;

        public m_nodeB : org.jbox2d.dynamics.contacts.ContactEdge = null;

        public m_fixtureA : org.jbox2d.dynamics.Fixture;

        public m_fixtureB : org.jbox2d.dynamics.Fixture;

        public m_indexA : number;

        public m_indexB : number;

        public m_manifold : org.jbox2d.collision.Manifold;

        public m_toiCount : number;

        public m_toi : number;

        public m_friction : number;

        public m_restitution : number;

        public m_tangentSpeed : number;

        pool : org.jbox2d.pooling.IWorldPool;

        constructor(argPool : org.jbox2d.pooling.IWorldPool) {
            if(this.m_flags===undefined) this.m_flags = 0;
            if(this.m_prev===undefined) this.m_prev = null;
            if(this.m_next===undefined) this.m_next = null;
            if(this.m_fixtureA===undefined) this.m_fixtureA = null;
            if(this.m_fixtureB===undefined) this.m_fixtureB = null;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_manifold===undefined) this.m_manifold = null;
            if(this.m_toiCount===undefined) this.m_toiCount = 0;
            if(this.m_toi===undefined) this.m_toi = 0;
            if(this.m_friction===undefined) this.m_friction = 0;
            if(this.m_restitution===undefined) this.m_restitution = 0;
            if(this.m_tangentSpeed===undefined) this.m_tangentSpeed = 0;
            if(this.pool===undefined) this.pool = null;
            this.m_fixtureA = null;
            this.m_fixtureB = null;
            this.m_nodeA = new org.jbox2d.dynamics.contacts.ContactEdge();
            this.m_nodeB = new org.jbox2d.dynamics.contacts.ContactEdge();
            this.m_manifold = new org.jbox2d.collision.Manifold();
            this.pool = argPool;
        }

        public init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fA : org.jbox2d.dynamics.Fixture, indexA : number, fB : org.jbox2d.dynamics.Fixture, indexB : number) {
            this.m_flags = Contact.ENABLED_FLAG;
            this.m_fixtureA = fA;
            this.m_fixtureB = fB;
            this.m_indexA = indexA;
            this.m_indexB = indexB;
            this.m_manifold.pointCount = 0;
            this.m_prev = null;
            this.m_next = null;
            this.m_nodeA.contact = null;
            this.m_nodeA.prev = null;
            this.m_nodeA.next = null;
            this.m_nodeA.other = null;
            this.m_nodeB.contact = null;
            this.m_nodeB.prev = null;
            this.m_nodeB.next = null;
            this.m_nodeB.other = null;
            this.m_toiCount = 0;
            this.m_friction = Contact.mixFriction(fA.m_friction, fB.m_friction);
            this.m_restitution = Contact.mixRestitution(fA.m_restitution, fB.m_restitution);
            this.m_tangentSpeed = 0;
        }

        /**
         * initialization for pooling
         * @param {org.jbox2d.dynamics.Fixture} fA
         * @param {number} indexA
         * @param {org.jbox2d.dynamics.Fixture} fB
         * @param {number} indexB
         */
        public init(fA? : any, indexA? : any, fB? : any, indexB? : any) : any {
            if(((fA != null && fA instanceof <any>org.jbox2d.dynamics.Fixture) || fA === null) && ((typeof indexA === 'number') || indexA === null) && ((fB != null && fB instanceof <any>org.jbox2d.dynamics.Fixture) || fB === null) && ((typeof indexB === 'number') || indexB === null)) {
                return <any>this.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fA, indexA, fB, indexB);
            } else throw new Error('invalid overload');
        }

        /**
         * Get the contact manifold. Do not set the point count to zero. Instead call Disable.
         * @return {org.jbox2d.collision.Manifold}
         */
        public getManifold() : org.jbox2d.collision.Manifold {
            return this.m_manifold;
        }

        /**
         * Get the world manifold.
         * @param {org.jbox2d.collision.WorldManifold} worldManifold
         */
        public getWorldManifold(worldManifold : org.jbox2d.collision.WorldManifold) {
            let bodyA : org.jbox2d.dynamics.Body = this.m_fixtureA.getBody();
            let bodyB : org.jbox2d.dynamics.Body = this.m_fixtureB.getBody();
            let shapeA : org.jbox2d.collision.shapes.Shape = this.m_fixtureA.getShape();
            let shapeB : org.jbox2d.collision.shapes.Shape = this.m_fixtureB.getShape();
            worldManifold.initialize(this.m_manifold, bodyA.getTransform(), shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);
        }

        /**
         * Is this contact touching
         * 
         * @return
         * @return {boolean}
         */
        public isTouching() : boolean {
            return (this.m_flags & Contact.TOUCHING_FLAG) === Contact.TOUCHING_FLAG;
        }

        /**
         * Enable/disable this contact. This can be used inside the pre-solve contact listener. The
         * contact is only disabled for the current time step (or sub-step in continuous collisions).
         * 
         * @param {boolean} flag
         */
        public setEnabled(flag : boolean) {
            if(flag) {
                this.m_flags |= Contact.ENABLED_FLAG;
            } else {
                this.m_flags &= ~Contact.ENABLED_FLAG;
            }
        }

        /**
         * Has this contact been disabled?
         * 
         * @return
         * @return {boolean}
         */
        public isEnabled() : boolean {
            return (this.m_flags & Contact.ENABLED_FLAG) === Contact.ENABLED_FLAG;
        }

        /**
         * Get the next contact in the world's contact list.
         * 
         * @return
         * @return {org.jbox2d.dynamics.contacts.Contact}
         */
        public getNext() : Contact {
            return this.m_next;
        }

        /**
         * Get the first fixture in this contact.
         * 
         * @return
         * @return {org.jbox2d.dynamics.Fixture}
         */
        public getFixtureA() : org.jbox2d.dynamics.Fixture {
            return this.m_fixtureA;
        }

        public getChildIndexA() : number {
            return this.m_indexA;
        }

        /**
         * Get the second fixture in this contact.
         * 
         * @return
         * @return {org.jbox2d.dynamics.Fixture}
         */
        public getFixtureB() : org.jbox2d.dynamics.Fixture {
            return this.m_fixtureB;
        }

        public getChildIndexB() : number {
            return this.m_indexB;
        }

        public setFriction(friction : number) {
            this.m_friction = friction;
        }

        public getFriction() : number {
            return this.m_friction;
        }

        public resetFriction() {
            this.m_friction = Contact.mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
        }

        public setRestitution(restitution : number) {
            this.m_restitution = restitution;
        }

        public getRestitution() : number {
            return this.m_restitution;
        }

        public resetRestitution() {
            this.m_restitution = Contact.mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
        }

        public setTangentSpeed(speed : number) {
            this.m_tangentSpeed = speed;
        }

        public getTangentSpeed() : number {
            return this.m_tangentSpeed;
        }

        public abstract evaluate(manifold : org.jbox2d.collision.Manifold, xfA : org.jbox2d.common.Transform, xfB : org.jbox2d.common.Transform);

        /**
         * Flag this contact for filtering. Filtering will occur the next time step.
         */
        public flagForFiltering() {
            this.m_flags |= Contact.FILTER_FLAG;
        }

        /*private*/ oldManifold : org.jbox2d.collision.Manifold = new org.jbox2d.collision.Manifold();

        public update(listener : org.jbox2d.callbacks.ContactListener) {
            this.oldManifold.set(this.m_manifold);
            this.m_flags |= Contact.ENABLED_FLAG;
            let touching : boolean = false;
            let wasTouching : boolean = (this.m_flags & Contact.TOUCHING_FLAG) === Contact.TOUCHING_FLAG;
            let sensorA : boolean = this.m_fixtureA.isSensor();
            let sensorB : boolean = this.m_fixtureB.isSensor();
            let sensor : boolean = sensorA || sensorB;
            let bodyA : org.jbox2d.dynamics.Body = this.m_fixtureA.getBody();
            let bodyB : org.jbox2d.dynamics.Body = this.m_fixtureB.getBody();
            let xfA : org.jbox2d.common.Transform = bodyA.getTransform();
            let xfB : org.jbox2d.common.Transform = bodyB.getTransform();
            if(sensor) {
                let shapeA : org.jbox2d.collision.shapes.Shape = this.m_fixtureA.getShape();
                let shapeB : org.jbox2d.collision.shapes.Shape = this.m_fixtureB.getShape();
                touching = this.pool.getCollision().testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);
                this.m_manifold.pointCount = 0;
            } else {
                this.evaluate(this.m_manifold, xfA, xfB);
                touching = this.m_manifold.pointCount > 0;
                for(let i : number = 0; i < this.m_manifold.pointCount; ++i) {
                    let mp2 : org.jbox2d.collision.ManifoldPoint = this.m_manifold.points[i];
                    mp2.normalImpulse = 0.0;
                    mp2.tangentImpulse = 0.0;
                    let id2 : org.jbox2d.collision.ContactID = mp2.id;
                    for(let j : number = 0; j < this.oldManifold.pointCount; ++j) {
                        let mp1 : org.jbox2d.collision.ManifoldPoint = this.oldManifold.points[j];
                        if(mp1.id.isEqual(id2)) {
                            mp2.normalImpulse = mp1.normalImpulse;
                            mp2.tangentImpulse = mp1.tangentImpulse;
                            break;
                        }
                    };
                };
                if(touching !== wasTouching) {
                    bodyA.setAwake(true);
                    bodyB.setAwake(true);
                }
            }
            if(touching) {
                this.m_flags |= Contact.TOUCHING_FLAG;
            } else {
                this.m_flags &= ~Contact.TOUCHING_FLAG;
            }
            if(listener == null) {
                return;
            }
            if(wasTouching === false && touching === true) {
                listener.beginContact(this);
            }
            if(wasTouching === true && touching === false) {
                listener.endContact(this);
            }
            if(sensor === false && touching) {
                listener.preSolve(this, this.oldManifold);
            }
        }

        /**
         * Friction mixing law. The idea is to allow either fixture to drive the restitution to zero. For
         * example, anything slides on ice.
         * 
         * @param {number} friction1
         * @param {number} friction2
         * @return
         * @return {number}
         */
        public static mixFriction(friction1 : number, friction2 : number) : number {
            return org.jbox2d.common.MathUtils.sqrt((<any>Math).fround(friction1 * friction2));
        }

        /**
         * Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface. For
         * example, a superball bounces on anything.
         * 
         * @param {number} restitution1
         * @param {number} restitution2
         * @return
         * @return {number}
         */
        public static mixRestitution(restitution1 : number, restitution2 : number) : number {
            return restitution1 > restitution2?restitution1:restitution2;
        }
    }
    Contact["__class"] = "org.jbox2d.dynamics.contacts.Contact";

}
namespace org.jbox2d.dynamics.contacts {
    export interface ContactCreator {
        contactCreateFcn(argPool : org.jbox2d.pooling.IWorldPool, fixtureA : org.jbox2d.dynamics.Fixture, fixtureB : org.jbox2d.dynamics.Fixture) : org.jbox2d.dynamics.contacts.Contact;

        contactDestroyFcn(argPool : org.jbox2d.pooling.IWorldPool, contact : org.jbox2d.dynamics.contacts.Contact);
    }
}
namespace org.jbox2d.dynamics.contacts {
    /**
     * A contact edge is used to connect bodies and contacts together in a contact graph where each body
     * is a node and each contact is an edge. A contact edge belongs to a doubly linked list maintained
     * in each attached body. Each contact has two contact nodes, one for each attached body.
     * 
     * @author daniel
     * @class
     */
    export class ContactEdge {
        /**
         * provides quick access to the other body attached.
         */
        public other : org.jbox2d.dynamics.Body = null;

        /**
         * the contact
         */
        public contact : org.jbox2d.dynamics.contacts.Contact = null;

        /**
         * the previous contact edge in the body's contact list
         */
        public prev : ContactEdge = null;

        /**
         * the next contact edge in the body's contact list
         */
        public next : ContactEdge = null;
    }
    ContactEdge["__class"] = "org.jbox2d.dynamics.contacts.ContactEdge";

}
namespace org.jbox2d.dynamics.contacts {
    export class ContactPositionConstraint {
        localPoints : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);

        localNormal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        localPoint : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        indexA : number;

        indexB : number;

        invMassA : number;

        invMassB : number;

        localCenterA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        invIA : number;

        invIB : number;

        type : org.jbox2d.collision.Manifold.ManifoldType;

        radiusA : number;

        radiusB : number;

        pointCount : number;

        public constructor() {
            if(this.indexA===undefined) this.indexA = 0;
            if(this.indexB===undefined) this.indexB = 0;
            if(this.invMassA===undefined) this.invMassA = 0;
            if(this.invMassB===undefined) this.invMassB = 0;
            if(this.invIA===undefined) this.invIA = 0;
            if(this.invIB===undefined) this.invIB = 0;
            if(this.type===undefined) this.type = null;
            if(this.radiusA===undefined) this.radiusA = 0;
            if(this.radiusB===undefined) this.radiusB = 0;
            if(this.pointCount===undefined) this.pointCount = 0;
            for(let i : number = 0; i < this.localPoints.length; i++) {
                this.localPoints[i] = new org.jbox2d.common.Vec2();
            };
        }
    }
    ContactPositionConstraint["__class"] = "org.jbox2d.dynamics.contacts.ContactPositionConstraint";

}
namespace org.jbox2d.dynamics.contacts {
    export class ContactRegister {
        public creator : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact>;

        public primary : boolean;

        constructor() {
            if(this.creator===undefined) this.creator = null;
            if(this.primary===undefined) this.primary = false;
        }
    }
    ContactRegister["__class"] = "org.jbox2d.dynamics.contacts.ContactRegister";

}
namespace org.jbox2d.dynamics.contacts {
    /**
     * @author Daniel
     * @class
     */
    export class ContactSolver {
        public static DEBUG_SOLVER : boolean = false;

        public static k_errorTol : number = 0.001;

        /**
         * For each solver, this is the initial number of constraints in the array, which expands as
         * needed.
         */
        public static INITIAL_NUM_CONSTRAINTS : number = 256;

        /**
         * Ensure a reasonable condition number. for the block solver
         */
        public static k_maxConditionNumber : number = 100.0;

        public m_step : org.jbox2d.dynamics.TimeStep;

        public m_positions : org.jbox2d.dynamics.contacts.Position[];

        public m_velocities : org.jbox2d.dynamics.contacts.Velocity[];

        public m_positionConstraints : org.jbox2d.dynamics.contacts.ContactPositionConstraint[];

        public m_velocityConstraints : org.jbox2d.dynamics.contacts.ContactVelocityConstraint[];

        public m_contacts : org.jbox2d.dynamics.contacts.Contact[];

        public m_count : number;

        public constructor() {
            if(this.m_step===undefined) this.m_step = null;
            if(this.m_positions===undefined) this.m_positions = null;
            if(this.m_velocities===undefined) this.m_velocities = null;
            if(this.m_positionConstraints===undefined) this.m_positionConstraints = null;
            if(this.m_velocityConstraints===undefined) this.m_velocityConstraints = null;
            if(this.m_contacts===undefined) this.m_contacts = null;
            if(this.m_count===undefined) this.m_count = 0;
            this.m_positionConstraints = (s => { let a=[]; while(s-->0) a.push(null); return a; })(ContactSolver.INITIAL_NUM_CONSTRAINTS);
            this.m_velocityConstraints = (s => { let a=[]; while(s-->0) a.push(null); return a; })(ContactSolver.INITIAL_NUM_CONSTRAINTS);
            for(let i : number = 0; i < ContactSolver.INITIAL_NUM_CONSTRAINTS; i++) {
                this.m_positionConstraints[i] = new org.jbox2d.dynamics.contacts.ContactPositionConstraint();
                this.m_velocityConstraints[i] = new org.jbox2d.dynamics.contacts.ContactVelocityConstraint();
            };
        }

        public init(def : ContactSolver.ContactSolverDef) {
            this.m_step = def.step;
            this.m_count = def.count;
            if(this.m_positionConstraints.length < this.m_count) {
                let old : org.jbox2d.dynamics.contacts.ContactPositionConstraint[] = this.m_positionConstraints;
                this.m_positionConstraints = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.MathUtils.max$int$int(old.length * 2, this.m_count));
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(old, 0, this.m_positionConstraints, 0, old.length);
                for(let i : number = old.length; i < this.m_positionConstraints.length; i++) {
                    this.m_positionConstraints[i] = new org.jbox2d.dynamics.contacts.ContactPositionConstraint();
                };
            }
            if(this.m_velocityConstraints.length < this.m_count) {
                let old : org.jbox2d.dynamics.contacts.ContactVelocityConstraint[] = this.m_velocityConstraints;
                this.m_velocityConstraints = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.MathUtils.max$int$int(old.length * 2, this.m_count));
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(old, 0, this.m_velocityConstraints, 0, old.length);
                for(let i : number = old.length; i < this.m_velocityConstraints.length; i++) {
                    this.m_velocityConstraints[i] = new org.jbox2d.dynamics.contacts.ContactVelocityConstraint();
                };
            }
            this.m_positions = def.positions;
            this.m_velocities = def.velocities;
            this.m_contacts = def.contacts;
            for(let i : number = 0; i < this.m_count; ++i) {
                let contact : org.jbox2d.dynamics.contacts.Contact = this.m_contacts[i];
                let fixtureA : org.jbox2d.dynamics.Fixture = contact.m_fixtureA;
                let fixtureB : org.jbox2d.dynamics.Fixture = contact.m_fixtureB;
                let shapeA : org.jbox2d.collision.shapes.Shape = fixtureA.getShape();
                let shapeB : org.jbox2d.collision.shapes.Shape = fixtureB.getShape();
                let radiusA : number = shapeA.m_radius;
                let radiusB : number = shapeB.m_radius;
                let bodyA : org.jbox2d.dynamics.Body = fixtureA.getBody();
                let bodyB : org.jbox2d.dynamics.Body = fixtureB.getBody();
                let manifold : org.jbox2d.collision.Manifold = contact.getManifold();
                let pointCount : number = manifold.pointCount;
                let vc : org.jbox2d.dynamics.contacts.ContactVelocityConstraint = this.m_velocityConstraints[i];
                vc.friction = contact.m_friction;
                vc.restitution = contact.m_restitution;
                vc.tangentSpeed = contact.m_tangentSpeed;
                vc.indexA = bodyA.m_islandIndex;
                vc.indexB = bodyB.m_islandIndex;
                vc.invMassA = bodyA.m_invMass;
                vc.invMassB = bodyB.m_invMass;
                vc.invIA = bodyA.m_invI;
                vc.invIB = bodyB.m_invI;
                vc.contactIndex = i;
                vc.pointCount = pointCount;
                vc.K.setZero();
                vc.normalMass.setZero();
                let pc : org.jbox2d.dynamics.contacts.ContactPositionConstraint = this.m_positionConstraints[i];
                pc.indexA = bodyA.m_islandIndex;
                pc.indexB = bodyB.m_islandIndex;
                pc.invMassA = bodyA.m_invMass;
                pc.invMassB = bodyB.m_invMass;
                pc.localCenterA.set$org_jbox2d_common_Vec2(bodyA.m_sweep.localCenter);
                pc.localCenterB.set$org_jbox2d_common_Vec2(bodyB.m_sweep.localCenter);
                pc.invIA = bodyA.m_invI;
                pc.invIB = bodyB.m_invI;
                pc.localNormal.set$org_jbox2d_common_Vec2(manifold.localNormal);
                pc.localPoint.set$org_jbox2d_common_Vec2(manifold.localPoint);
                pc.pointCount = pointCount;
                pc.radiusA = radiusA;
                pc.radiusB = radiusB;
                pc.type = manifold.type;
                for(let j : number = 0; j < pointCount; j++) {
                    let cp : org.jbox2d.collision.ManifoldPoint = manifold.points[j];
                    let vcp : org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint = vc.points[j];
                    if(this.m_step.warmStarting) {
                        vcp.normalImpulse = (<any>Math).fround(this.m_step.dtRatio * cp.normalImpulse);
                        vcp.tangentImpulse = (<any>Math).fround(this.m_step.dtRatio * cp.tangentImpulse);
                    } else {
                        vcp.normalImpulse = 0;
                        vcp.tangentImpulse = 0;
                    }
                    vcp.rA.setZero();
                    vcp.rB.setZero();
                    vcp.normalMass = 0;
                    vcp.tangentMass = 0;
                    vcp.velocityBias = 0;
                    pc.localPoints[j].x = cp.localPoint.x;
                    pc.localPoints[j].y = cp.localPoint.y;
                };
            };
        }

        public warmStart() {
            for(let i : number = 0; i < this.m_count; ++i) {
                let vc : org.jbox2d.dynamics.contacts.ContactVelocityConstraint = this.m_velocityConstraints[i];
                let indexA : number = vc.indexA;
                let indexB : number = vc.indexB;
                let mA : number = vc.invMassA;
                let iA : number = vc.invIA;
                let mB : number = vc.invMassB;
                let iB : number = vc.invIB;
                let pointCount : number = vc.pointCount;
                let vA : org.jbox2d.common.Vec2 = this.m_velocities[indexA].v;
                let wA : number = this.m_velocities[indexA].w;
                let vB : org.jbox2d.common.Vec2 = this.m_velocities[indexB].v;
                let wB : number = this.m_velocities[indexB].w;
                let normal : org.jbox2d.common.Vec2 = vc.normal;
                let tangentx : number = (<any>Math).fround(1.0 * normal.y);
                let tangenty : number = (<any>Math).fround(-1.0 * normal.x);
                for(let j : number = 0; j < pointCount; ++j) {
                    let vcp : org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint = vc.points[j];
                    let Px : number = (<any>Math).fround((<any>Math).fround(tangentx * vcp.tangentImpulse) + (<any>Math).fround(normal.x * vcp.normalImpulse));
                    let Py : number = (<any>Math).fround((<any>Math).fround(tangenty * vcp.tangentImpulse) + (<any>Math).fround(normal.y * vcp.normalImpulse));
                    wA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround(vcp.rA.x * Py) - (<any>Math).fround(vcp.rA.y * Px))));
                    vA.x -= (<any>Math).fround(Px * mA);
                    vA.y -= (<any>Math).fround(Py * mA);
                    wB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround(vcp.rB.x * Py) - (<any>Math).fround(vcp.rB.y * Px))));
                    vB.x += (<any>Math).fround(Px * mB);
                    vB.y += (<any>Math).fround(Py * mB);
                };
                this.m_velocities[indexA].w = wA;
                this.m_velocities[indexB].w = wB;
            };
        }

        /*private*/ xfA : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /*private*/ xfB : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /*private*/ worldManifold : org.jbox2d.collision.WorldManifold = new org.jbox2d.collision.WorldManifold();

        public initializeVelocityConstraints() {
            for(let i : number = 0; i < this.m_count; ++i) {
                let vc : org.jbox2d.dynamics.contacts.ContactVelocityConstraint = this.m_velocityConstraints[i];
                let pc : org.jbox2d.dynamics.contacts.ContactPositionConstraint = this.m_positionConstraints[i];
                let radiusA : number = pc.radiusA;
                let radiusB : number = pc.radiusB;
                let manifold : org.jbox2d.collision.Manifold = this.m_contacts[vc.contactIndex].getManifold();
                let indexA : number = vc.indexA;
                let indexB : number = vc.indexB;
                let mA : number = vc.invMassA;
                let mB : number = vc.invMassB;
                let iA : number = vc.invIA;
                let iB : number = vc.invIB;
                let localCenterA : org.jbox2d.common.Vec2 = pc.localCenterA;
                let localCenterB : org.jbox2d.common.Vec2 = pc.localCenterB;
                let cA : org.jbox2d.common.Vec2 = this.m_positions[indexA].c;
                let aA : number = this.m_positions[indexA].a;
                let vA : org.jbox2d.common.Vec2 = this.m_velocities[indexA].v;
                let wA : number = this.m_velocities[indexA].w;
                let cB : org.jbox2d.common.Vec2 = this.m_positions[indexB].c;
                let aB : number = this.m_positions[indexB].a;
                let vB : org.jbox2d.common.Vec2 = this.m_velocities[indexB].v;
                let wB : number = this.m_velocities[indexB].w;
                let xfAq : org.jbox2d.common.Rot = this.xfA.q;
                let xfBq : org.jbox2d.common.Rot = this.xfB.q;
                xfAq.set$float(aA);
                xfBq.set$float(aB);
                this.xfA.p.x = (<any>Math).fround(cA.x - ((<any>Math).fround((<any>Math).fround(xfAq.c * localCenterA.x) - (<any>Math).fround(xfAq.s * localCenterA.y))));
                this.xfA.p.y = (<any>Math).fround(cA.y - ((<any>Math).fround((<any>Math).fround(xfAq.s * localCenterA.x) + (<any>Math).fround(xfAq.c * localCenterA.y))));
                this.xfB.p.x = (<any>Math).fround(cB.x - ((<any>Math).fround((<any>Math).fround(xfBq.c * localCenterB.x) - (<any>Math).fround(xfBq.s * localCenterB.y))));
                this.xfB.p.y = (<any>Math).fround(cB.y - ((<any>Math).fround((<any>Math).fround(xfBq.s * localCenterB.x) + (<any>Math).fround(xfBq.c * localCenterB.y))));
                this.worldManifold.initialize(manifold, this.xfA, radiusA, this.xfB, radiusB);
                let vcnormal : org.jbox2d.common.Vec2 = vc.normal;
                vcnormal.x = this.worldManifold.normal.x;
                vcnormal.y = this.worldManifold.normal.y;
                let pointCount : number = vc.pointCount;
                for(let j : number = 0; j < pointCount; ++j) {
                    let vcp : org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint = vc.points[j];
                    let wmPj : org.jbox2d.common.Vec2 = this.worldManifold.points[j];
                    let vcprA : org.jbox2d.common.Vec2 = vcp.rA;
                    let vcprB : org.jbox2d.common.Vec2 = vcp.rB;
                    vcprA.x = (<any>Math).fround(wmPj.x - cA.x);
                    vcprA.y = (<any>Math).fround(wmPj.y - cA.y);
                    vcprB.x = (<any>Math).fround(wmPj.x - cB.x);
                    vcprB.y = (<any>Math).fround(wmPj.y - cB.y);
                    let rnA : number = (<any>Math).fround((<any>Math).fround(vcprA.x * vcnormal.y) - (<any>Math).fround(vcprA.y * vcnormal.x));
                    let rnB : number = (<any>Math).fround((<any>Math).fround(vcprB.x * vcnormal.y) - (<any>Math).fround(vcprB.y * vcnormal.x));
                    let kNormal : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * rnA) * rnA)) + (<any>Math).fround((<any>Math).fround(iB * rnB) * rnB));
                    vcp.normalMass = kNormal > 0.0?(<any>Math).fround(1.0 / kNormal):0.0;
                    let tangentx : number = (<any>Math).fround(1.0 * vcnormal.y);
                    let tangenty : number = (<any>Math).fround(-1.0 * vcnormal.x);
                    let rtA : number = (<any>Math).fround((<any>Math).fround(vcprA.x * tangenty) - (<any>Math).fround(vcprA.y * tangentx));
                    let rtB : number = (<any>Math).fround((<any>Math).fround(vcprB.x * tangenty) - (<any>Math).fround(vcprB.y * tangentx));
                    let kTangent : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * rtA) * rtA)) + (<any>Math).fround((<any>Math).fround(iB * rtB) * rtB));
                    vcp.tangentMass = kTangent > 0.0?(<any>Math).fround(1.0 / kTangent):0.0;
                    vcp.velocityBias = 0.0;
                    let tempx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(vB.x + (<any>Math).fround(-wB * vcprB.y)) - vA.x) - ((<any>Math).fround(-wA * vcprA.y)));
                    let tempy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(vB.y + (<any>Math).fround(wB * vcprB.x)) - vA.y) - ((<any>Math).fround(wA * vcprA.x)));
                    let vRel : number = (<any>Math).fround((<any>Math).fround(vcnormal.x * tempx) + (<any>Math).fround(vcnormal.y * tempy));
                    if(vRel < -org.jbox2d.common.Settings.velocityThreshold) {
                        vcp.velocityBias = (<any>Math).fround(-vc.restitution * vRel);
                    }
                };
                if(vc.pointCount === 2) {
                    let vcp1 : org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint = vc.points[0];
                    let vcp2 : org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint = vc.points[1];
                    let rn1A : number = (<any>Math).fround((<any>Math).fround(vcp1.rA.x * vcnormal.y) - (<any>Math).fround(vcp1.rA.y * vcnormal.x));
                    let rn1B : number = (<any>Math).fround((<any>Math).fround(vcp1.rB.x * vcnormal.y) - (<any>Math).fround(vcp1.rB.y * vcnormal.x));
                    let rn2A : number = (<any>Math).fround((<any>Math).fround(vcp2.rA.x * vcnormal.y) - (<any>Math).fround(vcp2.rA.y * vcnormal.x));
                    let rn2B : number = (<any>Math).fround((<any>Math).fround(vcp2.rB.x * vcnormal.y) - (<any>Math).fround(vcp2.rB.y * vcnormal.x));
                    let k11 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * rn1A) * rn1A)) + (<any>Math).fround((<any>Math).fround(iB * rn1B) * rn1B));
                    let k22 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * rn2A) * rn2A)) + (<any>Math).fround((<any>Math).fround(iB * rn2B) * rn2B));
                    let k12 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * rn1A) * rn2A)) + (<any>Math).fround((<any>Math).fround(iB * rn1B) * rn2B));
                    if((<any>Math).fround(k11 * k11) < (<any>Math).fround(ContactSolver.k_maxConditionNumber * ((<any>Math).fround((<any>Math).fround(k11 * k22) - (<any>Math).fround(k12 * k12))))) {
                        vc.K.ex.x = k11;
                        vc.K.ex.y = k12;
                        vc.K.ey.x = k12;
                        vc.K.ey.y = k22;
                        vc.K.invertToOut(vc.normalMass);
                    } else {
                        vc.pointCount = 1;
                    }
                }
            };
        }

        public solveVelocityConstraints() {
            for(let i : number = 0; i < this.m_count; ++i) {
                let vc : org.jbox2d.dynamics.contacts.ContactVelocityConstraint = this.m_velocityConstraints[i];
                let indexA : number = vc.indexA;
                let indexB : number = vc.indexB;
                let mA : number = vc.invMassA;
                let mB : number = vc.invMassB;
                let iA : number = vc.invIA;
                let iB : number = vc.invIB;
                let pointCount : number = vc.pointCount;
                let vA : org.jbox2d.common.Vec2 = this.m_velocities[indexA].v;
                let wA : number = this.m_velocities[indexA].w;
                let vB : org.jbox2d.common.Vec2 = this.m_velocities[indexB].v;
                let wB : number = this.m_velocities[indexB].w;
                let normal : org.jbox2d.common.Vec2 = vc.normal;
                let normalx : number = normal.x;
                let normaly : number = normal.y;
                let tangentx : number = (<any>Math).fround(1.0 * vc.normal.y);
                let tangenty : number = (<any>Math).fround(-1.0 * vc.normal.x);
                let friction : number = vc.friction;
                for(let j : number = 0; j < pointCount; ++j) {
                    let vcp : org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint = vc.points[j];
                    let a : org.jbox2d.common.Vec2 = vcp.rA;
                    let dvx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(-wB * vcp.rB.y) + vB.x) - vA.x) + (<any>Math).fround(wA * a.y));
                    let dvy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(wB * vcp.rB.x) + vB.y) - vA.y) - (<any>Math).fround(wA * a.x));
                    let vt : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(dvx * tangentx) + (<any>Math).fround(dvy * tangenty)) - vc.tangentSpeed);
                    let lambda : number = (<any>Math).fround(vcp.tangentMass * (-vt));
                    let maxFriction : number = (<any>Math).fround(friction * vcp.normalImpulse);
                    let newImpulse : number = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(vcp.tangentImpulse + lambda), -maxFriction, maxFriction);
                    lambda = (<any>Math).fround(newImpulse - vcp.tangentImpulse);
                    vcp.tangentImpulse = newImpulse;
                    let Px : number = (<any>Math).fround(tangentx * lambda);
                    let Py : number = (<any>Math).fround(tangenty * lambda);
                    vA.x -= (<any>Math).fround(Px * mA);
                    vA.y -= (<any>Math).fround(Py * mA);
                    wA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround(vcp.rA.x * Py) - (<any>Math).fround(vcp.rA.y * Px))));
                    vB.x += (<any>Math).fround(Px * mB);
                    vB.y += (<any>Math).fround(Py * mB);
                    wB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround(vcp.rB.x * Py) - (<any>Math).fround(vcp.rB.y * Px))));
                };
                if(vc.pointCount === 1) {
                    let vcp : org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint = vc.points[0];
                    let dvx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(-wB * vcp.rB.y) + vB.x) - vA.x) + (<any>Math).fround(wA * vcp.rA.y));
                    let dvy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(wB * vcp.rB.x) + vB.y) - vA.y) - (<any>Math).fround(wA * vcp.rA.x));
                    let vn : number = (<any>Math).fround((<any>Math).fround(dvx * normalx) + (<any>Math).fround(dvy * normaly));
                    let lambda : number = (<any>Math).fround(-vcp.normalMass * ((<any>Math).fround(vn - vcp.velocityBias)));
                    let a : number = (<any>Math).fround(vcp.normalImpulse + lambda);
                    let newImpulse : number = (a > 0.0?a:0.0);
                    lambda = (<any>Math).fround(newImpulse - vcp.normalImpulse);
                    vcp.normalImpulse = newImpulse;
                    let Px : number = (<any>Math).fround(normalx * lambda);
                    let Py : number = (<any>Math).fround(normaly * lambda);
                    vA.x -= (<any>Math).fround(Px * mA);
                    vA.y -= (<any>Math).fround(Py * mA);
                    wA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround(vcp.rA.x * Py) - (<any>Math).fround(vcp.rA.y * Px))));
                    vB.x += (<any>Math).fround(Px * mB);
                    vB.y += (<any>Math).fround(Py * mB);
                    wB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround(vcp.rB.x * Py) - (<any>Math).fround(vcp.rB.y * Px))));
                } else {
                    let cp1 : org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint = vc.points[0];
                    let cp2 : org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint = vc.points[1];
                    let cp1rA : org.jbox2d.common.Vec2 = cp1.rA;
                    let cp1rB : org.jbox2d.common.Vec2 = cp1.rB;
                    let cp2rA : org.jbox2d.common.Vec2 = cp2.rA;
                    let cp2rB : org.jbox2d.common.Vec2 = cp2.rB;
                    let ax : number = cp1.normalImpulse;
                    let ay : number = cp2.normalImpulse;
                    let dv1x : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(-wB * cp1rB.y) + vB.x) - vA.x) + (<any>Math).fround(wA * cp1rA.y));
                    let dv1y : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(wB * cp1rB.x) + vB.y) - vA.y) - (<any>Math).fround(wA * cp1rA.x));
                    let dv2x : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(-wB * cp2rB.y) + vB.x) - vA.x) + (<any>Math).fround(wA * cp2rA.y));
                    let dv2y : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(wB * cp2rB.x) + vB.y) - vA.y) - (<any>Math).fround(wA * cp2rA.x));
                    let vn1 : number = (<any>Math).fround((<any>Math).fround(dv1x * normalx) + (<any>Math).fround(dv1y * normaly));
                    let vn2 : number = (<any>Math).fround((<any>Math).fround(dv2x * normalx) + (<any>Math).fround(dv2y * normaly));
                    let bx : number = (<any>Math).fround(vn1 - cp1.velocityBias);
                    let by : number = (<any>Math).fround(vn2 - cp2.velocityBias);
                    let R : org.jbox2d.common.Mat22 = vc.K;
                    bx -= (<any>Math).fround((<any>Math).fround(R.ex.x * ax) + (<any>Math).fround(R.ey.x * ay));
                    by -= (<any>Math).fround((<any>Math).fround(R.ex.y * ax) + (<any>Math).fround(R.ey.y * ay));
                    for(; ; ) {
                        let R1 : org.jbox2d.common.Mat22 = vc.normalMass;
                        let xx : number = (<any>Math).fround((<any>Math).fround(R1.ex.x * bx) + (<any>Math).fround(R1.ey.x * by));
                        let xy : number = (<any>Math).fround((<any>Math).fround(R1.ex.y * bx) + (<any>Math).fround(R1.ey.y * by));
                        xx *= -1;
                        xy *= -1;
                        if(xx >= 0.0 && xy >= 0.0) {
                            let dx : number = (<any>Math).fround(xx - ax);
                            let dy : number = (<any>Math).fround(xy - ay);
                            let P1x : number = (<any>Math).fround(dx * normalx);
                            let P1y : number = (<any>Math).fround(dx * normaly);
                            let P2x : number = (<any>Math).fround(dy * normalx);
                            let P2y : number = (<any>Math).fround(dy * normaly);
                            vA.x -= (<any>Math).fround(mA * ((<any>Math).fround(P1x + P2x)));
                            vA.y -= (<any>Math).fround(mA * ((<any>Math).fround(P1y + P2y)));
                            vB.x += (<any>Math).fround(mB * ((<any>Math).fround(P1x + P2x)));
                            vB.y += (<any>Math).fround(mB * ((<any>Math).fround(P1y + P2y)));
                            wA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(cp1rA.x * P1y) - (<any>Math).fround(cp1rA.y * P1x)) + ((<any>Math).fround((<any>Math).fround(cp2rA.x * P2y) - (<any>Math).fround(cp2rA.y * P2x))))));
                            wB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(cp1rB.x * P1y) - (<any>Math).fround(cp1rB.y * P1x)) + ((<any>Math).fround((<any>Math).fround(cp2rB.x * P2y) - (<any>Math).fround(cp2rB.y * P2x))))));
                            cp1.normalImpulse = xx;
                            cp2.normalImpulse = xy;
                            if(ContactSolver.DEBUG_SOLVER) {
                                let dv1 : org.jbox2d.common.Vec2 = vB.add(org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(wB, cp1rB).subLocal(vA).subLocal(org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(wA, cp1rA)));
                                let dv2 : org.jbox2d.common.Vec2 = vB.add(org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(wB, cp2rB).subLocal(vA).subLocal(org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(wA, cp2rA)));
                                vn1 = org.jbox2d.common.Vec2.dot(dv1, normal);
                                vn2 = org.jbox2d.common.Vec2.dot(dv2, normal);
                            }
                            break;
                        }
                        xx = (<any>Math).fround(-cp1.normalMass * bx);
                        xy = 0.0;
                        vn1 = 0.0;
                        vn2 = (<any>Math).fround((<any>Math).fround(vc.K.ex.y * xx) + by);
                        if(xx >= 0.0 && vn2 >= 0.0) {
                            let dx : number = (<any>Math).fround(xx - ax);
                            let dy : number = (<any>Math).fround(xy - ay);
                            let P1x : number = (<any>Math).fround(normalx * dx);
                            let P1y : number = (<any>Math).fround(normaly * dx);
                            let P2x : number = (<any>Math).fround(normalx * dy);
                            let P2y : number = (<any>Math).fround(normaly * dy);
                            vA.x -= (<any>Math).fround(mA * ((<any>Math).fround(P1x + P2x)));
                            vA.y -= (<any>Math).fround(mA * ((<any>Math).fround(P1y + P2y)));
                            vB.x += (<any>Math).fround(mB * ((<any>Math).fround(P1x + P2x)));
                            vB.y += (<any>Math).fround(mB * ((<any>Math).fround(P1y + P2y)));
                            wA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(cp1rA.x * P1y) - (<any>Math).fround(cp1rA.y * P1x)) + ((<any>Math).fround((<any>Math).fround(cp2rA.x * P2y) - (<any>Math).fround(cp2rA.y * P2x))))));
                            wB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(cp1rB.x * P1y) - (<any>Math).fround(cp1rB.y * P1x)) + ((<any>Math).fround((<any>Math).fround(cp2rB.x * P2y) - (<any>Math).fround(cp2rB.y * P2x))))));
                            cp1.normalImpulse = xx;
                            cp2.normalImpulse = xy;
                            if(ContactSolver.DEBUG_SOLVER) {
                                let dv1 : org.jbox2d.common.Vec2 = vB.add(org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(wB, cp1rB).subLocal(vA).subLocal(org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(wA, cp1rA)));
                                vn1 = org.jbox2d.common.Vec2.dot(dv1, normal);
                            }
                            break;
                        }
                        xx = 0.0;
                        xy = (<any>Math).fround(-cp2.normalMass * by);
                        vn1 = (<any>Math).fround((<any>Math).fround(vc.K.ey.x * xy) + bx);
                        vn2 = 0.0;
                        if(xy >= 0.0 && vn1 >= 0.0) {
                            let dx : number = (<any>Math).fround(xx - ax);
                            let dy : number = (<any>Math).fround(xy - ay);
                            let P1x : number = (<any>Math).fround(normalx * dx);
                            let P1y : number = (<any>Math).fround(normaly * dx);
                            let P2x : number = (<any>Math).fround(normalx * dy);
                            let P2y : number = (<any>Math).fround(normaly * dy);
                            vA.x -= (<any>Math).fround(mA * ((<any>Math).fround(P1x + P2x)));
                            vA.y -= (<any>Math).fround(mA * ((<any>Math).fround(P1y + P2y)));
                            vB.x += (<any>Math).fround(mB * ((<any>Math).fround(P1x + P2x)));
                            vB.y += (<any>Math).fround(mB * ((<any>Math).fround(P1y + P2y)));
                            wA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(cp1rA.x * P1y) - (<any>Math).fround(cp1rA.y * P1x)) + ((<any>Math).fround((<any>Math).fround(cp2rA.x * P2y) - (<any>Math).fround(cp2rA.y * P2x))))));
                            wB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(cp1rB.x * P1y) - (<any>Math).fround(cp1rB.y * P1x)) + ((<any>Math).fround((<any>Math).fround(cp2rB.x * P2y) - (<any>Math).fround(cp2rB.y * P2x))))));
                            cp1.normalImpulse = xx;
                            cp2.normalImpulse = xy;
                            if(ContactSolver.DEBUG_SOLVER) {
                                let dv2 : org.jbox2d.common.Vec2 = vB.add(org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(wB, cp2rB).subLocal(vA).subLocal(org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(wA, cp2rA)));
                                vn2 = org.jbox2d.common.Vec2.dot(dv2, normal);
                            }
                            break;
                        }
                        xx = 0.0;
                        xy = 0.0;
                        vn1 = bx;
                        vn2 = by;
                        if(vn1 >= 0.0 && vn2 >= 0.0) {
                            let dx : number = (<any>Math).fround(xx - ax);
                            let dy : number = (<any>Math).fround(xy - ay);
                            let P1x : number = (<any>Math).fround(normalx * dx);
                            let P1y : number = (<any>Math).fround(normaly * dx);
                            let P2x : number = (<any>Math).fround(normalx * dy);
                            let P2y : number = (<any>Math).fround(normaly * dy);
                            vA.x -= (<any>Math).fround(mA * ((<any>Math).fround(P1x + P2x)));
                            vA.y -= (<any>Math).fround(mA * ((<any>Math).fround(P1y + P2y)));
                            vB.x += (<any>Math).fround(mB * ((<any>Math).fround(P1x + P2x)));
                            vB.y += (<any>Math).fround(mB * ((<any>Math).fround(P1y + P2y)));
                            wA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(cp1rA.x * P1y) - (<any>Math).fround(cp1rA.y * P1x)) + ((<any>Math).fround((<any>Math).fround(cp2rA.x * P2y) - (<any>Math).fround(cp2rA.y * P2x))))));
                            wB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(cp1rB.x * P1y) - (<any>Math).fround(cp1rB.y * P1x)) + ((<any>Math).fround((<any>Math).fround(cp2rB.x * P2y) - (<any>Math).fround(cp2rB.y * P2x))))));
                            cp1.normalImpulse = xx;
                            cp2.normalImpulse = xy;
                            break;
                        }
                        break;
                    };
                }
                this.m_velocities[indexA].w = wA;
                this.m_velocities[indexB].w = wB;
            };
        }

        public storeImpulses() {
            for(let i : number = 0; i < this.m_count; i++) {
                let vc : org.jbox2d.dynamics.contacts.ContactVelocityConstraint = this.m_velocityConstraints[i];
                let manifold : org.jbox2d.collision.Manifold = this.m_contacts[vc.contactIndex].getManifold();
                for(let j : number = 0; j < vc.pointCount; j++) {
                    manifold.points[j].normalImpulse = vc.points[j].normalImpulse;
                    manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;
                };
            };
        }

        /*private*/ psolver : org.jbox2d.dynamics.contacts.PositionSolverManifold = new org.jbox2d.dynamics.contacts.PositionSolverManifold();

        /**
         * Sequential solver.
         * @return {boolean}
         */
        public solvePositionConstraints() : boolean {
            let minSeparation : number = 0.0;
            for(let i : number = 0; i < this.m_count; ++i) {
                let pc : org.jbox2d.dynamics.contacts.ContactPositionConstraint = this.m_positionConstraints[i];
                let indexA : number = pc.indexA;
                let indexB : number = pc.indexB;
                let mA : number = pc.invMassA;
                let iA : number = pc.invIA;
                let localCenterA : org.jbox2d.common.Vec2 = pc.localCenterA;
                let localCenterAx : number = localCenterA.x;
                let localCenterAy : number = localCenterA.y;
                let mB : number = pc.invMassB;
                let iB : number = pc.invIB;
                let localCenterB : org.jbox2d.common.Vec2 = pc.localCenterB;
                let localCenterBx : number = localCenterB.x;
                let localCenterBy : number = localCenterB.y;
                let pointCount : number = pc.pointCount;
                let cA : org.jbox2d.common.Vec2 = this.m_positions[indexA].c;
                let aA : number = this.m_positions[indexA].a;
                let cB : org.jbox2d.common.Vec2 = this.m_positions[indexB].c;
                let aB : number = this.m_positions[indexB].a;
                for(let j : number = 0; j < pointCount; ++j) {
                    let xfAq : org.jbox2d.common.Rot = this.xfA.q;
                    let xfBq : org.jbox2d.common.Rot = this.xfB.q;
                    xfAq.set$float(aA);
                    xfBq.set$float(aB);
                    this.xfA.p.x = (<any>Math).fround((<any>Math).fround(cA.x - (<any>Math).fround(xfAq.c * localCenterAx)) + (<any>Math).fround(xfAq.s * localCenterAy));
                    this.xfA.p.y = (<any>Math).fround((<any>Math).fround(cA.y - (<any>Math).fround(xfAq.s * localCenterAx)) - (<any>Math).fround(xfAq.c * localCenterAy));
                    this.xfB.p.x = (<any>Math).fround((<any>Math).fround(cB.x - (<any>Math).fround(xfBq.c * localCenterBx)) + (<any>Math).fround(xfBq.s * localCenterBy));
                    this.xfB.p.y = (<any>Math).fround((<any>Math).fround(cB.y - (<any>Math).fround(xfBq.s * localCenterBx)) - (<any>Math).fround(xfBq.c * localCenterBy));
                    let psm : org.jbox2d.dynamics.contacts.PositionSolverManifold = this.psolver;
                    psm.initialize(pc, this.xfA, this.xfB, j);
                    let normal : org.jbox2d.common.Vec2 = psm.normal;
                    let point : org.jbox2d.common.Vec2 = psm.point;
                    let separation : number = psm.separation;
                    let rAx : number = (<any>Math).fround(point.x - cA.x);
                    let rAy : number = (<any>Math).fround(point.y - cA.y);
                    let rBx : number = (<any>Math).fround(point.x - cB.x);
                    let rBy : number = (<any>Math).fround(point.y - cB.y);
                    minSeparation = org.jbox2d.common.MathUtils.min$float$float(minSeparation, separation);
                    let C : number = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(org.jbox2d.common.Settings.baumgarte * ((<any>Math).fround(separation + org.jbox2d.common.Settings.linearSlop))), -org.jbox2d.common.Settings.maxLinearCorrection, 0.0);
                    let rnA : number = (<any>Math).fround((<any>Math).fround(rAx * normal.y) - (<any>Math).fround(rAy * normal.x));
                    let rnB : number = (<any>Math).fround((<any>Math).fround(rBx * normal.y) - (<any>Math).fround(rBy * normal.x));
                    let K : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * rnA) * rnA)) + (<any>Math).fround((<any>Math).fround(iB * rnB) * rnB));
                    let impulse : number = K > 0.0?(<any>Math).fround(-C / K):0.0;
                    let Px : number = (<any>Math).fround(normal.x * impulse);
                    let Py : number = (<any>Math).fround(normal.y * impulse);
                    cA.x -= (<any>Math).fround(Px * mA);
                    cA.y -= (<any>Math).fround(Py * mA);
                    aA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround(rAx * Py) - (<any>Math).fround(rAy * Px))));
                    cB.x += (<any>Math).fround(Px * mB);
                    cB.y += (<any>Math).fround(Py * mB);
                    aB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround(rBx * Py) - (<any>Math).fround(rBy * Px))));
                };
                this.m_positions[indexA].a = aA;
                this.m_positions[indexB].a = aB;
            };
            return minSeparation >= (<any>Math).fround(-3.0 * org.jbox2d.common.Settings.linearSlop);
        }

        public solveTOIPositionConstraints(toiIndexA : number, toiIndexB : number) : boolean {
            let minSeparation : number = 0.0;
            for(let i : number = 0; i < this.m_count; ++i) {
                let pc : org.jbox2d.dynamics.contacts.ContactPositionConstraint = this.m_positionConstraints[i];
                let indexA : number = pc.indexA;
                let indexB : number = pc.indexB;
                let localCenterA : org.jbox2d.common.Vec2 = pc.localCenterA;
                let localCenterB : org.jbox2d.common.Vec2 = pc.localCenterB;
                let localCenterAx : number = localCenterA.x;
                let localCenterAy : number = localCenterA.y;
                let localCenterBx : number = localCenterB.x;
                let localCenterBy : number = localCenterB.y;
                let pointCount : number = pc.pointCount;
                let mA : number = 0.0;
                let iA : number = 0.0;
                if(indexA === toiIndexA || indexA === toiIndexB) {
                    mA = pc.invMassA;
                    iA = pc.invIA;
                }
                let mB : number = 0.0;
                let iB : number = 0.0;
                if(indexB === toiIndexA || indexB === toiIndexB) {
                    mB = pc.invMassB;
                    iB = pc.invIB;
                }
                let cA : org.jbox2d.common.Vec2 = this.m_positions[indexA].c;
                let aA : number = this.m_positions[indexA].a;
                let cB : org.jbox2d.common.Vec2 = this.m_positions[indexB].c;
                let aB : number = this.m_positions[indexB].a;
                for(let j : number = 0; j < pointCount; ++j) {
                    let xfAq : org.jbox2d.common.Rot = this.xfA.q;
                    let xfBq : org.jbox2d.common.Rot = this.xfB.q;
                    xfAq.set$float(aA);
                    xfBq.set$float(aB);
                    this.xfA.p.x = (<any>Math).fround((<any>Math).fround(cA.x - (<any>Math).fround(xfAq.c * localCenterAx)) + (<any>Math).fround(xfAq.s * localCenterAy));
                    this.xfA.p.y = (<any>Math).fround((<any>Math).fround(cA.y - (<any>Math).fround(xfAq.s * localCenterAx)) - (<any>Math).fround(xfAq.c * localCenterAy));
                    this.xfB.p.x = (<any>Math).fround((<any>Math).fround(cB.x - (<any>Math).fround(xfBq.c * localCenterBx)) + (<any>Math).fround(xfBq.s * localCenterBy));
                    this.xfB.p.y = (<any>Math).fround((<any>Math).fround(cB.y - (<any>Math).fround(xfBq.s * localCenterBx)) - (<any>Math).fround(xfBq.c * localCenterBy));
                    let psm : org.jbox2d.dynamics.contacts.PositionSolverManifold = this.psolver;
                    psm.initialize(pc, this.xfA, this.xfB, j);
                    let normal : org.jbox2d.common.Vec2 = psm.normal;
                    let point : org.jbox2d.common.Vec2 = psm.point;
                    let separation : number = psm.separation;
                    let rAx : number = (<any>Math).fround(point.x - cA.x);
                    let rAy : number = (<any>Math).fround(point.y - cA.y);
                    let rBx : number = (<any>Math).fround(point.x - cB.x);
                    let rBy : number = (<any>Math).fround(point.y - cB.y);
                    minSeparation = org.jbox2d.common.MathUtils.min$float$float(minSeparation, separation);
                    let C : number = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(org.jbox2d.common.Settings.toiBaugarte * ((<any>Math).fround(separation + org.jbox2d.common.Settings.linearSlop))), -org.jbox2d.common.Settings.maxLinearCorrection, 0.0);
                    let rnA : number = (<any>Math).fround((<any>Math).fround(rAx * normal.y) - (<any>Math).fround(rAy * normal.x));
                    let rnB : number = (<any>Math).fround((<any>Math).fround(rBx * normal.y) - (<any>Math).fround(rBy * normal.x));
                    let K : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * rnA) * rnA)) + (<any>Math).fround((<any>Math).fround(iB * rnB) * rnB));
                    let impulse : number = K > 0.0?(<any>Math).fround(-C / K):0.0;
                    let Px : number = (<any>Math).fround(normal.x * impulse);
                    let Py : number = (<any>Math).fround(normal.y * impulse);
                    cA.x -= (<any>Math).fround(Px * mA);
                    cA.y -= (<any>Math).fround(Py * mA);
                    aA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround(rAx * Py) - (<any>Math).fround(rAy * Px))));
                    cB.x += (<any>Math).fround(Px * mB);
                    cB.y += (<any>Math).fround(Py * mB);
                    aB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround(rBx * Py) - (<any>Math).fround(rBy * Px))));
                };
                this.m_positions[indexA].a = aA;
                this.m_positions[indexB].a = aB;
            };
            return minSeparation >= (<any>Math).fround(-1.5 * org.jbox2d.common.Settings.linearSlop);
        }
    }
    ContactSolver["__class"] = "org.jbox2d.dynamics.contacts.ContactSolver";


    export namespace ContactSolver {

        export class ContactSolverDef {
            public step : org.jbox2d.dynamics.TimeStep;

            public contacts : org.jbox2d.dynamics.contacts.Contact[];

            public count : number;

            public positions : org.jbox2d.dynamics.contacts.Position[];

            public velocities : org.jbox2d.dynamics.contacts.Velocity[];

            constructor() {
                if(this.step===undefined) this.step = null;
                if(this.contacts===undefined) this.contacts = null;
                if(this.count===undefined) this.count = 0;
                if(this.positions===undefined) this.positions = null;
                if(this.velocities===undefined) this.velocities = null;
            }
        }
        ContactSolverDef["__class"] = "org.jbox2d.dynamics.contacts.ContactSolver.ContactSolverDef";

    }


    export class PositionSolverManifold {
        public normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public point : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public separation : number;

        public initialize(pc : org.jbox2d.dynamics.contacts.ContactPositionConstraint, xfA : org.jbox2d.common.Transform, xfB : org.jbox2d.common.Transform, index : number) {
            let xfAq : org.jbox2d.common.Rot = xfA.q;
            let xfBq : org.jbox2d.common.Rot = xfB.q;
            let pcLocalPointsI : org.jbox2d.common.Vec2 = pc.localPoints[index];
            switch((pc.type)) {
            case org.jbox2d.collision.Manifold.ManifoldType.CIRCLES:
                {
                    let plocalPoint : org.jbox2d.common.Vec2 = pc.localPoint;
                    let pLocalPoints0 : org.jbox2d.common.Vec2 = pc.localPoints[0];
                    let pointAx : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfAq.c * plocalPoint.x) - (<any>Math).fround(xfAq.s * plocalPoint.y))) + xfA.p.x);
                    let pointAy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfAq.s * plocalPoint.x) + (<any>Math).fround(xfAq.c * plocalPoint.y))) + xfA.p.y);
                    let pointBx : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfBq.c * pLocalPoints0.x) - (<any>Math).fround(xfBq.s * pLocalPoints0.y))) + xfB.p.x);
                    let pointBy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfBq.s * pLocalPoints0.x) + (<any>Math).fround(xfBq.c * pLocalPoints0.y))) + xfB.p.y);
                    this.normal.x = (<any>Math).fround(pointBx - pointAx);
                    this.normal.y = (<any>Math).fround(pointBy - pointAy);
                    this.normal.normalize();
                    this.point.x = (<any>Math).fround(((<any>Math).fround(pointAx + pointBx)) * 0.5);
                    this.point.y = (<any>Math).fround(((<any>Math).fround(pointAy + pointBy)) * 0.5);
                    let tempx : number = (<any>Math).fround(pointBx - pointAx);
                    let tempy : number = (<any>Math).fround(pointBy - pointAy);
                    this.separation = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(tempx * this.normal.x) + (<any>Math).fround(tempy * this.normal.y)) - pc.radiusA) - pc.radiusB);
                    break;
                };
            case org.jbox2d.collision.Manifold.ManifoldType.FACE_A:
                {
                    let pcLocalNormal : org.jbox2d.common.Vec2 = pc.localNormal;
                    let pcLocalPoint : org.jbox2d.common.Vec2 = pc.localPoint;
                    this.normal.x = (<any>Math).fround((<any>Math).fround(xfAq.c * pcLocalNormal.x) - (<any>Math).fround(xfAq.s * pcLocalNormal.y));
                    this.normal.y = (<any>Math).fround((<any>Math).fround(xfAq.s * pcLocalNormal.x) + (<any>Math).fround(xfAq.c * pcLocalNormal.y));
                    let planePointx : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfAq.c * pcLocalPoint.x) - (<any>Math).fround(xfAq.s * pcLocalPoint.y))) + xfA.p.x);
                    let planePointy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfAq.s * pcLocalPoint.x) + (<any>Math).fround(xfAq.c * pcLocalPoint.y))) + xfA.p.y);
                    let clipPointx : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfBq.c * pcLocalPointsI.x) - (<any>Math).fround(xfBq.s * pcLocalPointsI.y))) + xfB.p.x);
                    let clipPointy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfBq.s * pcLocalPointsI.x) + (<any>Math).fround(xfBq.c * pcLocalPointsI.y))) + xfB.p.y);
                    let tempx : number = (<any>Math).fround(clipPointx - planePointx);
                    let tempy : number = (<any>Math).fround(clipPointy - planePointy);
                    this.separation = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(tempx * this.normal.x) + (<any>Math).fround(tempy * this.normal.y)) - pc.radiusA) - pc.radiusB);
                    this.point.x = clipPointx;
                    this.point.y = clipPointy;
                    break;
                };
            case org.jbox2d.collision.Manifold.ManifoldType.FACE_B:
                {
                    let pcLocalNormal : org.jbox2d.common.Vec2 = pc.localNormal;
                    let pcLocalPoint : org.jbox2d.common.Vec2 = pc.localPoint;
                    this.normal.x = (<any>Math).fround((<any>Math).fround(xfBq.c * pcLocalNormal.x) - (<any>Math).fround(xfBq.s * pcLocalNormal.y));
                    this.normal.y = (<any>Math).fround((<any>Math).fround(xfBq.s * pcLocalNormal.x) + (<any>Math).fround(xfBq.c * pcLocalNormal.y));
                    let planePointx : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfBq.c * pcLocalPoint.x) - (<any>Math).fround(xfBq.s * pcLocalPoint.y))) + xfB.p.x);
                    let planePointy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfBq.s * pcLocalPoint.x) + (<any>Math).fround(xfBq.c * pcLocalPoint.y))) + xfB.p.y);
                    let clipPointx : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfAq.c * pcLocalPointsI.x) - (<any>Math).fround(xfAq.s * pcLocalPointsI.y))) + xfA.p.x);
                    let clipPointy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfAq.s * pcLocalPointsI.x) + (<any>Math).fround(xfAq.c * pcLocalPointsI.y))) + xfA.p.y);
                    let tempx : number = (<any>Math).fround(clipPointx - planePointx);
                    let tempy : number = (<any>Math).fround(clipPointy - planePointy);
                    this.separation = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(tempx * this.normal.x) + (<any>Math).fround(tempy * this.normal.y)) - pc.radiusA) - pc.radiusB);
                    this.point.x = clipPointx;
                    this.point.y = clipPointy;
                    this.normal.x *= -1;
                    this.normal.y *= -1;
                };
                break;
            }
        }

        constructor() {
            if(this.separation===undefined) this.separation = 0;
        }
    }
    PositionSolverManifold["__class"] = "org.jbox2d.dynamics.contacts.PositionSolverManifold";

}
namespace org.jbox2d.dynamics.contacts {
    export class ContactVelocityConstraint {
        public points : ContactVelocityConstraint.VelocityConstraintPoint[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);

        public normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public normalMass : org.jbox2d.common.Mat22 = new org.jbox2d.common.Mat22();

        public K : org.jbox2d.common.Mat22 = new org.jbox2d.common.Mat22();

        public indexA : number;

        public indexB : number;

        public invMassA : number;

        public invMassB : number;

        public invIA : number;

        public invIB : number;

        public friction : number;

        public restitution : number;

        public tangentSpeed : number;

        public pointCount : number;

        public contactIndex : number;

        public constructor() {
            if(this.indexA===undefined) this.indexA = 0;
            if(this.indexB===undefined) this.indexB = 0;
            if(this.invMassA===undefined) this.invMassA = 0;
            if(this.invMassB===undefined) this.invMassB = 0;
            if(this.invIA===undefined) this.invIA = 0;
            if(this.invIB===undefined) this.invIB = 0;
            if(this.friction===undefined) this.friction = 0;
            if(this.restitution===undefined) this.restitution = 0;
            if(this.tangentSpeed===undefined) this.tangentSpeed = 0;
            if(this.pointCount===undefined) this.pointCount = 0;
            if(this.contactIndex===undefined) this.contactIndex = 0;
            for(let i : number = 0; i < this.points.length; i++) {
                this.points[i] = new ContactVelocityConstraint.VelocityConstraintPoint();
            };
        }
    }
    ContactVelocityConstraint["__class"] = "org.jbox2d.dynamics.contacts.ContactVelocityConstraint";


    export namespace ContactVelocityConstraint {

        export class VelocityConstraintPoint {
            public rA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            public rB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            public normalImpulse : number;

            public tangentImpulse : number;

            public normalMass : number;

            public tangentMass : number;

            public velocityBias : number;

            constructor() {
                if(this.normalImpulse===undefined) this.normalImpulse = 0;
                if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
                if(this.normalMass===undefined) this.normalMass = 0;
                if(this.tangentMass===undefined) this.tangentMass = 0;
                if(this.velocityBias===undefined) this.velocityBias = 0;
            }
        }
        VelocityConstraintPoint["__class"] = "org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint";

    }

}
namespace org.jbox2d.dynamics.contacts {
    export class Position {
        public c : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public a : number;

        constructor() {
            if(this.a===undefined) this.a = 0;
        }
    }
    Position["__class"] = "org.jbox2d.dynamics.contacts.Position";

}
namespace org.jbox2d.dynamics.contacts {
    export class Velocity {
        public v : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public w : number;

        constructor() {
            if(this.w===undefined) this.w = 0;
        }
    }
    Velocity["__class"] = "org.jbox2d.dynamics.contacts.Velocity";

}
namespace org.jbox2d.dynamics {
    /**
     * This holds contact filtering data.
     * 
     * @author daniel
     * @class
     */
    export class Filter {
        /**
         * The collision category bits. Normally you would just set one bit.
         */
        public categoryBits : number;

        /**
         * The collision mask bits. This states the categories that this
         * shape would accept for collision.
         */
        public maskBits : number;

        /**
         * Collision groups allow a certain group of objects to never collide (negative)
         * or always collide (positive). Zero means no collision group. Non-zero group
         * filtering always wins against the mask bits.
         */
        public groupIndex : number;

        public constructor() {
            if(this.categoryBits===undefined) this.categoryBits = 0;
            if(this.maskBits===undefined) this.maskBits = 0;
            if(this.groupIndex===undefined) this.groupIndex = 0;
            this.categoryBits = 1;
            this.maskBits = 65535;
            this.groupIndex = 0;
        }

        public set(argOther : Filter) {
            this.categoryBits = argOther.categoryBits;
            this.maskBits = argOther.maskBits;
            this.groupIndex = argOther.groupIndex;
        }
    }
    Filter["__class"] = "org.jbox2d.dynamics.Filter";

}
namespace org.jbox2d.dynamics {
    /**
     * A fixture is used to attach a shape to a body for collision detection. A fixture inherits its
     * transform from its parent. Fixtures hold additional non-geometric data such as friction,
     * collision filters, etc. Fixtures are created via Body::CreateFixture.
     * 
     * @warning you cannot reuse fixtures.
     * 
     * @author daniel
     * @class
     */
    export class Fixture {
        public m_density : number;

        public m_next : Fixture;

        public m_body : org.jbox2d.dynamics.Body;

        public m_shape : org.jbox2d.collision.shapes.Shape;

        public m_friction : number;

        public m_restitution : number;

        public m_proxies : org.jbox2d.dynamics.FixtureProxy[];

        public m_proxyCount : number;

        public m_filter : org.jbox2d.dynamics.Filter;

        public m_isSensor : boolean;

        public m_userData : any;

        public constructor() {
            if(this.m_density===undefined) this.m_density = 0;
            if(this.m_next===undefined) this.m_next = null;
            if(this.m_body===undefined) this.m_body = null;
            if(this.m_shape===undefined) this.m_shape = null;
            if(this.m_friction===undefined) this.m_friction = 0;
            if(this.m_restitution===undefined) this.m_restitution = 0;
            if(this.m_proxies===undefined) this.m_proxies = null;
            if(this.m_proxyCount===undefined) this.m_proxyCount = 0;
            if(this.m_filter===undefined) this.m_filter = null;
            if(this.m_isSensor===undefined) this.m_isSensor = false;
            if(this.m_userData===undefined) this.m_userData = null;
            this.m_userData = null;
            this.m_body = null;
            this.m_next = null;
            this.m_proxies = null;
            this.m_proxyCount = 0;
            this.m_shape = null;
            this.m_filter = new org.jbox2d.dynamics.Filter();
        }

        /**
         * Get the type of the child shape. You can use this to down cast to the concrete shape.
         * 
         * @return {org.jbox2d.collision.shapes.ShapeType} the shape type.
         */
        public getType() : org.jbox2d.collision.shapes.ShapeType {
            return this.m_shape.getType();
        }

        /**
         * Get the child shape. You can modify the child shape, however you should not change the number
         * of vertices because this will crash some collision caching mechanisms.
         * 
         * @return
         * @return {org.jbox2d.collision.shapes.Shape}
         */
        public getShape() : org.jbox2d.collision.shapes.Shape {
            return this.m_shape;
        }

        /**
         * Is this fixture a sensor (non-solid)?
         * 
         * @return {boolean} the true if the shape is a sensor.
         * @return
         */
        public isSensor() : boolean {
            return this.m_isSensor;
        }

        /**
         * Set if this fixture is a sensor.
         * 
         * @param {boolean} sensor
         */
        public setSensor(sensor : boolean) {
            if(sensor !== this.m_isSensor) {
                this.m_body.setAwake(true);
                this.m_isSensor = sensor;
            }
        }

        /**
         * Set the contact filtering data. This is an expensive operation and should not be called
         * frequently. This will not update contacts until the next time step when either parent body is
         * awake. This automatically calls refilter.
         * 
         * @param {org.jbox2d.dynamics.Filter} filter
         */
        public setFilterData(filter : org.jbox2d.dynamics.Filter) {
            this.m_filter.set(filter);
            this.refilter();
        }

        /**
         * Get the contact filtering data.
         * 
         * @return
         * @return {org.jbox2d.dynamics.Filter}
         */
        public getFilterData() : org.jbox2d.dynamics.Filter {
            return this.m_filter;
        }

        /**
         * Call this if you want to establish collision that was previously disabled by
         * ContactFilter::ShouldCollide.
         */
        public refilter() {
            if(this.m_body == null) {
                return;
            }
            let edge : org.jbox2d.dynamics.contacts.ContactEdge = this.m_body.getContactList();
            while((edge != null)) {
                let contact : org.jbox2d.dynamics.contacts.Contact = edge.contact;
                let fixtureA : Fixture = contact.getFixtureA();
                let fixtureB : Fixture = contact.getFixtureB();
                if(fixtureA === this || fixtureB === this) {
                    contact.flagForFiltering();
                }
                edge = edge.next;
            };
            let world : org.jbox2d.dynamics.World = this.m_body.getWorld();
            if(world == null) {
                return;
            }
            let broadPhase : org.jbox2d.collision.broadphase.BroadPhase = world.m_contactManager.m_broadPhase;
            for(let i : number = 0; i < this.m_proxyCount; ++i) {
                broadPhase.touchProxy(this.m_proxies[i].proxyId);
            };
        }

        /**
         * Get the parent body of this fixture. This is NULL if the fixture is not attached.
         * 
         * @return {org.jbox2d.dynamics.Body} the parent body.
         * @return
         */
        public getBody() : org.jbox2d.dynamics.Body {
            return this.m_body;
        }

        /**
         * Get the next fixture in the parent body's fixture list.
         * 
         * @return {org.jbox2d.dynamics.Fixture} the next shape.
         * @return
         */
        public getNext() : Fixture {
            return this.m_next;
        }

        public setDensity(density : number) {
            this.m_density = density;
        }

        public getDensity() : number {
            return this.m_density;
        }

        /**
         * Get the user data that was assigned in the fixture definition. Use this to store your
         * application specific data.
         * 
         * @return
         * @return {*}
         */
        public getUserData() : any {
            return this.m_userData;
        }

        /**
         * Set the user data. Use this to store your application specific data.
         * 
         * @param {*} data
         */
        public setUserData(data : any) {
            this.m_userData = data;
        }

        /**
         * Test a point for containment in this fixture. This only works for convex shapes.
         * 
         * @param {org.jbox2d.common.Vec2} p a point in world coordinates.
         * @return
         * @return {boolean}
         */
        public testPoint(p : org.jbox2d.common.Vec2) : boolean {
            return this.m_shape.testPoint(this.m_body.m_xf, p);
        }

        /**
         * Cast a ray against this shape.
         * 
         * @param {org.jbox2d.collision.RayCastOutput} output the ray-cast results.
         * @param {org.jbox2d.collision.RayCastInput} input the ray-cast input parameters.
         * @param {org.jbox2d.collision.RayCastOutput} output
         * @param {org.jbox2d.collision.RayCastInput} input
         * @param {number} childIndex
         * @return {boolean}
         */
        public raycast(output : org.jbox2d.collision.RayCastOutput, input : org.jbox2d.collision.RayCastInput, childIndex : number) : boolean {
            return this.m_shape.raycast(output, input, this.m_body.m_xf, childIndex);
        }

        /**
         * Get the mass data for this fixture. The mass data is based on the density and the shape. The
         * rotational inertia is about the shape's origin.
         * 
         * @return
         * @param {org.jbox2d.collision.shapes.MassData} massData
         */
        public getMassData(massData : org.jbox2d.collision.shapes.MassData) {
            this.m_shape.computeMass(massData, this.m_density);
        }

        /**
         * Get the coefficient of friction.
         * 
         * @return
         * @return {number}
         */
        public getFriction() : number {
            return this.m_friction;
        }

        /**
         * Set the coefficient of friction. This will _not_ change the friction of existing contacts.
         * 
         * @param {number} friction
         */
        public setFriction(friction : number) {
            this.m_friction = friction;
        }

        /**
         * Get the coefficient of restitution.
         * 
         * @return
         * @return {number}
         */
        public getRestitution() : number {
            return this.m_restitution;
        }

        /**
         * Set the coefficient of restitution. This will _not_ change the restitution of existing
         * contacts.
         * 
         * @param {number} restitution
         */
        public setRestitution(restitution : number) {
            this.m_restitution = restitution;
        }

        /**
         * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a more accurate
         * AABB, compute it using the shape and the body transform.
         * 
         * @return
         * @param {number} childIndex
         * @return {org.jbox2d.collision.AABB}
         */
        public getAABB(childIndex : number) : org.jbox2d.collision.AABB {
            return this.m_proxies[childIndex].aabb;
        }

        /**
         * Compute the distance from this fixture.
         * 
         * @param {org.jbox2d.common.Vec2} p a point in world coordinates.
         * @return {number} distance
         * @param {number} childIndex
         * @param {org.jbox2d.common.Vec2} normalOut
         */
        public computeDistance(p : org.jbox2d.common.Vec2, childIndex : number, normalOut : org.jbox2d.common.Vec2) : number {
            return this.m_shape.computeDistanceToOut(this.m_body.getTransform(), p, childIndex, normalOut);
        }

        public create(body : org.jbox2d.dynamics.Body, def : org.jbox2d.dynamics.FixtureDef) {
            this.m_userData = def.userData;
            this.m_friction = def.friction;
            this.m_restitution = def.restitution;
            this.m_body = body;
            this.m_next = null;
            this.m_filter.set(def.filter);
            this.m_isSensor = def.__isSensor;
            this.m_shape = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.shape);
            let childCount : number = this.m_shape.getChildCount();
            if(this.m_proxies == null) {
                this.m_proxies = (s => { let a=[]; while(s-->0) a.push(null); return a; })(childCount);
                for(let i : number = 0; i < childCount; i++) {
                    this.m_proxies[i] = new org.jbox2d.dynamics.FixtureProxy();
                    this.m_proxies[i].fixture = null;
                    this.m_proxies[i].proxyId = org.jbox2d.collision.broadphase.BroadPhase.NULL_PROXY;
                };
            }
            if(this.m_proxies.length < childCount) {
                let old : org.jbox2d.dynamics.FixtureProxy[] = this.m_proxies;
                let newLen : number = org.jbox2d.common.MathUtils.max$int$int(old.length * 2, childCount);
                this.m_proxies = (s => { let a=[]; while(s-->0) a.push(null); return a; })(newLen);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(old, 0, this.m_proxies, 0, old.length);
                for(let i : number = 0; i < newLen; i++) {
                    if(i >= old.length) {
                        this.m_proxies[i] = new org.jbox2d.dynamics.FixtureProxy();
                    }
                    this.m_proxies[i].fixture = null;
                    this.m_proxies[i].proxyId = org.jbox2d.collision.broadphase.BroadPhase.NULL_PROXY;
                };
            }
            this.m_proxyCount = 0;
            this.m_density = def.density;
        }

        public destroy() {
            this.m_shape = null;
            this.m_proxies = null;
            this.m_next = null;
        }

        public createProxies(broadPhase : org.jbox2d.collision.broadphase.BroadPhase, xf : org.jbox2d.common.Transform) {
            this.m_proxyCount = this.m_shape.getChildCount();
            for(let i : number = 0; i < this.m_proxyCount; ++i) {
                let proxy : org.jbox2d.dynamics.FixtureProxy = this.m_proxies[i];
                this.m_shape.computeAABB(proxy.aabb, xf, i);
                proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);
                proxy.fixture = this;
                proxy.childIndex = i;
            };
        }

        /**
         * Internal method
         * 
         * @param {*} broadPhase
         */
        public destroyProxies(broadPhase : org.jbox2d.collision.broadphase.BroadPhase) {
            for(let i : number = 0; i < this.m_proxyCount; ++i) {
                let proxy : org.jbox2d.dynamics.FixtureProxy = this.m_proxies[i];
                broadPhase.destroyProxy(proxy.proxyId);
                proxy.proxyId = org.jbox2d.collision.broadphase.BroadPhase.NULL_PROXY;
            };
            this.m_proxyCount = 0;
        }

        /*private*/ pool1 : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ pool2 : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ displacement : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * Internal method
         * 
         * @param {*} broadPhase
         * @param xf1
         * @param xf2
         * @param {org.jbox2d.common.Transform} transform1
         * @param {org.jbox2d.common.Transform} transform2
         */
        synchronize(broadPhase : org.jbox2d.collision.broadphase.BroadPhase, transform1 : org.jbox2d.common.Transform, transform2 : org.jbox2d.common.Transform) {
            if(this.m_proxyCount === 0) {
                return;
            }
            for(let i : number = 0; i < this.m_proxyCount; ++i) {
                let proxy : org.jbox2d.dynamics.FixtureProxy = this.m_proxies[i];
                let aabb1 : org.jbox2d.collision.AABB = this.pool1;
                let aab : org.jbox2d.collision.AABB = this.pool2;
                this.m_shape.computeAABB(aabb1, transform1, proxy.childIndex);
                this.m_shape.computeAABB(aab, transform2, proxy.childIndex);
                proxy.aabb.lowerBound.x = aabb1.lowerBound.x < aab.lowerBound.x?aabb1.lowerBound.x:aab.lowerBound.x;
                proxy.aabb.lowerBound.y = aabb1.lowerBound.y < aab.lowerBound.y?aabb1.lowerBound.y:aab.lowerBound.y;
                proxy.aabb.upperBound.x = aabb1.upperBound.x > aab.upperBound.x?aabb1.upperBound.x:aab.upperBound.x;
                proxy.aabb.upperBound.y = aabb1.upperBound.y > aab.upperBound.y?aabb1.upperBound.y:aab.upperBound.y;
                this.displacement.x = (<any>Math).fround(transform2.p.x - transform1.p.x);
                this.displacement.y = (<any>Math).fround(transform2.p.y - transform1.p.y);
                broadPhase.moveProxy(proxy.proxyId, proxy.aabb, this.displacement);
            };
        }
    }
    Fixture["__class"] = "org.jbox2d.dynamics.Fixture";

}
namespace org.jbox2d.dynamics {
    /**
     * A fixture definition is used to create a fixture. This class defines an abstract fixture
     * definition. You can reuse fixture definitions safely.
     * 
     * @author daniel
     * @class
     */
    export class FixtureDef {
        /**
         * The shape, this must be set. The shape will be cloned, so you can create the shape on the
         * stack.
         */
        public shape : org.jbox2d.collision.shapes.Shape = null;

        /**
         * Use this to store application specific fixture data.
         */
        public userData : any;

        /**
         * The friction coefficient, usually in the range [0,1].
         */
        public friction : number;

        /**
         * The restitution (elasticity) usually in the range [0,1].
         */
        public restitution : number;

        /**
         * The density, usually in kg/m^2
         */
        public density : number;

        /**
         * A sensor shape collects contact information but never generates a collision response.
         */
        public __isSensor : boolean;

        /**
         * Contact filtering data;
         */
        public filter : org.jbox2d.dynamics.Filter;

        public constructor() {
            if(this.userData===undefined) this.userData = null;
            if(this.friction===undefined) this.friction = 0;
            if(this.restitution===undefined) this.restitution = 0;
            if(this.density===undefined) this.density = 0;
            if(this.__isSensor===undefined) this.__isSensor = false;
            if(this.filter===undefined) this.filter = null;
            this.shape = null;
            this.userData = null;
            this.friction = 0.2;
            this.restitution = 0.0;
            this.density = 0.0;
            this.filter = new org.jbox2d.dynamics.Filter();
            this.__isSensor = false;
        }

        /**
         * The shape, this must be set. The shape will be cloned, so you can create the shape on the
         * stack.
         * @return {org.jbox2d.collision.shapes.Shape}
         */
        public getShape() : org.jbox2d.collision.shapes.Shape {
            return this.shape;
        }

        /**
         * The shape, this must be set. The shape will be cloned, so you can create the shape on the
         * stack.
         * @param {org.jbox2d.collision.shapes.Shape} shape
         */
        public setShape(shape : org.jbox2d.collision.shapes.Shape) {
            this.shape = shape;
        }

        /**
         * Use this to store application specific fixture data.
         * @return {*}
         */
        public getUserData() : any {
            return this.userData;
        }

        /**
         * Use this to store application specific fixture data.
         * @param {*} userData
         */
        public setUserData(userData : any) {
            this.userData = userData;
        }

        /**
         * The friction coefficient, usually in the range [0,1].
         * @return {number}
         */
        public getFriction() : number {
            return this.friction;
        }

        /**
         * The friction coefficient, usually in the range [0,1].
         * @param {number} friction
         */
        public setFriction(friction : number) {
            this.friction = friction;
        }

        /**
         * The restitution (elasticity) usually in the range [0,1].
         * @return {number}
         */
        public getRestitution() : number {
            return this.restitution;
        }

        /**
         * The restitution (elasticity) usually in the range [0,1].
         * @param {number} restitution
         */
        public setRestitution(restitution : number) {
            this.restitution = restitution;
        }

        /**
         * The density, usually in kg/m^2
         * @return {number}
         */
        public getDensity() : number {
            return this.density;
        }

        /**
         * The density, usually in kg/m^2
         * @param {number} density
         */
        public setDensity(density : number) {
            this.density = density;
        }

        /**
         * A sensor shape collects contact information but never generates a collision response.
         * @return {boolean}
         */
        public isSensor() : boolean {
            return this.__isSensor;
        }

        /**
         * A sensor shape collects contact information but never generates a collision response.
         * @param {boolean} isSensor
         */
        public setSensor(isSensor : boolean) {
            this.__isSensor = isSensor;
        }

        /**
         * Contact filtering data;
         * @return {org.jbox2d.dynamics.Filter}
         */
        public getFilter() : org.jbox2d.dynamics.Filter {
            return this.filter;
        }

        /**
         * Contact filtering data;
         * @param {org.jbox2d.dynamics.Filter} filter
         */
        public setFilter(filter : org.jbox2d.dynamics.Filter) {
            this.filter = filter;
        }
    }
    FixtureDef["__class"] = "org.jbox2d.dynamics.FixtureDef";

}
namespace org.jbox2d.dynamics {
    /**
     * This proxy is used internally to connect fixtures to the broad-phase.
     * 
     * @author Daniel
     * @class
     */
    export class FixtureProxy {
        aabb : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        fixture : org.jbox2d.dynamics.Fixture;

        childIndex : number;

        proxyId : number;

        constructor() {
            if(this.fixture===undefined) this.fixture = null;
            if(this.childIndex===undefined) this.childIndex = 0;
            if(this.proxyId===undefined) this.proxyId = 0;
        }
    }
    FixtureProxy["__class"] = "org.jbox2d.dynamics.FixtureProxy";

}
namespace org.jbox2d.dynamics {
    /**
     * This is an internal class.
     * 
     * @author Daniel Murphy
     * @class
     */
    export class Island {
        public m_listener : org.jbox2d.callbacks.ContactListener;

        public m_bodies : org.jbox2d.dynamics.Body[];

        public m_contacts : org.jbox2d.dynamics.contacts.Contact[];

        public m_joints : org.jbox2d.dynamics.joints.Joint[];

        public m_positions : org.jbox2d.dynamics.contacts.Position[];

        public m_velocities : org.jbox2d.dynamics.contacts.Velocity[];

        public m_bodyCount : number;

        public m_jointCount : number;

        public m_contactCount : number;

        public m_bodyCapacity : number;

        public m_contactCapacity : number;

        public m_jointCapacity : number;

        public constructor() {
            if(this.m_listener===undefined) this.m_listener = null;
            if(this.m_bodies===undefined) this.m_bodies = null;
            if(this.m_contacts===undefined) this.m_contacts = null;
            if(this.m_joints===undefined) this.m_joints = null;
            if(this.m_positions===undefined) this.m_positions = null;
            if(this.m_velocities===undefined) this.m_velocities = null;
            if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
            if(this.m_jointCount===undefined) this.m_jointCount = 0;
            if(this.m_contactCount===undefined) this.m_contactCount = 0;
            if(this.m_bodyCapacity===undefined) this.m_bodyCapacity = 0;
            if(this.m_contactCapacity===undefined) this.m_contactCapacity = 0;
            if(this.m_jointCapacity===undefined) this.m_jointCapacity = 0;
        }

        public init(bodyCapacity : number, contactCapacity : number, jointCapacity : number, listener : org.jbox2d.callbacks.ContactListener) {
            this.m_bodyCapacity = bodyCapacity;
            this.m_contactCapacity = contactCapacity;
            this.m_jointCapacity = jointCapacity;
            this.m_bodyCount = 0;
            this.m_contactCount = 0;
            this.m_jointCount = 0;
            this.m_listener = listener;
            if(this.m_bodies == null || this.m_bodyCapacity > this.m_bodies.length) {
                this.m_bodies = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_bodyCapacity);
            }
            if(this.m_joints == null || this.m_jointCapacity > this.m_joints.length) {
                this.m_joints = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_jointCapacity);
            }
            if(this.m_contacts == null || this.m_contactCapacity > this.m_contacts.length) {
                this.m_contacts = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_contactCapacity);
            }
            if(this.m_velocities == null || this.m_bodyCapacity > this.m_velocities.length) {
                let old : org.jbox2d.dynamics.contacts.Velocity[] = this.m_velocities == null?[]:this.m_velocities;
                this.m_velocities = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_bodyCapacity);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(old, 0, this.m_velocities, 0, old.length);
                for(let i : number = old.length; i < this.m_velocities.length; i++) {
                    this.m_velocities[i] = new org.jbox2d.dynamics.contacts.Velocity();
                };
            }
            if(this.m_positions == null || this.m_bodyCapacity > this.m_positions.length) {
                let old : org.jbox2d.dynamics.contacts.Position[] = this.m_positions == null?[]:this.m_positions;
                this.m_positions = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_bodyCapacity);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(old, 0, this.m_positions, 0, old.length);
                for(let i : number = old.length; i < this.m_positions.length; i++) {
                    this.m_positions[i] = new org.jbox2d.dynamics.contacts.Position();
                };
            }
        }

        public clear() {
            this.m_bodyCount = 0;
            this.m_contactCount = 0;
            this.m_jointCount = 0;
        }

        /*private*/ contactSolver : org.jbox2d.dynamics.contacts.ContactSolver = new org.jbox2d.dynamics.contacts.ContactSolver();

        /*private*/ timer : org.jbox2d.common.Timer = new org.jbox2d.common.Timer();

        /*private*/ solverData : org.jbox2d.dynamics.SolverData = new org.jbox2d.dynamics.SolverData();

        /*private*/ solverDef : org.jbox2d.dynamics.contacts.ContactSolver.ContactSolverDef = new org.jbox2d.dynamics.contacts.ContactSolver.ContactSolverDef();

        public solve(profile : org.jbox2d.dynamics.Profile, step : org.jbox2d.dynamics.TimeStep, gravity : org.jbox2d.common.Vec2, allowSleep : boolean) {
            let h : number = step.dt;
            for(let i : number = 0; i < this.m_bodyCount; ++i) {
                let b : org.jbox2d.dynamics.Body = this.m_bodies[i];
                let bm_sweep : org.jbox2d.common.Sweep = b.m_sweep;
                let c : org.jbox2d.common.Vec2 = bm_sweep.c;
                let a : number = bm_sweep.a;
                let v : org.jbox2d.common.Vec2 = b.m_linearVelocity;
                let w : number = b.m_angularVelocity;
                bm_sweep.c0.set$org_jbox2d_common_Vec2(bm_sweep.c);
                bm_sweep.a0 = bm_sweep.a;
                if(b.m_type === org.jbox2d.dynamics.BodyType.DYNAMIC) {
                    v.x += (<any>Math).fround(h * ((<any>Math).fround((<any>Math).fround(b.m_gravityScale * gravity.x) + (<any>Math).fround(b.m_invMass * b.m_force.x))));
                    v.y += (<any>Math).fround(h * ((<any>Math).fround((<any>Math).fround(b.m_gravityScale * gravity.y) + (<any>Math).fround(b.m_invMass * b.m_force.y))));
                    w += (<any>Math).fround((<any>Math).fround(h * b.m_invI) * b.m_torque);
                    v.x *= (<any>Math).fround(1.0 / ((<any>Math).fround(1.0 + (<any>Math).fround(h * b.m_linearDamping))));
                    v.y *= (<any>Math).fround(1.0 / ((<any>Math).fround(1.0 + (<any>Math).fround(h * b.m_linearDamping))));
                    w *= (<any>Math).fround(1.0 / ((<any>Math).fround(1.0 + (<any>Math).fround(h * b.m_angularDamping))));
                }
                this.m_positions[i].c.x = c.x;
                this.m_positions[i].c.y = c.y;
                this.m_positions[i].a = a;
                this.m_velocities[i].v.x = v.x;
                this.m_velocities[i].v.y = v.y;
                this.m_velocities[i].w = w;
            };
            this.timer.reset();
            this.solverData.step = step;
            this.solverData.positions = this.m_positions;
            this.solverData.velocities = this.m_velocities;
            this.solverDef.step = step;
            this.solverDef.contacts = this.m_contacts;
            this.solverDef.count = this.m_contactCount;
            this.solverDef.positions = this.m_positions;
            this.solverDef.velocities = this.m_velocities;
            this.contactSolver.init(this.solverDef);
            this.contactSolver.initializeVelocityConstraints();
            if(step.warmStarting) {
                this.contactSolver.warmStart();
            }
            for(let i : number = 0; i < this.m_jointCount; ++i) {
                this.m_joints[i].initVelocityConstraints(this.solverData);
            };
            profile.solveInit.accum(this.timer.getMilliseconds());
            this.timer.reset();
            for(let i : number = 0; i < step.velocityIterations; ++i) {
                for(let j : number = 0; j < this.m_jointCount; ++j) {
                    this.m_joints[j].solveVelocityConstraints(this.solverData);
                };
                this.contactSolver.solveVelocityConstraints();
            };
            this.contactSolver.storeImpulses();
            profile.solveVelocity.accum(this.timer.getMilliseconds());
            for(let i : number = 0; i < this.m_bodyCount; ++i) {
                let c : org.jbox2d.common.Vec2 = this.m_positions[i].c;
                let a : number = this.m_positions[i].a;
                let v : org.jbox2d.common.Vec2 = this.m_velocities[i].v;
                let w : number = this.m_velocities[i].w;
                let translationx : number = (<any>Math).fround(v.x * h);
                let translationy : number = (<any>Math).fround(v.y * h);
                if((<any>Math).fround((<any>Math).fround(translationx * translationx) + (<any>Math).fround(translationy * translationy)) > org.jbox2d.common.Settings.maxTranslationSquared_$LI$()) {
                    let ratio : number = (<any>Math).fround(org.jbox2d.common.Settings.maxTranslation / org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(translationx * translationx) + (<any>Math).fround(translationy * translationy))));
                    v.x *= ratio;
                    v.y *= ratio;
                }
                let rotation : number = (<any>Math).fround(h * w);
                if((<any>Math).fround(rotation * rotation) > org.jbox2d.common.Settings.maxRotationSquared_$LI$()) {
                    let ratio : number = (<any>Math).fround(org.jbox2d.common.Settings.maxRotation_$LI$() / org.jbox2d.common.MathUtils.abs$float(rotation));
                    w *= ratio;
                }
                c.x += (<any>Math).fround(h * v.x);
                c.y += (<any>Math).fround(h * v.y);
                a += (<any>Math).fround(h * w);
                this.m_positions[i].a = a;
                this.m_velocities[i].w = w;
            };
            this.timer.reset();
            let positionSolved : boolean = false;
            for(let i : number = 0; i < step.positionIterations; ++i) {
                let contactsOkay : boolean = this.contactSolver.solvePositionConstraints();
                let jointsOkay : boolean = true;
                for(let j : number = 0; j < this.m_jointCount; ++j) {
                    let jointOkay : boolean = this.m_joints[j].solvePositionConstraints(this.solverData);
                    jointsOkay = jointsOkay && jointOkay;
                };
                if(contactsOkay && jointsOkay) {
                    positionSolved = true;
                    break;
                }
            };
            for(let i : number = 0; i < this.m_bodyCount; ++i) {
                let body : org.jbox2d.dynamics.Body = this.m_bodies[i];
                body.m_sweep.c.x = this.m_positions[i].c.x;
                body.m_sweep.c.y = this.m_positions[i].c.y;
                body.m_sweep.a = this.m_positions[i].a;
                body.m_linearVelocity.x = this.m_velocities[i].v.x;
                body.m_linearVelocity.y = this.m_velocities[i].v.y;
                body.m_angularVelocity = this.m_velocities[i].w;
                body.synchronizeTransform();
            };
            profile.solvePosition.accum(this.timer.getMilliseconds());
            this.report(this.contactSolver.m_velocityConstraints);
            if(allowSleep) {
                let minSleepTime : number = Number.MAX_VALUE;
                let linTolSqr : number = (<any>Math).fround(org.jbox2d.common.Settings.linearSleepTolerance * org.jbox2d.common.Settings.linearSleepTolerance);
                let angTolSqr : number = (<any>Math).fround(org.jbox2d.common.Settings.angularSleepTolerance_$LI$() * org.jbox2d.common.Settings.angularSleepTolerance_$LI$());
                for(let i : number = 0; i < this.m_bodyCount; ++i) {
                    let b : org.jbox2d.dynamics.Body = this.m_bodies[i];
                    if(b.getType() === org.jbox2d.dynamics.BodyType.STATIC) {
                        continue;
                    }
                    if((b.m_flags & org.jbox2d.dynamics.Body.e_autoSleepFlag) === 0 || (<any>Math).fround(b.m_angularVelocity * b.m_angularVelocity) > angTolSqr || org.jbox2d.common.Vec2.dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                        b.m_sleepTime = 0.0;
                        minSleepTime = 0.0;
                    } else {
                        b.m_sleepTime += h;
                        minSleepTime = org.jbox2d.common.MathUtils.min$float$float(minSleepTime, b.m_sleepTime);
                    }
                };
                if(minSleepTime >= org.jbox2d.common.Settings.timeToSleep && positionSolved) {
                    for(let i : number = 0; i < this.m_bodyCount; ++i) {
                        let b : org.jbox2d.dynamics.Body = this.m_bodies[i];
                        b.setAwake(false);
                    };
                }
            }
        }

        /*private*/ toiContactSolver : org.jbox2d.dynamics.contacts.ContactSolver = new org.jbox2d.dynamics.contacts.ContactSolver();

        /*private*/ toiSolverDef : org.jbox2d.dynamics.contacts.ContactSolver.ContactSolverDef = new org.jbox2d.dynamics.contacts.ContactSolver.ContactSolverDef();

        public solveTOI(subStep : org.jbox2d.dynamics.TimeStep, toiIndexA : number, toiIndexB : number) {
            for(let i : number = 0; i < this.m_bodyCount; ++i) {
                this.m_positions[i].c.x = this.m_bodies[i].m_sweep.c.x;
                this.m_positions[i].c.y = this.m_bodies[i].m_sweep.c.y;
                this.m_positions[i].a = this.m_bodies[i].m_sweep.a;
                this.m_velocities[i].v.x = this.m_bodies[i].m_linearVelocity.x;
                this.m_velocities[i].v.y = this.m_bodies[i].m_linearVelocity.y;
                this.m_velocities[i].w = this.m_bodies[i].m_angularVelocity;
            };
            this.toiSolverDef.contacts = this.m_contacts;
            this.toiSolverDef.count = this.m_contactCount;
            this.toiSolverDef.step = subStep;
            this.toiSolverDef.positions = this.m_positions;
            this.toiSolverDef.velocities = this.m_velocities;
            this.toiContactSolver.init(this.toiSolverDef);
            for(let i : number = 0; i < subStep.positionIterations; ++i) {
                let contactsOkay : boolean = this.toiContactSolver.solveTOIPositionConstraints(toiIndexA, toiIndexB);
                if(contactsOkay) {
                    break;
                }
            };
            this.m_bodies[toiIndexA].m_sweep.c0.x = this.m_positions[toiIndexA].c.x;
            this.m_bodies[toiIndexA].m_sweep.c0.y = this.m_positions[toiIndexA].c.y;
            this.m_bodies[toiIndexA].m_sweep.a0 = this.m_positions[toiIndexA].a;
            this.m_bodies[toiIndexB].m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_positions[toiIndexB].c);
            this.m_bodies[toiIndexB].m_sweep.a0 = this.m_positions[toiIndexB].a;
            this.toiContactSolver.initializeVelocityConstraints();
            for(let i : number = 0; i < subStep.velocityIterations; ++i) {
                this.toiContactSolver.solveVelocityConstraints();
            };
            let h : number = subStep.dt;
            for(let i : number = 0; i < this.m_bodyCount; ++i) {
                let c : org.jbox2d.common.Vec2 = this.m_positions[i].c;
                let a : number = this.m_positions[i].a;
                let v : org.jbox2d.common.Vec2 = this.m_velocities[i].v;
                let w : number = this.m_velocities[i].w;
                let translationx : number = (<any>Math).fround(v.x * h);
                let translationy : number = (<any>Math).fround(v.y * h);
                if((<any>Math).fround((<any>Math).fround(translationx * translationx) + (<any>Math).fround(translationy * translationy)) > org.jbox2d.common.Settings.maxTranslationSquared_$LI$()) {
                    let ratio : number = (<any>Math).fround(org.jbox2d.common.Settings.maxTranslation / org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(translationx * translationx) + (<any>Math).fround(translationy * translationy))));
                    v.mulLocal(ratio);
                }
                let rotation : number = (<any>Math).fround(h * w);
                if((<any>Math).fround(rotation * rotation) > org.jbox2d.common.Settings.maxRotationSquared_$LI$()) {
                    let ratio : number = (<any>Math).fround(org.jbox2d.common.Settings.maxRotation_$LI$() / org.jbox2d.common.MathUtils.abs$float(rotation));
                    w *= ratio;
                }
                c.x += (<any>Math).fround(v.x * h);
                c.y += (<any>Math).fround(v.y * h);
                a += (<any>Math).fround(h * w);
                this.m_positions[i].c.x = c.x;
                this.m_positions[i].c.y = c.y;
                this.m_positions[i].a = a;
                this.m_velocities[i].v.x = v.x;
                this.m_velocities[i].v.y = v.y;
                this.m_velocities[i].w = w;
                let body : org.jbox2d.dynamics.Body = this.m_bodies[i];
                body.m_sweep.c.x = c.x;
                body.m_sweep.c.y = c.y;
                body.m_sweep.a = a;
                body.m_linearVelocity.x = v.x;
                body.m_linearVelocity.y = v.y;
                body.m_angularVelocity = w;
                body.synchronizeTransform();
            };
            this.report(this.toiContactSolver.m_velocityConstraints);
        }

        public add$org_jbox2d_dynamics_Body(body : org.jbox2d.dynamics.Body) {
            body.m_islandIndex = this.m_bodyCount;
            this.m_bodies[this.m_bodyCount] = body;
            ++this.m_bodyCount;
        }

        public add(body? : any) : any {
            if(((body != null && body instanceof <any>org.jbox2d.dynamics.Body) || body === null)) {
                return <any>this.add$org_jbox2d_dynamics_Body(body);
            } else if(((body != null && body instanceof <any>org.jbox2d.dynamics.contacts.Contact) || body === null)) {
                return <any>this.add$org_jbox2d_dynamics_contacts_Contact(body);
            } else if(((body != null && body instanceof <any>org.jbox2d.dynamics.joints.Joint) || body === null)) {
                return <any>this.add$org_jbox2d_dynamics_joints_Joint(body);
            } else throw new Error('invalid overload');
        }

        public add$org_jbox2d_dynamics_contacts_Contact(contact : org.jbox2d.dynamics.contacts.Contact) {
            this.m_contacts[this.m_contactCount++] = contact;
        }

        public add$org_jbox2d_dynamics_joints_Joint(joint : org.jbox2d.dynamics.joints.Joint) {
            this.m_joints[this.m_jointCount++] = joint;
        }

        /*private*/ impulse : org.jbox2d.callbacks.ContactImpulse = new org.jbox2d.callbacks.ContactImpulse();

        public report(constraints : org.jbox2d.dynamics.contacts.ContactVelocityConstraint[]) {
            if(this.m_listener == null) {
                return;
            }
            for(let i : number = 0; i < this.m_contactCount; ++i) {
                let c : org.jbox2d.dynamics.contacts.Contact = this.m_contacts[i];
                let vc : org.jbox2d.dynamics.contacts.ContactVelocityConstraint = constraints[i];
                this.impulse.count = vc.pointCount;
                for(let j : number = 0; j < vc.pointCount; ++j) {
                    this.impulse.normalImpulses[j] = vc.points[j].normalImpulse;
                    this.impulse.tangentImpulses[j] = vc.points[j].tangentImpulse;
                };
                this.m_listener.postSolve(c, this.impulse);
            };
        }
    }
    Island["__class"] = "org.jbox2d.dynamics.Island";

}
namespace org.jbox2d.dynamics.joints {
    export class Jacobian {
        public linearA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public angularA : number;

        public angularB : number;

        constructor() {
            if(this.angularA===undefined) this.angularA = 0;
            if(this.angularB===undefined) this.angularB = 0;
        }
    }
    Jacobian["__class"] = "org.jbox2d.dynamics.joints.Jacobian";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * The base joint class. Joints are used to constrain two bodies together in various fashions. Some
     * joints also feature limits and motors.
     * 
     * @author Daniel Murphy
     * @class
     */
    export abstract class Joint {
        public static create(world : org.jbox2d.dynamics.World, def : org.jbox2d.dynamics.joints.JointDef) : Joint {
            switch((def.type)) {
            case org.jbox2d.dynamics.joints.JointType.MOUSE:
                return new org.jbox2d.dynamics.joints.MouseJoint(world.getPool(), <org.jbox2d.dynamics.joints.MouseJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.DISTANCE:
                return new org.jbox2d.dynamics.joints.DistanceJoint(world.getPool(), <org.jbox2d.dynamics.joints.DistanceJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.PRISMATIC:
                return new org.jbox2d.dynamics.joints.PrismaticJoint(world.getPool(), <org.jbox2d.dynamics.joints.PrismaticJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.REVOLUTE:
                return new org.jbox2d.dynamics.joints.RevoluteJoint(world.getPool(), <org.jbox2d.dynamics.joints.RevoluteJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.WELD:
                return new org.jbox2d.dynamics.joints.WeldJoint(world.getPool(), <org.jbox2d.dynamics.joints.WeldJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.FRICTION:
                return new org.jbox2d.dynamics.joints.FrictionJoint(world.getPool(), <org.jbox2d.dynamics.joints.FrictionJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.WHEEL:
                return new org.jbox2d.dynamics.joints.WheelJoint(world.getPool(), <org.jbox2d.dynamics.joints.WheelJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.GEAR:
                return new org.jbox2d.dynamics.joints.GearJoint(world.getPool(), <org.jbox2d.dynamics.joints.GearJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.PULLEY:
                return new org.jbox2d.dynamics.joints.PulleyJoint(world.getPool(), <org.jbox2d.dynamics.joints.PulleyJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.CONSTANT_VOLUME:
                return new org.jbox2d.dynamics.joints.ConstantVolumeJoint(world, <org.jbox2d.dynamics.joints.ConstantVolumeJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.ROPE:
                return new org.jbox2d.dynamics.joints.RopeJoint(world.getPool(), <org.jbox2d.dynamics.joints.RopeJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.MOTOR:
                return new org.jbox2d.dynamics.joints.MotorJoint(world.getPool(), <org.jbox2d.dynamics.joints.MotorJointDef>def);
            case org.jbox2d.dynamics.joints.JointType.UNKNOWN:
            default:
                return null;
            }
        }

        public static destroy(joint : Joint) {
            joint.destructor();
        }

        /*private*/ m_type : org.jbox2d.dynamics.joints.JointType;

        public m_prev : Joint;

        public m_next : Joint;

        public m_edgeA : org.jbox2d.dynamics.joints.JointEdge;

        public m_edgeB : org.jbox2d.dynamics.joints.JointEdge;

        m_bodyA : org.jbox2d.dynamics.Body;

        m_bodyB : org.jbox2d.dynamics.Body;

        public m_islandFlag : boolean;

        /*private*/ m_collideConnected : boolean;

        public m_userData : any;

        pool : org.jbox2d.pooling.IWorldPool;

        constructor(worldPool : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.JointDef) {
            if(this.m_type===undefined) this.m_type = null;
            if(this.m_prev===undefined) this.m_prev = null;
            if(this.m_next===undefined) this.m_next = null;
            if(this.m_edgeA===undefined) this.m_edgeA = null;
            if(this.m_edgeB===undefined) this.m_edgeB = null;
            if(this.m_bodyA===undefined) this.m_bodyA = null;
            if(this.m_bodyB===undefined) this.m_bodyB = null;
            if(this.m_islandFlag===undefined) this.m_islandFlag = false;
            if(this.m_collideConnected===undefined) this.m_collideConnected = false;
            if(this.m_userData===undefined) this.m_userData = null;
            if(this.pool===undefined) this.pool = null;
            this.pool = worldPool;
            this.m_type = def.type;
            this.m_prev = null;
            this.m_next = null;
            this.m_bodyA = def.bodyA;
            this.m_bodyB = def.bodyB;
            this.m_collideConnected = def.collideConnected;
            this.m_islandFlag = false;
            this.m_userData = def.userData;
            this.m_edgeA = new org.jbox2d.dynamics.joints.JointEdge();
            this.m_edgeA.joint = null;
            this.m_edgeA.other = null;
            this.m_edgeA.prev = null;
            this.m_edgeA.next = null;
            this.m_edgeB = new org.jbox2d.dynamics.joints.JointEdge();
            this.m_edgeB.joint = null;
            this.m_edgeB.other = null;
            this.m_edgeB.prev = null;
            this.m_edgeB.next = null;
        }

        /**
         * get the type of the concrete joint.
         * 
         * @return
         * @return {org.jbox2d.dynamics.joints.JointType}
         */
        public getType() : org.jbox2d.dynamics.joints.JointType {
            return this.m_type;
        }

        /**
         * get the first body attached to this joint.
         * @return {org.jbox2d.dynamics.Body}
         */
        public getBodyA() : org.jbox2d.dynamics.Body {
            return this.m_bodyA;
        }

        /**
         * get the second body attached to this joint.
         * 
         * @return
         * @return {org.jbox2d.dynamics.Body}
         */
        public getBodyB() : org.jbox2d.dynamics.Body {
            return this.m_bodyB;
        }

        /**
         * get the anchor point on bodyA in world coordinates.
         * 
         * @return
         * @param {org.jbox2d.common.Vec2} out
         */
        public abstract getAnchorA(out : org.jbox2d.common.Vec2);

        /**
         * get the anchor point on bodyB in world coordinates.
         * 
         * @return
         * @param {org.jbox2d.common.Vec2} out
         */
        public abstract getAnchorB(out : org.jbox2d.common.Vec2);

        /**
         * get the reaction force on body2 at the joint anchor in Newtons.
         * 
         * @param {number} inv_dt
         * @return
         * @param {org.jbox2d.common.Vec2} out
         */
        public abstract getReactionForce(inv_dt : number, out : org.jbox2d.common.Vec2);

        /**
         * get the reaction torque on body2 in N*m.
         * 
         * @param {number} inv_dt
         * @return
         * @return {number}
         */
        public abstract getReactionTorque(inv_dt : number) : number;

        /**
         * get the next joint the world joint list.
         * @return {org.jbox2d.dynamics.joints.Joint}
         */
        public getNext() : Joint {
            return this.m_next;
        }

        /**
         * get the user data pointer.
         * @return {*}
         */
        public getUserData() : any {
            return this.m_userData;
        }

        /**
         * Set the user data pointer.
         * @param {*} data
         */
        public setUserData(data : any) {
            this.m_userData = data;
        }

        /**
         * Get collide connected. Note: modifying the collide connect flag won't work correctly because
         * the flag is only checked when fixture AABBs begin to overlap.
         * @return {boolean}
         */
        public getCollideConnected() : boolean {
            return this.m_collideConnected;
        }

        /**
         * Short-cut function to determine if either body is inactive.
         * 
         * @return
         * @return {boolean}
         */
        public isActive() : boolean {
            return this.m_bodyA.isActive() && this.m_bodyB.isActive();
        }

        /**
         * Internal
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public abstract initVelocityConstraints(data : org.jbox2d.dynamics.SolverData);

        /**
         * Internal
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public abstract solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData);

        /**
         * This returns true if the position errors are within tolerance. Internal.
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public abstract solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean;

        /**
         * Override to handle destruction of joint
         */
        public destructor() {
        }
    }
    Joint["__class"] = "org.jbox2d.dynamics.joints.Joint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Joint definitions are used to construct joints.
     * @author Daniel Murphy
     * @param {org.jbox2d.dynamics.joints.JointType} type
     * @class
     */
    export class JointDef {
        public constructor(type : org.jbox2d.dynamics.joints.JointType) {
            if(this.type===undefined) this.type = null;
            if(this.userData===undefined) this.userData = null;
            if(this.bodyA===undefined) this.bodyA = null;
            if(this.bodyB===undefined) this.bodyB = null;
            if(this.collideConnected===undefined) this.collideConnected = false;
            this.type = type;
            this.userData = null;
            this.bodyA = null;
            this.bodyB = null;
            this.collideConnected = false;
        }

        /**
         * The joint type is set automatically for concrete joint types.
         */
        public type : org.jbox2d.dynamics.joints.JointType;

        /**
         * Use this to attach application specific data to your joints.
         */
        public userData : any;

        /**
         * The first attached body.
         */
        public bodyA : org.jbox2d.dynamics.Body;

        /**
         * The second attached body.
         */
        public bodyB : org.jbox2d.dynamics.Body;

        /**
         * Set this flag to true if the attached bodies should collide.
         */
        public collideConnected : boolean;
    }
    JointDef["__class"] = "org.jbox2d.dynamics.joints.JointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A joint edge is used to connect bodies and joints together
     * in a joint graph where each body is a node and each joint
     * is an edge. A joint edge belongs to a doubly linked list
     * maintained in each attached body. Each joint has two joint
     * nodes, one for each attached body.
     * @author Daniel
     * @class
     */
    export class JointEdge {
        /**
         * Provides quick access to the other body attached
         */
        public other : org.jbox2d.dynamics.Body = null;

        /**
         * the joint
         */
        public joint : org.jbox2d.dynamics.joints.Joint = null;

        /**
         * the previous joint edge in the body's joint list
         */
        public prev : JointEdge = null;

        /**
         * the next joint edge in the body's joint list
         */
        public next : JointEdge = null;
    }
    JointEdge["__class"] = "org.jbox2d.dynamics.joints.JointEdge";

}
namespace org.jbox2d.dynamics.joints {
    export enum JointType {
        UNKNOWN, REVOLUTE, PRISMATIC, DISTANCE, PULLEY, MOUSE, GEAR, WHEEL, WELD, FRICTION, ROPE, CONSTANT_VOLUME, MOTOR
    }
}
namespace org.jbox2d.dynamics.joints {
    export enum LimitState {
        INACTIVE, AT_LOWER, AT_UPPER, EQUAL
    }
}
namespace org.jbox2d.dynamics {
    export class Profile {
        static LONG_AVG_NUMS : number = 20;

        static LONG_FRACTION : number; public static LONG_FRACTION_$LI$() : number { if(Profile.LONG_FRACTION == null) Profile.LONG_FRACTION = (<any>Math).fround(1.0 / Profile.LONG_AVG_NUMS); return Profile.LONG_FRACTION; };

        static SHORT_AVG_NUMS : number = 5;

        static SHORT_FRACTION : number; public static SHORT_FRACTION_$LI$() : number { if(Profile.SHORT_FRACTION == null) Profile.SHORT_FRACTION = (<any>Math).fround(1.0 / Profile.SHORT_AVG_NUMS); return Profile.SHORT_FRACTION; };

        public step : Profile.ProfileEntry = new Profile.ProfileEntry();

        public stepInit : Profile.ProfileEntry = new Profile.ProfileEntry();

        public collide : Profile.ProfileEntry = new Profile.ProfileEntry();

        public solveParticleSystem : Profile.ProfileEntry = new Profile.ProfileEntry();

        public solve : Profile.ProfileEntry = new Profile.ProfileEntry();

        public solveInit : Profile.ProfileEntry = new Profile.ProfileEntry();

        public solveVelocity : Profile.ProfileEntry = new Profile.ProfileEntry();

        public solvePosition : Profile.ProfileEntry = new Profile.ProfileEntry();

        public broadphase : Profile.ProfileEntry = new Profile.ProfileEntry();

        public solveTOI : Profile.ProfileEntry = new Profile.ProfileEntry();

        public toDebugStrings(strings : Array<string>) {
            /* add */(strings.push("Profile:")>0);
            /* add */(strings.push(" step: " + this.step)>0);
            /* add */(strings.push("  init: " + this.stepInit)>0);
            /* add */(strings.push("  collide: " + this.collide)>0);
            /* add */(strings.push("  particles: " + this.solveParticleSystem)>0);
            /* add */(strings.push("  solve: " + this.solve)>0);
            /* add */(strings.push("   solveInit: " + this.solveInit)>0);
            /* add */(strings.push("   solveVelocity: " + this.solveVelocity)>0);
            /* add */(strings.push("   solvePosition: " + this.solvePosition)>0);
            /* add */(strings.push("   broadphase: " + this.broadphase)>0);
            /* add */(strings.push("  solveTOI: " + this.solveTOI)>0);
        }
    }
    Profile["__class"] = "org.jbox2d.dynamics.Profile";


    export namespace Profile {

        export class ProfileEntry {
            longAvg : number;

            shortAvg : number;

            min : number;

            max : number;

            __accum : number;

            public constructor() {
                if(this.longAvg===undefined) this.longAvg = 0;
                if(this.shortAvg===undefined) this.shortAvg = 0;
                if(this.min===undefined) this.min = 0;
                if(this.max===undefined) this.max = 0;
                if(this.__accum===undefined) this.__accum = 0;
                this.min = Number.MAX_VALUE;
                this.max = -Number.MAX_VALUE;
            }

            public record(value : number) {
                this.longAvg = (<any>Math).fround((<any>Math).fround(this.longAvg * ((<any>Math).fround(1 - org.jbox2d.dynamics.Profile.LONG_FRACTION_$LI$()))) + (<any>Math).fround(value * org.jbox2d.dynamics.Profile.LONG_FRACTION_$LI$()));
                this.shortAvg = (<any>Math).fround((<any>Math).fround(this.shortAvg * ((<any>Math).fround(1 - org.jbox2d.dynamics.Profile.SHORT_FRACTION_$LI$()))) + (<any>Math).fround(value * org.jbox2d.dynamics.Profile.SHORT_FRACTION_$LI$()));
                this.min = org.jbox2d.common.MathUtils.min$float$float(value, this.min);
                this.max = org.jbox2d.common.MathUtils.max$float$float(value, this.max);
            }

            public startAccum() {
                this.__accum = 0;
            }

            public accum(value : number) {
                this.__accum += value;
            }

            public endAccum() {
                this.record(this.__accum);
            }

            /**
             * 
             * @return {string}
             */
            public toString() : string {
                return this.shortAvg + " (" + this.longAvg + ")[" + this.min + "," + this.max + "]";
            }
        }
        ProfileEntry["__class"] = "org.jbox2d.dynamics.Profile.ProfileEntry";

    }

}
namespace org.jbox2d.dynamics {
    export class SolverData {
        public step : org.jbox2d.dynamics.TimeStep;

        public positions : org.jbox2d.dynamics.contacts.Position[];

        public velocities : org.jbox2d.dynamics.contacts.Velocity[];

        constructor() {
            if(this.step===undefined) this.step = null;
            if(this.positions===undefined) this.positions = null;
            if(this.velocities===undefined) this.velocities = null;
        }
    }
    SolverData["__class"] = "org.jbox2d.dynamics.SolverData";

}
namespace org.jbox2d.dynamics {
    /**
     * This is an internal structure.
     * @class
     */
    export class TimeStep {
        /**
         * time step
         */
        public dt : number;

        /**
         * inverse time step (0 if dt == 0).
         */
        public inv_dt : number;

        /**
         * dt * inv_dt0
         */
        public dtRatio : number;

        public velocityIterations : number;

        public positionIterations : number;

        public warmStarting : boolean;

        constructor() {
            if(this.dt===undefined) this.dt = 0;
            if(this.inv_dt===undefined) this.inv_dt = 0;
            if(this.dtRatio===undefined) this.dtRatio = 0;
            if(this.velocityIterations===undefined) this.velocityIterations = 0;
            if(this.positionIterations===undefined) this.positionIterations = 0;
            if(this.warmStarting===undefined) this.warmStarting = false;
        }
    }
    TimeStep["__class"] = "org.jbox2d.dynamics.TimeStep";

}
namespace org.jbox2d.dynamics {
    /**
     * The world class manages all physics entities, dynamic simulation, and asynchronous queries. The
     * world also contains efficient memory management facilities.
     * 
     * @author Daniel Murphy
     * @param {org.jbox2d.common.Vec2} gravity
     * @param {*} pool
     * @param {*} strategy
     * @class
     */
    export class World {
        public static WORLD_POOL_SIZE : number = 100;

        public static WORLD_POOL_CONTAINER_SIZE : number = 10;

        public static NEW_FIXTURE : number = 1;

        public static LOCKED : number = 2;

        public static CLEAR_FORCES : number = 4;

        public activeContacts : number = 0;

        public contactPoolCount : number = 0;

        m_flags : number;

        m_contactManager : org.jbox2d.dynamics.ContactManager;

        /*private*/ m_bodyList : org.jbox2d.dynamics.Body;

        /*private*/ m_jointList : org.jbox2d.dynamics.joints.Joint;

        /*private*/ m_bodyCount : number;

        /*private*/ m_jointCount : number;

        /*private*/ m_gravity : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_allowSleep : boolean;

        /*private*/ m_destructionListener : org.jbox2d.callbacks.DestructionListener;

        /*private*/ m_particleDestructionListener : org.jbox2d.callbacks.ParticleDestructionListener;

        /*private*/ m_debugDraw : org.jbox2d.callbacks.DebugDraw;

        /*private*/ pool : org.jbox2d.pooling.IWorldPool;

        /**
         * This is used to compute the time step ratio to support a variable time step.
         */
        /*private*/ m_inv_dt0 : number;

        /*private*/ m_warmStarting : boolean;

        /*private*/ m_continuousPhysics : boolean;

        /*private*/ m_subStepping : boolean;

        /*private*/ m_stepComplete : boolean;

        /*private*/ m_profile : org.jbox2d.dynamics.Profile;

        /*private*/ m_particleSystem : org.jbox2d.particle.ParticleSystem;

        /*private*/ contactStacks : org.jbox2d.dynamics.contacts.ContactRegister[][] = <any> (function(dims) { let allocate = function(dims) { if(dims.length==0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([/* Enum.values */function() { let result: number[] = []; for(let val in org.jbox2d.collision.shapes.ShapeType) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }().length, /* Enum.values */function() { let result: number[] = []; for(let val in org.jbox2d.collision.shapes.ShapeType) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }().length]);

        public constructor(gravity? : any, pool? : any, strategy? : any) {
            if(((gravity != null && gravity instanceof <any>org.jbox2d.common.Vec2) || gravity === null) && ((pool != null && (pool["__interfaces"] != null && pool["__interfaces"].indexOf("org.jbox2d.pooling.IWorldPool") >= 0 || pool.constructor != null && pool.constructor["__interfaces"] != null && pool.constructor["__interfaces"].indexOf("org.jbox2d.pooling.IWorldPool") >= 0)) || pool === null) && ((strategy != null && (strategy["__interfaces"] != null && strategy["__interfaces"].indexOf("org.jbox2d.collision.broadphase.BroadPhaseStrategy") >= 0 || strategy.constructor != null && strategy.constructor["__interfaces"] != null && strategy.constructor["__interfaces"].indexOf("org.jbox2d.collision.broadphase.BroadPhaseStrategy") >= 0)) || strategy === null)) {
                let __args = Array.prototype.slice.call(arguments);
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let broadPhase : any = new org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer(strategy);
                    if(this.m_flags===undefined) this.m_flags = 0;
                    if(this.m_contactManager===undefined) this.m_contactManager = null;
                    if(this.m_bodyList===undefined) this.m_bodyList = null;
                    if(this.m_jointList===undefined) this.m_jointList = null;
                    if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
                    if(this.m_jointCount===undefined) this.m_jointCount = 0;
                    if(this.m_allowSleep===undefined) this.m_allowSleep = false;
                    if(this.m_destructionListener===undefined) this.m_destructionListener = null;
                    if(this.m_particleDestructionListener===undefined) this.m_particleDestructionListener = null;
                    if(this.m_debugDraw===undefined) this.m_debugDraw = null;
                    if(this.pool===undefined) this.pool = null;
                    if(this.m_inv_dt0===undefined) this.m_inv_dt0 = 0;
                    if(this.m_warmStarting===undefined) this.m_warmStarting = false;
                    if(this.m_continuousPhysics===undefined) this.m_continuousPhysics = false;
                    if(this.m_subStepping===undefined) this.m_subStepping = false;
                    if(this.m_stepComplete===undefined) this.m_stepComplete = false;
                    if(this.m_profile===undefined) this.m_profile = null;
                    if(this.m_particleSystem===undefined) this.m_particleSystem = null;
                    this.activeContacts = 0;
                    this.contactPoolCount = 0;
                    this.m_gravity = new org.jbox2d.common.Vec2();
                    this.contactStacks = <any> (function(dims) { let allocate = function(dims) { if(dims.length==0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([/* Enum.values */function() { let result: number[] = []; for(let val in org.jbox2d.collision.shapes.ShapeType) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }().length, /* Enum.values */function() { let result: number[] = []; for(let val in org.jbox2d.collision.shapes.ShapeType) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }().length]);
                    this.__step = new org.jbox2d.dynamics.TimeStep();
                    this.stepTimer = new org.jbox2d.common.Timer();
                    this.tempTimer = new org.jbox2d.common.Timer();
                    this.color = new org.jbox2d.common.Color3f();
                    this.xf = new org.jbox2d.common.Transform();
                    this.cA = new org.jbox2d.common.Vec2();
                    this.cB = new org.jbox2d.common.Vec2();
                    this.avs = new org.jbox2d.pooling.arrays.Vec2Array();
                    this.wqwrapper = new org.jbox2d.dynamics.WorldQueryWrapper();
                    this.wrcwrapper = new org.jbox2d.dynamics.WorldRayCastWrapper();
                    this.input = new org.jbox2d.collision.RayCastInput();
                    this.island = new org.jbox2d.dynamics.Island();
                    this.stack = [null, null, null, null, null, null, null, null, null, null];
                    this.broadphaseTimer = new org.jbox2d.common.Timer();
                    this.toiIsland = new org.jbox2d.dynamics.Island();
                    this.toiInput = new org.jbox2d.collision.TimeOfImpact.TOIInput();
                    this.toiOutput = new org.jbox2d.collision.TimeOfImpact.TOIOutput();
                    this.subStep = new org.jbox2d.dynamics.TimeStep();
                    this.tempBodies = [null, null];
                    this.backup1 = new org.jbox2d.common.Sweep();
                    this.backup2 = new org.jbox2d.common.Sweep();
                    this.liquidLength = 0.12;
                    this.averageLinearVel = -1;
                    this.liquidOffset = new org.jbox2d.common.Vec2();
                    this.circCenterMoved = new org.jbox2d.common.Vec2();
                    this.liquidColor = new org.jbox2d.common.Color3f(0.4, 0.4, 1.0);
                    this.center = new org.jbox2d.common.Vec2();
                    this.axis = new org.jbox2d.common.Vec2();
                    this.v1 = new org.jbox2d.common.Vec2();
                    this.v2 = new org.jbox2d.common.Vec2();
                    this.tlvertices = new org.jbox2d.pooling.arrays.Vec2Array();
                    if(this.m_flags===undefined) this.m_flags = 0;
                    if(this.m_contactManager===undefined) this.m_contactManager = null;
                    if(this.m_bodyList===undefined) this.m_bodyList = null;
                    if(this.m_jointList===undefined) this.m_jointList = null;
                    if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
                    if(this.m_jointCount===undefined) this.m_jointCount = 0;
                    if(this.m_allowSleep===undefined) this.m_allowSleep = false;
                    if(this.m_destructionListener===undefined) this.m_destructionListener = null;
                    if(this.m_particleDestructionListener===undefined) this.m_particleDestructionListener = null;
                    if(this.m_debugDraw===undefined) this.m_debugDraw = null;
                    if(this.pool===undefined) this.pool = null;
                    if(this.m_inv_dt0===undefined) this.m_inv_dt0 = 0;
                    if(this.m_warmStarting===undefined) this.m_warmStarting = false;
                    if(this.m_continuousPhysics===undefined) this.m_continuousPhysics = false;
                    if(this.m_subStepping===undefined) this.m_subStepping = false;
                    if(this.m_stepComplete===undefined) this.m_stepComplete = false;
                    if(this.m_profile===undefined) this.m_profile = null;
                    if(this.m_particleSystem===undefined) this.m_particleSystem = null;
                    (() => {
                        this.pool = pool;
                        this.m_destructionListener = null;
                        this.m_debugDraw = null;
                        this.m_bodyList = null;
                        this.m_jointList = null;
                        this.m_bodyCount = 0;
                        this.m_jointCount = 0;
                        this.m_warmStarting = true;
                        this.m_continuousPhysics = true;
                        this.m_subStepping = false;
                        this.m_stepComplete = true;
                        this.m_allowSleep = true;
                        this.m_gravity.set$org_jbox2d_common_Vec2(gravity);
                        this.m_flags = World.CLEAR_FORCES;
                        this.m_inv_dt0 = 0.0;
                        this.m_contactManager = new org.jbox2d.dynamics.ContactManager(this, broadPhase);
                        this.m_profile = new org.jbox2d.dynamics.Profile();
                        this.m_particleSystem = new org.jbox2d.particle.ParticleSystem(this);
                        this.initializeRegisters();
                    })();
                }
            } else if(((gravity != null && gravity instanceof <any>org.jbox2d.common.Vec2) || gravity === null) && ((pool != null && (pool["__interfaces"] != null && pool["__interfaces"].indexOf("org.jbox2d.pooling.IWorldPool") >= 0 || pool.constructor != null && pool.constructor["__interfaces"] != null && pool.constructor["__interfaces"].indexOf("org.jbox2d.pooling.IWorldPool") >= 0)) || pool === null) && ((strategy != null && (strategy["__interfaces"] != null && strategy["__interfaces"].indexOf("org.jbox2d.collision.broadphase.BroadPhase") >= 0 || strategy.constructor != null && strategy.constructor["__interfaces"] != null && strategy.constructor["__interfaces"].indexOf("org.jbox2d.collision.broadphase.BroadPhase") >= 0)) || strategy === null)) {
                let __args = Array.prototype.slice.call(arguments);
                let broadPhase : any = __args[2];
                if(this.m_flags===undefined) this.m_flags = 0;
                if(this.m_contactManager===undefined) this.m_contactManager = null;
                if(this.m_bodyList===undefined) this.m_bodyList = null;
                if(this.m_jointList===undefined) this.m_jointList = null;
                if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
                if(this.m_jointCount===undefined) this.m_jointCount = 0;
                if(this.m_allowSleep===undefined) this.m_allowSleep = false;
                if(this.m_destructionListener===undefined) this.m_destructionListener = null;
                if(this.m_particleDestructionListener===undefined) this.m_particleDestructionListener = null;
                if(this.m_debugDraw===undefined) this.m_debugDraw = null;
                if(this.pool===undefined) this.pool = null;
                if(this.m_inv_dt0===undefined) this.m_inv_dt0 = 0;
                if(this.m_warmStarting===undefined) this.m_warmStarting = false;
                if(this.m_continuousPhysics===undefined) this.m_continuousPhysics = false;
                if(this.m_subStepping===undefined) this.m_subStepping = false;
                if(this.m_stepComplete===undefined) this.m_stepComplete = false;
                if(this.m_profile===undefined) this.m_profile = null;
                if(this.m_particleSystem===undefined) this.m_particleSystem = null;
                this.activeContacts = 0;
                this.contactPoolCount = 0;
                this.m_gravity = new org.jbox2d.common.Vec2();
                this.contactStacks = <any> (function(dims) { let allocate = function(dims) { if(dims.length==0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([/* Enum.values */function() { let result: number[] = []; for(let val in org.jbox2d.collision.shapes.ShapeType) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }().length, /* Enum.values */function() { let result: number[] = []; for(let val in org.jbox2d.collision.shapes.ShapeType) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }().length]);
                this.__step = new org.jbox2d.dynamics.TimeStep();
                this.stepTimer = new org.jbox2d.common.Timer();
                this.tempTimer = new org.jbox2d.common.Timer();
                this.color = new org.jbox2d.common.Color3f();
                this.xf = new org.jbox2d.common.Transform();
                this.cA = new org.jbox2d.common.Vec2();
                this.cB = new org.jbox2d.common.Vec2();
                this.avs = new org.jbox2d.pooling.arrays.Vec2Array();
                this.wqwrapper = new org.jbox2d.dynamics.WorldQueryWrapper();
                this.wrcwrapper = new org.jbox2d.dynamics.WorldRayCastWrapper();
                this.input = new org.jbox2d.collision.RayCastInput();
                this.island = new org.jbox2d.dynamics.Island();
                this.stack = [null, null, null, null, null, null, null, null, null, null];
                this.broadphaseTimer = new org.jbox2d.common.Timer();
                this.toiIsland = new org.jbox2d.dynamics.Island();
                this.toiInput = new org.jbox2d.collision.TimeOfImpact.TOIInput();
                this.toiOutput = new org.jbox2d.collision.TimeOfImpact.TOIOutput();
                this.subStep = new org.jbox2d.dynamics.TimeStep();
                this.tempBodies = [null, null];
                this.backup1 = new org.jbox2d.common.Sweep();
                this.backup2 = new org.jbox2d.common.Sweep();
                this.liquidLength = 0.12;
                this.averageLinearVel = -1;
                this.liquidOffset = new org.jbox2d.common.Vec2();
                this.circCenterMoved = new org.jbox2d.common.Vec2();
                this.liquidColor = new org.jbox2d.common.Color3f(0.4, 0.4, 1.0);
                this.center = new org.jbox2d.common.Vec2();
                this.axis = new org.jbox2d.common.Vec2();
                this.v1 = new org.jbox2d.common.Vec2();
                this.v2 = new org.jbox2d.common.Vec2();
                this.tlvertices = new org.jbox2d.pooling.arrays.Vec2Array();
                if(this.m_flags===undefined) this.m_flags = 0;
                if(this.m_contactManager===undefined) this.m_contactManager = null;
                if(this.m_bodyList===undefined) this.m_bodyList = null;
                if(this.m_jointList===undefined) this.m_jointList = null;
                if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
                if(this.m_jointCount===undefined) this.m_jointCount = 0;
                if(this.m_allowSleep===undefined) this.m_allowSleep = false;
                if(this.m_destructionListener===undefined) this.m_destructionListener = null;
                if(this.m_particleDestructionListener===undefined) this.m_particleDestructionListener = null;
                if(this.m_debugDraw===undefined) this.m_debugDraw = null;
                if(this.pool===undefined) this.pool = null;
                if(this.m_inv_dt0===undefined) this.m_inv_dt0 = 0;
                if(this.m_warmStarting===undefined) this.m_warmStarting = false;
                if(this.m_continuousPhysics===undefined) this.m_continuousPhysics = false;
                if(this.m_subStepping===undefined) this.m_subStepping = false;
                if(this.m_stepComplete===undefined) this.m_stepComplete = false;
                if(this.m_profile===undefined) this.m_profile = null;
                if(this.m_particleSystem===undefined) this.m_particleSystem = null;
                (() => {
                    this.pool = pool;
                    this.m_destructionListener = null;
                    this.m_debugDraw = null;
                    this.m_bodyList = null;
                    this.m_jointList = null;
                    this.m_bodyCount = 0;
                    this.m_jointCount = 0;
                    this.m_warmStarting = true;
                    this.m_continuousPhysics = true;
                    this.m_subStepping = false;
                    this.m_stepComplete = true;
                    this.m_allowSleep = true;
                    this.m_gravity.set$org_jbox2d_common_Vec2(gravity);
                    this.m_flags = World.CLEAR_FORCES;
                    this.m_inv_dt0 = 0.0;
                    this.m_contactManager = new org.jbox2d.dynamics.ContactManager(this, broadPhase);
                    this.m_profile = new org.jbox2d.dynamics.Profile();
                    this.m_particleSystem = new org.jbox2d.particle.ParticleSystem(this);
                    this.initializeRegisters();
                })();
            } else if(((gravity != null && gravity instanceof <any>org.jbox2d.common.Vec2) || gravity === null) && ((pool != null && (pool["__interfaces"] != null && pool["__interfaces"].indexOf("org.jbox2d.pooling.IWorldPool") >= 0 || pool.constructor != null && pool.constructor["__interfaces"] != null && pool.constructor["__interfaces"].indexOf("org.jbox2d.pooling.IWorldPool") >= 0)) || pool === null) && strategy === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let strategy : any = new org.jbox2d.collision.broadphase.DynamicTree();
                    {
                        let __args = Array.prototype.slice.call(arguments);
                        let broadPhase : any = new org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer(strategy);
                        if(this.m_flags===undefined) this.m_flags = 0;
                        if(this.m_contactManager===undefined) this.m_contactManager = null;
                        if(this.m_bodyList===undefined) this.m_bodyList = null;
                        if(this.m_jointList===undefined) this.m_jointList = null;
                        if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
                        if(this.m_jointCount===undefined) this.m_jointCount = 0;
                        if(this.m_allowSleep===undefined) this.m_allowSleep = false;
                        if(this.m_destructionListener===undefined) this.m_destructionListener = null;
                        if(this.m_particleDestructionListener===undefined) this.m_particleDestructionListener = null;
                        if(this.m_debugDraw===undefined) this.m_debugDraw = null;
                        if(this.pool===undefined) this.pool = null;
                        if(this.m_inv_dt0===undefined) this.m_inv_dt0 = 0;
                        if(this.m_warmStarting===undefined) this.m_warmStarting = false;
                        if(this.m_continuousPhysics===undefined) this.m_continuousPhysics = false;
                        if(this.m_subStepping===undefined) this.m_subStepping = false;
                        if(this.m_stepComplete===undefined) this.m_stepComplete = false;
                        if(this.m_profile===undefined) this.m_profile = null;
                        if(this.m_particleSystem===undefined) this.m_particleSystem = null;
                        this.activeContacts = 0;
                        this.contactPoolCount = 0;
                        this.m_gravity = new org.jbox2d.common.Vec2();
                        this.contactStacks = <any> (function(dims) { let allocate = function(dims) { if(dims.length==0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([/* Enum.values */function() { let result: number[] = []; for(let val in org.jbox2d.collision.shapes.ShapeType) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }().length, /* Enum.values */function() { let result: number[] = []; for(let val in org.jbox2d.collision.shapes.ShapeType) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }().length]);
                        this.__step = new org.jbox2d.dynamics.TimeStep();
                        this.stepTimer = new org.jbox2d.common.Timer();
                        this.tempTimer = new org.jbox2d.common.Timer();
                        this.color = new org.jbox2d.common.Color3f();
                        this.xf = new org.jbox2d.common.Transform();
                        this.cA = new org.jbox2d.common.Vec2();
                        this.cB = new org.jbox2d.common.Vec2();
                        this.avs = new org.jbox2d.pooling.arrays.Vec2Array();
                        this.wqwrapper = new org.jbox2d.dynamics.WorldQueryWrapper();
                        this.wrcwrapper = new org.jbox2d.dynamics.WorldRayCastWrapper();
                        this.input = new org.jbox2d.collision.RayCastInput();
                        this.island = new org.jbox2d.dynamics.Island();
                        this.stack = [null, null, null, null, null, null, null, null, null, null];
                        this.broadphaseTimer = new org.jbox2d.common.Timer();
                        this.toiIsland = new org.jbox2d.dynamics.Island();
                        this.toiInput = new org.jbox2d.collision.TimeOfImpact.TOIInput();
                        this.toiOutput = new org.jbox2d.collision.TimeOfImpact.TOIOutput();
                        this.subStep = new org.jbox2d.dynamics.TimeStep();
                        this.tempBodies = [null, null];
                        this.backup1 = new org.jbox2d.common.Sweep();
                        this.backup2 = new org.jbox2d.common.Sweep();
                        this.liquidLength = 0.12;
                        this.averageLinearVel = -1;
                        this.liquidOffset = new org.jbox2d.common.Vec2();
                        this.circCenterMoved = new org.jbox2d.common.Vec2();
                        this.liquidColor = new org.jbox2d.common.Color3f(0.4, 0.4, 1.0);
                        this.center = new org.jbox2d.common.Vec2();
                        this.axis = new org.jbox2d.common.Vec2();
                        this.v1 = new org.jbox2d.common.Vec2();
                        this.v2 = new org.jbox2d.common.Vec2();
                        this.tlvertices = new org.jbox2d.pooling.arrays.Vec2Array();
                        if(this.m_flags===undefined) this.m_flags = 0;
                        if(this.m_contactManager===undefined) this.m_contactManager = null;
                        if(this.m_bodyList===undefined) this.m_bodyList = null;
                        if(this.m_jointList===undefined) this.m_jointList = null;
                        if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
                        if(this.m_jointCount===undefined) this.m_jointCount = 0;
                        if(this.m_allowSleep===undefined) this.m_allowSleep = false;
                        if(this.m_destructionListener===undefined) this.m_destructionListener = null;
                        if(this.m_particleDestructionListener===undefined) this.m_particleDestructionListener = null;
                        if(this.m_debugDraw===undefined) this.m_debugDraw = null;
                        if(this.pool===undefined) this.pool = null;
                        if(this.m_inv_dt0===undefined) this.m_inv_dt0 = 0;
                        if(this.m_warmStarting===undefined) this.m_warmStarting = false;
                        if(this.m_continuousPhysics===undefined) this.m_continuousPhysics = false;
                        if(this.m_subStepping===undefined) this.m_subStepping = false;
                        if(this.m_stepComplete===undefined) this.m_stepComplete = false;
                        if(this.m_profile===undefined) this.m_profile = null;
                        if(this.m_particleSystem===undefined) this.m_particleSystem = null;
                        (() => {
                            this.pool = pool;
                            this.m_destructionListener = null;
                            this.m_debugDraw = null;
                            this.m_bodyList = null;
                            this.m_jointList = null;
                            this.m_bodyCount = 0;
                            this.m_jointCount = 0;
                            this.m_warmStarting = true;
                            this.m_continuousPhysics = true;
                            this.m_subStepping = false;
                            this.m_stepComplete = true;
                            this.m_allowSleep = true;
                            this.m_gravity.set$org_jbox2d_common_Vec2(gravity);
                            this.m_flags = World.CLEAR_FORCES;
                            this.m_inv_dt0 = 0.0;
                            this.m_contactManager = new org.jbox2d.dynamics.ContactManager(this, broadPhase);
                            this.m_profile = new org.jbox2d.dynamics.Profile();
                            this.m_particleSystem = new org.jbox2d.particle.ParticleSystem(this);
                            this.initializeRegisters();
                        })();
                    }
                }
            } else if(((gravity != null && gravity instanceof <any>org.jbox2d.common.Vec2) || gravity === null) && pool === undefined && strategy === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let pool : any = new org.jbox2d.pooling.normal.DefaultWorldPool(World.WORLD_POOL_SIZE, World.WORLD_POOL_CONTAINER_SIZE);
                    {
                        let __args = Array.prototype.slice.call(arguments);
                        let strategy : any = new org.jbox2d.collision.broadphase.DynamicTree();
                        {
                            let __args = Array.prototype.slice.call(arguments);
                            let broadPhase : any = new org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer(strategy);
                            if(this.m_flags===undefined) this.m_flags = 0;
                            if(this.m_contactManager===undefined) this.m_contactManager = null;
                            if(this.m_bodyList===undefined) this.m_bodyList = null;
                            if(this.m_jointList===undefined) this.m_jointList = null;
                            if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
                            if(this.m_jointCount===undefined) this.m_jointCount = 0;
                            if(this.m_allowSleep===undefined) this.m_allowSleep = false;
                            if(this.m_destructionListener===undefined) this.m_destructionListener = null;
                            if(this.m_particleDestructionListener===undefined) this.m_particleDestructionListener = null;
                            if(this.m_debugDraw===undefined) this.m_debugDraw = null;
                            if(this.pool===undefined) this.pool = null;
                            if(this.m_inv_dt0===undefined) this.m_inv_dt0 = 0;
                            if(this.m_warmStarting===undefined) this.m_warmStarting = false;
                            if(this.m_continuousPhysics===undefined) this.m_continuousPhysics = false;
                            if(this.m_subStepping===undefined) this.m_subStepping = false;
                            if(this.m_stepComplete===undefined) this.m_stepComplete = false;
                            if(this.m_profile===undefined) this.m_profile = null;
                            if(this.m_particleSystem===undefined) this.m_particleSystem = null;
                            this.activeContacts = 0;
                            this.contactPoolCount = 0;
                            this.m_gravity = new org.jbox2d.common.Vec2();
                            this.contactStacks = <any> (function(dims) { let allocate = function(dims) { if(dims.length==0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([/* Enum.values */function() { let result: number[] = []; for(let val in org.jbox2d.collision.shapes.ShapeType) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }().length, /* Enum.values */function() { let result: number[] = []; for(let val in org.jbox2d.collision.shapes.ShapeType) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }().length]);
                            this.__step = new org.jbox2d.dynamics.TimeStep();
                            this.stepTimer = new org.jbox2d.common.Timer();
                            this.tempTimer = new org.jbox2d.common.Timer();
                            this.color = new org.jbox2d.common.Color3f();
                            this.xf = new org.jbox2d.common.Transform();
                            this.cA = new org.jbox2d.common.Vec2();
                            this.cB = new org.jbox2d.common.Vec2();
                            this.avs = new org.jbox2d.pooling.arrays.Vec2Array();
                            this.wqwrapper = new org.jbox2d.dynamics.WorldQueryWrapper();
                            this.wrcwrapper = new org.jbox2d.dynamics.WorldRayCastWrapper();
                            this.input = new org.jbox2d.collision.RayCastInput();
                            this.island = new org.jbox2d.dynamics.Island();
                            this.stack = [null, null, null, null, null, null, null, null, null, null];
                            this.broadphaseTimer = new org.jbox2d.common.Timer();
                            this.toiIsland = new org.jbox2d.dynamics.Island();
                            this.toiInput = new org.jbox2d.collision.TimeOfImpact.TOIInput();
                            this.toiOutput = new org.jbox2d.collision.TimeOfImpact.TOIOutput();
                            this.subStep = new org.jbox2d.dynamics.TimeStep();
                            this.tempBodies = [null, null];
                            this.backup1 = new org.jbox2d.common.Sweep();
                            this.backup2 = new org.jbox2d.common.Sweep();
                            this.liquidLength = 0.12;
                            this.averageLinearVel = -1;
                            this.liquidOffset = new org.jbox2d.common.Vec2();
                            this.circCenterMoved = new org.jbox2d.common.Vec2();
                            this.liquidColor = new org.jbox2d.common.Color3f(0.4, 0.4, 1.0);
                            this.center = new org.jbox2d.common.Vec2();
                            this.axis = new org.jbox2d.common.Vec2();
                            this.v1 = new org.jbox2d.common.Vec2();
                            this.v2 = new org.jbox2d.common.Vec2();
                            this.tlvertices = new org.jbox2d.pooling.arrays.Vec2Array();
                            if(this.m_flags===undefined) this.m_flags = 0;
                            if(this.m_contactManager===undefined) this.m_contactManager = null;
                            if(this.m_bodyList===undefined) this.m_bodyList = null;
                            if(this.m_jointList===undefined) this.m_jointList = null;
                            if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
                            if(this.m_jointCount===undefined) this.m_jointCount = 0;
                            if(this.m_allowSleep===undefined) this.m_allowSleep = false;
                            if(this.m_destructionListener===undefined) this.m_destructionListener = null;
                            if(this.m_particleDestructionListener===undefined) this.m_particleDestructionListener = null;
                            if(this.m_debugDraw===undefined) this.m_debugDraw = null;
                            if(this.pool===undefined) this.pool = null;
                            if(this.m_inv_dt0===undefined) this.m_inv_dt0 = 0;
                            if(this.m_warmStarting===undefined) this.m_warmStarting = false;
                            if(this.m_continuousPhysics===undefined) this.m_continuousPhysics = false;
                            if(this.m_subStepping===undefined) this.m_subStepping = false;
                            if(this.m_stepComplete===undefined) this.m_stepComplete = false;
                            if(this.m_profile===undefined) this.m_profile = null;
                            if(this.m_particleSystem===undefined) this.m_particleSystem = null;
                            (() => {
                                this.pool = pool;
                                this.m_destructionListener = null;
                                this.m_debugDraw = null;
                                this.m_bodyList = null;
                                this.m_jointList = null;
                                this.m_bodyCount = 0;
                                this.m_jointCount = 0;
                                this.m_warmStarting = true;
                                this.m_continuousPhysics = true;
                                this.m_subStepping = false;
                                this.m_stepComplete = true;
                                this.m_allowSleep = true;
                                this.m_gravity.set$org_jbox2d_common_Vec2(gravity);
                                this.m_flags = World.CLEAR_FORCES;
                                this.m_inv_dt0 = 0.0;
                                this.m_contactManager = new org.jbox2d.dynamics.ContactManager(this, broadPhase);
                                this.m_profile = new org.jbox2d.dynamics.Profile();
                                this.m_particleSystem = new org.jbox2d.particle.ParticleSystem(this);
                                this.initializeRegisters();
                            })();
                        }
                    }
                }
            } else throw new Error('invalid overload');
        }

        public setAllowSleep(flag : boolean) {
            if(flag === this.m_allowSleep) {
                return;
            }
            this.m_allowSleep = flag;
            if(this.m_allowSleep === false) {
                for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.m_next) {
                    b.setAwake(true);
                };
            }
        }

        public setSubStepping(subStepping : boolean) {
            this.m_subStepping = subStepping;
        }

        public isSubStepping() : boolean {
            return this.m_subStepping;
        }

        public isAllowSleep() : boolean {
            return this.m_allowSleep;
        }

        /*private*/ addType(creator : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact>, type1 : org.jbox2d.collision.shapes.ShapeType, type2 : org.jbox2d.collision.shapes.ShapeType) {
            let register : org.jbox2d.dynamics.contacts.ContactRegister = new org.jbox2d.dynamics.contacts.ContactRegister();
            register.creator = creator;
            register.primary = true;
            this.contactStacks[/* Enum.ordinal */org.jbox2d.collision.shapes.ShapeType[org.jbox2d.collision.shapes.ShapeType[type1]]][/* Enum.ordinal */org.jbox2d.collision.shapes.ShapeType[org.jbox2d.collision.shapes.ShapeType[type2]]] = register;
            if(type1 !== type2) {
                let register2 : org.jbox2d.dynamics.contacts.ContactRegister = new org.jbox2d.dynamics.contacts.ContactRegister();
                register2.creator = creator;
                register2.primary = false;
                this.contactStacks[/* Enum.ordinal */org.jbox2d.collision.shapes.ShapeType[org.jbox2d.collision.shapes.ShapeType[type2]]][/* Enum.ordinal */org.jbox2d.collision.shapes.ShapeType[org.jbox2d.collision.shapes.ShapeType[type1]]] = register2;
            }
        }

        /*private*/ initializeRegisters() {
            this.addType(this.pool.getCircleContactStack(), org.jbox2d.collision.shapes.ShapeType.CIRCLE, org.jbox2d.collision.shapes.ShapeType.CIRCLE);
            this.addType(this.pool.getPolyCircleContactStack(), org.jbox2d.collision.shapes.ShapeType.POLYGON, org.jbox2d.collision.shapes.ShapeType.CIRCLE);
            this.addType(this.pool.getPolyContactStack(), org.jbox2d.collision.shapes.ShapeType.POLYGON, org.jbox2d.collision.shapes.ShapeType.POLYGON);
            this.addType(this.pool.getEdgeCircleContactStack(), org.jbox2d.collision.shapes.ShapeType.EDGE, org.jbox2d.collision.shapes.ShapeType.CIRCLE);
            this.addType(this.pool.getEdgePolyContactStack(), org.jbox2d.collision.shapes.ShapeType.EDGE, org.jbox2d.collision.shapes.ShapeType.POLYGON);
            this.addType(this.pool.getChainCircleContactStack(), org.jbox2d.collision.shapes.ShapeType.CHAIN, org.jbox2d.collision.shapes.ShapeType.CIRCLE);
            this.addType(this.pool.getChainPolyContactStack(), org.jbox2d.collision.shapes.ShapeType.CHAIN, org.jbox2d.collision.shapes.ShapeType.POLYGON);
        }

        public getDestructionListener() : org.jbox2d.callbacks.DestructionListener {
            return this.m_destructionListener;
        }

        public getParticleDestructionListener() : org.jbox2d.callbacks.ParticleDestructionListener {
            return this.m_particleDestructionListener;
        }

        public setParticleDestructionListener(listener : org.jbox2d.callbacks.ParticleDestructionListener) {
            this.m_particleDestructionListener = listener;
        }

        public popContact(fixtureA : org.jbox2d.dynamics.Fixture, indexA : number, fixtureB : org.jbox2d.dynamics.Fixture, indexB : number) : org.jbox2d.dynamics.contacts.Contact {
            let type1 : org.jbox2d.collision.shapes.ShapeType = fixtureA.getType();
            let type2 : org.jbox2d.collision.shapes.ShapeType = fixtureB.getType();
            let reg : org.jbox2d.dynamics.contacts.ContactRegister = this.contactStacks[/* Enum.ordinal */org.jbox2d.collision.shapes.ShapeType[org.jbox2d.collision.shapes.ShapeType[type1]]][/* Enum.ordinal */org.jbox2d.collision.shapes.ShapeType[org.jbox2d.collision.shapes.ShapeType[type2]]];
            if(reg != null) {
                if(reg.primary) {
                    let c : org.jbox2d.dynamics.contacts.Contact = reg.creator.pop();
                    c.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fixtureA, indexA, fixtureB, indexB);
                    return c;
                } else {
                    let c : org.jbox2d.dynamics.contacts.Contact = reg.creator.pop();
                    c.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fixtureB, indexB, fixtureA, indexA);
                    return c;
                }
            } else {
                return null;
            }
        }

        public pushContact(contact : org.jbox2d.dynamics.contacts.Contact) {
            let fixtureA : org.jbox2d.dynamics.Fixture = contact.getFixtureA();
            let fixtureB : org.jbox2d.dynamics.Fixture = contact.getFixtureB();
            if(contact.m_manifold.pointCount > 0 && !fixtureA.isSensor() && !fixtureB.isSensor()) {
                fixtureA.getBody().setAwake(true);
                fixtureB.getBody().setAwake(true);
            }
            let type1 : org.jbox2d.collision.shapes.ShapeType = fixtureA.getType();
            let type2 : org.jbox2d.collision.shapes.ShapeType = fixtureB.getType();
            let creator : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact> = this.contactStacks[/* Enum.ordinal */org.jbox2d.collision.shapes.ShapeType[org.jbox2d.collision.shapes.ShapeType[type1]]][/* Enum.ordinal */org.jbox2d.collision.shapes.ShapeType[org.jbox2d.collision.shapes.ShapeType[type2]]].creator;
            creator.push(contact);
        }

        public getPool() : org.jbox2d.pooling.IWorldPool {
            return this.pool;
        }

        /**
         * Register a destruction listener. The listener is owned by you and must remain in scope.
         * 
         * @param {*} listener
         */
        public setDestructionListener(listener : org.jbox2d.callbacks.DestructionListener) {
            this.m_destructionListener = listener;
        }

        /**
         * Register a contact filter to provide specific control over collision. Otherwise the default
         * filter is used (_defaultFilter). The listener is owned by you and must remain in scope.
         * 
         * @param {org.jbox2d.callbacks.ContactFilter} filter
         */
        public setContactFilter(filter : org.jbox2d.callbacks.ContactFilter) {
            this.m_contactManager.m_contactFilter = filter;
        }

        /**
         * Register a contact event listener. The listener is owned by you and must remain in scope.
         * 
         * @param {*} listener
         */
        public setContactListener(listener : org.jbox2d.callbacks.ContactListener) {
            this.m_contactManager.m_contactListener = listener;
        }

        /**
         * Register a routine for debug drawing. The debug draw functions are called inside with
         * World.DrawDebugData method. The debug draw object is owned by you and must remain in scope.
         * 
         * @param {org.jbox2d.callbacks.DebugDraw} debugDraw
         */
        public setDebugDraw(debugDraw : org.jbox2d.callbacks.DebugDraw) {
            this.m_debugDraw = debugDraw;
        }

        /**
         * create a rigid body given a definition. No reference to the definition is retained.
         * 
         * @warning This function is locked during callbacks.
         * @param {org.jbox2d.dynamics.BodyDef} def
         * @return
         * @return {org.jbox2d.dynamics.Body}
         */
        public createBody(def : org.jbox2d.dynamics.BodyDef) : org.jbox2d.dynamics.Body {
            if(this.isLocked()) {
                return null;
            }
            let b : org.jbox2d.dynamics.Body = new org.jbox2d.dynamics.Body(def, this);
            b.m_prev = null;
            b.m_next = this.m_bodyList;
            if(this.m_bodyList != null) {
                this.m_bodyList.m_prev = b;
            }
            this.m_bodyList = b;
            ++this.m_bodyCount;
            return b;
        }

        /**
         * destroy a rigid body given a definition. No reference to the definition is retained. This
         * function is locked during callbacks.
         * 
         * @warning This automatically deletes all associated shapes and joints.
         * @warning This function is locked during callbacks.
         * @param {org.jbox2d.dynamics.Body} body
         */
        public destroyBody(body : org.jbox2d.dynamics.Body) {
            if(this.isLocked()) {
                return;
            }
            let je : org.jbox2d.dynamics.joints.JointEdge = body.m_jointList;
            while((je != null)) {
                let je0 : org.jbox2d.dynamics.joints.JointEdge = je;
                je = je.next;
                if(this.m_destructionListener != null) {
                    this.m_destructionListener['sayGoodbye$org_jbox2d_dynamics_joints_Joint'](je0.joint);
                }
                this.destroyJoint(je0.joint);
                body.m_jointList = je;
            };
            body.m_jointList = null;
            let ce : org.jbox2d.dynamics.contacts.ContactEdge = body.m_contactList;
            while((ce != null)) {
                let ce0 : org.jbox2d.dynamics.contacts.ContactEdge = ce;
                ce = ce.next;
                this.m_contactManager.destroy(ce0.contact);
            };
            body.m_contactList = null;
            let f : org.jbox2d.dynamics.Fixture = body.m_fixtureList;
            while((f != null)) {
                let f0 : org.jbox2d.dynamics.Fixture = f;
                f = f.m_next;
                if(this.m_destructionListener != null) {
                    this.m_destructionListener['sayGoodbye$org_jbox2d_dynamics_Fixture'](f0);
                }
                f0.destroyProxies(this.m_contactManager.m_broadPhase);
                f0.destroy();
                body.m_fixtureList = f;
                body.m_fixtureCount -= 1;
            };
            body.m_fixtureList = null;
            body.m_fixtureCount = 0;
            if(body.m_prev != null) {
                body.m_prev.m_next = body.m_next;
            }
            if(body.m_next != null) {
                body.m_next.m_prev = body.m_prev;
            }
            if(body === this.m_bodyList) {
                this.m_bodyList = body.m_next;
            }
            --this.m_bodyCount;
        }

        /**
         * create a joint to constrain bodies together. No reference to the definition is retained. This
         * may cause the connected bodies to cease colliding.
         * 
         * @warning This function is locked during callbacks.
         * @param {org.jbox2d.dynamics.joints.JointDef} def
         * @return
         * @return {org.jbox2d.dynamics.joints.Joint}
         */
        public createJoint(def : org.jbox2d.dynamics.joints.JointDef) : org.jbox2d.dynamics.joints.Joint {
            if(this.isLocked()) {
                return null;
            }
            let j : org.jbox2d.dynamics.joints.Joint = org.jbox2d.dynamics.joints.Joint.create(this, def);
            j.m_prev = null;
            j.m_next = this.m_jointList;
            if(this.m_jointList != null) {
                this.m_jointList.m_prev = j;
            }
            this.m_jointList = j;
            ++this.m_jointCount;
            j.m_edgeA.joint = j;
            j.m_edgeA.other = j.getBodyB();
            j.m_edgeA.prev = null;
            j.m_edgeA.next = j.getBodyA().m_jointList;
            if(j.getBodyA().m_jointList != null) {
                j.getBodyA().m_jointList.prev = j.m_edgeA;
            }
            j.getBodyA().m_jointList = j.m_edgeA;
            j.m_edgeB.joint = j;
            j.m_edgeB.other = j.getBodyA();
            j.m_edgeB.prev = null;
            j.m_edgeB.next = j.getBodyB().m_jointList;
            if(j.getBodyB().m_jointList != null) {
                j.getBodyB().m_jointList.prev = j.m_edgeB;
            }
            j.getBodyB().m_jointList = j.m_edgeB;
            let bodyA : org.jbox2d.dynamics.Body = def.bodyA;
            let bodyB : org.jbox2d.dynamics.Body = def.bodyB;
            if(def.collideConnected === false) {
                let edge : org.jbox2d.dynamics.contacts.ContactEdge = bodyB.getContactList();
                while((edge != null)) {
                    if(edge.other === bodyA) {
                        edge.contact.flagForFiltering();
                    }
                    edge = edge.next;
                };
            }
            return j;
        }

        /**
         * destroy a joint. This may cause the connected bodies to begin colliding.
         * 
         * @warning This function is locked during callbacks.
         * @param joint
         * @param {org.jbox2d.dynamics.joints.Joint} j
         */
        public destroyJoint(j : org.jbox2d.dynamics.joints.Joint) {
            if(this.isLocked()) {
                return;
            }
            let collideConnected : boolean = j.getCollideConnected();
            if(j.m_prev != null) {
                j.m_prev.m_next = j.m_next;
            }
            if(j.m_next != null) {
                j.m_next.m_prev = j.m_prev;
            }
            if(j === this.m_jointList) {
                this.m_jointList = j.m_next;
            }
            let bodyA : org.jbox2d.dynamics.Body = j.getBodyA();
            let bodyB : org.jbox2d.dynamics.Body = j.getBodyB();
            bodyA.setAwake(true);
            bodyB.setAwake(true);
            if(j.m_edgeA.prev != null) {
                j.m_edgeA.prev.next = j.m_edgeA.next;
            }
            if(j.m_edgeA.next != null) {
                j.m_edgeA.next.prev = j.m_edgeA.prev;
            }
            if(j.m_edgeA === bodyA.m_jointList) {
                bodyA.m_jointList = j.m_edgeA.next;
            }
            j.m_edgeA.prev = null;
            j.m_edgeA.next = null;
            if(j.m_edgeB.prev != null) {
                j.m_edgeB.prev.next = j.m_edgeB.next;
            }
            if(j.m_edgeB.next != null) {
                j.m_edgeB.next.prev = j.m_edgeB.prev;
            }
            if(j.m_edgeB === bodyB.m_jointList) {
                bodyB.m_jointList = j.m_edgeB.next;
            }
            j.m_edgeB.prev = null;
            j.m_edgeB.next = null;
            org.jbox2d.dynamics.joints.Joint.destroy(j);
            --this.m_jointCount;
            if(collideConnected === false) {
                let edge : org.jbox2d.dynamics.contacts.ContactEdge = bodyB.getContactList();
                while((edge != null)) {
                    if(edge.other === bodyA) {
                        edge.contact.flagForFiltering();
                    }
                    edge = edge.next;
                };
            }
        }

        /*private*/ __step : org.jbox2d.dynamics.TimeStep = new org.jbox2d.dynamics.TimeStep();

        /*private*/ stepTimer : org.jbox2d.common.Timer = new org.jbox2d.common.Timer();

        /*private*/ tempTimer : org.jbox2d.common.Timer = new org.jbox2d.common.Timer();

        /**
         * Take a time step. This performs collision detection, integration, and constraint solution.
         * 
         * @param timeStep the amount of time to simulate, this should not vary.
         * @param {number} velocityIterations for the velocity constraint solver.
         * @param {number} positionIterations for the position constraint solver.
         * @param {number} dt
         */
        public step(dt : number, velocityIterations : number, positionIterations : number) {
            this.stepTimer.reset();
            this.tempTimer.reset();
            if((this.m_flags & World.NEW_FIXTURE) === World.NEW_FIXTURE) {
                this.m_contactManager.findNewContacts();
                this.m_flags &= ~World.NEW_FIXTURE;
            }
            this.m_flags |= World.LOCKED;
            this.__step.dt = dt;
            this.__step.velocityIterations = velocityIterations;
            this.__step.positionIterations = positionIterations;
            if(dt > 0.0) {
                this.__step.inv_dt = (<any>Math).fround(1.0 / dt);
            } else {
                this.__step.inv_dt = 0.0;
            }
            this.__step.dtRatio = (<any>Math).fround(this.m_inv_dt0 * dt);
            this.__step.warmStarting = this.m_warmStarting;
            this.m_profile.stepInit.record(this.tempTimer.getMilliseconds());
            this.tempTimer.reset();
            this.m_contactManager.collide();
            this.m_profile.collide.record(this.tempTimer.getMilliseconds());
            if(this.m_stepComplete && this.__step.dt > 0.0) {
                this.tempTimer.reset();
                this.m_particleSystem.solve(this.__step);
                this.m_profile.solveParticleSystem.record(this.tempTimer.getMilliseconds());
                this.tempTimer.reset();
                this.solve(this.__step);
                this.m_profile.solve.record(this.tempTimer.getMilliseconds());
            }
            if(this.m_continuousPhysics && this.__step.dt > 0.0) {
                this.tempTimer.reset();
                this.solveTOI(this.__step);
                this.m_profile.solveTOI.record(this.tempTimer.getMilliseconds());
            }
            if(this.__step.dt > 0.0) {
                this.m_inv_dt0 = this.__step.inv_dt;
            }
            if((this.m_flags & World.CLEAR_FORCES) === World.CLEAR_FORCES) {
                this.clearForces();
            }
            this.m_flags &= ~World.LOCKED;
            this.m_profile.step.record(this.stepTimer.getMilliseconds());
        }

        /**
         * Call this after you are done with time steps to clear the forces. You normally call this after
         * each call to Step, unless you are performing sub-steps. By default, forces will be
         * automatically cleared, so you don't need to call this function.
         * 
         * @see setAutoClearForces
         */
        public clearForces() {
            for(let body : org.jbox2d.dynamics.Body = this.m_bodyList; body != null; body = body.getNext()) {
                body.m_force.setZero();
                body.m_torque = 0.0;
            };
        }

        /*private*/ color : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f();

        /*private*/ xf : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /*private*/ cA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ cB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ avs : org.jbox2d.pooling.arrays.Vec2Array = new org.jbox2d.pooling.arrays.Vec2Array();

        /**
         * Call this to draw shapes and other debug draw data.
         */
        public drawDebugData() {
            if(this.m_debugDraw == null) {
                return;
            }
            let flags : number = this.m_debugDraw.getFlags();
            let wireframe : boolean = (flags & org.jbox2d.callbacks.DebugDraw.e_wireframeDrawingBit_$LI$()) !== 0;
            if((flags & org.jbox2d.callbacks.DebugDraw.e_shapeBit_$LI$()) !== 0) {
                for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.getNext()) {
                    this.xf.set$org_jbox2d_common_Transform(b.getTransform());
                    for(let f : org.jbox2d.dynamics.Fixture = b.getFixtureList(); f != null; f = f.getNext()) {
                        if(b.isActive() === false) {
                            this.color.set$float$float$float(0.5, 0.5, 0.3);
                            this.drawShape(f, this.xf, this.color, wireframe);
                        } else if(b.getType() === org.jbox2d.dynamics.BodyType.STATIC) {
                            this.color.set$float$float$float(0.5, 0.9, 0.3);
                            this.drawShape(f, this.xf, this.color, wireframe);
                        } else if(b.getType() === org.jbox2d.dynamics.BodyType.KINEMATIC) {
                            this.color.set$float$float$float(0.5, 0.5, 0.9);
                            this.drawShape(f, this.xf, this.color, wireframe);
                        } else if(b.isAwake() === false) {
                            this.color.set$float$float$float(0.5, 0.5, 0.5);
                            this.drawShape(f, this.xf, this.color, wireframe);
                        } else {
                            this.color.set$float$float$float(0.9, 0.7, 0.7);
                            this.drawShape(f, this.xf, this.color, wireframe);
                        }
                    };
                };
                this.drawParticleSystem(this.m_particleSystem);
            }
            if((flags & org.jbox2d.callbacks.DebugDraw.e_jointBit_$LI$()) !== 0) {
                for(let j : org.jbox2d.dynamics.joints.Joint = this.m_jointList; j != null; j = j.getNext()) {
                    this.drawJoint(j);
                };
            }
            if((flags & org.jbox2d.callbacks.DebugDraw.e_pairBit_$LI$()) !== 0) {
                this.color.set$float$float$float(0.3, 0.9, 0.9);
                for(let c : org.jbox2d.dynamics.contacts.Contact = this.m_contactManager.m_contactList; c != null; c = c.getNext()) {
                    let fixtureA : org.jbox2d.dynamics.Fixture = c.getFixtureA();
                    let fixtureB : org.jbox2d.dynamics.Fixture = c.getFixtureB();
                    fixtureA.getAABB(c.getChildIndexA()).getCenterToOut(this.cA);
                    fixtureB.getAABB(c.getChildIndexB()).getCenterToOut(this.cB);
                    this.m_debugDraw.drawSegment(this.cA, this.cB, this.color);
                };
            }
            if((flags & org.jbox2d.callbacks.DebugDraw.e_aabbBit_$LI$()) !== 0) {
                this.color.set$float$float$float(0.9, 0.3, 0.9);
                for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.getNext()) {
                    if(b.isActive() === false) {
                        continue;
                    }
                    for(let f : org.jbox2d.dynamics.Fixture = b.getFixtureList(); f != null; f = f.getNext()) {
                        for(let i : number = 0; i < f.m_proxyCount; ++i) {
                            let proxy : org.jbox2d.dynamics.FixtureProxy = f.m_proxies[i];
                            let aabb : org.jbox2d.collision.AABB = this.m_contactManager.m_broadPhase.getFatAABB(proxy.proxyId);
                            if(aabb != null) {
                                let vs : org.jbox2d.common.Vec2[] = this.avs.get(4);
                                vs[0].set$float$float(aabb.lowerBound.x, aabb.lowerBound.y);
                                vs[1].set$float$float(aabb.upperBound.x, aabb.lowerBound.y);
                                vs[2].set$float$float(aabb.upperBound.x, aabb.upperBound.y);
                                vs[3].set$float$float(aabb.lowerBound.x, aabb.upperBound.y);
                                this.m_debugDraw.drawPolygon(vs, 4, this.color);
                            }
                        };
                    };
                };
            }
            if((flags & org.jbox2d.callbacks.DebugDraw.e_centerOfMassBit_$LI$()) !== 0) {
                for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.getNext()) {
                    this.xf.set$org_jbox2d_common_Transform(b.getTransform());
                    this.xf.p.set$org_jbox2d_common_Vec2(b.getWorldCenter());
                    this.m_debugDraw.drawTransform(this.xf);
                };
            }
            if((flags & org.jbox2d.callbacks.DebugDraw.e_dynamicTreeBit_$LI$()) !== 0) {
                this.m_contactManager.m_broadPhase.drawTree(this.m_debugDraw);
            }
            this.m_debugDraw.flush();
        }

        /*private*/ wqwrapper : org.jbox2d.dynamics.WorldQueryWrapper = new org.jbox2d.dynamics.WorldQueryWrapper();

        public queryAABB$org_jbox2d_callbacks_QueryCallback$org_jbox2d_collision_AABB(callback : org.jbox2d.callbacks.QueryCallback, aabb : org.jbox2d.collision.AABB) {
            this.wqwrapper.broadPhase = this.m_contactManager.m_broadPhase;
            this.wqwrapper.callback = callback;
            this.m_contactManager.m_broadPhase.query(this.wqwrapper, aabb);
        }

        public queryAABB$org_jbox2d_callbacks_QueryCallback$org_jbox2d_callbacks_ParticleQueryCallback$org_jbox2d_collision_AABB(callback : org.jbox2d.callbacks.QueryCallback, particleCallback : org.jbox2d.callbacks.ParticleQueryCallback, aabb : org.jbox2d.collision.AABB) {
            this.wqwrapper.broadPhase = this.m_contactManager.m_broadPhase;
            this.wqwrapper.callback = callback;
            this.m_contactManager.m_broadPhase.query(this.wqwrapper, aabb);
            this.m_particleSystem.queryAABB(particleCallback, aabb);
        }

        /**
         * Query the world for all fixtures and particles that potentially overlap the provided AABB.
         * 
         * @param {*} callback a user implemented callback class.
         * @param {*} particleCallback callback for particles.
         * @param {org.jbox2d.collision.AABB} aabb the query box.
         */
        public queryAABB(callback? : any, particleCallback? : any, aabb? : any) : any {
            if(((callback != null && (callback["__interfaces"] != null && callback["__interfaces"].indexOf("org.jbox2d.callbacks.QueryCallback") >= 0 || callback.constructor != null && callback.constructor["__interfaces"] != null && callback.constructor["__interfaces"].indexOf("org.jbox2d.callbacks.QueryCallback") >= 0)) || callback === null) && ((particleCallback != null && (particleCallback["__interfaces"] != null && particleCallback["__interfaces"].indexOf("org.jbox2d.callbacks.ParticleQueryCallback") >= 0 || particleCallback.constructor != null && particleCallback.constructor["__interfaces"] != null && particleCallback.constructor["__interfaces"].indexOf("org.jbox2d.callbacks.ParticleQueryCallback") >= 0)) || particleCallback === null) && ((aabb != null && aabb instanceof <any>org.jbox2d.collision.AABB) || aabb === null)) {
                return <any>this.queryAABB$org_jbox2d_callbacks_QueryCallback$org_jbox2d_callbacks_ParticleQueryCallback$org_jbox2d_collision_AABB(callback, particleCallback, aabb);
            } else if(((callback != null && (callback["__interfaces"] != null && callback["__interfaces"].indexOf("org.jbox2d.callbacks.QueryCallback") >= 0 || callback.constructor != null && callback.constructor["__interfaces"] != null && callback.constructor["__interfaces"].indexOf("org.jbox2d.callbacks.QueryCallback") >= 0)) || callback === null) && ((particleCallback != null && particleCallback instanceof <any>org.jbox2d.collision.AABB) || particleCallback === null) && aabb === undefined) {
                return <any>this.queryAABB$org_jbox2d_callbacks_QueryCallback$org_jbox2d_collision_AABB(callback, particleCallback);
            } else if(((callback != null && (callback["__interfaces"] != null && callback["__interfaces"].indexOf("org.jbox2d.callbacks.ParticleQueryCallback") >= 0 || callback.constructor != null && callback.constructor["__interfaces"] != null && callback.constructor["__interfaces"].indexOf("org.jbox2d.callbacks.ParticleQueryCallback") >= 0)) || callback === null) && ((particleCallback != null && particleCallback instanceof <any>org.jbox2d.collision.AABB) || particleCallback === null) && aabb === undefined) {
                return <any>this.queryAABB$org_jbox2d_callbacks_ParticleQueryCallback$org_jbox2d_collision_AABB(callback, particleCallback);
            } else throw new Error('invalid overload');
        }

        public queryAABB$org_jbox2d_callbacks_ParticleQueryCallback$org_jbox2d_collision_AABB(particleCallback : org.jbox2d.callbacks.ParticleQueryCallback, aabb : org.jbox2d.collision.AABB) {
            this.m_particleSystem.queryAABB(particleCallback, aabb);
        }

        /*private*/ wrcwrapper : org.jbox2d.dynamics.WorldRayCastWrapper = new org.jbox2d.dynamics.WorldRayCastWrapper();

        /*private*/ input : org.jbox2d.collision.RayCastInput = new org.jbox2d.collision.RayCastInput();

        public raycast$org_jbox2d_callbacks_RayCastCallback$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(callback : org.jbox2d.callbacks.RayCastCallback, point1 : org.jbox2d.common.Vec2, point2 : org.jbox2d.common.Vec2) {
            this.wrcwrapper.broadPhase = this.m_contactManager.m_broadPhase;
            this.wrcwrapper.callback = callback;
            this.input.maxFraction = 1.0;
            this.input.p1.set$org_jbox2d_common_Vec2(point1);
            this.input.p2.set$org_jbox2d_common_Vec2(point2);
            this.m_contactManager.m_broadPhase.raycast(this.wrcwrapper, this.input);
        }

        public raycast$org_jbox2d_callbacks_RayCastCallback$org_jbox2d_callbacks_ParticleRaycastCallback$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(callback : org.jbox2d.callbacks.RayCastCallback, particleCallback : org.jbox2d.callbacks.ParticleRaycastCallback, point1 : org.jbox2d.common.Vec2, point2 : org.jbox2d.common.Vec2) {
            this.wrcwrapper.broadPhase = this.m_contactManager.m_broadPhase;
            this.wrcwrapper.callback = callback;
            this.input.maxFraction = 1.0;
            this.input.p1.set$org_jbox2d_common_Vec2(point1);
            this.input.p2.set$org_jbox2d_common_Vec2(point2);
            this.m_contactManager.m_broadPhase.raycast(this.wrcwrapper, this.input);
            this.m_particleSystem.raycast(particleCallback, point1, point2);
        }

        /**
         * Ray-cast the world for all fixtures and particles in the path of the ray. Your callback
         * controls whether you get the closest point, any point, or n-points. The ray-cast ignores shapes
         * that contain the starting point.
         * 
         * @param {*} callback a user implemented callback class.
         * @param {*} particleCallback the particle callback class.
         * @param {org.jbox2d.common.Vec2} point1 the ray starting point
         * @param {org.jbox2d.common.Vec2} point2 the ray ending point
         */
        public raycast(callback? : any, particleCallback? : any, point1? : any, point2? : any) : any {
            if(((callback != null && (callback["__interfaces"] != null && callback["__interfaces"].indexOf("org.jbox2d.callbacks.RayCastCallback") >= 0 || callback.constructor != null && callback.constructor["__interfaces"] != null && callback.constructor["__interfaces"].indexOf("org.jbox2d.callbacks.RayCastCallback") >= 0)) || callback === null) && ((particleCallback != null && (particleCallback["__interfaces"] != null && particleCallback["__interfaces"].indexOf("org.jbox2d.callbacks.ParticleRaycastCallback") >= 0 || particleCallback.constructor != null && particleCallback.constructor["__interfaces"] != null && particleCallback.constructor["__interfaces"].indexOf("org.jbox2d.callbacks.ParticleRaycastCallback") >= 0)) || particleCallback === null) && ((point1 != null && point1 instanceof <any>org.jbox2d.common.Vec2) || point1 === null) && ((point2 != null && point2 instanceof <any>org.jbox2d.common.Vec2) || point2 === null)) {
                return <any>this.raycast$org_jbox2d_callbacks_RayCastCallback$org_jbox2d_callbacks_ParticleRaycastCallback$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(callback, particleCallback, point1, point2);
            } else if(((callback != null && (callback["__interfaces"] != null && callback["__interfaces"].indexOf("org.jbox2d.callbacks.RayCastCallback") >= 0 || callback.constructor != null && callback.constructor["__interfaces"] != null && callback.constructor["__interfaces"].indexOf("org.jbox2d.callbacks.RayCastCallback") >= 0)) || callback === null) && ((particleCallback != null && particleCallback instanceof <any>org.jbox2d.common.Vec2) || particleCallback === null) && ((point1 != null && point1 instanceof <any>org.jbox2d.common.Vec2) || point1 === null) && point2 === undefined) {
                return <any>this.raycast$org_jbox2d_callbacks_RayCastCallback$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(callback, particleCallback, point1);
            } else if(((callback != null && (callback["__interfaces"] != null && callback["__interfaces"].indexOf("org.jbox2d.callbacks.ParticleRaycastCallback") >= 0 || callback.constructor != null && callback.constructor["__interfaces"] != null && callback.constructor["__interfaces"].indexOf("org.jbox2d.callbacks.ParticleRaycastCallback") >= 0)) || callback === null) && ((particleCallback != null && particleCallback instanceof <any>org.jbox2d.common.Vec2) || particleCallback === null) && ((point1 != null && point1 instanceof <any>org.jbox2d.common.Vec2) || point1 === null) && point2 === undefined) {
                return <any>this.raycast$org_jbox2d_callbacks_ParticleRaycastCallback$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(callback, particleCallback, point1);
            } else throw new Error('invalid overload');
        }

        public raycast$org_jbox2d_callbacks_ParticleRaycastCallback$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(particleCallback : org.jbox2d.callbacks.ParticleRaycastCallback, point1 : org.jbox2d.common.Vec2, point2 : org.jbox2d.common.Vec2) {
            this.m_particleSystem.raycast(particleCallback, point1, point2);
        }

        /**
         * Get the world body list. With the returned body, use Body.getNext to get the next body in the
         * world list. A null body indicates the end of the list.
         * 
         * @return {org.jbox2d.dynamics.Body} the head of the world body list.
         */
        public getBodyList() : org.jbox2d.dynamics.Body {
            return this.m_bodyList;
        }

        /**
         * Get the world joint list. With the returned joint, use Joint.getNext to get the next joint in
         * the world list. A null joint indicates the end of the list.
         * 
         * @return {org.jbox2d.dynamics.joints.Joint} the head of the world joint list.
         */
        public getJointList() : org.jbox2d.dynamics.joints.Joint {
            return this.m_jointList;
        }

        /**
         * Get the world contact list. With the returned contact, use Contact.getNext to get the next
         * contact in the world list. A null contact indicates the end of the list.
         * 
         * @return {org.jbox2d.dynamics.contacts.Contact} the head of the world contact list.
         * @warning contacts are created and destroyed in the middle of a time step. Use ContactListener
         * to avoid missing contacts.
         */
        public getContactList() : org.jbox2d.dynamics.contacts.Contact {
            return this.m_contactManager.m_contactList;
        }

        public isSleepingAllowed() : boolean {
            return this.m_allowSleep;
        }

        public setSleepingAllowed(sleepingAllowed : boolean) {
            this.m_allowSleep = sleepingAllowed;
        }

        /**
         * Enable/disable warm starting. For testing.
         * 
         * @param {boolean} flag
         */
        public setWarmStarting(flag : boolean) {
            this.m_warmStarting = flag;
        }

        public isWarmStarting() : boolean {
            return this.m_warmStarting;
        }

        /**
         * Enable/disable continuous physics. For testing.
         * 
         * @param {boolean} flag
         */
        public setContinuousPhysics(flag : boolean) {
            this.m_continuousPhysics = flag;
        }

        public isContinuousPhysics() : boolean {
            return this.m_continuousPhysics;
        }

        /**
         * Get the number of broad-phase proxies.
         * 
         * @return
         * @return {number}
         */
        public getProxyCount() : number {
            return this.m_contactManager.m_broadPhase.getProxyCount();
        }

        /**
         * Get the number of bodies.
         * 
         * @return
         * @return {number}
         */
        public getBodyCount() : number {
            return this.m_bodyCount;
        }

        /**
         * Get the number of joints.
         * 
         * @return
         * @return {number}
         */
        public getJointCount() : number {
            return this.m_jointCount;
        }

        /**
         * Get the number of contacts (each may have 0 or more contact points).
         * 
         * @return
         * @return {number}
         */
        public getContactCount() : number {
            return this.m_contactManager.m_contactCount;
        }

        /**
         * Gets the height of the dynamic tree
         * 
         * @return
         * @return {number}
         */
        public getTreeHeight() : number {
            return this.m_contactManager.m_broadPhase.getTreeHeight();
        }

        /**
         * Gets the balance of the dynamic tree
         * 
         * @return
         * @return {number}
         */
        public getTreeBalance() : number {
            return this.m_contactManager.m_broadPhase.getTreeBalance();
        }

        /**
         * Gets the quality of the dynamic tree
         * 
         * @return
         * @return {number}
         */
        public getTreeQuality() : number {
            return this.m_contactManager.m_broadPhase.getTreeQuality();
        }

        /**
         * Change the global gravity vector.
         * 
         * @param {org.jbox2d.common.Vec2} gravity
         */
        public setGravity(gravity : org.jbox2d.common.Vec2) {
            this.m_gravity.set$org_jbox2d_common_Vec2(gravity);
        }

        /**
         * Get the global gravity vector.
         * 
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public getGravity() : org.jbox2d.common.Vec2 {
            return this.m_gravity;
        }

        /**
         * Is the world locked (in the middle of a time step).
         * 
         * @return
         * @return {boolean}
         */
        public isLocked() : boolean {
            return (this.m_flags & World.LOCKED) === World.LOCKED;
        }

        /**
         * Set flag to control automatic clearing of forces after each time step.
         * 
         * @param {boolean} flag
         */
        public setAutoClearForces(flag : boolean) {
            if(flag) {
                this.m_flags |= World.CLEAR_FORCES;
            } else {
                this.m_flags &= ~World.CLEAR_FORCES;
            }
        }

        /**
         * Get the flag that controls automatic clearing of forces after each time step.
         * 
         * @return
         * @return {boolean}
         */
        public getAutoClearForces() : boolean {
            return (this.m_flags & World.CLEAR_FORCES) === World.CLEAR_FORCES;
        }

        /**
         * Get the contact manager for testing purposes
         * 
         * @return
         * @return {org.jbox2d.dynamics.ContactManager}
         */
        public getContactManager() : org.jbox2d.dynamics.ContactManager {
            return this.m_contactManager;
        }

        public getProfile() : org.jbox2d.dynamics.Profile {
            return this.m_profile;
        }

        /*private*/ island : org.jbox2d.dynamics.Island = new org.jbox2d.dynamics.Island();

        /*private*/ stack : org.jbox2d.dynamics.Body[] = [null, null, null, null, null, null, null, null, null, null];

        /*private*/ broadphaseTimer : org.jbox2d.common.Timer = new org.jbox2d.common.Timer();

        /*private*/ solve(step : org.jbox2d.dynamics.TimeStep) {
            this.m_profile.solveInit.startAccum();
            this.m_profile.solveVelocity.startAccum();
            this.m_profile.solvePosition.startAccum();
            for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.m_next) {
                b.m_xf0.set$org_jbox2d_common_Transform(b.m_xf);
            };
            this.island.init(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, this.m_contactManager.m_contactListener);
            for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.m_next) {
                b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
            };
            for(let c : org.jbox2d.dynamics.contacts.Contact = this.m_contactManager.m_contactList; c != null; c = c.m_next) {
                c.m_flags &= ~org.jbox2d.dynamics.contacts.Contact.ISLAND_FLAG;
            };
            for(let j : org.jbox2d.dynamics.joints.Joint = this.m_jointList; j != null; j = j.m_next) {
                j.m_islandFlag = false;
            };
            let stackSize : number = this.m_bodyCount;
            if(this.stack.length < stackSize) {
                this.stack = (s => { let a=[]; while(s-->0) a.push(null); return a; })(stackSize);
            }
            for(let seed : org.jbox2d.dynamics.Body = this.m_bodyList; seed != null; seed = seed.m_next) {
                if((seed.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) === org.jbox2d.dynamics.Body.e_islandFlag) {
                    continue;
                }
                if(seed.isAwake() === false || seed.isActive() === false) {
                    continue;
                }
                if(seed.getType() === org.jbox2d.dynamics.BodyType.STATIC) {
                    continue;
                }
                this.island.clear();
                let stackCount : number = 0;
                this.stack[stackCount++] = seed;
                seed.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                while((stackCount > 0)) {
                    let b : org.jbox2d.dynamics.Body = this.stack[--stackCount];
                    this.island.add$org_jbox2d_dynamics_Body(b);
                    b.setAwake(true);
                    if(b.getType() === org.jbox2d.dynamics.BodyType.STATIC) {
                        continue;
                    }
                    for(let ce : org.jbox2d.dynamics.contacts.ContactEdge = b.m_contactList; ce != null; ce = ce.next) {
                        let contact : org.jbox2d.dynamics.contacts.Contact = ce.contact;
                        if((contact.m_flags & org.jbox2d.dynamics.contacts.Contact.ISLAND_FLAG) === org.jbox2d.dynamics.contacts.Contact.ISLAND_FLAG) {
                            continue;
                        }
                        if(contact.isEnabled() === false || contact.isTouching() === false) {
                            continue;
                        }
                        let sensorA : boolean = contact.m_fixtureA.m_isSensor;
                        let sensorB : boolean = contact.m_fixtureB.m_isSensor;
                        if(sensorA || sensorB) {
                            continue;
                        }
                        this.island.add$org_jbox2d_dynamics_contacts_Contact(contact);
                        contact.m_flags |= org.jbox2d.dynamics.contacts.Contact.ISLAND_FLAG;
                        let other : org.jbox2d.dynamics.Body = ce.other;
                        if((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) === org.jbox2d.dynamics.Body.e_islandFlag) {
                            continue;
                        }
                        this.stack[stackCount++] = other;
                        other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                    };
                    for(let je : org.jbox2d.dynamics.joints.JointEdge = b.m_jointList; je != null; je = je.next) {
                        if(je.joint.m_islandFlag === true) {
                            continue;
                        }
                        let other : org.jbox2d.dynamics.Body = je.other;
                        if(other.isActive() === false) {
                            continue;
                        }
                        this.island.add$org_jbox2d_dynamics_joints_Joint(je.joint);
                        je.joint.m_islandFlag = true;
                        if((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) === org.jbox2d.dynamics.Body.e_islandFlag) {
                            continue;
                        }
                        this.stack[stackCount++] = other;
                        other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                    };
                };
                this.island.solve(this.m_profile, step, this.m_gravity, this.m_allowSleep);
                for(let i : number = 0; i < this.island.m_bodyCount; ++i) {
                    let b : org.jbox2d.dynamics.Body = this.island.m_bodies[i];
                    if(b.getType() === org.jbox2d.dynamics.BodyType.STATIC) {
                        b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
                    }
                };
            };
            this.m_profile.solveInit.endAccum();
            this.m_profile.solveVelocity.endAccum();
            this.m_profile.solvePosition.endAccum();
            this.broadphaseTimer.reset();
            for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.getNext()) {
                if((b.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) === 0) {
                    continue;
                }
                if(b.getType() === org.jbox2d.dynamics.BodyType.STATIC) {
                    continue;
                }
                b.synchronizeFixtures();
            };
            this.m_contactManager.findNewContacts();
            this.m_profile.broadphase.record(this.broadphaseTimer.getMilliseconds());
        }

        /*private*/ toiIsland : org.jbox2d.dynamics.Island = new org.jbox2d.dynamics.Island();

        /*private*/ toiInput : org.jbox2d.collision.TimeOfImpact.TOIInput = new org.jbox2d.collision.TimeOfImpact.TOIInput();

        /*private*/ toiOutput : org.jbox2d.collision.TimeOfImpact.TOIOutput = new org.jbox2d.collision.TimeOfImpact.TOIOutput();

        /*private*/ subStep : org.jbox2d.dynamics.TimeStep = new org.jbox2d.dynamics.TimeStep();

        /*private*/ tempBodies : org.jbox2d.dynamics.Body[] = [null, null];

        /*private*/ backup1 : org.jbox2d.common.Sweep = new org.jbox2d.common.Sweep();

        /*private*/ backup2 : org.jbox2d.common.Sweep = new org.jbox2d.common.Sweep();

        /*private*/ solveTOI(step : org.jbox2d.dynamics.TimeStep) {
            let island : org.jbox2d.dynamics.Island = this.toiIsland;
            island.init(2 * org.jbox2d.common.Settings.maxTOIContacts, org.jbox2d.common.Settings.maxTOIContacts, 0, this.m_contactManager.m_contactListener);
            if(this.m_stepComplete) {
                for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.m_next) {
                    b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
                    b.m_sweep.alpha0 = 0.0;
                };
                for(let c : org.jbox2d.dynamics.contacts.Contact = this.m_contactManager.m_contactList; c != null; c = c.m_next) {
                    c.m_flags &= ~(org.jbox2d.dynamics.contacts.Contact.TOI_FLAG | org.jbox2d.dynamics.contacts.Contact.ISLAND_FLAG);
                    c.m_toiCount = 0;
                    c.m_toi = 1.0;
                };
            }
            for(; ; ) {
                let minContact : org.jbox2d.dynamics.contacts.Contact = null;
                let minAlpha : number = 1.0;
                for(let c : org.jbox2d.dynamics.contacts.Contact = this.m_contactManager.m_contactList; c != null; c = c.m_next) {
                    if(c.isEnabled() === false) {
                        continue;
                    }
                    if(c.m_toiCount > org.jbox2d.common.Settings.maxSubSteps) {
                        continue;
                    }
                    let alpha : number = 1.0;
                    if((c.m_flags & org.jbox2d.dynamics.contacts.Contact.TOI_FLAG) !== 0) {
                        alpha = c.m_toi;
                    } else {
                        let fA : org.jbox2d.dynamics.Fixture = c.getFixtureA();
                        let fB : org.jbox2d.dynamics.Fixture = c.getFixtureB();
                        if(fA.isSensor() || fB.isSensor()) {
                            continue;
                        }
                        let bA : org.jbox2d.dynamics.Body = fA.getBody();
                        let bB : org.jbox2d.dynamics.Body = fB.getBody();
                        let typeA : org.jbox2d.dynamics.BodyType = bA.m_type;
                        let typeB : org.jbox2d.dynamics.BodyType = bB.m_type;
                        let activeA : boolean = bA.isAwake() && typeA !== org.jbox2d.dynamics.BodyType.STATIC;
                        let activeB : boolean = bB.isAwake() && typeB !== org.jbox2d.dynamics.BodyType.STATIC;
                        if(activeA === false && activeB === false) {
                            continue;
                        }
                        let collideA : boolean = bA.isBullet() || typeA !== org.jbox2d.dynamics.BodyType.DYNAMIC;
                        let collideB : boolean = bB.isBullet() || typeB !== org.jbox2d.dynamics.BodyType.DYNAMIC;
                        if(collideA === false && collideB === false) {
                            continue;
                        }
                        let alpha0 : number = bA.m_sweep.alpha0;
                        if(bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
                            alpha0 = bB.m_sweep.alpha0;
                            bA.m_sweep.advance(alpha0);
                        } else if(bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
                            alpha0 = bA.m_sweep.alpha0;
                            bB.m_sweep.advance(alpha0);
                        }
                        let indexA : number = c.getChildIndexA();
                        let indexB : number = c.getChildIndexB();
                        let input : org.jbox2d.collision.TimeOfImpact.TOIInput = this.toiInput;
                        input.proxyA.set(fA.getShape(), indexA);
                        input.proxyB.set(fB.getShape(), indexB);
                        input.sweepA.set(bA.m_sweep);
                        input.sweepB.set(bB.m_sweep);
                        input.tMax = 1.0;
                        this.pool.getTimeOfImpact().timeOfImpact(this.toiOutput, input);
                        let beta : number = this.toiOutput.t;
                        if(this.toiOutput.state === org.jbox2d.collision.TimeOfImpact.TOIOutputState.TOUCHING) {
                            alpha = org.jbox2d.common.MathUtils.min$float$float((<any>Math).fround(alpha0 + (<any>Math).fround(((<any>Math).fround(1.0 - alpha0)) * beta)), 1.0);
                        } else {
                            alpha = 1.0;
                        }
                        c.m_toi = alpha;
                        c.m_flags |= org.jbox2d.dynamics.contacts.Contact.TOI_FLAG;
                    }
                    if(alpha < minAlpha) {
                        minContact = c;
                        minAlpha = alpha;
                    }
                };
                if(minContact == null || (<any>Math).fround(1.0 - (<any>Math).fround(10.0 * org.jbox2d.common.Settings.EPSILON)) < minAlpha) {
                    this.m_stepComplete = true;
                    break;
                }
                let fA : org.jbox2d.dynamics.Fixture = minContact.getFixtureA();
                let fB : org.jbox2d.dynamics.Fixture = minContact.getFixtureB();
                let bA : org.jbox2d.dynamics.Body = fA.getBody();
                let bB : org.jbox2d.dynamics.Body = fB.getBody();
                this.backup1.set(bA.m_sweep);
                this.backup2.set(bB.m_sweep);
                bA.advance(minAlpha);
                bB.advance(minAlpha);
                minContact.update(this.m_contactManager.m_contactListener);
                minContact.m_flags &= ~org.jbox2d.dynamics.contacts.Contact.TOI_FLAG;
                ++minContact.m_toiCount;
                if(minContact.isEnabled() === false || minContact.isTouching() === false) {
                    minContact.setEnabled(false);
                    bA.m_sweep.set(this.backup1);
                    bB.m_sweep.set(this.backup2);
                    bA.synchronizeTransform();
                    bB.synchronizeTransform();
                    continue;
                }
                bA.setAwake(true);
                bB.setAwake(true);
                island.clear();
                island.add$org_jbox2d_dynamics_Body(bA);
                island.add$org_jbox2d_dynamics_Body(bB);
                island.add$org_jbox2d_dynamics_contacts_Contact(minContact);
                bA.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                bB.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                minContact.m_flags |= org.jbox2d.dynamics.contacts.Contact.ISLAND_FLAG;
                this.tempBodies[0] = bA;
                this.tempBodies[1] = bB;
                for(let i : number = 0; i < 2; ++i) {
                    let body : org.jbox2d.dynamics.Body = this.tempBodies[i];
                    if(body.m_type === org.jbox2d.dynamics.BodyType.DYNAMIC) {
                        for(let ce : org.jbox2d.dynamics.contacts.ContactEdge = body.m_contactList; ce != null; ce = ce.next) {
                            if(island.m_bodyCount === island.m_bodyCapacity) {
                                break;
                            }
                            if(island.m_contactCount === island.m_contactCapacity) {
                                break;
                            }
                            let contact : org.jbox2d.dynamics.contacts.Contact = ce.contact;
                            if((contact.m_flags & org.jbox2d.dynamics.contacts.Contact.ISLAND_FLAG) !== 0) {
                                continue;
                            }
                            let other : org.jbox2d.dynamics.Body = ce.other;
                            if(other.m_type === org.jbox2d.dynamics.BodyType.DYNAMIC && body.isBullet() === false && other.isBullet() === false) {
                                continue;
                            }
                            let sensorA : boolean = contact.m_fixtureA.m_isSensor;
                            let sensorB : boolean = contact.m_fixtureB.m_isSensor;
                            if(sensorA || sensorB) {
                                continue;
                            }
                            this.backup1.set(other.m_sweep);
                            if((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) === 0) {
                                other.advance(minAlpha);
                            }
                            contact.update(this.m_contactManager.m_contactListener);
                            if(contact.isEnabled() === false) {
                                other.m_sweep.set(this.backup1);
                                other.synchronizeTransform();
                                continue;
                            }
                            if(contact.isTouching() === false) {
                                other.m_sweep.set(this.backup1);
                                other.synchronizeTransform();
                                continue;
                            }
                            contact.m_flags |= org.jbox2d.dynamics.contacts.Contact.ISLAND_FLAG;
                            island.add$org_jbox2d_dynamics_contacts_Contact(contact);
                            if((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) !== 0) {
                                continue;
                            }
                            other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                            if(other.m_type !== org.jbox2d.dynamics.BodyType.STATIC) {
                                other.setAwake(true);
                            }
                            island.add$org_jbox2d_dynamics_Body(other);
                        };
                    }
                };
                this.subStep.dt = (<any>Math).fround(((<any>Math).fround(1.0 - minAlpha)) * step.dt);
                this.subStep.inv_dt = (<any>Math).fround(1.0 / this.subStep.dt);
                this.subStep.dtRatio = 1.0;
                this.subStep.positionIterations = 20;
                this.subStep.velocityIterations = step.velocityIterations;
                this.subStep.warmStarting = false;
                island.solveTOI(this.subStep, bA.m_islandIndex, bB.m_islandIndex);
                for(let i : number = 0; i < island.m_bodyCount; ++i) {
                    let body : org.jbox2d.dynamics.Body = island.m_bodies[i];
                    body.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
                    if(body.m_type !== org.jbox2d.dynamics.BodyType.DYNAMIC) {
                        continue;
                    }
                    body.synchronizeFixtures();
                    for(let ce : org.jbox2d.dynamics.contacts.ContactEdge = body.m_contactList; ce != null; ce = ce.next) {
                        ce.contact.m_flags &= ~(org.jbox2d.dynamics.contacts.Contact.TOI_FLAG | org.jbox2d.dynamics.contacts.Contact.ISLAND_FLAG);
                    };
                };
                this.m_contactManager.findNewContacts();
                if(this.m_subStepping) {
                    this.m_stepComplete = false;
                    break;
                }
            };
        }

        /*private*/ drawJoint(joint : org.jbox2d.dynamics.joints.Joint) {
            let bodyA : org.jbox2d.dynamics.Body = joint.getBodyA();
            let bodyB : org.jbox2d.dynamics.Body = joint.getBodyB();
            let xf1 : org.jbox2d.common.Transform = bodyA.getTransform();
            let xf2 : org.jbox2d.common.Transform = bodyB.getTransform();
            let x1 : org.jbox2d.common.Vec2 = xf1.p;
            let x2 : org.jbox2d.common.Vec2 = xf2.p;
            let p1 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let p2 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            joint.getAnchorA(p1);
            joint.getAnchorB(p2);
            this.color.set$float$float$float(0.5, 0.8, 0.8);
            switch((joint.getType())) {
            case org.jbox2d.dynamics.joints.JointType.DISTANCE:
                this.m_debugDraw.drawSegment(p1, p2, this.color);
                break;
            case org.jbox2d.dynamics.joints.JointType.PULLEY:
                {
                    let pulley : org.jbox2d.dynamics.joints.PulleyJoint = <org.jbox2d.dynamics.joints.PulleyJoint>joint;
                    let s1 : org.jbox2d.common.Vec2 = pulley.getGroundAnchorA();
                    let s2 : org.jbox2d.common.Vec2 = pulley.getGroundAnchorB();
                    this.m_debugDraw.drawSegment(s1, p1, this.color);
                    this.m_debugDraw.drawSegment(s2, p2, this.color);
                    this.m_debugDraw.drawSegment(s1, s2, this.color);
                };
                break;
            case org.jbox2d.dynamics.joints.JointType.CONSTANT_VOLUME:
            case org.jbox2d.dynamics.joints.JointType.MOUSE:
                break;
            default:
                this.m_debugDraw.drawSegment(x1, p1, this.color);
                this.m_debugDraw.drawSegment(p1, p2, this.color);
                this.m_debugDraw.drawSegment(x2, p2, this.color);
            }
            this.pool.pushVec2(2);
        }

        static LIQUID_INT : number; public static LIQUID_INT_$LI$() : number { if(World.LIQUID_INT == null) World.LIQUID_INT = new Number(1234598372).valueOf(); return World.LIQUID_INT; };

        /*private*/ liquidLength : number = 0.12;

        /*private*/ averageLinearVel : number = -1;

        /*private*/ liquidOffset : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ circCenterMoved : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ liquidColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f(0.4, 0.4, 1.0);

        /*private*/ center : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ axis : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ v1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ v2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ tlvertices : org.jbox2d.pooling.arrays.Vec2Array = new org.jbox2d.pooling.arrays.Vec2Array();

        /*private*/ drawShape(fixture : org.jbox2d.dynamics.Fixture, xf : org.jbox2d.common.Transform, color : org.jbox2d.common.Color3f, wireframe : boolean) {
            switch((fixture.getType())) {
            case org.jbox2d.collision.shapes.ShapeType.CIRCLE:
                {
                    let circle : org.jbox2d.collision.shapes.CircleShape = <org.jbox2d.collision.shapes.CircleShape>fixture.getShape();
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf, circle.m_p, this.center);
                    let radius : number = circle.m_radius;
                    xf.q.getXAxis(this.axis);
                    if(fixture.getUserData() != null && /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(fixture.getUserData(),World.LIQUID_INT_$LI$()))) {
                        let b : org.jbox2d.dynamics.Body = fixture.getBody();
                        this.liquidOffset.set$org_jbox2d_common_Vec2(b.m_linearVelocity);
                        let linVelLength : number = b.m_linearVelocity.length();
                        if(this.averageLinearVel === -1) {
                            this.averageLinearVel = linVelLength;
                        } else {
                            this.averageLinearVel = (<any>Math).fround((<any>Math).fround(0.98 * this.averageLinearVel) + (<any>Math).fround(0.02 * linVelLength));
                        }
                        this.liquidOffset.mulLocal((<any>Math).fround((<any>Math).fround(this.liquidLength / this.averageLinearVel) / 2));
                        this.circCenterMoved.set$org_jbox2d_common_Vec2(this.center).addLocal$org_jbox2d_common_Vec2(this.liquidOffset);
                        this.center.subLocal(this.liquidOffset);
                        this.m_debugDraw.drawSegment(this.center, this.circCenterMoved, this.liquidColor);
                        return;
                    }
                    if(wireframe) {
                        this.m_debugDraw.drawCircle$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2$org_jbox2d_common_Color3f(this.center, radius, this.axis, color);
                    } else {
                        this.m_debugDraw.drawSolidCircle(this.center, radius, this.axis, color);
                    }
                };
                break;
            case org.jbox2d.collision.shapes.ShapeType.POLYGON:
                {
                    let poly : org.jbox2d.collision.shapes.PolygonShape = <org.jbox2d.collision.shapes.PolygonShape>fixture.getShape();
                    let vertexCount : number = poly.m_count;
                    let vertices : org.jbox2d.common.Vec2[] = this.tlvertices.get(org.jbox2d.common.Settings.maxPolygonVertices);
                    for(let i : number = 0; i < vertexCount; ++i) {
                        org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf, poly.m_vertices[i], vertices[i]);
                    };
                    if(wireframe) {
                        this.m_debugDraw.drawPolygon(vertices, vertexCount, color);
                    } else {
                        this.m_debugDraw.drawSolidPolygon(vertices, vertexCount, color);
                    }
                };
                break;
            case org.jbox2d.collision.shapes.ShapeType.EDGE:
                {
                    let edge : org.jbox2d.collision.shapes.EdgeShape = <org.jbox2d.collision.shapes.EdgeShape>fixture.getShape();
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf, edge.m_vertex1, this.v1);
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf, edge.m_vertex2, this.v2);
                    this.m_debugDraw.drawSegment(this.v1, this.v2, color);
                };
                break;
            case org.jbox2d.collision.shapes.ShapeType.CHAIN:
                {
                    let chain : org.jbox2d.collision.shapes.ChainShape = <org.jbox2d.collision.shapes.ChainShape>fixture.getShape();
                    let count : number = chain.m_count;
                    let vertices : org.jbox2d.common.Vec2[] = chain.m_vertices;
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf, vertices[0], this.v1);
                    for(let i : number = 1; i < count; ++i) {
                        org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf, vertices[i], this.v2);
                        this.m_debugDraw.drawSegment(this.v1, this.v2, color);
                        this.m_debugDraw.drawCircle$org_jbox2d_common_Vec2$float$org_jbox2d_common_Color3f(this.v1, 0.05, color);
                        this.v1.set$org_jbox2d_common_Vec2(this.v2);
                    };
                };
                break;
            default:
                break;
            }
        }

        /*private*/ drawParticleSystem(system : org.jbox2d.particle.ParticleSystem) {
            let wireframe : boolean = (this.m_debugDraw.getFlags() & org.jbox2d.callbacks.DebugDraw.e_wireframeDrawingBit_$LI$()) !== 0;
            let particleCount : number = system.getParticleCount();
            if(particleCount !== 0) {
                let particleRadius : number = system.getParticleRadius();
                let positionBuffer : org.jbox2d.common.Vec2[] = system.getParticlePositionBuffer();
                let colorBuffer : org.jbox2d.particle.ParticleColor[] = null;
                if(system.m_colorBuffer.data != null) {
                    colorBuffer = system.getParticleColorBuffer();
                }
                if(wireframe) {
                    this.m_debugDraw.drawParticlesWireframe(positionBuffer, particleRadius, colorBuffer, particleCount);
                } else {
                    this.m_debugDraw.drawParticles(positionBuffer, particleRadius, colorBuffer, particleCount);
                }
            }
        }

        /**
         * Create a particle whose properties have been defined. No reference to the definition is
         * retained. A simulation step must occur before it's possible to interact with a newly created
         * particle. For example, DestroyParticleInShape() will not destroy a particle until Step() has
         * been called.
         * 
         * @warning This function is locked during callbacks.
         * @return {number} the index of the particle.
         * @param {org.jbox2d.particle.ParticleDef} def
         */
        public createParticle(def : org.jbox2d.particle.ParticleDef) : number {
            if(this.isLocked()) {
                return 0;
            }
            let p : number = this.m_particleSystem.createParticle(def);
            return p;
        }

        public destroyParticle(index : number, callDestructionListener : boolean = false) {
            this.m_particleSystem.destroyParticle(index, callDestructionListener);
        }

        public destroyParticlesInShape$org_jbox2d_collision_shapes_Shape$org_jbox2d_common_Transform(shape : org.jbox2d.collision.shapes.Shape, xf : org.jbox2d.common.Transform) : number {
            return this.destroyParticlesInShape$org_jbox2d_collision_shapes_Shape$org_jbox2d_common_Transform$boolean(shape, xf, false);
        }

        public destroyParticlesInShape$org_jbox2d_collision_shapes_Shape$org_jbox2d_common_Transform$boolean(shape : org.jbox2d.collision.shapes.Shape, xf : org.jbox2d.common.Transform, callDestructionListener : boolean) : number {
            if(this.isLocked()) {
                return 0;
            }
            return this.m_particleSystem.destroyParticlesInShape(shape, xf, callDestructionListener);
        }

        /**
         * Destroy particles inside a shape. This function is locked during callbacks. In addition, this
         * function immediately destroys particles in the shape in contrast to DestroyParticle() which
         * defers the destruction until the next simulation step.
         * 
         * @param Shape which encloses particles that should be destroyed.
         * @param Transform applied to the shape.
         * @param Whether to call the world b2DestructionListener for each particle destroyed.
         * @warning This function is locked during callbacks.
         * @return {number} Number of particles destroyed.
         * @param {org.jbox2d.collision.shapes.Shape} shape
         * @param {org.jbox2d.common.Transform} xf
         * @param {boolean} callDestructionListener
         */
        public destroyParticlesInShape(shape? : any, xf? : any, callDestructionListener? : any) : any {
            if(((shape != null && shape instanceof <any>org.jbox2d.collision.shapes.Shape) || shape === null) && ((xf != null && xf instanceof <any>org.jbox2d.common.Transform) || xf === null) && ((typeof callDestructionListener === 'boolean') || callDestructionListener === null)) {
                return <any>this.destroyParticlesInShape$org_jbox2d_collision_shapes_Shape$org_jbox2d_common_Transform$boolean(shape, xf, callDestructionListener);
            } else if(((shape != null && shape instanceof <any>org.jbox2d.collision.shapes.Shape) || shape === null) && ((xf != null && xf instanceof <any>org.jbox2d.common.Transform) || xf === null) && callDestructionListener === undefined) {
                return <any>this.destroyParticlesInShape$org_jbox2d_collision_shapes_Shape$org_jbox2d_common_Transform(shape, xf);
            } else throw new Error('invalid overload');
        }

        /**
         * Create a particle group whose properties have been defined. No reference to the definition is
         * retained.
         * 
         * @warning This function is locked during callbacks.
         * @param {org.jbox2d.particle.ParticleGroupDef} def
         * @return {org.jbox2d.particle.ParticleGroup}
         */
        public createParticleGroup(def : org.jbox2d.particle.ParticleGroupDef) : org.jbox2d.particle.ParticleGroup {
            if(this.isLocked()) {
                return null;
            }
            let g : org.jbox2d.particle.ParticleGroup = this.m_particleSystem.createParticleGroup(def);
            return g;
        }

        /**
         * Join two particle groups.
         * 
         * @param the first group. Expands to encompass the second group.
         * @param the second group. It is destroyed.
         * @warning This function is locked during callbacks.
         * @param {org.jbox2d.particle.ParticleGroup} groupA
         * @param {org.jbox2d.particle.ParticleGroup} groupB
         */
        public joinParticleGroups(groupA : org.jbox2d.particle.ParticleGroup, groupB : org.jbox2d.particle.ParticleGroup) {
            if(this.isLocked()) {
                return;
            }
            this.m_particleSystem.joinParticleGroups(groupA, groupB);
        }

        public destroyParticlesInGroup$org_jbox2d_particle_ParticleGroup$boolean(group : org.jbox2d.particle.ParticleGroup, callDestructionListener : boolean) {
            if(this.isLocked()) {
                return;
            }
            this.m_particleSystem.destroyParticlesInGroup(group, callDestructionListener);
        }

        /**
         * Destroy particles in a group. This function is locked during callbacks.
         * 
         * @param The particle group to destroy.
         * @param Whether to call the world b2DestructionListener for each particle is destroyed.
         * @warning This function is locked during callbacks.
         * @param {org.jbox2d.particle.ParticleGroup} group
         * @param {boolean} callDestructionListener
         */
        public destroyParticlesInGroup(group? : any, callDestructionListener? : any) : any {
            if(((group != null && group instanceof <any>org.jbox2d.particle.ParticleGroup) || group === null) && ((typeof callDestructionListener === 'boolean') || callDestructionListener === null)) {
                return <any>this.destroyParticlesInGroup$org_jbox2d_particle_ParticleGroup$boolean(group, callDestructionListener);
            } else if(((group != null && group instanceof <any>org.jbox2d.particle.ParticleGroup) || group === null) && callDestructionListener === undefined) {
                return <any>this.destroyParticlesInGroup$org_jbox2d_particle_ParticleGroup(group);
            } else throw new Error('invalid overload');
        }

        public destroyParticlesInGroup$org_jbox2d_particle_ParticleGroup(group : org.jbox2d.particle.ParticleGroup) {
            this.destroyParticlesInGroup$org_jbox2d_particle_ParticleGroup$boolean(group, false);
        }

        /**
         * Get the world particle group list. With the returned group, use ParticleGroup::GetNext to get
         * the next group in the world list. A NULL group indicates the end of the list.
         * 
         * @return {Array} the head of the world particle group list.
         */
        public getParticleGroupList() : org.jbox2d.particle.ParticleGroup[] {
            return this.m_particleSystem.getParticleGroupList();
        }

        /**
         * Get the number of particle groups.
         * 
         * @return
         * @return {number}
         */
        public getParticleGroupCount() : number {
            return this.m_particleSystem.getParticleGroupCount();
        }

        /**
         * Get the number of particles.
         * 
         * @return
         * @return {number}
         */
        public getParticleCount() : number {
            return this.m_particleSystem.getParticleCount();
        }

        /**
         * Get the maximum number of particles.
         * 
         * @return
         * @return {number}
         */
        public getParticleMaxCount() : number {
            return this.m_particleSystem.getParticleMaxCount();
        }

        /**
         * Set the maximum number of particles.
         * 
         * @param {number} count
         */
        public setParticleMaxCount(count : number) {
            this.m_particleSystem.setParticleMaxCount(count);
        }

        /**
         * Change the particle density.
         * 
         * @param {number} density
         */
        public setParticleDensity(density : number) {
            this.m_particleSystem.setParticleDensity(density);
        }

        /**
         * Get the particle density.
         * 
         * @return
         * @return {number}
         */
        public getParticleDensity() : number {
            return this.m_particleSystem.getParticleDensity();
        }

        /**
         * Change the particle gravity scale. Adjusts the effect of the global gravity vector on
         * particles. Default value is 1.0f.
         * 
         * @param {number} gravityScale
         */
        public setParticleGravityScale(gravityScale : number) {
            this.m_particleSystem.setParticleGravityScale(gravityScale);
        }

        /**
         * Get the particle gravity scale.
         * 
         * @return
         * @return {number}
         */
        public getParticleGravityScale() : number {
            return this.m_particleSystem.getParticleGravityScale();
        }

        /**
         * Damping is used to reduce the velocity of particles. The damping parameter can be larger than
         * 1.0f but the damping effect becomes sensitive to the time step when the damping parameter is
         * large.
         * 
         * @param {number} damping
         */
        public setParticleDamping(damping : number) {
            this.m_particleSystem.setParticleDamping(damping);
        }

        /**
         * Get damping for particles
         * 
         * @return
         * @return {number}
         */
        public getParticleDamping() : number {
            return this.m_particleSystem.getParticleDamping();
        }

        /**
         * Change the particle radius. You should set this only once, on world start. If you change the
         * radius during execution, existing particles may explode, shrink, or behave unexpectedly.
         * 
         * @param {number} radius
         */
        public setParticleRadius(radius : number) {
            this.m_particleSystem.setParticleRadius(radius);
        }

        /**
         * Get the particle radius.
         * 
         * @return
         * @return {number}
         */
        public getParticleRadius() : number {
            return this.m_particleSystem.getParticleRadius();
        }

        /**
         * Get the particle data. @return the pointer to the head of the particle data.
         * 
         * @return
         * @return {Array}
         */
        public getParticleFlagsBuffer() : number[] {
            return this.m_particleSystem.getParticleFlagsBuffer();
        }

        public getParticlePositionBuffer() : org.jbox2d.common.Vec2[] {
            return this.m_particleSystem.getParticlePositionBuffer();
        }

        public getParticleVelocityBuffer() : org.jbox2d.common.Vec2[] {
            return this.m_particleSystem.getParticleVelocityBuffer();
        }

        public getParticleColorBuffer() : org.jbox2d.particle.ParticleColor[] {
            return this.m_particleSystem.getParticleColorBuffer();
        }

        public getParticleGroupBuffer() : org.jbox2d.particle.ParticleGroup[] {
            return this.m_particleSystem.getParticleGroupBuffer();
        }

        public getParticleUserDataBuffer() : any[] {
            return this.m_particleSystem.getParticleUserDataBuffer();
        }

        /**
         * Set a buffer for particle data.
         * 
         * @param {Array} buffer is a pointer to a block of memory.
         * @param size is the number of values in the block.
         * @param {number} capacity
         */
        public setParticleFlagsBuffer(buffer : number[], capacity : number) {
            this.m_particleSystem.setParticleFlagsBuffer(buffer, capacity);
        }

        public setParticlePositionBuffer(buffer : org.jbox2d.common.Vec2[], capacity : number) {
            this.m_particleSystem.setParticlePositionBuffer(buffer, capacity);
        }

        public setParticleVelocityBuffer(buffer : org.jbox2d.common.Vec2[], capacity : number) {
            this.m_particleSystem.setParticleVelocityBuffer(buffer, capacity);
        }

        public setParticleColorBuffer(buffer : org.jbox2d.particle.ParticleColor[], capacity : number) {
            this.m_particleSystem.setParticleColorBuffer(buffer, capacity);
        }

        public setParticleUserDataBuffer(buffer : any[], capacity : number) {
            this.m_particleSystem.setParticleUserDataBuffer(buffer, capacity);
        }

        /**
         * Get contacts between particles
         * 
         * @return
         * @return {Array}
         */
        public getParticleContacts() : org.jbox2d.particle.ParticleContact[] {
            return this.m_particleSystem.m_contactBuffer;
        }

        public getParticleContactCount() : number {
            return this.m_particleSystem.m_contactCount;
        }

        /**
         * Get contacts between particles and bodies
         * 
         * @return
         * @return {Array}
         */
        public getParticleBodyContacts() : org.jbox2d.particle.ParticleBodyContact[] {
            return this.m_particleSystem.m_bodyContactBuffer;
        }

        public getParticleBodyContactCount() : number {
            return this.m_particleSystem.m_bodyContactCount;
        }

        /**
         * Compute the kinetic energy that can be lost by damping force
         * 
         * @return
         * @return {number}
         */
        public computeParticleCollisionEnergy() : number {
            return this.m_particleSystem.computeParticleCollisionEnergy();
        }
    }
    World["__class"] = "org.jbox2d.dynamics.World";


    export class WorldQueryWrapper implements org.jbox2d.callbacks.TreeCallback {
        public treeCallback(nodeId : number) : boolean {
            let proxy : org.jbox2d.dynamics.FixtureProxy = <org.jbox2d.dynamics.FixtureProxy>this.broadPhase.getUserData(nodeId);
            return this.callback.reportFixture(proxy.fixture);
        }

        broadPhase : org.jbox2d.collision.broadphase.BroadPhase;

        callback : org.jbox2d.callbacks.QueryCallback;

        constructor() {
            if(this.broadPhase===undefined) this.broadPhase = null;
            if(this.callback===undefined) this.callback = null;
        }
    }
    WorldQueryWrapper["__class"] = "org.jbox2d.dynamics.WorldQueryWrapper";
    WorldQueryWrapper["__interfaces"] = ["org.jbox2d.callbacks.TreeCallback"];



    export class WorldRayCastWrapper implements org.jbox2d.callbacks.TreeRayCastCallback {
        /*private*/ output : org.jbox2d.collision.RayCastOutput = new org.jbox2d.collision.RayCastOutput();

        /*private*/ temp : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ point : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public raycastCallback(input : org.jbox2d.collision.RayCastInput, nodeId : number) : number {
            let userData : any = this.broadPhase.getUserData(nodeId);
            let proxy : org.jbox2d.dynamics.FixtureProxy = <org.jbox2d.dynamics.FixtureProxy>userData;
            let fixture : org.jbox2d.dynamics.Fixture = proxy.fixture;
            let index : number = proxy.childIndex;
            let hit : boolean = fixture.raycast(this.output, input, index);
            if(hit) {
                let fraction : number = this.output.fraction;
                this.temp.set$org_jbox2d_common_Vec2(input.p2).mulLocal(fraction);
                this.point.set$org_jbox2d_common_Vec2(input.p1).mulLocal((<any>Math).fround(1 - fraction)).addLocal$org_jbox2d_common_Vec2(this.temp);
                return this.callback.reportFixture(fixture, this.point, this.output.normal, fraction);
            }
            return input.maxFraction;
        }

        broadPhase : org.jbox2d.collision.broadphase.BroadPhase;

        callback : org.jbox2d.callbacks.RayCastCallback;

        constructor() {
            if(this.broadPhase===undefined) this.broadPhase = null;
            if(this.callback===undefined) this.callback = null;
        }
    }
    WorldRayCastWrapper["__class"] = "org.jbox2d.dynamics.WorldRayCastWrapper";
    WorldRayCastWrapper["__interfaces"] = ["org.jbox2d.callbacks.TreeRayCastCallback"];


}
namespace org.jbox2d.particle {
    export class ParticleBodyContact {
        /**
         * Index of the particle making contact.
         */
        public index : number;

        /**
         * The body making contact.
         */
        public body : org.jbox2d.dynamics.Body;

        /**
         * Weight of the contact. A value between 0.0f and 1.0f.
         */
        weight : number;

        /**
         * The normalized direction from the particle to the body.
         */
        public normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The effective mass used in calculating force.
         */
        mass : number;

        constructor() {
            if(this.index===undefined) this.index = 0;
            if(this.body===undefined) this.body = null;
            if(this.weight===undefined) this.weight = 0;
            if(this.mass===undefined) this.mass = 0;
        }
    }
    ParticleBodyContact["__class"] = "org.jbox2d.particle.ParticleBodyContact";

}
namespace org.jbox2d.particle {
    /**
     * Small color object for each particle
     * 
     * @author dmurph
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} a
     * @class
     */
    export class ParticleColor {
        public r : number;

        public g : number;

        public b : number;

        public a : number;

        public constructor(r? : any, g? : any, b? : any, a? : any) {
            if(((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.r===undefined) this.r = 0;
                if(this.g===undefined) this.g = 0;
                if(this.b===undefined) this.b = 0;
                if(this.a===undefined) this.a = 0;
                if(this.r===undefined) this.r = 0;
                if(this.g===undefined) this.g = 0;
                if(this.b===undefined) this.b = 0;
                if(this.a===undefined) this.a = 0;
                (() => {
                    this.set$byte$byte$byte$byte(r, g, b, a);
                })();
            } else if(((r != null && r instanceof <any>org.jbox2d.common.Color3f) || r === null) && g === undefined && b === undefined && a === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let color : any = __args[0];
                if(this.r===undefined) this.r = 0;
                if(this.g===undefined) this.g = 0;
                if(this.b===undefined) this.b = 0;
                if(this.a===undefined) this.a = 0;
                if(this.r===undefined) this.r = 0;
                if(this.g===undefined) this.g = 0;
                if(this.b===undefined) this.b = 0;
                if(this.a===undefined) this.a = 0;
                (() => {
                    this.set$org_jbox2d_common_Color3f(color);
                })();
            } else if(r === undefined && g === undefined && b === undefined && a === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.r===undefined) this.r = 0;
                if(this.g===undefined) this.g = 0;
                if(this.b===undefined) this.b = 0;
                if(this.a===undefined) this.a = 0;
                if(this.r===undefined) this.r = 0;
                if(this.g===undefined) this.g = 0;
                if(this.b===undefined) this.b = 0;
                if(this.a===undefined) this.a = 0;
                (() => {
                    this.r = (<number>127|0);
                    this.g = (<number>127|0);
                    this.b = (<number>127|0);
                    this.a = (<number>50|0);
                })();
            } else throw new Error('invalid overload');
        }

        public set$org_jbox2d_common_Color3f(color : org.jbox2d.common.Color3f) {
            this.r = (<number>((<any>Math).fround(255 * color.x))|0);
            this.g = (<number>((<any>Math).fround(255 * color.y))|0);
            this.b = (<number>((<any>Math).fround(255 * color.z))|0);
            this.a = (<number>255|0);
        }

        public set$org_jbox2d_particle_ParticleColor(color : ParticleColor) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            this.a = color.a;
        }

        public isZero() : boolean {
            return this.r === 0 && this.g === 0 && this.b === 0 && this.a === 0;
        }

        public set$byte$byte$byte$byte(r : number, g : number, b : number, a : number) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }

        public set(r? : any, g? : any, b? : any, a? : any) : any {
            if(((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                return <any>this.set$byte$byte$byte$byte(r, g, b, a);
            } else if(((r != null && r instanceof <any>org.jbox2d.common.Color3f) || r === null) && g === undefined && b === undefined && a === undefined) {
                return <any>this.set$org_jbox2d_common_Color3f(r);
            } else if(((r != null && r instanceof <any>org.jbox2d.particle.ParticleColor) || r === null) && g === undefined && b === undefined && a === undefined) {
                return <any>this.set$org_jbox2d_particle_ParticleColor(r);
            } else throw new Error('invalid overload');
        }
    }
    ParticleColor["__class"] = "org.jbox2d.particle.ParticleColor";

}
namespace org.jbox2d.particle {
    export class ParticleContact {
        /**
         * Indices of the respective particles making contact.
         */
        public indexA : number;

        /**
         * Indices of the respective particles making contact.
         */
        public indexB : number;

        /**
         * The logical sum of the particle behaviors that have been set.
         */
        public flags : number;

        /**
         * Weight of the contact. A value between 0.0f and 1.0f.
         */
        public weight : number;

        /**
         * The normalized direction from A to B.
         */
        public normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        constructor() {
            if(this.indexA===undefined) this.indexA = 0;
            if(this.indexB===undefined) this.indexB = 0;
            if(this.flags===undefined) this.flags = 0;
            if(this.weight===undefined) this.weight = 0;
        }
    }
    ParticleContact["__class"] = "org.jbox2d.particle.ParticleContact";

}
namespace org.jbox2d.particle {
    export class ParticleDef {
        /**
         * Specifies the type of particle. A particle may be more than one type. Multiple types are
         * chained by logical sums, for example: pd.flags = ParticleType.b2_elasticParticle |
         * ParticleType.b2_viscousParticle.
         */
        flags : number;

        /**
         * The world position of the particle.
         */
        public position : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The linear velocity of the particle in world co-ordinates.
         */
        public velocity : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The color of the particle.
         */
        public color : org.jbox2d.particle.ParticleColor;

        /**
         * Use this to store application-specific body data.
         */
        public userData : any;

        constructor() {
            if(this.flags===undefined) this.flags = 0;
            if(this.color===undefined) this.color = null;
            if(this.userData===undefined) this.userData = null;
        }
    }
    ParticleDef["__class"] = "org.jbox2d.particle.ParticleDef";

}
namespace org.jbox2d.particle {
    export class ParticleGroup {
        m_system : org.jbox2d.particle.ParticleSystem;

        m_firstIndex : number;

        m_lastIndex : number;

        m_groupFlags : number;

        m_strength : number;

        m_prev : ParticleGroup;

        m_next : ParticleGroup;

        m_timestamp : number;

        m_mass : number;

        m_inertia : number;

        m_center : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        m_linearVelocity : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        m_angularVelocity : number;

        m_transform : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        m_destroyAutomatically : boolean;

        m_toBeDestroyed : boolean;

        m_toBeSplit : boolean;

        m_userData : any;

        public constructor() {
            if(this.m_system===undefined) this.m_system = null;
            if(this.m_firstIndex===undefined) this.m_firstIndex = 0;
            if(this.m_lastIndex===undefined) this.m_lastIndex = 0;
            if(this.m_groupFlags===undefined) this.m_groupFlags = 0;
            if(this.m_strength===undefined) this.m_strength = 0;
            if(this.m_prev===undefined) this.m_prev = null;
            if(this.m_next===undefined) this.m_next = null;
            if(this.m_timestamp===undefined) this.m_timestamp = 0;
            if(this.m_mass===undefined) this.m_mass = 0;
            if(this.m_inertia===undefined) this.m_inertia = 0;
            if(this.m_angularVelocity===undefined) this.m_angularVelocity = 0;
            if(this.m_destroyAutomatically===undefined) this.m_destroyAutomatically = false;
            if(this.m_toBeDestroyed===undefined) this.m_toBeDestroyed = false;
            if(this.m_toBeSplit===undefined) this.m_toBeSplit = false;
            if(this.m_userData===undefined) this.m_userData = null;
            this.m_firstIndex = 0;
            this.m_lastIndex = 0;
            this.m_groupFlags = 0;
            this.m_strength = 1.0;
            this.m_timestamp = -1;
            this.m_mass = 0;
            this.m_inertia = 0;
            this.m_angularVelocity = 0;
            this.m_transform.setIdentity();
            this.m_destroyAutomatically = true;
            this.m_toBeDestroyed = false;
            this.m_toBeSplit = false;
        }

        public getNext() : ParticleGroup {
            return this.m_next;
        }

        public getParticleCount() : number {
            return this.m_lastIndex - this.m_firstIndex;
        }

        public getBufferIndex() : number {
            return this.m_firstIndex;
        }

        public getGroupFlags() : number {
            return this.m_groupFlags;
        }

        public setGroupFlags(flags : number) {
            this.m_groupFlags = flags;
        }

        public getMass() : number {
            this.updateStatistics();
            return this.m_mass;
        }

        public getInertia() : number {
            this.updateStatistics();
            return this.m_inertia;
        }

        public getCenter() : org.jbox2d.common.Vec2 {
            this.updateStatistics();
            return this.m_center;
        }

        public getLinearVelocity() : org.jbox2d.common.Vec2 {
            this.updateStatistics();
            return this.m_linearVelocity;
        }

        public getAngularVelocity() : number {
            this.updateStatistics();
            return this.m_angularVelocity;
        }

        public getTransform() : org.jbox2d.common.Transform {
            return this.m_transform;
        }

        public getPosition() : org.jbox2d.common.Vec2 {
            return this.m_transform.p;
        }

        public getAngle() : number {
            return this.m_transform.q.getAngle();
        }

        public getUserData() : any {
            return this.m_userData;
        }

        public setUserData(data : any) {
            this.m_userData = data;
        }

        public updateStatistics() {
            if(this.m_timestamp !== this.m_system.m_timestamp) {
                let m : number = this.m_system.getParticleMass();
                this.m_mass = 0;
                this.m_center.setZero();
                this.m_linearVelocity.setZero();
                for(let i : number = this.m_firstIndex; i < this.m_lastIndex; i++) {
                    this.m_mass += m;
                    let pos : org.jbox2d.common.Vec2 = this.m_system.m_positionBuffer.data[i];
                    this.m_center.x += (<any>Math).fround(m * pos.x);
                    this.m_center.y += (<any>Math).fround(m * pos.y);
                    let vel : org.jbox2d.common.Vec2 = this.m_system.m_velocityBuffer.data[i];
                    this.m_linearVelocity.x += (<any>Math).fround(m * vel.x);
                    this.m_linearVelocity.y += (<any>Math).fround(m * vel.y);
                };
                if(this.m_mass > 0) {
                    this.m_center.x *= (<any>Math).fround(1 / this.m_mass);
                    this.m_center.y *= (<any>Math).fround(1 / this.m_mass);
                    this.m_linearVelocity.x *= (<any>Math).fround(1 / this.m_mass);
                    this.m_linearVelocity.y *= (<any>Math).fround(1 / this.m_mass);
                }
                this.m_inertia = 0;
                this.m_angularVelocity = 0;
                for(let i : number = this.m_firstIndex; i < this.m_lastIndex; i++) {
                    let pos : org.jbox2d.common.Vec2 = this.m_system.m_positionBuffer.data[i];
                    let vel : org.jbox2d.common.Vec2 = this.m_system.m_velocityBuffer.data[i];
                    let px : number = (<any>Math).fround(pos.x - this.m_center.x);
                    let py : number = (<any>Math).fround(pos.y - this.m_center.y);
                    let vx : number = (<any>Math).fround(vel.x - this.m_linearVelocity.x);
                    let vy : number = (<any>Math).fround(vel.y - this.m_linearVelocity.y);
                    this.m_inertia += (<any>Math).fround(m * ((<any>Math).fround((<any>Math).fround(px * px) + (<any>Math).fround(py * py))));
                    this.m_angularVelocity += (<any>Math).fround(m * ((<any>Math).fround((<any>Math).fround(px * vy) - (<any>Math).fround(py * vx))));
                };
                if(this.m_inertia > 0) {
                    this.m_angularVelocity *= (<any>Math).fround(1 / this.m_inertia);
                }
                this.m_timestamp = this.m_system.m_timestamp;
            }
        }
    }
    ParticleGroup["__class"] = "org.jbox2d.particle.ParticleGroup";

}
namespace org.jbox2d.particle {
    /**
     * A particle group definition holds all the data needed to construct a particle group. You can
     * safely re-use these definitions.
     * @class
     */
    export class ParticleGroupDef {
        /**
         * The particle-behavior flags.
         */
        public flags : number;

        /**
         * The group-construction flags.
         */
        public groupFlags : number;

        /**
         * The world position of the group. Moves the group's shape a distance equal to the value of
         * position.
         */
        public position : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The world angle of the group in radians. Rotates the shape by an angle equal to the value of
         * angle.
         */
        public angle : number;

        /**
         * The linear velocity of the group's origin in world co-ordinates.
         */
        public linearVelocity : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The angular velocity of the group.
         */
        public angularVelocity : number;

        /**
         * The color of all particles in the group.
         */
        public color : org.jbox2d.particle.ParticleColor;

        /**
         * The strength of cohesion among the particles in a group with flag b2_elasticParticle or
         * b2_springParticle.
         */
        public strength : number;

        /**
         * Shape containing the particle group.
         */
        public shape : org.jbox2d.collision.shapes.Shape;

        /**
         * If true, destroy the group automatically after its last particle has been destroyed.
         */
        public destroyAutomatically : boolean;

        /**
         * Use this to store application-specific group data.
         */
        public userData : any;

        public constructor() {
            if(this.flags===undefined) this.flags = 0;
            if(this.groupFlags===undefined) this.groupFlags = 0;
            if(this.angle===undefined) this.angle = 0;
            if(this.angularVelocity===undefined) this.angularVelocity = 0;
            if(this.color===undefined) this.color = null;
            if(this.strength===undefined) this.strength = 0;
            if(this.shape===undefined) this.shape = null;
            if(this.destroyAutomatically===undefined) this.destroyAutomatically = false;
            if(this.userData===undefined) this.userData = null;
            this.flags = 0;
            this.groupFlags = 0;
            this.angle = 0;
            this.angularVelocity = 0;
            this.strength = 1;
            this.destroyAutomatically = true;
        }
    }
    ParticleGroupDef["__class"] = "org.jbox2d.particle.ParticleGroupDef";

}
namespace org.jbox2d.particle {
    export class ParticleGroupType {
        /**
         * resists penetration
         */
        public static b2_solidParticleGroup : number; public static b2_solidParticleGroup_$LI$() : number { if(ParticleGroupType.b2_solidParticleGroup == null) ParticleGroupType.b2_solidParticleGroup = 1 << 0; return ParticleGroupType.b2_solidParticleGroup; };

        /**
         * keeps its shape
         */
        public static b2_rigidParticleGroup : number; public static b2_rigidParticleGroup_$LI$() : number { if(ParticleGroupType.b2_rigidParticleGroup == null) ParticleGroupType.b2_rigidParticleGroup = 1 << 1; return ParticleGroupType.b2_rigidParticleGroup; };
    }
    ParticleGroupType["__class"] = "org.jbox2d.particle.ParticleGroupType";

}
namespace org.jbox2d.particle {
    /**
     * The particle type. Can be combined with | operator. Zero means liquid.
     * 
     * @author dmurph
     * @class
     */
    export class ParticleType {
        public static b2_waterParticle : number = 0;

        /**
         * removed after next step
         */
        public static b2_zombieParticle : number; public static b2_zombieParticle_$LI$() : number { if(ParticleType.b2_zombieParticle == null) ParticleType.b2_zombieParticle = 1 << 1; return ParticleType.b2_zombieParticle; };

        /**
         * zero velocity
         */
        public static b2_wallParticle : number; public static b2_wallParticle_$LI$() : number { if(ParticleType.b2_wallParticle == null) ParticleType.b2_wallParticle = 1 << 2; return ParticleType.b2_wallParticle; };

        /**
         * with restitution from stretching
         */
        public static b2_springParticle : number; public static b2_springParticle_$LI$() : number { if(ParticleType.b2_springParticle == null) ParticleType.b2_springParticle = 1 << 3; return ParticleType.b2_springParticle; };

        /**
         * with restitution from deformation
         */
        public static b2_elasticParticle : number; public static b2_elasticParticle_$LI$() : number { if(ParticleType.b2_elasticParticle == null) ParticleType.b2_elasticParticle = 1 << 4; return ParticleType.b2_elasticParticle; };

        /**
         * with viscosity
         */
        public static b2_viscousParticle : number; public static b2_viscousParticle_$LI$() : number { if(ParticleType.b2_viscousParticle == null) ParticleType.b2_viscousParticle = 1 << 5; return ParticleType.b2_viscousParticle; };

        /**
         * without isotropic pressure
         */
        public static b2_powderParticle : number; public static b2_powderParticle_$LI$() : number { if(ParticleType.b2_powderParticle == null) ParticleType.b2_powderParticle = 1 << 6; return ParticleType.b2_powderParticle; };

        /**
         * with surface tension
         */
        public static b2_tensileParticle : number; public static b2_tensileParticle_$LI$() : number { if(ParticleType.b2_tensileParticle == null) ParticleType.b2_tensileParticle = 1 << 7; return ParticleType.b2_tensileParticle; };

        /**
         * mixing color between contacting particles
         */
        public static b2_colorMixingParticle : number; public static b2_colorMixingParticle_$LI$() : number { if(ParticleType.b2_colorMixingParticle == null) ParticleType.b2_colorMixingParticle = 1 << 8; return ParticleType.b2_colorMixingParticle; };

        /**
         * call b2DestructionListener on destruction
         */
        public static b2_destructionListener : number; public static b2_destructionListener_$LI$() : number { if(ParticleType.b2_destructionListener == null) ParticleType.b2_destructionListener = 1 << 9; return ParticleType.b2_destructionListener; };
    }
    ParticleType["__class"] = "org.jbox2d.particle.ParticleType";

}
namespace org.jbox2d.particle {
    export class StackQueue<T> {
        /*private*/ m_buffer : T[];

        /*private*/ m_front : number;

        /*private*/ m_back : number;

        /*private*/ m_end : number;

        public constructor() {
            if(this.m_buffer===undefined) this.m_buffer = null;
            if(this.m_front===undefined) this.m_front = 0;
            if(this.m_back===undefined) this.m_back = 0;
            if(this.m_end===undefined) this.m_end = 0;
        }

        public reset(buffer : T[]) {
            this.m_buffer = buffer;
            this.m_front = 0;
            this.m_back = 0;
            this.m_end = buffer.length;
        }

        public push(task : T) {
            if(this.m_back >= this.m_end) {
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.m_buffer, this.m_front, this.m_buffer, 0, this.m_back - this.m_front);
                this.m_back -= this.m_front;
                this.m_front = 0;
                if(this.m_back >= this.m_end) {
                    return;
                }
            }
            this.m_buffer[this.m_back++] = task;
        }

        public pop() : T {
            return this.m_buffer[this.m_front++];
        }

        public empty() : boolean {
            return this.m_front >= this.m_back;
        }

        public front() : T {
            return this.m_buffer[this.m_front];
        }
    }
    StackQueue["__class"] = "org.jbox2d.particle.StackQueue";

}
namespace org.jbox2d.pooling.arrays {
    /**
     * Not thread safe float[] pooling.
     * @author Daniel
     * @class
     */
    export class FloatArray {
        /*private*/ map : any = <any>({});

        public get(argLength : number) : number[] {
            if(!/* containsKey */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return true; } return false; })(<any>this.map, argLength)) {
                /* put */((m,k,v) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { m.entries[i].value=v; return; } m.entries.push({key:k,value:v,getKey: function() { return this.key }, getValue: function() { return this.value }}); })(<any>this.map, argLength, this.getInitializedArray(argLength));
            }
            return /* get */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return m.entries[i].value; } return null; })(<any>this.map, argLength);
        }

        getInitializedArray(argLength : number) : number[] {
            return (s => { let a=[]; while(s-->0) a.push(0); return a; })(argLength);
        }
    }
    FloatArray["__class"] = "org.jbox2d.pooling.arrays.FloatArray";

}
namespace org.jbox2d.pooling.arrays {
    export class GeneratorArray {
        /*private*/ map : any = <any>({});

        public get(length : number) : org.jbox2d.particle.VoronoiDiagram.Generator[] {
            if(!/* containsKey */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return true; } return false; })(<any>this.map, length)) {
                /* put */((m,k,v) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { m.entries[i].value=v; return; } m.entries.push({key:k,value:v,getKey: function() { return this.key }, getValue: function() { return this.value }}); })(<any>this.map, length, this.getInitializedArray(length));
            }
            return /* get */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return m.entries[i].value; } return null; })(<any>this.map, length);
        }

        getInitializedArray(length : number) : org.jbox2d.particle.VoronoiDiagram.Generator[] {
            let ray : org.jbox2d.particle.VoronoiDiagram.Generator[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(length);
            for(let i : number = 0; i < ray.length; i++) {
                ray[i] = new org.jbox2d.particle.VoronoiDiagram.Generator();
            };
            return ray;
        }
    }
    GeneratorArray["__class"] = "org.jbox2d.pooling.arrays.GeneratorArray";

}
namespace org.jbox2d.pooling.arrays {
    /**
     * Not thread safe int[] pooling
     * @author Daniel Murphy
     * @class
     */
    export class IntArray {
        /*private*/ map : any = <any>({});

        public get(argLength : number) : number[] {
            if(!/* containsKey */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return true; } return false; })(<any>this.map, argLength)) {
                /* put */((m,k,v) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { m.entries[i].value=v; return; } m.entries.push({key:k,value:v,getKey: function() { return this.key }, getValue: function() { return this.value }}); })(<any>this.map, argLength, this.getInitializedArray(argLength));
            }
            return /* get */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return m.entries[i].value; } return null; })(<any>this.map, argLength);
        }

        getInitializedArray(argLength : number) : number[] {
            return (s => { let a=[]; while(s-->0) a.push(0); return a; })(argLength);
        }
    }
    IntArray["__class"] = "org.jbox2d.pooling.arrays.IntArray";

}
namespace org.jbox2d.pooling.arrays {
    /**
     * not thread safe Vec2[] pool
     * @author dmurph
     * @class
     */
    export class Vec2Array {
        /*private*/ map : any = <any>({});

        public get(argLength : number) : org.jbox2d.common.Vec2[] {
            if(!/* containsKey */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return true; } return false; })(<any>this.map, argLength)) {
                /* put */((m,k,v) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { m.entries[i].value=v; return; } m.entries.push({key:k,value:v,getKey: function() { return this.key }, getValue: function() { return this.value }}); })(<any>this.map, argLength, this.getInitializedArray(argLength));
            }
            return /* get */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return m.entries[i].value; } return null; })(<any>this.map, argLength);
        }

        getInitializedArray(argLength : number) : org.jbox2d.common.Vec2[] {
            let ray : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(argLength);
            for(let i : number = 0; i < ray.length; i++) {
                ray[i] = new org.jbox2d.common.Vec2();
            };
            return ray;
        }
    }
    Vec2Array["__class"] = "org.jbox2d.pooling.arrays.Vec2Array";

}
namespace org.jbox2d.pooling {
    /**
     * Same functionality of a regular java.util stack.  Object
     * return order does not matter.
     * @author Daniel
     * 
     * @param <E>
     * @class
     */
    export interface IDynamicStack<E> {
        /**
         * Pops an item off the stack
         * @return
         * @return {*}
         */
        pop() : E;

        /**
         * Pushes an item back on the stack
         * @param {*} argObject
         */
        push(argObject : E);
    }
}
namespace org.jbox2d.pooling {
    /**
     * This stack assumes that when you push 'n' items back,
     * you're pushing back the last 'n' items popped.
     * @author Daniel
     * 
     * @param <E>
     * @class
     */
    export interface IOrderedStack<E> {
        /**
         * Returns the next 'argNum' objects in the pool
         * in an array
         * @param {number} argNum
         * @return {Array} an array containing the next pool objects in
         * items 0-argNum.  Array length and uniqueness not
         * guaranteed.
         */
        pop(argNum? : any) : any;

        /**
         * Tells the stack to take back the last 'argNum' items
         * @param {number} argNum
         */
        push(argNum : number);
    }
}
namespace org.jbox2d.pooling {
    /**
     * World pool interface
     * @author Daniel
     * @class
     */
    export interface IWorldPool {
        getPolyContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact>;

        getCircleContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact>;

        getPolyCircleContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact>;

        getEdgeCircleContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact>;

        getEdgePolyContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact>;

        getChainCircleContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact>;

        getChainPolyContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact>;

        popVec2(num? : any) : any;

        pushVec2(num : number);

        popVec3(num? : any) : any;

        pushVec3(num : number);

        popMat22(num? : any) : any;

        pushMat22(num : number);

        popMat33() : org.jbox2d.common.Mat33;

        pushMat33(num : number);

        popAABB(num? : any) : any;

        pushAABB(num : number);

        popRot() : org.jbox2d.common.Rot;

        pushRot(num : number);

        getCollision() : org.jbox2d.collision.Collision;

        getTimeOfImpact() : org.jbox2d.collision.TimeOfImpact;

        getDistance() : org.jbox2d.collision.Distance;

        getFloatArray(argLength : number) : number[];

        getIntArray(argLength : number) : number[];

        getVec2Array(argLength : number) : org.jbox2d.common.Vec2[];
    }
}
namespace org.jbox2d.pooling.normal {
    export abstract class CircleStack<E> implements org.jbox2d.pooling.IOrderedStack<E> {
        /*private*/ pool : any[];

        /*private*/ index : number;

        /*private*/ size : number;

        /*private*/ container : any[];

        public constructor(argStackSize : number, argContainerSize : number) {
            if(this.pool===undefined) this.pool = null;
            if(this.index===undefined) this.index = 0;
            if(this.size===undefined) this.size = 0;
            if(this.container===undefined) this.container = null;
            this.size = argStackSize;
            this.pool = (s => { let a=[]; while(s-->0) a.push(null); return a; })(argStackSize);
            for(let i : number = 0; i < argStackSize; i++) {
                this.pool[i] = this.newInstance();
            };
            this.index = 0;
            this.container = (s => { let a=[]; while(s-->0) a.push(null); return a; })(argContainerSize);
        }

        public pop$() : E {
            this.index++;
            if(this.index >= this.size) {
                this.index = 0;
            }
            return <E><any>this.pool[this.index];
        }

        public pop$int(argNum : number) : E[] {
            if(this.index + argNum < this.size) {
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.pool, this.index, this.container, 0, argNum);
                this.index += argNum;
            } else {
                let overlap : number = (this.index + argNum) - this.size;
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.pool, this.index, this.container, 0, argNum - overlap);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.pool, 0, this.container, argNum - overlap, overlap);
                this.index = overlap;
            }
            return <E[]>this.container;
        }

        public pop(argNum? : any) : any {
            if(((typeof argNum === 'number') || argNum === null)) {
                return <any>this.pop$int(argNum);
            } else if(argNum === undefined) {
                return <any>this.pop$();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {number} argNum
         */
        public push(argNum : number) {
        }

        /**
         * Creates a new instance of the object contained by this stack.
         * @return {*}
         */
        abstract newInstance() : E;
    }
    CircleStack["__class"] = "org.jbox2d.pooling.normal.CircleStack";
    CircleStack["__interfaces"] = ["org.jbox2d.pooling.IOrderedStack"];


}
namespace org.jbox2d.pooling.normal {
    export abstract class MutableStack<E> implements org.jbox2d.pooling.IDynamicStack<E> {
        /*private*/ stack : E[];

        /*private*/ index : number;

        /*private*/ size : number;

        public constructor(argInitSize : number) {
            if(this.stack===undefined) this.stack = null;
            if(this.index===undefined) this.index = 0;
            if(this.size===undefined) this.size = 0;
            this.index = 0;
            this.stack = null;
            this.index = 0;
            this.extendStack(argInitSize);
        }

        /*private*/ extendStack(argSize : number) {
            let newStack : E[] = this.newArray(argSize);
            if(this.stack != null) {
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.stack, 0, newStack, 0, this.size);
            }
            for(let i : number = 0; i < newStack.length; i++) {
                newStack[i] = this.newInstance();
            };
            this.stack = newStack;
            this.size = newStack.length;
        }

        public pop() : E {
            if(this.index >= this.size) {
                this.extendStack(this.size * 2);
            }
            return this.stack[this.index++];
        }

        public push(argObject : E) {
            this.stack[--this.index] = argObject;
        }

        /**
         * Creates a new instance of the object contained by this stack.
         * @return {*}
         */
        abstract newInstance() : E;

        abstract newArray(size : number) : E[];
    }
    MutableStack["__class"] = "org.jbox2d.pooling.normal.MutableStack";
    MutableStack["__interfaces"] = ["org.jbox2d.pooling.IDynamicStack"];


}
namespace org.jbox2d.pooling.normal {
    /**
     * @author Daniel Murphy
     * @param {number} argStackSize
     * @param {number} argContainerSize
     * @class
     */
    export abstract class OrderedStack<E> {
        /*private*/ pool : any[];

        /*private*/ index : number;

        /*private*/ size : number;

        /*private*/ container : any[];

        public constructor(argStackSize : number, argContainerSize : number) {
            if(this.pool===undefined) this.pool = null;
            if(this.index===undefined) this.index = 0;
            if(this.size===undefined) this.size = 0;
            if(this.container===undefined) this.container = null;
            this.size = argStackSize;
            this.pool = (s => { let a=[]; while(s-->0) a.push(null); return a; })(argStackSize);
            for(let i : number = 0; i < argStackSize; i++) {
                this.pool[i] = this.newInstance();
            };
            this.index = 0;
            this.container = (s => { let a=[]; while(s-->0) a.push(null); return a; })(argContainerSize);
        }

        public pop$() : E {
            return <E><any>this.pool[this.index++];
        }

        public pop$int(argNum : number) : E[] {
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.pool, this.index, this.container, 0, argNum);
            this.index += argNum;
            return <E[]>this.container;
        }

        public pop(argNum? : any) : any {
            if(((typeof argNum === 'number') || argNum === null)) {
                return <any>this.pop$int(argNum);
            } else if(argNum === undefined) {
                return <any>this.pop$();
            } else throw new Error('invalid overload');
        }

        public push(argNum : number) {
            this.index -= argNum;
        }

        /**
         * Creates a new instance of the object contained by this stack.
         * @return {*}
         */
        abstract newInstance() : E;
    }
    OrderedStack["__class"] = "org.jbox2d.pooling.normal.OrderedStack";

}
namespace org.jbox2d.pooling.stacks {
    export class DynamicIntStack {
        /*private*/ stack : number[];

        /*private*/ size : number;

        /*private*/ position : number;

        public constructor(initialSize : number) {
            if(this.stack===undefined) this.stack = null;
            if(this.size===undefined) this.size = 0;
            if(this.position===undefined) this.position = 0;
            this.stack = (s => { let a=[]; while(s-->0) a.push(0); return a; })(initialSize);
            this.position = 0;
            this.size = initialSize;
        }

        public reset() {
            this.position = 0;
        }

        public pop() : number {
            return this.stack[--this.position];
        }

        public push(i : number) {
            if(this.position === this.size) {
                let old : number[] = this.stack;
                this.stack = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.size * 2);
                this.size = this.stack.length;
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(old, 0, this.stack, 0, old.length);
            }
            this.stack[this.position++] = i;
        }

        public getCount() : number {
            return this.position;
        }
    }
    DynamicIntStack["__class"] = "org.jbox2d.pooling.stacks.DynamicIntStack";

}
namespace org.jbox2d.collision.shapes {
    /**
     * A chain shape is a free form sequence of line segments. The chain has two-sided collision, so you
     * can use inside and outside collision. Therefore, you may use any winding order. Connectivity
     * information is used to create smooth collisions. WARNING: The chain will not collide properly if
     * there are self-intersections.
     * 
     * @author Daniel
     * @class
     * @extends org.jbox2d.collision.shapes.Shape
     */
    export class ChainShape extends org.jbox2d.collision.shapes.Shape {
        public m_vertices : org.jbox2d.common.Vec2[];

        public m_count : number;

        public m_prevVertex : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public m_nextVertex : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public m_hasPrevVertex : boolean = false;

        public m_hasNextVertex : boolean = false;

        /*private*/ pool0 : org.jbox2d.collision.shapes.EdgeShape = new org.jbox2d.collision.shapes.EdgeShape();

        public constructor() {
            super(org.jbox2d.collision.shapes.ShapeType.CHAIN);
            if(this.m_vertices===undefined) this.m_vertices = null;
            if(this.m_count===undefined) this.m_count = 0;
            this.m_vertices = null;
            this.m_radius = org.jbox2d.common.Settings.polygonRadius_$LI$();
            this.m_count = 0;
        }

        public clear() {
            this.m_vertices = null;
            this.m_count = 0;
        }

        /**
         * 
         * @return {number}
         */
        public getChildCount() : number {
            return this.m_count - 1;
        }

        /**
         * Get a child edge.
         * @param {org.jbox2d.collision.shapes.EdgeShape} edge
         * @param {number} index
         */
        public getChildEdge(edge : org.jbox2d.collision.shapes.EdgeShape, index : number) {
            edge.m_radius = this.m_radius;
            let v0 : org.jbox2d.common.Vec2 = this.m_vertices[index + 0];
            let v1 : org.jbox2d.common.Vec2 = this.m_vertices[index + 1];
            edge.m_vertex1.x = v0.x;
            edge.m_vertex1.y = v0.y;
            edge.m_vertex2.x = v1.x;
            edge.m_vertex2.y = v1.y;
            if(index > 0) {
                let v : org.jbox2d.common.Vec2 = this.m_vertices[index - 1];
                edge.m_vertex0.x = v.x;
                edge.m_vertex0.y = v.y;
                edge.m_hasVertex0 = true;
            } else {
                edge.m_vertex0.x = this.m_prevVertex.x;
                edge.m_vertex0.y = this.m_prevVertex.y;
                edge.m_hasVertex0 = this.m_hasPrevVertex;
            }
            if(index < this.m_count - 2) {
                let v : org.jbox2d.common.Vec2 = this.m_vertices[index + 2];
                edge.m_vertex3.x = v.x;
                edge.m_vertex3.y = v.y;
                edge.m_hasVertex3 = true;
            } else {
                edge.m_vertex3.x = this.m_nextVertex.x;
                edge.m_vertex3.y = this.m_nextVertex.y;
                edge.m_hasVertex3 = this.m_hasNextVertex;
            }
        }

        /**
         * 
         * @param {org.jbox2d.common.Transform} xf
         * @param {org.jbox2d.common.Vec2} p
         * @param {number} childIndex
         * @param {org.jbox2d.common.Vec2} normalOut
         * @return {number}
         */
        public computeDistanceToOut(xf : org.jbox2d.common.Transform, p : org.jbox2d.common.Vec2, childIndex : number, normalOut : org.jbox2d.common.Vec2) : number {
            let edge : org.jbox2d.collision.shapes.EdgeShape = this.pool0;
            this.getChildEdge(edge, childIndex);
            return edge.computeDistanceToOut(xf, p, 0, normalOut);
        }

        /**
         * 
         * @param {org.jbox2d.common.Transform} xf
         * @param {org.jbox2d.common.Vec2} p
         * @return {boolean}
         */
        public testPoint(xf : org.jbox2d.common.Transform, p : org.jbox2d.common.Vec2) : boolean {
            return false;
        }

        /**
         * 
         * @param {org.jbox2d.collision.RayCastOutput} output
         * @param {org.jbox2d.collision.RayCastInput} input
         * @param {org.jbox2d.common.Transform} xf
         * @param {number} childIndex
         * @return {boolean}
         */
        public raycast(output : org.jbox2d.collision.RayCastOutput, input : org.jbox2d.collision.RayCastInput, xf : org.jbox2d.common.Transform, childIndex : number) : boolean {
            let edgeShape : org.jbox2d.collision.shapes.EdgeShape = this.pool0;
            let i1 : number = childIndex;
            let i2 : number = childIndex + 1;
            if(i2 === this.m_count) {
                i2 = 0;
            }
            let v : org.jbox2d.common.Vec2 = this.m_vertices[i1];
            edgeShape.m_vertex1.x = v.x;
            edgeShape.m_vertex1.y = v.y;
            let v1 : org.jbox2d.common.Vec2 = this.m_vertices[i2];
            edgeShape.m_vertex2.x = v1.x;
            edgeShape.m_vertex2.y = v1.y;
            return edgeShape.raycast(output, input, xf, 0);
        }

        /**
         * 
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.Transform} xf
         * @param {number} childIndex
         */
        public computeAABB(aabb : org.jbox2d.collision.AABB, xf : org.jbox2d.common.Transform, childIndex : number) {
            let lower : org.jbox2d.common.Vec2 = aabb.lowerBound;
            let upper : org.jbox2d.common.Vec2 = aabb.upperBound;
            let i1 : number = childIndex;
            let i2 : number = childIndex + 1;
            if(i2 === this.m_count) {
                i2 = 0;
            }
            let vi1 : org.jbox2d.common.Vec2 = this.m_vertices[i1];
            let vi2 : org.jbox2d.common.Vec2 = this.m_vertices[i2];
            let xfq : org.jbox2d.common.Rot = xf.q;
            let xfp : org.jbox2d.common.Vec2 = xf.p;
            let v1x : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfq.c * vi1.x) - (<any>Math).fround(xfq.s * vi1.y))) + xfp.x);
            let v1y : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfq.s * vi1.x) + (<any>Math).fround(xfq.c * vi1.y))) + xfp.y);
            let v2x : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfq.c * vi2.x) - (<any>Math).fround(xfq.s * vi2.y))) + xfp.x);
            let v2y : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfq.s * vi2.x) + (<any>Math).fround(xfq.c * vi2.y))) + xfp.y);
            lower.x = v1x < v2x?v1x:v2x;
            lower.y = v1y < v2y?v1y:v2y;
            upper.x = v1x > v2x?v1x:v2x;
            upper.y = v1y > v2y?v1y:v2y;
        }

        /**
         * 
         * @param {org.jbox2d.collision.shapes.MassData} massData
         * @param {number} density
         */
        public computeMass(massData : org.jbox2d.collision.shapes.MassData, density : number) {
            massData.mass = 0.0;
            massData.center.setZero();
            massData.I = 0.0;
        }

        /**
         * 
         * @return {org.jbox2d.collision.shapes.Shape}
         */
        public clone() : org.jbox2d.collision.shapes.Shape {
            let clone : ChainShape = new ChainShape();
            clone.createChain(this.m_vertices, this.m_count);
            clone.m_prevVertex.set$org_jbox2d_common_Vec2(this.m_prevVertex);
            clone.m_nextVertex.set$org_jbox2d_common_Vec2(this.m_nextVertex);
            clone.m_hasPrevVertex = this.m_hasPrevVertex;
            clone.m_hasNextVertex = this.m_hasNextVertex;
            return clone;
        }

        /**
         * Create a loop. This automatically adjusts connectivity.
         * 
         * @param {Array} vertices an array of vertices, these are copied
         * @param {number} count the vertex count
         */
        public createLoop(vertices : org.jbox2d.common.Vec2[], count : number) {
            this.m_count = count + 1;
            this.m_vertices = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_count);
            for(let i : number = 1; i < count; i++) {
                let v1 : org.jbox2d.common.Vec2 = vertices[i - 1];
                let v2 : org.jbox2d.common.Vec2 = vertices[i];
                if(org.jbox2d.common.MathUtils.distanceSquared(v1, v2) < (<any>Math).fround(org.jbox2d.common.Settings.linearSlop * org.jbox2d.common.Settings.linearSlop)) {
                    throw Object.defineProperty(new Error("Vertices of chain shape are too close together"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                }
            };
            for(let i : number = 0; i < count; i++) {
                this.m_vertices[i] = new org.jbox2d.common.Vec2(vertices[i]);
            };
            this.m_vertices[count] = new org.jbox2d.common.Vec2(this.m_vertices[0]);
            this.m_prevVertex.set$org_jbox2d_common_Vec2(this.m_vertices[this.m_count - 2]);
            this.m_nextVertex.set$org_jbox2d_common_Vec2(this.m_vertices[1]);
            this.m_hasPrevVertex = true;
            this.m_hasNextVertex = true;
        }

        /**
         * Create a chain with isolated end vertices.
         * 
         * @param {Array} vertices an array of vertices, these are copied
         * @param {number} count the vertex count
         */
        public createChain(vertices : org.jbox2d.common.Vec2[], count : number) {
            this.m_count = count;
            this.m_vertices = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_count);
            for(let i : number = 1; i < this.m_count; i++) {
                let v1 : org.jbox2d.common.Vec2 = vertices[i - 1];
                let v2 : org.jbox2d.common.Vec2 = vertices[i];
                if(org.jbox2d.common.MathUtils.distanceSquared(v1, v2) < (<any>Math).fround(org.jbox2d.common.Settings.linearSlop * org.jbox2d.common.Settings.linearSlop)) {
                    throw Object.defineProperty(new Error("Vertices of chain shape are too close together"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                }
            };
            for(let i : number = 0; i < this.m_count; i++) {
                this.m_vertices[i] = new org.jbox2d.common.Vec2(vertices[i]);
            };
            this.m_hasPrevVertex = false;
            this.m_hasNextVertex = false;
            this.m_prevVertex.setZero();
            this.m_nextVertex.setZero();
        }

        /**
         * Establish connectivity to a vertex that precedes the first vertex. Don't call this for loops.
         * 
         * @param {org.jbox2d.common.Vec2} prevVertex
         */
        public setPrevVertex(prevVertex : org.jbox2d.common.Vec2) {
            this.m_prevVertex.set$org_jbox2d_common_Vec2(prevVertex);
            this.m_hasPrevVertex = true;
        }

        /**
         * Establish connectivity to a vertex that follows the last vertex. Don't call this for loops.
         * 
         * @param {org.jbox2d.common.Vec2} nextVertex
         */
        public setNextVertex(nextVertex : org.jbox2d.common.Vec2) {
            this.m_nextVertex.set$org_jbox2d_common_Vec2(nextVertex);
            this.m_hasNextVertex = true;
        }
    }
    ChainShape["__class"] = "org.jbox2d.collision.shapes.ChainShape";

}
namespace org.jbox2d.collision.shapes {
    /**
     * A circle shape.
     * @class
     * @extends org.jbox2d.collision.shapes.Shape
     */
    export class CircleShape extends org.jbox2d.collision.shapes.Shape {
        public m_p : org.jbox2d.common.Vec2;

        public constructor() {
            super(org.jbox2d.collision.shapes.ShapeType.CIRCLE);
            if(this.m_p===undefined) this.m_p = null;
            this.m_p = new org.jbox2d.common.Vec2();
            this.m_radius = 0;
        }

        public clone() : org.jbox2d.collision.shapes.Shape {
            let shape : CircleShape = new CircleShape();
            shape.m_p.x = this.m_p.x;
            shape.m_p.y = this.m_p.y;
            shape.m_radius = this.m_radius;
            return shape;
        }

        public getChildCount() : number {
            return 1;
        }

        /**
         * Get the supporting vertex index in the given direction.
         * 
         * @param {org.jbox2d.common.Vec2} d
         * @return
         * @return {number}
         */
        public getSupport(d : org.jbox2d.common.Vec2) : number {
            return 0;
        }

        /**
         * Get the supporting vertex in the given direction.
         * 
         * @param {org.jbox2d.common.Vec2} d
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public getSupportVertex(d : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return this.m_p;
        }

        /**
         * Get the vertex count.
         * 
         * @return
         * @return {number}
         */
        public getVertexCount() : number {
            return 1;
        }

        /**
         * Get a vertex by index.
         * 
         * @param {number} index
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public getVertex(index : number) : org.jbox2d.common.Vec2 {
            return this.m_p;
        }

        /**
         * 
         * @param {org.jbox2d.common.Transform} transform
         * @param {org.jbox2d.common.Vec2} p
         * @return {boolean}
         */
        public testPoint(transform : org.jbox2d.common.Transform, p : org.jbox2d.common.Vec2) : boolean {
            let q : org.jbox2d.common.Rot = transform.q;
            let tp : org.jbox2d.common.Vec2 = transform.p;
            let centerx : number = -((<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(q.c * this.m_p.x) - (<any>Math).fround(q.s * this.m_p.y)) + tp.x) - p.x));
            let centery : number = -((<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(q.s * this.m_p.x) + (<any>Math).fround(q.c * this.m_p.y)) + tp.y) - p.y));
            return (<any>Math).fround((<any>Math).fround(centerx * centerx) + (<any>Math).fround(centery * centery)) <= (<any>Math).fround(this.m_radius * this.m_radius);
        }

        /**
         * 
         * @param {org.jbox2d.common.Transform} xf
         * @param {org.jbox2d.common.Vec2} p
         * @param {number} childIndex
         * @param {org.jbox2d.common.Vec2} normalOut
         * @return {number}
         */
        public computeDistanceToOut(xf : org.jbox2d.common.Transform, p : org.jbox2d.common.Vec2, childIndex : number, normalOut : org.jbox2d.common.Vec2) : number {
            let xfq : org.jbox2d.common.Rot = xf.q;
            let centerx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(xfq.c * this.m_p.x) - (<any>Math).fround(xfq.s * this.m_p.y)) + xf.p.x);
            let centery : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(xfq.s * this.m_p.x) + (<any>Math).fround(xfq.c * this.m_p.y)) + xf.p.y);
            let dx : number = (<any>Math).fround(p.x - centerx);
            let dy : number = (<any>Math).fround(p.y - centery);
            let d1 : number = org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy)));
            normalOut.x = (<any>Math).fround((<any>Math).fround(dx * 1) / d1);
            normalOut.y = (<any>Math).fround((<any>Math).fround(dy * 1) / d1);
            return (<any>Math).fround(d1 - this.m_radius);
        }

        /**
         * 
         * @param {org.jbox2d.collision.RayCastOutput} output
         * @param {org.jbox2d.collision.RayCastInput} input
         * @param {org.jbox2d.common.Transform} transform
         * @param {number} childIndex
         * @return {boolean}
         */
        public raycast(output : org.jbox2d.collision.RayCastOutput, input : org.jbox2d.collision.RayCastInput, transform : org.jbox2d.common.Transform, childIndex : number) : boolean {
            let inputp1 : org.jbox2d.common.Vec2 = input.p1;
            let inputp2 : org.jbox2d.common.Vec2 = input.p2;
            let tq : org.jbox2d.common.Rot = transform.q;
            let tp : org.jbox2d.common.Vec2 = transform.p;
            let positionx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(tq.c * this.m_p.x) - (<any>Math).fround(tq.s * this.m_p.y)) + tp.x);
            let positiony : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(tq.s * this.m_p.x) + (<any>Math).fround(tq.c * this.m_p.y)) + tp.y);
            let sx : number = (<any>Math).fround(inputp1.x - positionx);
            let sy : number = (<any>Math).fround(inputp1.y - positiony);
            let b : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(sx * sx) + (<any>Math).fround(sy * sy)) - (<any>Math).fround(this.m_radius * this.m_radius));
            let rx : number = (<any>Math).fround(inputp2.x - inputp1.x);
            let ry : number = (<any>Math).fround(inputp2.y - inputp1.y);
            let c : number = (<any>Math).fround((<any>Math).fround(sx * rx) + (<any>Math).fround(sy * ry));
            let rr : number = (<any>Math).fround((<any>Math).fround(rx * rx) + (<any>Math).fround(ry * ry));
            let sigma : number = (<any>Math).fround((<any>Math).fround(c * c) - (<any>Math).fround(rr * b));
            if(sigma < 0.0 || rr < org.jbox2d.common.Settings.EPSILON) {
                return false;
            }
            let a : number = -((<any>Math).fround(c + org.jbox2d.common.MathUtils.sqrt(sigma)));
            if(0.0 <= a && a <= (<any>Math).fround(input.maxFraction * rr)) {
                a /= rr;
                output.fraction = a;
                output.normal.x = (<any>Math).fround((<any>Math).fround(rx * a) + sx);
                output.normal.y = (<any>Math).fround((<any>Math).fround(ry * a) + sy);
                output.normal.normalize();
                return true;
            }
            return false;
        }

        /**
         * 
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.Transform} transform
         * @param {number} childIndex
         */
        public computeAABB(aabb : org.jbox2d.collision.AABB, transform : org.jbox2d.common.Transform, childIndex : number) {
            let tq : org.jbox2d.common.Rot = transform.q;
            let tp : org.jbox2d.common.Vec2 = transform.p;
            let px : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(tq.c * this.m_p.x) - (<any>Math).fround(tq.s * this.m_p.y)) + tp.x);
            let py : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(tq.s * this.m_p.x) + (<any>Math).fround(tq.c * this.m_p.y)) + tp.y);
            aabb.lowerBound.x = (<any>Math).fround(px - this.m_radius);
            aabb.lowerBound.y = (<any>Math).fround(py - this.m_radius);
            aabb.upperBound.x = (<any>Math).fround(px + this.m_radius);
            aabb.upperBound.y = (<any>Math).fround(py + this.m_radius);
        }

        /**
         * 
         * @param {org.jbox2d.collision.shapes.MassData} massData
         * @param {number} density
         */
        public computeMass(massData : org.jbox2d.collision.shapes.MassData, density : number) {
            massData.mass = (<any>Math).fround((<any>Math).fround((<any>Math).fround(density * org.jbox2d.common.Settings.PI_$LI$()) * this.m_radius) * this.m_radius);
            massData.center.x = this.m_p.x;
            massData.center.y = this.m_p.y;
            massData.I = (<any>Math).fround(massData.mass * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(0.5 * this.m_radius) * this.m_radius) + ((<any>Math).fround((<any>Math).fround(this.m_p.x * this.m_p.x) + (<any>Math).fround(this.m_p.y * this.m_p.y))))));
        }
    }
    CircleShape["__class"] = "org.jbox2d.collision.shapes.CircleShape";

}
namespace org.jbox2d.collision.shapes {
    /**
     * A line segment (edge) shape. These can be connected in chains or loops to other edge shapes. The
     * connectivity information is used to ensure correct contact normals.
     * 
     * @author Daniel
     * @class
     * @extends org.jbox2d.collision.shapes.Shape
     */
    export class EdgeShape extends org.jbox2d.collision.shapes.Shape {
        /**
         * edge vertex 1
         */
        public m_vertex1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * edge vertex 2
         */
        public m_vertex2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * optional adjacent vertex 1. Used for smooth collision
         */
        public m_vertex0 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * optional adjacent vertex 2. Used for smooth collision
         */
        public m_vertex3 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public m_hasVertex0 : boolean = false;

        public m_hasVertex3 : boolean = false;

        public constructor() {
            super(org.jbox2d.collision.shapes.ShapeType.EDGE);
            this.m_radius = org.jbox2d.common.Settings.polygonRadius_$LI$();
        }

        /**
         * 
         * @return {number}
         */
        public getChildCount() : number {
            return 1;
        }

        public set(v1 : org.jbox2d.common.Vec2, v2 : org.jbox2d.common.Vec2) {
            this.m_vertex1.set$org_jbox2d_common_Vec2(v1);
            this.m_vertex2.set$org_jbox2d_common_Vec2(v2);
            this.m_hasVertex0 = this.m_hasVertex3 = false;
        }

        /**
         * 
         * @param {org.jbox2d.common.Transform} xf
         * @param {org.jbox2d.common.Vec2} p
         * @return {boolean}
         */
        public testPoint(xf : org.jbox2d.common.Transform, p : org.jbox2d.common.Vec2) : boolean {
            return false;
        }

        /*private*/ normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * 
         * @param {org.jbox2d.common.Transform} xf
         * @param {org.jbox2d.common.Vec2} p
         * @param {number} childIndex
         * @param {org.jbox2d.common.Vec2} normalOut
         * @return {number}
         */
        public computeDistanceToOut(xf : org.jbox2d.common.Transform, p : org.jbox2d.common.Vec2, childIndex : number, normalOut : org.jbox2d.common.Vec2) : number {
            let xfqc : number = xf.q.c;
            let xfqs : number = xf.q.s;
            let xfpx : number = xf.p.x;
            let xfpy : number = xf.p.y;
            let v1x : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfqc * this.m_vertex1.x) - (<any>Math).fround(xfqs * this.m_vertex1.y))) + xfpx);
            let v1y : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfqs * this.m_vertex1.x) + (<any>Math).fround(xfqc * this.m_vertex1.y))) + xfpy);
            let v2x : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfqc * this.m_vertex2.x) - (<any>Math).fround(xfqs * this.m_vertex2.y))) + xfpx);
            let v2y : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfqs * this.m_vertex2.x) + (<any>Math).fround(xfqc * this.m_vertex2.y))) + xfpy);
            let dx : number = (<any>Math).fround(p.x - v1x);
            let dy : number = (<any>Math).fround(p.y - v1y);
            let sx : number = (<any>Math).fround(v2x - v1x);
            let sy : number = (<any>Math).fround(v2y - v1y);
            let ds : number = (<any>Math).fround((<any>Math).fround(dx * sx) + (<any>Math).fround(dy * sy));
            if(ds > 0) {
                let s2 : number = (<any>Math).fround((<any>Math).fround(sx * sx) + (<any>Math).fround(sy * sy));
                if(ds > s2) {
                    dx = (<any>Math).fround(p.x - v2x);
                    dy = (<any>Math).fround(p.y - v2y);
                } else {
                    dx -= (<any>Math).fround((<any>Math).fround(ds / s2) * sx);
                    dy -= (<any>Math).fround((<any>Math).fround(ds / s2) * sy);
                }
            }
            let d1 : number = org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy)));
            if(d1 > 0) {
                normalOut.x = (<any>Math).fround((<any>Math).fround(1 / d1) * dx);
                normalOut.y = (<any>Math).fround((<any>Math).fround(1 / d1) * dy);
            } else {
                normalOut.x = 0;
                normalOut.y = 0;
            }
            return d1;
        }

        /**
         * 
         * @param {org.jbox2d.collision.RayCastOutput} output
         * @param {org.jbox2d.collision.RayCastInput} input
         * @param {org.jbox2d.common.Transform} xf
         * @param {number} childIndex
         * @return {boolean}
         */
        public raycast(output : org.jbox2d.collision.RayCastOutput, input : org.jbox2d.collision.RayCastInput, xf : org.jbox2d.common.Transform, childIndex : number) : boolean {
            let tempx : number;
            let tempy : number;
            let v1 : org.jbox2d.common.Vec2 = this.m_vertex1;
            let v2 : org.jbox2d.common.Vec2 = this.m_vertex2;
            let xfq : org.jbox2d.common.Rot = xf.q;
            let xfp : org.jbox2d.common.Vec2 = xf.p;
            tempx = (<any>Math).fround(input.p1.x - xfp.x);
            tempy = (<any>Math).fround(input.p1.y - xfp.y);
            let p1x : number = (<any>Math).fround((<any>Math).fround(xfq.c * tempx) + (<any>Math).fround(xfq.s * tempy));
            let p1y : number = (<any>Math).fround((<any>Math).fround(-xfq.s * tempx) + (<any>Math).fround(xfq.c * tempy));
            tempx = (<any>Math).fround(input.p2.x - xfp.x);
            tempy = (<any>Math).fround(input.p2.y - xfp.y);
            let p2x : number = (<any>Math).fround((<any>Math).fround(xfq.c * tempx) + (<any>Math).fround(xfq.s * tempy));
            let p2y : number = (<any>Math).fround((<any>Math).fround(-xfq.s * tempx) + (<any>Math).fround(xfq.c * tempy));
            let dx : number = (<any>Math).fround(p2x - p1x);
            let dy : number = (<any>Math).fround(p2y - p1y);
            this.normal.x = (<any>Math).fround(v2.y - v1.y);
            this.normal.y = (<any>Math).fround(v1.x - v2.x);
            this.normal.normalize();
            let normalx : number = this.normal.x;
            let normaly : number = this.normal.y;
            tempx = (<any>Math).fround(v1.x - p1x);
            tempy = (<any>Math).fround(v1.y - p1y);
            let numerator : number = (<any>Math).fround((<any>Math).fround(normalx * tempx) + (<any>Math).fround(normaly * tempy));
            let denominator : number = (<any>Math).fround((<any>Math).fround(normalx * dx) + (<any>Math).fround(normaly * dy));
            if(denominator === 0.0) {
                return false;
            }
            let t : number = (<any>Math).fround(numerator / denominator);
            if(t < 0.0 || 1.0 < t) {
                return false;
            }
            let qx : number = (<any>Math).fround(p1x + (<any>Math).fround(t * dx));
            let qy : number = (<any>Math).fround(p1y + (<any>Math).fround(t * dy));
            let rx : number = (<any>Math).fround(v2.x - v1.x);
            let ry : number = (<any>Math).fround(v2.y - v1.y);
            let rr : number = (<any>Math).fround((<any>Math).fround(rx * rx) + (<any>Math).fround(ry * ry));
            if(rr === 0.0) {
                return false;
            }
            tempx = (<any>Math).fround(qx - v1.x);
            tempy = (<any>Math).fround(qy - v1.y);
            let s : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(tempx * rx) + (<any>Math).fround(tempy * ry))) / rr);
            if(s < 0.0 || 1.0 < s) {
                return false;
            }
            output.fraction = t;
            if(numerator > 0.0) {
                output.normal.x = (<any>Math).fround((<any>Math).fround(-xfq.c * this.normal.x) + (<any>Math).fround(xfq.s * this.normal.y));
                output.normal.y = (<any>Math).fround((<any>Math).fround(-xfq.s * this.normal.x) - (<any>Math).fround(xfq.c * this.normal.y));
            } else {
                output.normal.x = (<any>Math).fround((<any>Math).fround(xfq.c * this.normal.x) - (<any>Math).fround(xfq.s * this.normal.y));
                output.normal.y = (<any>Math).fround((<any>Math).fround(xfq.s * this.normal.x) + (<any>Math).fround(xfq.c * this.normal.y));
            }
            return true;
        }

        /**
         * 
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.Transform} xf
         * @param {number} childIndex
         */
        public computeAABB(aabb : org.jbox2d.collision.AABB, xf : org.jbox2d.common.Transform, childIndex : number) {
            let lowerBound : org.jbox2d.common.Vec2 = aabb.lowerBound;
            let upperBound : org.jbox2d.common.Vec2 = aabb.upperBound;
            let xfq : org.jbox2d.common.Rot = xf.q;
            let v1x : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfq.c * this.m_vertex1.x) - (<any>Math).fround(xfq.s * this.m_vertex1.y))) + xf.p.x);
            let v1y : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfq.s * this.m_vertex1.x) + (<any>Math).fround(xfq.c * this.m_vertex1.y))) + xf.p.y);
            let v2x : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfq.c * this.m_vertex2.x) - (<any>Math).fround(xfq.s * this.m_vertex2.y))) + xf.p.x);
            let v2y : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfq.s * this.m_vertex2.x) + (<any>Math).fround(xfq.c * this.m_vertex2.y))) + xf.p.y);
            lowerBound.x = v1x < v2x?v1x:v2x;
            lowerBound.y = v1y < v2y?v1y:v2y;
            upperBound.x = v1x > v2x?v1x:v2x;
            upperBound.y = v1y > v2y?v1y:v2y;
            lowerBound.x -= this.m_radius;
            lowerBound.y -= this.m_radius;
            upperBound.x += this.m_radius;
            upperBound.y += this.m_radius;
        }

        /**
         * 
         * @param {org.jbox2d.collision.shapes.MassData} massData
         * @param {number} density
         */
        public computeMass(massData : org.jbox2d.collision.shapes.MassData, density : number) {
            massData.mass = 0.0;
            massData.center.set$org_jbox2d_common_Vec2(this.m_vertex1).addLocal$org_jbox2d_common_Vec2(this.m_vertex2).mulLocal(0.5);
            massData.I = 0.0;
        }

        /**
         * 
         * @return {org.jbox2d.collision.shapes.Shape}
         */
        public clone() : org.jbox2d.collision.shapes.Shape {
            let edge : EdgeShape = new EdgeShape();
            edge.m_radius = this.m_radius;
            edge.m_hasVertex0 = this.m_hasVertex0;
            edge.m_hasVertex3 = this.m_hasVertex3;
            edge.m_vertex0.set$org_jbox2d_common_Vec2(this.m_vertex0);
            edge.m_vertex1.set$org_jbox2d_common_Vec2(this.m_vertex1);
            edge.m_vertex2.set$org_jbox2d_common_Vec2(this.m_vertex2);
            edge.m_vertex3.set$org_jbox2d_common_Vec2(this.m_vertex3);
            return edge;
        }
    }
    EdgeShape["__class"] = "org.jbox2d.collision.shapes.EdgeShape";

}
namespace org.jbox2d.collision.shapes {
    /**
     * A convex polygon shape. Polygons have a maximum number of vertices equal to _maxPolygonVertices.
     * In most cases you should not need many vertices for a convex polygon.
     * @class
     * @extends org.jbox2d.collision.shapes.Shape
     */
    export class PolygonShape extends org.jbox2d.collision.shapes.Shape {
        /**
         * Dump lots of debug information.
         */
        static m_debug : boolean = false;

        /**
         * Local position of the shape centroid in parent body frame.
         */
        public m_centroid : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The vertices of the shape. Note: use getVertexCount(), not m_vertices.length, to get number of
         * active vertices.
         */
        public m_vertices : org.jbox2d.common.Vec2[];

        /**
         * The normals of the shape. Note: use getVertexCount(), not m_normals.length, to get number of
         * active normals.
         */
        public m_normals : org.jbox2d.common.Vec2[];

        /**
         * Number of active vertices in the shape.
         */
        public m_count : number;

        /*private*/ pool1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ pool2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ pool3 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ pool4 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ poolt1 : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        public constructor() {
            super(org.jbox2d.collision.shapes.ShapeType.POLYGON);
            if(this.m_vertices===undefined) this.m_vertices = null;
            if(this.m_normals===undefined) this.m_normals = null;
            if(this.m_count===undefined) this.m_count = 0;
            this.m_count = 0;
            this.m_vertices = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxPolygonVertices);
            for(let i : number = 0; i < this.m_vertices.length; i++) {
                this.m_vertices[i] = new org.jbox2d.common.Vec2();
            };
            this.m_normals = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxPolygonVertices);
            for(let i : number = 0; i < this.m_normals.length; i++) {
                this.m_normals[i] = new org.jbox2d.common.Vec2();
            };
            this.setRadius(org.jbox2d.common.Settings.polygonRadius_$LI$());
            this.m_centroid.setZero();
        }

        public clone() : org.jbox2d.collision.shapes.Shape {
            let shape : PolygonShape = new PolygonShape();
            shape.m_centroid.set$org_jbox2d_common_Vec2(this.m_centroid);
            for(let i : number = 0; i < shape.m_normals.length; i++) {
                shape.m_normals[i].set$org_jbox2d_common_Vec2(this.m_normals[i]);
                shape.m_vertices[i].set$org_jbox2d_common_Vec2(this.m_vertices[i]);
            };
            shape.setRadius(this.getRadius());
            shape.m_count = this.m_count;
            return shape;
        }

        public set$org_jbox2d_common_Vec2_A$int(vertices : org.jbox2d.common.Vec2[], count : number) {
            this.set$org_jbox2d_common_Vec2_A$int$org_jbox2d_pooling_arrays_Vec2Array$org_jbox2d_pooling_arrays_IntArray(vertices, count, null, null);
        }

        public set$org_jbox2d_common_Vec2_A$int$org_jbox2d_pooling_arrays_Vec2Array$org_jbox2d_pooling_arrays_IntArray(verts : org.jbox2d.common.Vec2[], num : number, vecPool : org.jbox2d.pooling.arrays.Vec2Array, intPool : org.jbox2d.pooling.arrays.IntArray) {
            if(num < 3) {
                this.setAsBox$float$float(1.0, 1.0);
                return;
            }
            let n : number = org.jbox2d.common.MathUtils.min$int$int(num, org.jbox2d.common.Settings.maxPolygonVertices);
            let ps : org.jbox2d.common.Vec2[] = (vecPool != null)?vecPool.get(org.jbox2d.common.Settings.maxPolygonVertices):(s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxPolygonVertices);
            let tempCount : number = 0;
            for(let i : number = 0; i < n; ++i) {
                let v : org.jbox2d.common.Vec2 = verts[i];
                let unique : boolean = true;
                for(let j : number = 0; j < tempCount; ++j) {
                    if(org.jbox2d.common.MathUtils.distanceSquared(v, ps[j]) < (<any>Math).fround(0.5 * org.jbox2d.common.Settings.linearSlop)) {
                        unique = false;
                        break;
                    }
                };
                if(unique) {
                    ps[tempCount++] = v;
                }
            };
            n = tempCount;
            if(n < 3) {
                this.setAsBox$float$float(1.0, 1.0);
                return;
            }
            let i0 : number = 0;
            let x0 : number = ps[0].x;
            for(let i : number = 1; i < n; ++i) {
                let x : number = ps[i].x;
                if(x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {
                    i0 = i;
                    x0 = x;
                }
            };
            let hull : number[] = (intPool != null)?intPool.get(org.jbox2d.common.Settings.maxPolygonVertices):(s => { let a=[]; while(s-->0) a.push(0); return a; })(org.jbox2d.common.Settings.maxPolygonVertices);
            let m : number = 0;
            let ih : number = i0;
            while((true)) {
                hull[m] = ih;
                let ie : number = 0;
                for(let j : number = 1; j < n; ++j) {
                    if(ie === ih) {
                        ie = j;
                        continue;
                    }
                    let r : org.jbox2d.common.Vec2 = this.pool1.set$org_jbox2d_common_Vec2(ps[ie]).subLocal(ps[hull[m]]);
                    let v : org.jbox2d.common.Vec2 = this.pool2.set$org_jbox2d_common_Vec2(ps[j]).subLocal(ps[hull[m]]);
                    let c : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r, v);
                    if(c < 0.0) {
                        ie = j;
                    }
                    if(c === 0.0 && v.lengthSquared() > r.lengthSquared()) {
                        ie = j;
                    }
                };
                ++m;
                ih = ie;
                if(ie === i0) {
                    break;
                }
            };
            this.m_count = m;
            for(let i : number = 0; i < this.m_count; ++i) {
                if(this.m_vertices[i] == null) {
                    this.m_vertices[i] = new org.jbox2d.common.Vec2();
                }
                this.m_vertices[i].set$org_jbox2d_common_Vec2(ps[hull[i]]);
            };
            let edge : org.jbox2d.common.Vec2 = this.pool1;
            for(let i : number = 0; i < this.m_count; ++i) {
                let i1 : number = i;
                let i2 : number = i + 1 < this.m_count?i + 1:0;
                edge.set$org_jbox2d_common_Vec2(this.m_vertices[i2]).subLocal(this.m_vertices[i1]);
                org.jbox2d.common.Vec2.crossToOutUnsafe$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(edge, 1.0, this.m_normals[i]);
                this.m_normals[i].normalize();
            };
            this.computeCentroidToOut(this.m_vertices, this.m_count, this.m_centroid);
        }

        /**
         * Create a convex hull from the given array of points. The count must be in the range [3,
         * Settings.maxPolygonVertices]. This method takes an arraypool for pooling.
         * 
         * @warning the points may be re-ordered, even if they form a convex polygon.
         * @warning collinear points are removed.
         * @param {Array} verts
         * @param {number} num
         * @param {org.jbox2d.pooling.arrays.Vec2Array} vecPool
         * @param {org.jbox2d.pooling.arrays.IntArray} intPool
         */
        public set(verts? : any, num? : any, vecPool? : any, intPool? : any) : any {
            if(((verts != null && verts instanceof <any>Array && (verts.length==0 || verts[0] == null ||(verts[0] != null && verts[0] instanceof <any>org.jbox2d.common.Vec2))) || verts === null) && ((typeof num === 'number') || num === null) && ((vecPool != null && vecPool instanceof <any>org.jbox2d.pooling.arrays.Vec2Array) || vecPool === null) && ((intPool != null && intPool instanceof <any>org.jbox2d.pooling.arrays.IntArray) || intPool === null)) {
                return <any>this.set$org_jbox2d_common_Vec2_A$int$org_jbox2d_pooling_arrays_Vec2Array$org_jbox2d_pooling_arrays_IntArray(verts, num, vecPool, intPool);
            } else if(((verts != null && verts instanceof <any>Array && (verts.length==0 || verts[0] == null ||(verts[0] != null && verts[0] instanceof <any>org.jbox2d.common.Vec2))) || verts === null) && ((typeof num === 'number') || num === null) && vecPool === undefined && intPool === undefined) {
                return <any>this.set$org_jbox2d_common_Vec2_A$int(verts, num);
            } else throw new Error('invalid overload');
        }

        public setAsBox$float$float(hx : number, hy : number) {
            this.m_count = 4;
            this.m_vertices[0].set$float$float(-hx, -hy);
            this.m_vertices[1].set$float$float(hx, -hy);
            this.m_vertices[2].set$float$float(hx, hy);
            this.m_vertices[3].set$float$float(-hx, hy);
            this.m_normals[0].set$float$float(0.0, -1.0);
            this.m_normals[1].set$float$float(1.0, 0.0);
            this.m_normals[2].set$float$float(0.0, 1.0);
            this.m_normals[3].set$float$float(-1.0, 0.0);
            this.m_centroid.setZero();
        }

        public setAsBox$float$float$org_jbox2d_common_Vec2$float(hx : number, hy : number, center : org.jbox2d.common.Vec2, angle : number) {
            this.m_count = 4;
            this.m_vertices[0].set$float$float(-hx, -hy);
            this.m_vertices[1].set$float$float(hx, -hy);
            this.m_vertices[2].set$float$float(hx, hy);
            this.m_vertices[3].set$float$float(-hx, hy);
            this.m_normals[0].set$float$float(0.0, -1.0);
            this.m_normals[1].set$float$float(1.0, 0.0);
            this.m_normals[2].set$float$float(0.0, 1.0);
            this.m_normals[3].set$float$float(-1.0, 0.0);
            this.m_centroid.set$org_jbox2d_common_Vec2(center);
            let xf : org.jbox2d.common.Transform = this.poolt1;
            xf.p.set$org_jbox2d_common_Vec2(center);
            xf.q.set$float(angle);
            for(let i : number = 0; i < this.m_count; ++i) {
                org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf, this.m_vertices[i], this.m_vertices[i]);
                org.jbox2d.common.Rot.mulToOut(xf.q, this.m_normals[i], this.m_normals[i]);
            };
        }

        /**
         * Build vertices to represent an oriented box.
         * 
         * @param {number} hx the half-width.
         * @param {number} hy the half-height.
         * @param {org.jbox2d.common.Vec2} center the center of the box in local coordinates.
         * @param {number} angle the rotation of the box in local coordinates.
         */
        public setAsBox(hx? : any, hy? : any, center? : any, angle? : any) : any {
            if(((typeof hx === 'number') || hx === null) && ((typeof hy === 'number') || hy === null) && ((center != null && center instanceof <any>org.jbox2d.common.Vec2) || center === null) && ((typeof angle === 'number') || angle === null)) {
                return <any>this.setAsBox$float$float$org_jbox2d_common_Vec2$float(hx, hy, center, angle);
            } else if(((typeof hx === 'number') || hx === null) && ((typeof hy === 'number') || hy === null) && center === undefined && angle === undefined) {
                return <any>this.setAsBox$float$float(hx, hy);
            } else throw new Error('invalid overload');
        }

        public getChildCount() : number {
            return 1;
        }

        /**
         * 
         * @param {org.jbox2d.common.Transform} xf
         * @param {org.jbox2d.common.Vec2} p
         * @return {boolean}
         */
        public testPoint(xf : org.jbox2d.common.Transform, p : org.jbox2d.common.Vec2) : boolean {
            let tempx : number;
            let tempy : number;
            let xfq : org.jbox2d.common.Rot = xf.q;
            tempx = (<any>Math).fround(p.x - xf.p.x);
            tempy = (<any>Math).fround(p.y - xf.p.y);
            let pLocalx : number = (<any>Math).fround((<any>Math).fround(xfq.c * tempx) + (<any>Math).fround(xfq.s * tempy));
            let pLocaly : number = (<any>Math).fround((<any>Math).fround(-xfq.s * tempx) + (<any>Math).fround(xfq.c * tempy));
            if(PolygonShape.m_debug) {
                console.info("--testPoint debug--");
                console.info("Vertices: ");
                for(let i : number = 0; i < this.m_count; ++i) {
                    console.info(this.m_vertices[i]);
                };
                console.info("pLocal: " + pLocalx + ", " + pLocaly);
            }
            for(let i : number = 0; i < this.m_count; ++i) {
                let vertex : org.jbox2d.common.Vec2 = this.m_vertices[i];
                let normal : org.jbox2d.common.Vec2 = this.m_normals[i];
                tempx = (<any>Math).fround(pLocalx - vertex.x);
                tempy = (<any>Math).fround(pLocaly - vertex.y);
                let dot : number = (<any>Math).fround((<any>Math).fround(normal.x * tempx) + (<any>Math).fround(normal.y * tempy));
                if(dot > 0.0) {
                    return false;
                }
            };
            return true;
        }

        /**
         * 
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.Transform} xf
         * @param {number} childIndex
         */
        public computeAABB(aabb : org.jbox2d.collision.AABB, xf : org.jbox2d.common.Transform, childIndex : number) {
            let lower : org.jbox2d.common.Vec2 = aabb.lowerBound;
            let upper : org.jbox2d.common.Vec2 = aabb.upperBound;
            let v1 : org.jbox2d.common.Vec2 = this.m_vertices[0];
            let xfqc : number = xf.q.c;
            let xfqs : number = xf.q.s;
            let xfpx : number = xf.p.x;
            let xfpy : number = xf.p.y;
            lower.x = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfqc * v1.x) - (<any>Math).fround(xfqs * v1.y))) + xfpx);
            lower.y = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfqs * v1.x) + (<any>Math).fround(xfqc * v1.y))) + xfpy);
            upper.x = lower.x;
            upper.y = lower.y;
            for(let i : number = 1; i < this.m_count; ++i) {
                let v2 : org.jbox2d.common.Vec2 = this.m_vertices[i];
                let vx : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfqc * v2.x) - (<any>Math).fround(xfqs * v2.y))) + xfpx);
                let vy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfqs * v2.x) + (<any>Math).fround(xfqc * v2.y))) + xfpy);
                lower.x = lower.x < vx?lower.x:vx;
                lower.y = lower.y < vy?lower.y:vy;
                upper.x = upper.x > vx?upper.x:vx;
                upper.y = upper.y > vy?upper.y:vy;
            };
            lower.x -= this.m_radius;
            lower.y -= this.m_radius;
            upper.x += this.m_radius;
            upper.y += this.m_radius;
        }

        /**
         * Get the vertex count.
         * 
         * @return
         * @return {number}
         */
        public getVertexCount() : number {
            return this.m_count;
        }

        /**
         * Get a vertex by index.
         * 
         * @param {number} index
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public getVertex(index : number) : org.jbox2d.common.Vec2 {
            return this.m_vertices[index];
        }

        /**
         * 
         * @param {org.jbox2d.common.Transform} xf
         * @param {org.jbox2d.common.Vec2} p
         * @param {number} childIndex
         * @param {org.jbox2d.common.Vec2} normalOut
         * @return {number}
         */
        public computeDistanceToOut(xf : org.jbox2d.common.Transform, p : org.jbox2d.common.Vec2, childIndex : number, normalOut : org.jbox2d.common.Vec2) : number {
            let xfqc : number = xf.q.c;
            let xfqs : number = xf.q.s;
            let tx : number = (<any>Math).fround(p.x - xf.p.x);
            let ty : number = (<any>Math).fround(p.y - xf.p.y);
            let pLocalx : number = (<any>Math).fround((<any>Math).fround(xfqc * tx) + (<any>Math).fround(xfqs * ty));
            let pLocaly : number = (<any>Math).fround((<any>Math).fround(-xfqs * tx) + (<any>Math).fround(xfqc * ty));
            let maxDistance : number = -Number.MAX_VALUE;
            let normalForMaxDistanceX : number = pLocalx;
            let normalForMaxDistanceY : number = pLocaly;
            for(let i : number = 0; i < this.m_count; ++i) {
                let vertex : org.jbox2d.common.Vec2 = this.m_vertices[i];
                let normal : org.jbox2d.common.Vec2 = this.m_normals[i];
                tx = (<any>Math).fround(pLocalx - vertex.x);
                ty = (<any>Math).fround(pLocaly - vertex.y);
                let dot : number = (<any>Math).fround((<any>Math).fround(normal.x * tx) + (<any>Math).fround(normal.y * ty));
                if(dot > maxDistance) {
                    maxDistance = dot;
                    normalForMaxDistanceX = normal.x;
                    normalForMaxDistanceY = normal.y;
                }
            };
            let distance : number;
            if(maxDistance > 0) {
                let minDistanceX : number = normalForMaxDistanceX;
                let minDistanceY : number = normalForMaxDistanceY;
                let minDistance2 : number = (<any>Math).fround(maxDistance * maxDistance);
                for(let i : number = 0; i < this.m_count; ++i) {
                    let vertex : org.jbox2d.common.Vec2 = this.m_vertices[i];
                    let distanceVecX : number = (<any>Math).fround(pLocalx - vertex.x);
                    let distanceVecY : number = (<any>Math).fround(pLocaly - vertex.y);
                    let distance2 : number = ((<any>Math).fround((<any>Math).fround(distanceVecX * distanceVecX) + (<any>Math).fround(distanceVecY * distanceVecY)));
                    if(minDistance2 > distance2) {
                        minDistanceX = distanceVecX;
                        minDistanceY = distanceVecY;
                        minDistance2 = distance2;
                    }
                };
                distance = org.jbox2d.common.MathUtils.sqrt(minDistance2);
                normalOut.x = (<any>Math).fround((<any>Math).fround(xfqc * minDistanceX) - (<any>Math).fround(xfqs * minDistanceY));
                normalOut.y = (<any>Math).fround((<any>Math).fround(xfqs * minDistanceX) + (<any>Math).fround(xfqc * minDistanceY));
                normalOut.normalize();
            } else {
                distance = maxDistance;
                normalOut.x = (<any>Math).fround((<any>Math).fround(xfqc * normalForMaxDistanceX) - (<any>Math).fround(xfqs * normalForMaxDistanceY));
                normalOut.y = (<any>Math).fround((<any>Math).fround(xfqs * normalForMaxDistanceX) + (<any>Math).fround(xfqc * normalForMaxDistanceY));
            }
            return distance;
        }

        /**
         * 
         * @param {org.jbox2d.collision.RayCastOutput} output
         * @param {org.jbox2d.collision.RayCastInput} input
         * @param {org.jbox2d.common.Transform} xf
         * @param {number} childIndex
         * @return {boolean}
         */
        public raycast(output : org.jbox2d.collision.RayCastOutput, input : org.jbox2d.collision.RayCastInput, xf : org.jbox2d.common.Transform, childIndex : number) : boolean {
            let xfqc : number = xf.q.c;
            let xfqs : number = xf.q.s;
            let xfp : org.jbox2d.common.Vec2 = xf.p;
            let tempx : number;
            let tempy : number;
            tempx = (<any>Math).fround(input.p1.x - xfp.x);
            tempy = (<any>Math).fround(input.p1.y - xfp.y);
            let p1x : number = (<any>Math).fround((<any>Math).fround(xfqc * tempx) + (<any>Math).fround(xfqs * tempy));
            let p1y : number = (<any>Math).fround((<any>Math).fround(-xfqs * tempx) + (<any>Math).fround(xfqc * tempy));
            tempx = (<any>Math).fround(input.p2.x - xfp.x);
            tempy = (<any>Math).fround(input.p2.y - xfp.y);
            let p2x : number = (<any>Math).fround((<any>Math).fround(xfqc * tempx) + (<any>Math).fround(xfqs * tempy));
            let p2y : number = (<any>Math).fround((<any>Math).fround(-xfqs * tempx) + (<any>Math).fround(xfqc * tempy));
            let dx : number = (<any>Math).fround(p2x - p1x);
            let dy : number = (<any>Math).fround(p2y - p1y);
            let lower : number = 0;
            let upper : number = input.maxFraction;
            let index : number = -1;
            for(let i : number = 0; i < this.m_count; ++i) {
                let normal : org.jbox2d.common.Vec2 = this.m_normals[i];
                let vertex : org.jbox2d.common.Vec2 = this.m_vertices[i];
                let tempxn : number = (<any>Math).fround(vertex.x - p1x);
                let tempyn : number = (<any>Math).fround(vertex.y - p1y);
                let numerator : number = (<any>Math).fround((<any>Math).fround(normal.x * tempxn) + (<any>Math).fround(normal.y * tempyn));
                let denominator : number = (<any>Math).fround((<any>Math).fround(normal.x * dx) + (<any>Math).fround(normal.y * dy));
                if(denominator === 0.0) {
                    if(numerator < 0.0) {
                        return false;
                    }
                } else {
                    if(denominator < 0.0 && numerator < (<any>Math).fround(lower * denominator)) {
                        lower = (<any>Math).fround(numerator / denominator);
                        index = i;
                    } else if(denominator > 0.0 && numerator < (<any>Math).fround(upper * denominator)) {
                        upper = (<any>Math).fround(numerator / denominator);
                    }
                }
                if(upper < lower) {
                    return false;
                }
            };
            if(index >= 0) {
                output.fraction = lower;
                let normal : org.jbox2d.common.Vec2 = this.m_normals[index];
                let out : org.jbox2d.common.Vec2 = output.normal;
                out.x = (<any>Math).fround((<any>Math).fround(xfqc * normal.x) - (<any>Math).fround(xfqs * normal.y));
                out.y = (<any>Math).fround((<any>Math).fround(xfqs * normal.x) + (<any>Math).fround(xfqc * normal.y));
                return true;
            }
            return false;
        }

        public computeCentroidToOut(vs : org.jbox2d.common.Vec2[], count : number, out : org.jbox2d.common.Vec2) {
            out.set$float$float(0.0, 0.0);
            let area : number = 0.0;
            let pRef : org.jbox2d.common.Vec2 = this.pool1;
            pRef.setZero();
            let e1 : org.jbox2d.common.Vec2 = this.pool2;
            let e2 : org.jbox2d.common.Vec2 = this.pool3;
            let inv3 : number = (<any>Math).fround(1.0 / 3.0);
            for(let i : number = 0; i < count; ++i) {
                let p1 : org.jbox2d.common.Vec2 = pRef;
                let p2 : org.jbox2d.common.Vec2 = vs[i];
                let p3 : org.jbox2d.common.Vec2 = i + 1 < count?vs[i + 1]:vs[0];
                e1.set$org_jbox2d_common_Vec2(p2).subLocal(p1);
                e2.set$org_jbox2d_common_Vec2(p3).subLocal(p1);
                let D : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2);
                let triangleArea : number = (<any>Math).fround(0.5 * D);
                area += triangleArea;
                e1.set$org_jbox2d_common_Vec2(p1).addLocal$org_jbox2d_common_Vec2(p2).addLocal$org_jbox2d_common_Vec2(p3).mulLocal((<any>Math).fround(triangleArea * inv3));
                out.addLocal$org_jbox2d_common_Vec2(e1);
            };
            out.mulLocal((<any>Math).fround(1.0 / area));
        }

        public computeMass(massData : org.jbox2d.collision.shapes.MassData, density : number) {
            let center : org.jbox2d.common.Vec2 = this.pool1;
            center.setZero();
            let area : number = 0.0;
            let I : number = 0.0;
            let s : org.jbox2d.common.Vec2 = this.pool2;
            s.setZero();
            for(let i : number = 0; i < this.m_count; ++i) {
                s.addLocal$org_jbox2d_common_Vec2(this.m_vertices[i]);
            };
            s.mulLocal((<any>Math).fround(1.0 / this.m_count));
            let k_inv3 : number = (<any>Math).fround(1.0 / 3.0);
            let e1 : org.jbox2d.common.Vec2 = this.pool3;
            let e2 : org.jbox2d.common.Vec2 = this.pool4;
            for(let i : number = 0; i < this.m_count; ++i) {
                e1.set$org_jbox2d_common_Vec2(this.m_vertices[i]).subLocal(s);
                e2.set$org_jbox2d_common_Vec2(s).negateLocal().addLocal$org_jbox2d_common_Vec2(i + 1 < this.m_count?this.m_vertices[i + 1]:this.m_vertices[0]);
                let D : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2);
                let triangleArea : number = (<any>Math).fround(0.5 * D);
                area += triangleArea;
                center.x += (<any>Math).fround((<any>Math).fround(triangleArea * k_inv3) * ((<any>Math).fround(e1.x + e2.x)));
                center.y += (<any>Math).fround((<any>Math).fround(triangleArea * k_inv3) * ((<any>Math).fround(e1.y + e2.y)));
                let ex1 : number = e1.x;
                let ey1 : number = e1.y;
                let ex2 : number = e2.x;
                let ey2 : number = e2.y;
                let intx2 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(ex1 * ex1) + (<any>Math).fround(ex2 * ex1)) + (<any>Math).fround(ex2 * ex2));
                let inty2 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(ey1 * ey1) + (<any>Math).fround(ey2 * ey1)) + (<any>Math).fround(ey2 * ey2));
                I += (<any>Math).fround(((<any>Math).fround((<any>Math).fround(0.25 * k_inv3) * D)) * ((<any>Math).fround(intx2 + inty2)));
            };
            massData.mass = (<any>Math).fround(density * area);
            center.mulLocal((<any>Math).fround(1.0 / area));
            massData.center.set$org_jbox2d_common_Vec2(center).addLocal$org_jbox2d_common_Vec2(s);
            massData.I = (<any>Math).fround(I * density);
            massData.I += (<any>Math).fround(massData.mass * (org.jbox2d.common.Vec2.dot(massData.center, massData.center)));
        }

        /**
         * Validate convexity. This is a very time consuming operation.
         * 
         * @return
         * @return {boolean}
         */
        public validate() : boolean {
            for(let i : number = 0; i < this.m_count; ++i) {
                let i1 : number = i;
                let i2 : number = i < this.m_count - 1?i1 + 1:0;
                let p : org.jbox2d.common.Vec2 = this.m_vertices[i1];
                let e : org.jbox2d.common.Vec2 = this.pool1.set$org_jbox2d_common_Vec2(this.m_vertices[i2]).subLocal(p);
                for(let j : number = 0; j < this.m_count; ++j) {
                    if(j === i1 || j === i2) {
                        continue;
                    }
                    let v : org.jbox2d.common.Vec2 = this.pool2.set$org_jbox2d_common_Vec2(this.m_vertices[j]).subLocal(p);
                    let c : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e, v);
                    if(c < 0.0) {
                        return false;
                    }
                };
            };
            return true;
        }

        /**
         * Get the vertices in local coordinates.
         * @return {Array}
         */
        public getVertices() : org.jbox2d.common.Vec2[] {
            return this.m_vertices;
        }

        /**
         * Get the edge normal vectors. There is one for each vertex.
         * @return {Array}
         */
        public getNormals() : org.jbox2d.common.Vec2[] {
            return this.m_normals;
        }

        /**
         * Get the centroid and apply the supplied transform.
         * @param {org.jbox2d.common.Transform} xf
         * @return {org.jbox2d.common.Vec2}
         */
        public centroid(xf : org.jbox2d.common.Transform) : org.jbox2d.common.Vec2 {
            return org.jbox2d.common.Transform.mul$org_jbox2d_common_Transform$org_jbox2d_common_Vec2(xf, this.m_centroid);
        }

        /**
         * Get the centroid and apply the supplied transform.
         * @param {org.jbox2d.common.Transform} xf
         * @param {org.jbox2d.common.Vec2} out
         * @return {org.jbox2d.common.Vec2}
         */
        public centroidToOut(xf : org.jbox2d.common.Transform, out : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf, this.m_centroid, out);
            return out;
        }
    }
    PolygonShape["__class"] = "org.jbox2d.collision.shapes.PolygonShape";

}
namespace org.jbox2d.common {
    /**
     * A few math methods that don't fit very well anywhere else.
     * @class
     * @extends org.jbox2d.common.PlatformMathUtils
     */
    export class MathUtils extends org.jbox2d.common.PlatformMathUtils {
        static __static_initialized : boolean = false;
        static __static_initialize() { if(!MathUtils.__static_initialized) { MathUtils.__static_initialized = true; MathUtils.__static_initializer_0(); } }

        public static PI : number; public static PI_$LI$() : number { MathUtils.__static_initialize(); if(MathUtils.PI == null) MathUtils.PI = (<any>Math).fround(Math.PI); return MathUtils.PI; };

        public static TWOPI : number; public static TWOPI_$LI$() : number { MathUtils.__static_initialize(); if(MathUtils.TWOPI == null) MathUtils.TWOPI = (<any>Math).fround((Math.PI * 2)); return MathUtils.TWOPI; };

        public static INV_PI : number; public static INV_PI_$LI$() : number { MathUtils.__static_initialize(); if(MathUtils.INV_PI == null) MathUtils.INV_PI = (<any>Math).fround(1.0 / MathUtils.PI_$LI$()); return MathUtils.INV_PI; };

        public static HALF_PI : number; public static HALF_PI_$LI$() : number { MathUtils.__static_initialize(); if(MathUtils.HALF_PI == null) MathUtils.HALF_PI = (<any>Math).fround(MathUtils.PI_$LI$() / 2); return MathUtils.HALF_PI; };

        public static QUARTER_PI : number; public static QUARTER_PI_$LI$() : number { MathUtils.__static_initialize(); if(MathUtils.QUARTER_PI == null) MathUtils.QUARTER_PI = (<any>Math).fround(MathUtils.PI_$LI$() / 4); return MathUtils.QUARTER_PI; };

        public static THREE_HALVES_PI : number; public static THREE_HALVES_PI_$LI$() : number { MathUtils.__static_initialize(); if(MathUtils.THREE_HALVES_PI == null) MathUtils.THREE_HALVES_PI = (<any>Math).fround(MathUtils.TWOPI_$LI$() - MathUtils.HALF_PI_$LI$()); return MathUtils.THREE_HALVES_PI; };

        /**
         * Degrees to radians conversion factor
         */
        public static DEG2RAD : number; public static DEG2RAD_$LI$() : number { MathUtils.__static_initialize(); if(MathUtils.DEG2RAD == null) MathUtils.DEG2RAD = (<any>Math).fround(MathUtils.PI_$LI$() / 180); return MathUtils.DEG2RAD; };

        /**
         * Radians to degrees conversion factor
         */
        public static RAD2DEG : number; public static RAD2DEG_$LI$() : number { MathUtils.__static_initialize(); if(MathUtils.RAD2DEG == null) MathUtils.RAD2DEG = (<any>Math).fround(180 / MathUtils.PI_$LI$()); return MathUtils.RAD2DEG; };

        public static __sinLUT : number[]; public static __sinLUT_$LI$() : number[] { MathUtils.__static_initialize(); if(MathUtils.__sinLUT == null) MathUtils.__sinLUT = (s => { let a=[]; while(s-->0) a.push(0); return a; })(org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$()); return MathUtils.__sinLUT; };

        static __static_initializer_0() {
            for(let i : number = 0; i < org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$(); i++) {
                MathUtils.__sinLUT_$LI$()[i] = (<any>Math).fround(Math.sin((<any>Math).fround(i * org.jbox2d.common.Settings.SINCOS_LUT_PRECISION)));
            };
        }

        public static sin(x : number) : number {
            if(org.jbox2d.common.Settings.SINCOS_LUT_ENABLED) {
                return MathUtils.sinLUT(x);
            } else {
                return (<any>Math).fround(Math.sin(x));
            }
        }

        public static sinLUT(x : number) : number {
            x %= MathUtils.TWOPI_$LI$();
            if(x < 0) {
                x += MathUtils.TWOPI_$LI$();
            }
            if(org.jbox2d.common.Settings.SINCOS_LUT_LERP) {
                x /= org.jbox2d.common.Settings.SINCOS_LUT_PRECISION;
                let index : number = (<number>x|0);
                if(index !== 0) {
                    x %= index;
                }
                if(index === org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$() - 1) {
                    return ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1 - x)) * MathUtils.__sinLUT_$LI$()[index]) + (<any>Math).fround(x * MathUtils.__sinLUT_$LI$()[0])));
                } else {
                    return ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1 - x)) * MathUtils.__sinLUT_$LI$()[index]) + (<any>Math).fround(x * MathUtils.__sinLUT_$LI$()[index + 1])));
                }
            } else {
                return MathUtils.__sinLUT_$LI$()[MathUtils.round((<any>Math).fround(x / org.jbox2d.common.Settings.SINCOS_LUT_PRECISION)) % org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$()];
            }
        }

        public static cos(x : number) : number {
            if(org.jbox2d.common.Settings.SINCOS_LUT_ENABLED) {
                return MathUtils.sinLUT((<any>Math).fround(MathUtils.HALF_PI_$LI$() - x));
            } else {
                return (<any>Math).fround(Math.cos(x));
            }
        }

        public static abs$float(x : number) : number {
            if(org.jbox2d.common.Settings.FAST_ABS) {
                return x > 0?x:-x;
            } else {
                return Math.abs(x);
            }
        }

        public static fastAbs(x : number) : number {
            return x > 0?x:-x;
        }

        public static abs$int(x : number) : number {
            let y : number = x >> 31;
            return (x ^ y) - y;
        }

        public static abs(x? : any) : any {
            if(((typeof x === 'number') || x === null)) {
                return <any>org.jbox2d.common.MathUtils.abs$int(x);
            } else if(((typeof x === 'number') || x === null)) {
                return <any>org.jbox2d.common.MathUtils.abs$float(x);
            } else throw new Error('invalid overload');
        }

        public static floor(x : number) : number {
            if(org.jbox2d.common.Settings.FAST_FLOOR) {
                return MathUtils.fastFloor(x);
            } else {
                return (<number>Math.floor(x)|0);
            }
        }

        public static fastFloor(x : number) : number {
            let y : number = (<number>x|0);
            if(x < y) {
                return y - 1;
            }
            return y;
        }

        public static ceil(x : number) : number {
            if(org.jbox2d.common.Settings.FAST_CEIL) {
                return MathUtils.fastCeil(x);
            } else {
                return (<number>Math.ceil(x)|0);
            }
        }

        public static fastCeil(x : number) : number {
            let y : number = (<number>x|0);
            if(x > y) {
                return y + 1;
            }
            return y;
        }

        public static round(x : number) : number {
            if(org.jbox2d.common.Settings.FAST_ROUND) {
                return MathUtils.floor((<any>Math).fround(x + 0.5));
            } else {
                return Math.round(x);
            }
        }

        /**
         * Rounds up the value to the nearest higher power^2 value.
         * 
         * @param {number} x
         * @return {number} power^2 value
         */
        public static ceilPowerOf2(x : number) : number {
            let pow2 : number = 1;
            while((pow2 < x)) {
                pow2 <<= 1;
            };
            return pow2;
        }

        public static max$float$float(a : number, b : number) : number {
            return a > b?a:b;
        }

        public static max$int$int(a : number, b : number) : number {
            return a > b?a:b;
        }

        public static max(a? : any, b? : any) : any {
            if(((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null)) {
                return <any>org.jbox2d.common.MathUtils.max$int$int(a, b);
            } else if(((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null)) {
                return <any>org.jbox2d.common.MathUtils.max$float$float(a, b);
            } else throw new Error('invalid overload');
        }

        public static min$float$float(a : number, b : number) : number {
            return a < b?a:b;
        }

        public static min$int$int(a : number, b : number) : number {
            return a < b?a:b;
        }

        public static min(a? : any, b? : any) : any {
            if(((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null)) {
                return <any>org.jbox2d.common.MathUtils.min$int$int(a, b);
            } else if(((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null)) {
                return <any>org.jbox2d.common.MathUtils.min$float$float(a, b);
            } else throw new Error('invalid overload');
        }

        public static map(val : number, fromMin : number, fromMax : number, toMin : number, toMax : number) : number {
            let mult : number = (<any>Math).fround(((<any>Math).fround(val - fromMin)) / ((<any>Math).fround(fromMax - fromMin)));
            let res : number = (<any>Math).fround(toMin + (<any>Math).fround(mult * ((<any>Math).fround(toMax - toMin))));
            return res;
        }

        public static clamp$float$float$float(a : number, low : number, high : number) : number {
            return MathUtils.max$float$float(low, MathUtils.min$float$float(a, high));
        }

        public static clamp$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a : org.jbox2d.common.Vec2, low : org.jbox2d.common.Vec2, high : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let min : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            min.x = a.x < high.x?a.x:high.x;
            min.y = a.y < high.y?a.y:high.y;
            min.x = low.x > min.x?low.x:min.x;
            min.y = low.y > min.y?low.y:min.y;
            return min;
        }

        public static clamp(a? : any, low? : any, high? : any) : any {
            if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && ((low != null && low instanceof <any>org.jbox2d.common.Vec2) || low === null) && ((high != null && high instanceof <any>org.jbox2d.common.Vec2) || high === null)) {
                return <any>org.jbox2d.common.MathUtils.clamp$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, low, high);
            } else if(((typeof a === 'number') || a === null) && ((typeof low === 'number') || low === null) && ((typeof high === 'number') || high === null)) {
                return <any>org.jbox2d.common.MathUtils.clamp$float$float$float(a, low, high);
            } else throw new Error('invalid overload');
        }

        public static clampToOut(a : org.jbox2d.common.Vec2, low : org.jbox2d.common.Vec2, high : org.jbox2d.common.Vec2, dest : org.jbox2d.common.Vec2) {
            dest.x = a.x < high.x?a.x:high.x;
            dest.y = a.y < high.y?a.y:high.y;
            dest.x = low.x > dest.x?low.x:dest.x;
            dest.y = low.y > dest.y?low.y:dest.y;
        }

        /**
         * Next Largest Power of 2: Given a binary integer value x, the next largest power of 2 can be
         * computed by a SWAR algorithm that recursively "folds" the upper bits into the lower bits. This
         * process yields a bit vector with the same most significant 1 as x, but all 1's below it. Adding
         * 1 to that value yields the next largest power of 2.
         * @param {number} x
         * @return {number}
         */
        public static nextPowerOfTwo(x : number) : number {
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            return x + 1;
        }

        public static isPowerOfTwo(x : number) : boolean {
            return x > 0 && (x & x - 1) === 0;
        }

        public static pow(a : number, b : number) : number {
            if(org.jbox2d.common.Settings.FAST_POW) {
                return PlatformMathUtils.fastPow(a, b);
            } else {
                return (<any>Math).fround(Math.pow(a, b));
            }
        }

        public static atan2(y : number, x : number) : number {
            if(org.jbox2d.common.Settings.FAST_ATAN2) {
                return MathUtils.fastAtan2(y, x);
            } else {
                return (<any>Math).fround(Math.atan2(y, x));
            }
        }

        public static fastAtan2(y : number, x : number) : number {
            if(x === 0.0) {
                if(y > 0.0) return MathUtils.HALF_PI_$LI$();
                if(y === 0.0) return 0.0;
                return -MathUtils.HALF_PI_$LI$();
            }
            let atan : number;
            let z : number = (<any>Math).fround(y / x);
            if(MathUtils.abs$float(z) < 1.0) {
                atan = (<any>Math).fround(z / ((<any>Math).fround(1.0 + (<any>Math).fround((<any>Math).fround(0.28 * z) * z))));
                if(x < 0.0) {
                    if(y < 0.0) return (<any>Math).fround(atan - MathUtils.PI_$LI$());
                    return (<any>Math).fround(atan + MathUtils.PI_$LI$());
                }
            } else {
                atan = (<any>Math).fround(MathUtils.HALF_PI_$LI$() - (<any>Math).fround(z / ((<any>Math).fround((<any>Math).fround(z * z) + 0.28))));
                if(y < 0.0) return (<any>Math).fround(atan - MathUtils.PI_$LI$());
            }
            return atan;
        }

        public static reduceAngle(theta : number) : number {
            theta %= MathUtils.TWOPI_$LI$();
            if(MathUtils.abs$float(theta) > MathUtils.PI_$LI$()) {
                theta = (<any>Math).fround(theta - MathUtils.TWOPI_$LI$());
            }
            if(MathUtils.abs$float(theta) > MathUtils.HALF_PI_$LI$()) {
                theta = (<any>Math).fround(MathUtils.PI_$LI$() - theta);
            }
            return theta;
        }

        public static randomFloat(argLow : number, argHigh : number) : number {
            return (<any>Math).fround((<any>Math).fround((<any>Math).fround(Math.random()) * ((<any>Math).fround(argHigh - argLow))) + argLow);
        }

        public static sqrt(x : number) : number {
            return (<any>Math).fround(Math.sqrt(x));
        }

        public static distanceSquared(v1 : org.jbox2d.common.Vec2, v2 : org.jbox2d.common.Vec2) : number {
            let dx : number = ((<any>Math).fround(v1.x - v2.x));
            let dy : number = ((<any>Math).fround(v1.y - v2.y));
            return (<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy));
        }

        public static distance(v1 : org.jbox2d.common.Vec2, v2 : org.jbox2d.common.Vec2) : number {
            return MathUtils.sqrt(MathUtils.distanceSquared(v1, v2));
        }
    }
    MathUtils["__class"] = "org.jbox2d.common.MathUtils";

}
namespace org.jbox2d.collision {
    /**
     * Functions used for computing contact points, distance queries, and TOI queries. Collision methods
     * are non-static for pooling speed, retrieve a collision object from the {@link SingletonPool}.
     * Should not be finalructed.
     * 
     * @author Daniel Murphy
     * @param {*} argPool
     * @class
     */
    export class Collision {
        public static NULL_FEATURE : number; public static NULL_FEATURE_$LI$() : number { if(Collision.NULL_FEATURE == null) Collision.NULL_FEATURE = Number.MAX_VALUE; return Collision.NULL_FEATURE; };

        /*private*/ pool : org.jbox2d.pooling.IWorldPool;

        public constructor(argPool : org.jbox2d.pooling.IWorldPool) {
            if(this.pool===undefined) this.pool = null;
            this.incidentEdge[0] = new Collision.ClipVertex();
            this.incidentEdge[1] = new Collision.ClipVertex();
            this.clipPoints1[0] = new Collision.ClipVertex();
            this.clipPoints1[1] = new Collision.ClipVertex();
            this.clipPoints2[0] = new Collision.ClipVertex();
            this.clipPoints2[1] = new Collision.ClipVertex();
            this.pool = argPool;
        }

        /*private*/ input : org.jbox2d.collision.DistanceInput = new org.jbox2d.collision.DistanceInput();

        /*private*/ cache : org.jbox2d.collision.Distance.SimplexCache = new org.jbox2d.collision.Distance.SimplexCache();

        /*private*/ output : org.jbox2d.collision.DistanceOutput = new org.jbox2d.collision.DistanceOutput();

        /**
         * Determine if two generic shapes overlap.
         * 
         * @param {org.jbox2d.collision.shapes.Shape} shapeA
         * @param {org.jbox2d.collision.shapes.Shape} shapeB
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.common.Transform} xfB
         * @return
         * @param {number} indexA
         * @param {number} indexB
         * @return {boolean}
         */
        public testOverlap(shapeA : org.jbox2d.collision.shapes.Shape, indexA : number, shapeB : org.jbox2d.collision.shapes.Shape, indexB : number, xfA : org.jbox2d.common.Transform, xfB : org.jbox2d.common.Transform) : boolean {
            this.input.proxyA.set(shapeA, indexA);
            this.input.proxyB.set(shapeB, indexB);
            this.input.transformA.set$org_jbox2d_common_Transform(xfA);
            this.input.transformB.set$org_jbox2d_common_Transform(xfB);
            this.input.useRadii = true;
            this.cache.count = 0;
            this.pool.getDistance().distance(this.output, this.cache, this.input);
            return this.output.distance < (<any>Math).fround(10.0 * org.jbox2d.common.Settings.EPSILON);
        }

        /**
         * Compute the point states given two manifolds. The states pertain to the transition from
         * manifold1 to manifold2. So state1 is either persist or remove while state2 is either add or
         * persist.
         * 
         * @param {Array} state1
         * @param {Array} state2
         * @param {org.jbox2d.collision.Manifold} manifold1
         * @param {org.jbox2d.collision.Manifold} manifold2
         */
        public static getPointStates(state1 : Collision.PointState[], state2 : Collision.PointState[], manifold1 : org.jbox2d.collision.Manifold, manifold2 : org.jbox2d.collision.Manifold) {
            for(let i : number = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; i++) {
                state1[i] = Collision.PointState.NULL_STATE;
                state2[i] = Collision.PointState.NULL_STATE;
            };
            for(let i : number = 0; i < manifold1.pointCount; i++) {
                let id : org.jbox2d.collision.ContactID = manifold1.points[i].id;
                state1[i] = Collision.PointState.REMOVE_STATE;
                for(let j : number = 0; j < manifold2.pointCount; j++) {
                    if(manifold2.points[j].id.isEqual(id)) {
                        state1[i] = Collision.PointState.PERSIST_STATE;
                        break;
                    }
                };
            };
            for(let i : number = 0; i < manifold2.pointCount; i++) {
                let id : org.jbox2d.collision.ContactID = manifold2.points[i].id;
                state2[i] = Collision.PointState.ADD_STATE;
                for(let j : number = 0; j < manifold1.pointCount; j++) {
                    if(manifold1.points[j].id.isEqual(id)) {
                        state2[i] = Collision.PointState.PERSIST_STATE;
                        break;
                    }
                };
            };
        }

        /**
         * Clipping for contact manifolds. Sutherland-Hodgman clipping.
         * 
         * @param {Array} vOut
         * @param {Array} vIn
         * @param {org.jbox2d.common.Vec2} normal
         * @param {number} offset
         * @return
         * @param {number} vertexIndexA
         * @return {number}
         */
        public static clipSegmentToLine(vOut : Collision.ClipVertex[], vIn : Collision.ClipVertex[], normal : org.jbox2d.common.Vec2, offset : number, vertexIndexA : number) : number {
            let numOut : number = 0;
            let vIn0 : Collision.ClipVertex = vIn[0];
            let vIn1 : Collision.ClipVertex = vIn[1];
            let vIn0v : org.jbox2d.common.Vec2 = vIn0.v;
            let vIn1v : org.jbox2d.common.Vec2 = vIn1.v;
            let distance0 : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(normal, vIn0v) - offset);
            let distance1 : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(normal, vIn1v) - offset);
            if(distance0 <= 0.0) {
                vOut[numOut++].set(vIn0);
            }
            if(distance1 <= 0.0) {
                vOut[numOut++].set(vIn1);
            }
            if((<any>Math).fround(distance0 * distance1) < 0.0) {
                let interp : number = (<any>Math).fround(distance0 / ((<any>Math).fround(distance0 - distance1)));
                let vOutNO : Collision.ClipVertex = vOut[numOut];
                vOutNO.v.x = (<any>Math).fround(vIn0v.x + (<any>Math).fround(interp * ((<any>Math).fround(vIn1v.x - vIn0v.x))));
                vOutNO.v.y = (<any>Math).fround(vIn0v.y + (<any>Math).fround(interp * ((<any>Math).fround(vIn1v.y - vIn0v.y))));
                vOutNO.id.indexA = (<number>vertexIndexA|0);
                vOutNO.id.indexB = vIn0.id.indexB;
                vOutNO.id.typeA = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.VERTEX]]|0);
                vOutNO.id.typeB = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.FACE]]|0);
                ++numOut;
            }
            return numOut;
        }

        static d : org.jbox2d.common.Vec2; public static d_$LI$() : org.jbox2d.common.Vec2 { if(Collision.d == null) Collision.d = new org.jbox2d.common.Vec2(); return Collision.d; };

        /**
         * Compute the collision manifold between two circles.
         * 
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.collision.shapes.CircleShape} circle1
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.collision.shapes.CircleShape} circle2
         * @param {org.jbox2d.common.Transform} xfB
         */
        public collideCircles(manifold : org.jbox2d.collision.Manifold, circle1 : org.jbox2d.collision.shapes.CircleShape, xfA : org.jbox2d.common.Transform, circle2 : org.jbox2d.collision.shapes.CircleShape, xfB : org.jbox2d.common.Transform) {
            manifold.pointCount = 0;
            let circle1p : org.jbox2d.common.Vec2 = circle1.m_p;
            let circle2p : org.jbox2d.common.Vec2 = circle2.m_p;
            let pAx : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfA.q.c * circle1p.x) - (<any>Math).fround(xfA.q.s * circle1p.y))) + xfA.p.x);
            let pAy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfA.q.s * circle1p.x) + (<any>Math).fround(xfA.q.c * circle1p.y))) + xfA.p.y);
            let pBx : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfB.q.c * circle2p.x) - (<any>Math).fround(xfB.q.s * circle2p.y))) + xfB.p.x);
            let pBy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfB.q.s * circle2p.x) + (<any>Math).fround(xfB.q.c * circle2p.y))) + xfB.p.y);
            let dx : number = (<any>Math).fround(pBx - pAx);
            let dy : number = (<any>Math).fround(pBy - pAy);
            let distSqr : number = (<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy));
            let radius : number = (<any>Math).fround(circle1.m_radius + circle2.m_radius);
            if(distSqr > (<any>Math).fround(radius * radius)) {
                return;
            }
            manifold.type = org.jbox2d.collision.Manifold.ManifoldType.CIRCLES;
            manifold.localPoint.set$org_jbox2d_common_Vec2(circle1p);
            manifold.localNormal.setZero();
            manifold.pointCount = 1;
            manifold.points[0].localPoint.set$org_jbox2d_common_Vec2(circle2p);
            manifold.points[0].id.zero();
        }

        /**
         * Compute the collision manifold between a polygon and a circle.
         * 
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.collision.shapes.CircleShape} circle
         * @param {org.jbox2d.common.Transform} xfB
         */
        public collidePolygonAndCircle(manifold : org.jbox2d.collision.Manifold, polygon : org.jbox2d.collision.shapes.PolygonShape, xfA : org.jbox2d.common.Transform, circle : org.jbox2d.collision.shapes.CircleShape, xfB : org.jbox2d.common.Transform) {
            manifold.pointCount = 0;
            let circlep : org.jbox2d.common.Vec2 = circle.m_p;
            let xfBq : org.jbox2d.common.Rot = xfB.q;
            let xfAq : org.jbox2d.common.Rot = xfA.q;
            let cx : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfBq.c * circlep.x) - (<any>Math).fround(xfBq.s * circlep.y))) + xfB.p.x);
            let cy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xfBq.s * circlep.x) + (<any>Math).fround(xfBq.c * circlep.y))) + xfB.p.y);
            let px : number = (<any>Math).fround(cx - xfA.p.x);
            let py : number = (<any>Math).fround(cy - xfA.p.y);
            let cLocalx : number = ((<any>Math).fround((<any>Math).fround(xfAq.c * px) + (<any>Math).fround(xfAq.s * py)));
            let cLocaly : number = ((<any>Math).fround((<any>Math).fround(-xfAq.s * px) + (<any>Math).fround(xfAq.c * py)));
            let normalIndex : number = 0;
            let separation : number = -Number.MAX_VALUE;
            let radius : number = (<any>Math).fround(polygon.m_radius + circle.m_radius);
            let vertexCount : number = polygon.m_count;
            let s : number;
            let vertices : org.jbox2d.common.Vec2[] = polygon.m_vertices;
            let normals : org.jbox2d.common.Vec2[] = polygon.m_normals;
            for(let i : number = 0; i < vertexCount; i++) {
                let vertex : org.jbox2d.common.Vec2 = vertices[i];
                let tempx : number = (<any>Math).fround(cLocalx - vertex.x);
                let tempy : number = (<any>Math).fround(cLocaly - vertex.y);
                s = (<any>Math).fround((<any>Math).fround(normals[i].x * tempx) + (<any>Math).fround(normals[i].y * tempy));
                if(s > radius) {
                    return;
                }
                if(s > separation) {
                    separation = s;
                    normalIndex = i;
                }
            };
            let vertIndex1 : number = normalIndex;
            let vertIndex2 : number = vertIndex1 + 1 < vertexCount?vertIndex1 + 1:0;
            let v1 : org.jbox2d.common.Vec2 = vertices[vertIndex1];
            let v2 : org.jbox2d.common.Vec2 = vertices[vertIndex2];
            if(separation < org.jbox2d.common.Settings.EPSILON) {
                manifold.pointCount = 1;
                manifold.type = org.jbox2d.collision.Manifold.ManifoldType.FACE_A;
                let normal : org.jbox2d.common.Vec2 = normals[normalIndex];
                manifold.localNormal.x = normal.x;
                manifold.localNormal.y = normal.y;
                manifold.localPoint.x = (<any>Math).fround(((<any>Math).fround(v1.x + v2.x)) * 0.5);
                manifold.localPoint.y = (<any>Math).fround(((<any>Math).fround(v1.y + v2.y)) * 0.5);
                let mpoint : org.jbox2d.collision.ManifoldPoint = manifold.points[0];
                mpoint.localPoint.x = circlep.x;
                mpoint.localPoint.y = circlep.y;
                mpoint.id.zero();
                return;
            }
            let tempX : number = (<any>Math).fround(cLocalx - v1.x);
            let tempY : number = (<any>Math).fround(cLocaly - v1.y);
            let temp2X : number = (<any>Math).fround(v2.x - v1.x);
            let temp2Y : number = (<any>Math).fround(v2.y - v1.y);
            let u1 : number = (<any>Math).fround((<any>Math).fround(tempX * temp2X) + (<any>Math).fround(tempY * temp2Y));
            let temp3X : number = (<any>Math).fround(cLocalx - v2.x);
            let temp3Y : number = (<any>Math).fround(cLocaly - v2.y);
            let temp4X : number = (<any>Math).fround(v1.x - v2.x);
            let temp4Y : number = (<any>Math).fround(v1.y - v2.y);
            let u2 : number = (<any>Math).fround((<any>Math).fround(temp3X * temp4X) + (<any>Math).fround(temp3Y * temp4Y));
            if(u1 <= 0.0) {
                let dx : number = (<any>Math).fround(cLocalx - v1.x);
                let dy : number = (<any>Math).fround(cLocaly - v1.y);
                if((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy)) > (<any>Math).fround(radius * radius)) {
                    return;
                }
                manifold.pointCount = 1;
                manifold.type = org.jbox2d.collision.Manifold.ManifoldType.FACE_A;
                manifold.localNormal.x = (<any>Math).fround(cLocalx - v1.x);
                manifold.localNormal.y = (<any>Math).fround(cLocaly - v1.y);
                manifold.localNormal.normalize();
                manifold.localPoint.set$org_jbox2d_common_Vec2(v1);
                manifold.points[0].localPoint.set$org_jbox2d_common_Vec2(circlep);
                manifold.points[0].id.zero();
            } else if(u2 <= 0.0) {
                let dx : number = (<any>Math).fround(cLocalx - v2.x);
                let dy : number = (<any>Math).fround(cLocaly - v2.y);
                if((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy)) > (<any>Math).fround(radius * radius)) {
                    return;
                }
                manifold.pointCount = 1;
                manifold.type = org.jbox2d.collision.Manifold.ManifoldType.FACE_A;
                manifold.localNormal.x = (<any>Math).fround(cLocalx - v2.x);
                manifold.localNormal.y = (<any>Math).fround(cLocaly - v2.y);
                manifold.localNormal.normalize();
                manifold.localPoint.set$org_jbox2d_common_Vec2(v2);
                manifold.points[0].localPoint.set$org_jbox2d_common_Vec2(circlep);
                manifold.points[0].id.zero();
            } else {
                let fcx : number = (<any>Math).fround(((<any>Math).fround(v1.x + v2.x)) * 0.5);
                let fcy : number = (<any>Math).fround(((<any>Math).fround(v1.y + v2.y)) * 0.5);
                let tx : number = (<any>Math).fround(cLocalx - fcx);
                let ty : number = (<any>Math).fround(cLocaly - fcy);
                let normal : org.jbox2d.common.Vec2 = normals[vertIndex1];
                separation = (<any>Math).fround((<any>Math).fround(tx * normal.x) + (<any>Math).fround(ty * normal.y));
                if(separation > radius) {
                    return;
                }
                manifold.pointCount = 1;
                manifold.type = org.jbox2d.collision.Manifold.ManifoldType.FACE_A;
                manifold.localNormal.set$org_jbox2d_common_Vec2(normals[vertIndex1]);
                manifold.localPoint.x = fcx;
                manifold.localPoint.y = fcy;
                manifold.points[0].localPoint.set$org_jbox2d_common_Vec2(circlep);
                manifold.points[0].id.zero();
            }
        }

        /*private*/ temp : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ xf : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /*private*/ n : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ v1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * Find the max separation between poly1 and poly2 using edge normals from poly1.
         * 
         * @param edgeIndex
         * @param {org.jbox2d.collision.shapes.PolygonShape} poly1
         * @param {org.jbox2d.common.Transform} xf1
         * @param {org.jbox2d.collision.shapes.PolygonShape} poly2
         * @param {org.jbox2d.common.Transform} xf2
         * @return
         * @param {org.jbox2d.collision.Collision.EdgeResults} results
         */
        public findMaxSeparation(results : Collision.EdgeResults, poly1 : org.jbox2d.collision.shapes.PolygonShape, xf1 : org.jbox2d.common.Transform, poly2 : org.jbox2d.collision.shapes.PolygonShape, xf2 : org.jbox2d.common.Transform) {
            let count1 : number = poly1.m_count;
            let count2 : number = poly2.m_count;
            let n1s : org.jbox2d.common.Vec2[] = poly1.m_normals;
            let v1s : org.jbox2d.common.Vec2[] = poly1.m_vertices;
            let v2s : org.jbox2d.common.Vec2[] = poly2.m_vertices;
            org.jbox2d.common.Transform.mulTransToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(xf2, xf1, this.xf);
            let xfq : org.jbox2d.common.Rot = this.xf.q;
            let bestIndex : number = 0;
            let maxSeparation : number = -Number.MAX_VALUE;
            for(let i : number = 0; i < count1; i++) {
                org.jbox2d.common.Rot.mulToOutUnsafe(xfq, n1s[i], this.n);
                org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.xf, v1s[i], this.v1);
                let si : number = Number.MAX_VALUE;
                for(let j : number = 0; j < count2; ++j) {
                    let v2sj : org.jbox2d.common.Vec2 = v2s[j];
                    let sij : number = (<any>Math).fround((<any>Math).fround(this.n.x * ((<any>Math).fround(v2sj.x - this.v1.x))) + (<any>Math).fround(this.n.y * ((<any>Math).fround(v2sj.y - this.v1.y))));
                    if(sij < si) {
                        si = sij;
                    }
                };
                if(si > maxSeparation) {
                    maxSeparation = si;
                    bestIndex = i;
                }
            };
            results.edgeIndex = bestIndex;
            results.separation = maxSeparation;
        }

        public findIncidentEdge(c : Collision.ClipVertex[], poly1 : org.jbox2d.collision.shapes.PolygonShape, xf1 : org.jbox2d.common.Transform, edge1 : number, poly2 : org.jbox2d.collision.shapes.PolygonShape, xf2 : org.jbox2d.common.Transform) {
            let count1 : number = poly1.m_count;
            let normals1 : org.jbox2d.common.Vec2[] = poly1.m_normals;
            let count2 : number = poly2.m_count;
            let vertices2 : org.jbox2d.common.Vec2[] = poly2.m_vertices;
            let normals2 : org.jbox2d.common.Vec2[] = poly2.m_normals;
            let c0 : Collision.ClipVertex = c[0];
            let c1 : Collision.ClipVertex = c[1];
            let xf1q : org.jbox2d.common.Rot = xf1.q;
            let xf2q : org.jbox2d.common.Rot = xf2.q;
            let v : org.jbox2d.common.Vec2 = normals1[edge1];
            let tempx : number = (<any>Math).fround((<any>Math).fround(xf1q.c * v.x) - (<any>Math).fround(xf1q.s * v.y));
            let tempy : number = (<any>Math).fround((<any>Math).fround(xf1q.s * v.x) + (<any>Math).fround(xf1q.c * v.y));
            let normal1x : number = (<any>Math).fround((<any>Math).fround(xf2q.c * tempx) + (<any>Math).fround(xf2q.s * tempy));
            let normal1y : number = (<any>Math).fround((<any>Math).fround(-xf2q.s * tempx) + (<any>Math).fround(xf2q.c * tempy));
            let index : number = 0;
            let minDot : number = Number.MAX_VALUE;
            for(let i : number = 0; i < count2; ++i) {
                let b : org.jbox2d.common.Vec2 = normals2[i];
                let dot : number = (<any>Math).fround((<any>Math).fround(normal1x * b.x) + (<any>Math).fround(normal1y * b.y));
                if(dot < minDot) {
                    minDot = dot;
                    index = i;
                }
            };
            let i1 : number = index;
            let i2 : number = i1 + 1 < count2?i1 + 1:0;
            let v1 : org.jbox2d.common.Vec2 = vertices2[i1];
            let out : org.jbox2d.common.Vec2 = c0.v;
            out.x = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xf2q.c * v1.x) - (<any>Math).fround(xf2q.s * v1.y))) + xf2.p.x);
            out.y = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xf2q.s * v1.x) + (<any>Math).fround(xf2q.c * v1.y))) + xf2.p.y);
            c0.id.indexA = (<number>edge1|0);
            c0.id.indexB = (<number>i1|0);
            c0.id.typeA = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.FACE]]|0);
            c0.id.typeB = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.VERTEX]]|0);
            let v2 : org.jbox2d.common.Vec2 = vertices2[i2];
            let out1 : org.jbox2d.common.Vec2 = c1.v;
            out1.x = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xf2q.c * v2.x) - (<any>Math).fround(xf2q.s * v2.y))) + xf2.p.x);
            out1.y = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(xf2q.s * v2.x) + (<any>Math).fround(xf2q.c * v2.y))) + xf2.p.y);
            c1.id.indexA = (<number>edge1|0);
            c1.id.indexB = (<number>i2|0);
            c1.id.typeA = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.FACE]]|0);
            c1.id.typeB = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.VERTEX]]|0);
        }

        /*private*/ results1 : Collision.EdgeResults = new Collision.EdgeResults();

        /*private*/ results2 : Collision.EdgeResults = new Collision.EdgeResults();

        /*private*/ incidentEdge : Collision.ClipVertex[] = [null, null];

        /*private*/ localTangent : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ localNormal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ planePoint : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ tangent : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ v11 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ v12 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ clipPoints1 : Collision.ClipVertex[] = [null, null];

        /*private*/ clipPoints2 : Collision.ClipVertex[] = [null, null];

        /**
         * Compute the collision manifold between two polygons.
         * 
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param polygon1
         * @param xf1
         * @param polygon2
         * @param xf2
         * @param {org.jbox2d.collision.shapes.PolygonShape} polyA
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.collision.shapes.PolygonShape} polyB
         * @param {org.jbox2d.common.Transform} xfB
         */
        public collidePolygons(manifold : org.jbox2d.collision.Manifold, polyA : org.jbox2d.collision.shapes.PolygonShape, xfA : org.jbox2d.common.Transform, polyB : org.jbox2d.collision.shapes.PolygonShape, xfB : org.jbox2d.common.Transform) {
            manifold.pointCount = 0;
            let totalRadius : number = (<any>Math).fround(polyA.m_radius + polyB.m_radius);
            this.findMaxSeparation(this.results1, polyA, xfA, polyB, xfB);
            if(this.results1.separation > totalRadius) {
                return;
            }
            this.findMaxSeparation(this.results2, polyB, xfB, polyA, xfA);
            if(this.results2.separation > totalRadius) {
                return;
            }
            let poly1 : org.jbox2d.collision.shapes.PolygonShape;
            let poly2 : org.jbox2d.collision.shapes.PolygonShape;
            let xf1 : org.jbox2d.common.Transform;
            let xf2 : org.jbox2d.common.Transform;
            let edge1 : number;
            let flip : boolean;
            let k_tol : number = (<any>Math).fround(0.1 * org.jbox2d.common.Settings.linearSlop);
            if(this.results2.separation > (<any>Math).fround(this.results1.separation + k_tol)) {
                poly1 = polyB;
                poly2 = polyA;
                xf1 = xfB;
                xf2 = xfA;
                edge1 = this.results2.edgeIndex;
                manifold.type = org.jbox2d.collision.Manifold.ManifoldType.FACE_B;
                flip = true;
            } else {
                poly1 = polyA;
                poly2 = polyB;
                xf1 = xfA;
                xf2 = xfB;
                edge1 = this.results1.edgeIndex;
                manifold.type = org.jbox2d.collision.Manifold.ManifoldType.FACE_A;
                flip = false;
            }
            let xf1q : org.jbox2d.common.Rot = xf1.q;
            this.findIncidentEdge(this.incidentEdge, poly1, xf1, edge1, poly2, xf2);
            let count1 : number = poly1.m_count;
            let vertices1 : org.jbox2d.common.Vec2[] = poly1.m_vertices;
            let iv1 : number = edge1;
            let iv2 : number = edge1 + 1 < count1?edge1 + 1:0;
            this.v11.set$org_jbox2d_common_Vec2(vertices1[iv1]);
            this.v12.set$org_jbox2d_common_Vec2(vertices1[iv2]);
            this.localTangent.x = (<any>Math).fround(this.v12.x - this.v11.x);
            this.localTangent.y = (<any>Math).fround(this.v12.y - this.v11.y);
            this.localTangent.normalize();
            this.localNormal.x = (<any>Math).fround(1.0 * this.localTangent.y);
            this.localNormal.y = (<any>Math).fround(-1.0 * this.localTangent.x);
            this.planePoint.x = (<any>Math).fround(((<any>Math).fround(this.v11.x + this.v12.x)) * 0.5);
            this.planePoint.y = (<any>Math).fround(((<any>Math).fround(this.v11.y + this.v12.y)) * 0.5);
            this.tangent.x = (<any>Math).fround((<any>Math).fround(xf1q.c * this.localTangent.x) - (<any>Math).fround(xf1q.s * this.localTangent.y));
            this.tangent.y = (<any>Math).fround((<any>Math).fround(xf1q.s * this.localTangent.x) + (<any>Math).fround(xf1q.c * this.localTangent.y));
            let normalx : number = (<any>Math).fround(1.0 * this.tangent.y);
            let normaly : number = (<any>Math).fround(-1.0 * this.tangent.x);
            org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1, this.v11, this.v11);
            org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1, this.v12, this.v12);
            let frontOffset : number = (<any>Math).fround((<any>Math).fround(normalx * this.v11.x) + (<any>Math).fround(normaly * this.v11.y));
            let sideOffset1 : number = (<any>Math).fround(-((<any>Math).fround((<any>Math).fround(this.tangent.x * this.v11.x) + (<any>Math).fround(this.tangent.y * this.v11.y))) + totalRadius);
            let sideOffset2 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.tangent.x * this.v12.x) + (<any>Math).fround(this.tangent.y * this.v12.y)) + totalRadius);
            let np : number;
            this.tangent.negateLocal();
            np = Collision.clipSegmentToLine(this.clipPoints1, this.incidentEdge, this.tangent, sideOffset1, iv1);
            this.tangent.negateLocal();
            if(np < 2) {
                return;
            }
            np = Collision.clipSegmentToLine(this.clipPoints2, this.clipPoints1, this.tangent, sideOffset2, iv2);
            if(np < 2) {
                return;
            }
            manifold.localNormal.set$org_jbox2d_common_Vec2(this.localNormal);
            manifold.localPoint.set$org_jbox2d_common_Vec2(this.planePoint);
            let pointCount : number = 0;
            for(let i : number = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; ++i) {
                let separation : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(normalx * this.clipPoints2[i].v.x) + (<any>Math).fround(normaly * this.clipPoints2[i].v.y)) - frontOffset);
                if(separation <= totalRadius) {
                    let cp : org.jbox2d.collision.ManifoldPoint = manifold.points[pointCount];
                    let out : org.jbox2d.common.Vec2 = cp.localPoint;
                    let px : number = (<any>Math).fround(this.clipPoints2[i].v.x - xf2.p.x);
                    let py : number = (<any>Math).fround(this.clipPoints2[i].v.y - xf2.p.y);
                    out.x = ((<any>Math).fround((<any>Math).fround(xf2.q.c * px) + (<any>Math).fround(xf2.q.s * py)));
                    out.y = ((<any>Math).fround((<any>Math).fround(-xf2.q.s * px) + (<any>Math).fround(xf2.q.c * py)));
                    cp.id.set(this.clipPoints2[i].id);
                    if(flip) {
                        cp.id.flip();
                    }
                    ++pointCount;
                }
            };
            manifold.pointCount = pointCount;
        }

        /*private*/ Q : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ e : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ cf : org.jbox2d.collision.ContactID = new org.jbox2d.collision.ContactID();

        /*private*/ e1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ P : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public collideEdgeAndCircle(manifold : org.jbox2d.collision.Manifold, edgeA : org.jbox2d.collision.shapes.EdgeShape, xfA : org.jbox2d.common.Transform, circleB : org.jbox2d.collision.shapes.CircleShape, xfB : org.jbox2d.common.Transform) {
            manifold.pointCount = 0;
            org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xfB, circleB.m_p, this.temp);
            org.jbox2d.common.Transform.mulTransToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xfA, this.temp, this.Q);
            let A : org.jbox2d.common.Vec2 = edgeA.m_vertex1;
            let B : org.jbox2d.common.Vec2 = edgeA.m_vertex2;
            this.e.set$org_jbox2d_common_Vec2(B).subLocal(A);
            let u : number = org.jbox2d.common.Vec2.dot(this.e, this.temp.set$org_jbox2d_common_Vec2(B).subLocal(this.Q));
            let v : number = org.jbox2d.common.Vec2.dot(this.e, this.temp.set$org_jbox2d_common_Vec2(this.Q).subLocal(A));
            let radius : number = (<any>Math).fround(edgeA.m_radius + circleB.m_radius);
            this.cf.indexB = 0;
            this.cf.typeB = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.VERTEX]]|0);
            if(v <= 0.0) {
                let P : org.jbox2d.common.Vec2 = A;
                Collision.d_$LI$().set$org_jbox2d_common_Vec2(this.Q).subLocal(P);
                let dd : number = org.jbox2d.common.Vec2.dot(Collision.d_$LI$(), Collision.d_$LI$());
                if(dd > (<any>Math).fround(radius * radius)) {
                    return;
                }
                if(edgeA.m_hasVertex0) {
                    let A1 : org.jbox2d.common.Vec2 = edgeA.m_vertex0;
                    let B1 : org.jbox2d.common.Vec2 = A;
                    this.e1.set$org_jbox2d_common_Vec2(B1).subLocal(A1);
                    let u1 : number = org.jbox2d.common.Vec2.dot(this.e1, this.temp.set$org_jbox2d_common_Vec2(B1).subLocal(this.Q));
                    if(u1 > 0.0) {
                        return;
                    }
                }
                this.cf.indexA = 0;
                this.cf.typeA = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.VERTEX]]|0);
                manifold.pointCount = 1;
                manifold.type = org.jbox2d.collision.Manifold.ManifoldType.CIRCLES;
                manifold.localNormal.setZero();
                manifold.localPoint.set$org_jbox2d_common_Vec2(P);
                manifold.points[0].id.set(this.cf);
                manifold.points[0].localPoint.set$org_jbox2d_common_Vec2(circleB.m_p);
                return;
            }
            if(u <= 0.0) {
                let P : org.jbox2d.common.Vec2 = B;
                Collision.d_$LI$().set$org_jbox2d_common_Vec2(this.Q).subLocal(P);
                let dd : number = org.jbox2d.common.Vec2.dot(Collision.d_$LI$(), Collision.d_$LI$());
                if(dd > (<any>Math).fround(radius * radius)) {
                    return;
                }
                if(edgeA.m_hasVertex3) {
                    let B2 : org.jbox2d.common.Vec2 = edgeA.m_vertex3;
                    let A2 : org.jbox2d.common.Vec2 = B;
                    let e2 : org.jbox2d.common.Vec2 = this.e1;
                    e2.set$org_jbox2d_common_Vec2(B2).subLocal(A2);
                    let v2 : number = org.jbox2d.common.Vec2.dot(e2, this.temp.set$org_jbox2d_common_Vec2(this.Q).subLocal(A2));
                    if(v2 > 0.0) {
                        return;
                    }
                }
                this.cf.indexA = 1;
                this.cf.typeA = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.VERTEX]]|0);
                manifold.pointCount = 1;
                manifold.type = org.jbox2d.collision.Manifold.ManifoldType.CIRCLES;
                manifold.localNormal.setZero();
                manifold.localPoint.set$org_jbox2d_common_Vec2(P);
                manifold.points[0].id.set(this.cf);
                manifold.points[0].localPoint.set$org_jbox2d_common_Vec2(circleB.m_p);
                return;
            }
            let den : number = org.jbox2d.common.Vec2.dot(this.e, this.e);
            this.P.set$org_jbox2d_common_Vec2(A).mulLocal(u).addLocal$org_jbox2d_common_Vec2(this.temp.set$org_jbox2d_common_Vec2(B).mulLocal(v));
            this.P.mulLocal((<any>Math).fround(1.0 / den));
            Collision.d_$LI$().set$org_jbox2d_common_Vec2(this.Q).subLocal(this.P);
            let dd : number = org.jbox2d.common.Vec2.dot(Collision.d_$LI$(), Collision.d_$LI$());
            if(dd > (<any>Math).fround(radius * radius)) {
                return;
            }
            this.n.x = -this.e.y;
            this.n.y = this.e.x;
            if(org.jbox2d.common.Vec2.dot(this.n, this.temp.set$org_jbox2d_common_Vec2(this.Q).subLocal(A)) < 0.0) {
                this.n.set$float$float(-this.n.x, -this.n.y);
            }
            this.n.normalize();
            this.cf.indexA = 0;
            this.cf.typeA = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.FACE]]|0);
            manifold.pointCount = 1;
            manifold.type = org.jbox2d.collision.Manifold.ManifoldType.FACE_A;
            manifold.localNormal.set$org_jbox2d_common_Vec2(this.n);
            manifold.localPoint.set$org_jbox2d_common_Vec2(A);
            manifold.points[0].id.set(this.cf);
            manifold.points[0].localPoint.set$org_jbox2d_common_Vec2(circleB.m_p);
        }

        /*private*/ collider : Collision.EPCollider = new Collision.EPCollider();

        public collideEdgeAndPolygon(manifold : org.jbox2d.collision.Manifold, edgeA : org.jbox2d.collision.shapes.EdgeShape, xfA : org.jbox2d.common.Transform, polygonB : org.jbox2d.collision.shapes.PolygonShape, xfB : org.jbox2d.common.Transform) {
            this.collider.collide(manifold, edgeA, xfA, polygonB, xfB);
        }
    }
    Collision["__class"] = "org.jbox2d.collision.Collision";


    export namespace Collision {

        /**
         * Java-specific class for returning edge results
         * @class
         */
        export class EdgeResults {
            public separation : number;

            public edgeIndex : number;

            constructor() {
                if(this.separation===undefined) this.separation = 0;
                if(this.edgeIndex===undefined) this.edgeIndex = 0;
            }
        }
        EdgeResults["__class"] = "org.jbox2d.collision.Collision.EdgeResults";


        /**
         * Used for computing contact manifolds.
         * @class
         */
        export class ClipVertex {
            public v : org.jbox2d.common.Vec2;

            public id : org.jbox2d.collision.ContactID;

            public constructor() {
                if(this.v===undefined) this.v = null;
                if(this.id===undefined) this.id = null;
                this.v = new org.jbox2d.common.Vec2();
                this.id = new org.jbox2d.collision.ContactID();
            }

            public set(cv : Collision.ClipVertex) {
                let v1 : org.jbox2d.common.Vec2 = cv.v;
                this.v.x = v1.x;
                this.v.y = v1.y;
                let c : org.jbox2d.collision.ContactID = cv.id;
                this.id.indexA = c.indexA;
                this.id.indexB = c.indexB;
                this.id.typeA = c.typeA;
                this.id.typeB = c.typeB;
            }
        }
        ClipVertex["__class"] = "org.jbox2d.collision.Collision.ClipVertex";


        /**
         * This is used for determining the state of contact points.
         * 
         * @author Daniel Murphy
         * @enum
         * @property {org.jbox2d.collision.Collision.PointState} NULL_STATE
         * point does not exist
         * @property {org.jbox2d.collision.Collision.PointState} ADD_STATE
         * point was added in the update
         * @property {org.jbox2d.collision.Collision.PointState} PERSIST_STATE
         * point persisted across the update
         * @property {org.jbox2d.collision.Collision.PointState} REMOVE_STATE
         * point was removed in the update
         * @class
         */
        export enum PointState {
            
            /**
             * point does not exist
             */
            NULL_STATE, 
            /**
             * point was added in the update
             */
            ADD_STATE, 
            /**
             * point persisted across the update
             */
            PERSIST_STATE, 
            /**
             * point was removed in the update
             */
            REMOVE_STATE
        }

        /**
         * This structure is used to keep track of the best separating axis.
         * @class
         */
        export class EPAxis {
            type : EPAxis.Type;

            index : number;

            separation : number;

            constructor() {
                if(this.type===undefined) this.type = null;
                if(this.index===undefined) this.index = 0;
                if(this.separation===undefined) this.separation = 0;
            }
        }
        EPAxis["__class"] = "org.jbox2d.collision.Collision.EPAxis";


        export namespace EPAxis {

            export enum Type {
                UNKNOWN, EDGE_A, EDGE_B
            }
        }


        /**
         * This holds polygon B expressed in frame A.
         * @class
         */
        export class TempPolygon {
            vertices : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxPolygonVertices);

            normals : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxPolygonVertices);

            count : number;

            public constructor() {
                if(this.count===undefined) this.count = 0;
                for(let i : number = 0; i < this.vertices.length; i++) {
                    this.vertices[i] = new org.jbox2d.common.Vec2();
                    this.normals[i] = new org.jbox2d.common.Vec2();
                };
            }
        }
        TempPolygon["__class"] = "org.jbox2d.collision.Collision.TempPolygon";


        /**
         * Reference face used for clipping
         * @class
         */
        export class ReferenceFace {
            i1 : number;

            i2 : number;

            v1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            v2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            sideNormal1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            sideOffset1 : number;

            sideNormal2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            sideOffset2 : number;

            constructor() {
                if(this.i1===undefined) this.i1 = 0;
                if(this.i2===undefined) this.i2 = 0;
                if(this.sideOffset1===undefined) this.sideOffset1 = 0;
                if(this.sideOffset2===undefined) this.sideOffset2 = 0;
            }
        }
        ReferenceFace["__class"] = "org.jbox2d.collision.Collision.ReferenceFace";


        /**
         * This class collides and edge and a polygon, taking into account edge adjacency.
         * @class
         */
        export class EPCollider {
            m_polygonB : Collision.TempPolygon = new Collision.TempPolygon();

            m_xf : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

            m_centroidB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_v0 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_v1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_v2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_v3 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_normal0 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_normal1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_normal2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_type1 : EPCollider.VertexType;

            m_type2 : EPCollider.VertexType;

            m_lowerLimit : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_upperLimit : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            m_radius : number;

            m_front : boolean;

            public constructor() {
                if(this.m_type1===undefined) this.m_type1 = null;
                if(this.m_type2===undefined) this.m_type2 = null;
                if(this.m_radius===undefined) this.m_radius = 0;
                if(this.m_front===undefined) this.m_front = false;
                for(let i : number = 0; i < 2; i++) {
                    this.ie[i] = new Collision.ClipVertex();
                    this.clipPoints1[i] = new Collision.ClipVertex();
                    this.clipPoints2[i] = new Collision.ClipVertex();
                };
            }

            edge1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            temp : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            edge0 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            edge2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            ie : Collision.ClipVertex[] = [null, null];

            clipPoints1 : Collision.ClipVertex[] = [null, null];

            clipPoints2 : Collision.ClipVertex[] = [null, null];

            rf : Collision.ReferenceFace = new Collision.ReferenceFace();

            edgeAxis : Collision.EPAxis = new Collision.EPAxis();

            polygonAxis : Collision.EPAxis = new Collision.EPAxis();

            public collide(manifold : org.jbox2d.collision.Manifold, edgeA : org.jbox2d.collision.shapes.EdgeShape, xfA : org.jbox2d.common.Transform, polygonB : org.jbox2d.collision.shapes.PolygonShape, xfB : org.jbox2d.common.Transform) {
                org.jbox2d.common.Transform.mulTransToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(xfA, xfB, this.m_xf);
                org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf, polygonB.m_centroid, this.m_centroidB);
                this.m_v0 = edgeA.m_vertex0;
                this.m_v1 = edgeA.m_vertex1;
                this.m_v2 = edgeA.m_vertex2;
                this.m_v3 = edgeA.m_vertex3;
                let hasVertex0 : boolean = edgeA.m_hasVertex0;
                let hasVertex3 : boolean = edgeA.m_hasVertex3;
                this.edge1.set$org_jbox2d_common_Vec2(this.m_v2).subLocal(this.m_v1);
                this.edge1.normalize();
                this.m_normal1.set$float$float(this.edge1.y, -this.edge1.x);
                let offset1 : number = org.jbox2d.common.Vec2.dot(this.m_normal1, this.temp.set$org_jbox2d_common_Vec2(this.m_centroidB).subLocal(this.m_v1));
                let offset0 : number = 0.0;
                let offset2 : number = 0.0;
                let convex1 : boolean = false;
                let convex2 : boolean = false;
                if(hasVertex0) {
                    this.edge0.set$org_jbox2d_common_Vec2(this.m_v1).subLocal(this.m_v0);
                    this.edge0.normalize();
                    this.m_normal0.set$float$float(this.edge0.y, -this.edge0.x);
                    convex1 = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.edge0, this.edge1) >= 0.0;
                    offset0 = org.jbox2d.common.Vec2.dot(this.m_normal0, this.temp.set$org_jbox2d_common_Vec2(this.m_centroidB).subLocal(this.m_v0));
                }
                if(hasVertex3) {
                    this.edge2.set$org_jbox2d_common_Vec2(this.m_v3).subLocal(this.m_v2);
                    this.edge2.normalize();
                    this.m_normal2.set$float$float(this.edge2.y, -this.edge2.x);
                    convex2 = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.edge1, this.edge2) > 0.0;
                    offset2 = org.jbox2d.common.Vec2.dot(this.m_normal2, this.temp.set$org_jbox2d_common_Vec2(this.m_centroidB).subLocal(this.m_v2));
                }
                if(hasVertex0 && hasVertex3) {
                    if(convex1 && convex2) {
                        this.m_front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;
                        if(this.m_front) {
                            this.m_normal.x = this.m_normal1.x;
                            this.m_normal.y = this.m_normal1.y;
                            this.m_lowerLimit.x = this.m_normal0.x;
                            this.m_lowerLimit.y = this.m_normal0.y;
                            this.m_upperLimit.x = this.m_normal2.x;
                            this.m_upperLimit.y = this.m_normal2.y;
                        } else {
                            this.m_normal.x = -this.m_normal1.x;
                            this.m_normal.y = -this.m_normal1.y;
                            this.m_lowerLimit.x = -this.m_normal1.x;
                            this.m_lowerLimit.y = -this.m_normal1.y;
                            this.m_upperLimit.x = -this.m_normal1.x;
                            this.m_upperLimit.y = -this.m_normal1.y;
                        }
                    } else if(convex1) {
                        this.m_front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);
                        if(this.m_front) {
                            this.m_normal.x = this.m_normal1.x;
                            this.m_normal.y = this.m_normal1.y;
                            this.m_lowerLimit.x = this.m_normal0.x;
                            this.m_lowerLimit.y = this.m_normal0.y;
                            this.m_upperLimit.x = this.m_normal1.x;
                            this.m_upperLimit.y = this.m_normal1.y;
                        } else {
                            this.m_normal.x = -this.m_normal1.x;
                            this.m_normal.y = -this.m_normal1.y;
                            this.m_lowerLimit.x = -this.m_normal2.x;
                            this.m_lowerLimit.y = -this.m_normal2.y;
                            this.m_upperLimit.x = -this.m_normal1.x;
                            this.m_upperLimit.y = -this.m_normal1.y;
                        }
                    } else if(convex2) {
                        this.m_front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);
                        if(this.m_front) {
                            this.m_normal.x = this.m_normal1.x;
                            this.m_normal.y = this.m_normal1.y;
                            this.m_lowerLimit.x = this.m_normal1.x;
                            this.m_lowerLimit.y = this.m_normal1.y;
                            this.m_upperLimit.x = this.m_normal2.x;
                            this.m_upperLimit.y = this.m_normal2.y;
                        } else {
                            this.m_normal.x = -this.m_normal1.x;
                            this.m_normal.y = -this.m_normal1.y;
                            this.m_lowerLimit.x = -this.m_normal1.x;
                            this.m_lowerLimit.y = -this.m_normal1.y;
                            this.m_upperLimit.x = -this.m_normal0.x;
                            this.m_upperLimit.y = -this.m_normal0.y;
                        }
                    } else {
                        this.m_front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;
                        if(this.m_front) {
                            this.m_normal.x = this.m_normal1.x;
                            this.m_normal.y = this.m_normal1.y;
                            this.m_lowerLimit.x = this.m_normal1.x;
                            this.m_lowerLimit.y = this.m_normal1.y;
                            this.m_upperLimit.x = this.m_normal1.x;
                            this.m_upperLimit.y = this.m_normal1.y;
                        } else {
                            this.m_normal.x = -this.m_normal1.x;
                            this.m_normal.y = -this.m_normal1.y;
                            this.m_lowerLimit.x = -this.m_normal2.x;
                            this.m_lowerLimit.y = -this.m_normal2.y;
                            this.m_upperLimit.x = -this.m_normal0.x;
                            this.m_upperLimit.y = -this.m_normal0.y;
                        }
                    }
                } else if(hasVertex0) {
                    if(convex1) {
                        this.m_front = offset0 >= 0.0 || offset1 >= 0.0;
                        if(this.m_front) {
                            this.m_normal.x = this.m_normal1.x;
                            this.m_normal.y = this.m_normal1.y;
                            this.m_lowerLimit.x = this.m_normal0.x;
                            this.m_lowerLimit.y = this.m_normal0.y;
                            this.m_upperLimit.x = -this.m_normal1.x;
                            this.m_upperLimit.y = -this.m_normal1.y;
                        } else {
                            this.m_normal.x = -this.m_normal1.x;
                            this.m_normal.y = -this.m_normal1.y;
                            this.m_lowerLimit.x = this.m_normal1.x;
                            this.m_lowerLimit.y = this.m_normal1.y;
                            this.m_upperLimit.x = -this.m_normal1.x;
                            this.m_upperLimit.y = -this.m_normal1.y;
                        }
                    } else {
                        this.m_front = offset0 >= 0.0 && offset1 >= 0.0;
                        if(this.m_front) {
                            this.m_normal.x = this.m_normal1.x;
                            this.m_normal.y = this.m_normal1.y;
                            this.m_lowerLimit.x = this.m_normal1.x;
                            this.m_lowerLimit.y = this.m_normal1.y;
                            this.m_upperLimit.x = -this.m_normal1.x;
                            this.m_upperLimit.y = -this.m_normal1.y;
                        } else {
                            this.m_normal.x = -this.m_normal1.x;
                            this.m_normal.y = -this.m_normal1.y;
                            this.m_lowerLimit.x = this.m_normal1.x;
                            this.m_lowerLimit.y = this.m_normal1.y;
                            this.m_upperLimit.x = -this.m_normal0.x;
                            this.m_upperLimit.y = -this.m_normal0.y;
                        }
                    }
                } else if(hasVertex3) {
                    if(convex2) {
                        this.m_front = offset1 >= 0.0 || offset2 >= 0.0;
                        if(this.m_front) {
                            this.m_normal.x = this.m_normal1.x;
                            this.m_normal.y = this.m_normal1.y;
                            this.m_lowerLimit.x = -this.m_normal1.x;
                            this.m_lowerLimit.y = -this.m_normal1.y;
                            this.m_upperLimit.x = this.m_normal2.x;
                            this.m_upperLimit.y = this.m_normal2.y;
                        } else {
                            this.m_normal.x = -this.m_normal1.x;
                            this.m_normal.y = -this.m_normal1.y;
                            this.m_lowerLimit.x = -this.m_normal1.x;
                            this.m_lowerLimit.y = -this.m_normal1.y;
                            this.m_upperLimit.x = this.m_normal1.x;
                            this.m_upperLimit.y = this.m_normal1.y;
                        }
                    } else {
                        this.m_front = offset1 >= 0.0 && offset2 >= 0.0;
                        if(this.m_front) {
                            this.m_normal.x = this.m_normal1.x;
                            this.m_normal.y = this.m_normal1.y;
                            this.m_lowerLimit.x = -this.m_normal1.x;
                            this.m_lowerLimit.y = -this.m_normal1.y;
                            this.m_upperLimit.x = this.m_normal1.x;
                            this.m_upperLimit.y = this.m_normal1.y;
                        } else {
                            this.m_normal.x = -this.m_normal1.x;
                            this.m_normal.y = -this.m_normal1.y;
                            this.m_lowerLimit.x = -this.m_normal2.x;
                            this.m_lowerLimit.y = -this.m_normal2.y;
                            this.m_upperLimit.x = this.m_normal1.x;
                            this.m_upperLimit.y = this.m_normal1.y;
                        }
                    }
                } else {
                    this.m_front = offset1 >= 0.0;
                    if(this.m_front) {
                        this.m_normal.x = this.m_normal1.x;
                        this.m_normal.y = this.m_normal1.y;
                        this.m_lowerLimit.x = -this.m_normal1.x;
                        this.m_lowerLimit.y = -this.m_normal1.y;
                        this.m_upperLimit.x = -this.m_normal1.x;
                        this.m_upperLimit.y = -this.m_normal1.y;
                    } else {
                        this.m_normal.x = -this.m_normal1.x;
                        this.m_normal.y = -this.m_normal1.y;
                        this.m_lowerLimit.x = this.m_normal1.x;
                        this.m_lowerLimit.y = this.m_normal1.y;
                        this.m_upperLimit.x = this.m_normal1.x;
                        this.m_upperLimit.y = this.m_normal1.y;
                    }
                }
                this.m_polygonB.count = polygonB.m_count;
                for(let i : number = 0; i < polygonB.m_count; ++i) {
                    org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf, polygonB.m_vertices[i], this.m_polygonB.vertices[i]);
                    org.jbox2d.common.Rot.mulToOutUnsafe(this.m_xf.q, polygonB.m_normals[i], this.m_polygonB.normals[i]);
                };
                this.m_radius = (<any>Math).fround(2.0 * org.jbox2d.common.Settings.polygonRadius_$LI$());
                manifold.pointCount = 0;
                this.computeEdgeSeparation(this.edgeAxis);
                if(this.edgeAxis.type === Collision.EPAxis.Type.UNKNOWN) {
                    return;
                }
                if(this.edgeAxis.separation > this.m_radius) {
                    return;
                }
                this.computePolygonSeparation(this.polygonAxis);
                if(this.polygonAxis.type !== Collision.EPAxis.Type.UNKNOWN && this.polygonAxis.separation > this.m_radius) {
                    return;
                }
                let k_relativeTol : number = 0.98;
                let k_absoluteTol : number = 0.001;
                let primaryAxis : Collision.EPAxis;
                if(this.polygonAxis.type === Collision.EPAxis.Type.UNKNOWN) {
                    primaryAxis = this.edgeAxis;
                } else if(this.polygonAxis.separation > (<any>Math).fround((<any>Math).fround(k_relativeTol * this.edgeAxis.separation) + k_absoluteTol)) {
                    primaryAxis = this.polygonAxis;
                } else {
                    primaryAxis = this.edgeAxis;
                }
                let ie0 : Collision.ClipVertex = this.ie[0];
                let ie1 : Collision.ClipVertex = this.ie[1];
                if(primaryAxis.type === Collision.EPAxis.Type.EDGE_A) {
                    manifold.type = org.jbox2d.collision.Manifold.ManifoldType.FACE_A;
                    let bestIndex : number = 0;
                    let bestValue : number = org.jbox2d.common.Vec2.dot(this.m_normal, this.m_polygonB.normals[0]);
                    for(let i : number = 1; i < this.m_polygonB.count; ++i) {
                        let value : number = org.jbox2d.common.Vec2.dot(this.m_normal, this.m_polygonB.normals[i]);
                        if(value < bestValue) {
                            bestValue = value;
                            bestIndex = i;
                        }
                    };
                    let i1 : number = bestIndex;
                    let i2 : number = i1 + 1 < this.m_polygonB.count?i1 + 1:0;
                    ie0.v.set$org_jbox2d_common_Vec2(this.m_polygonB.vertices[i1]);
                    ie0.id.indexA = 0;
                    ie0.id.indexB = (<number>i1|0);
                    ie0.id.typeA = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.FACE]]|0);
                    ie0.id.typeB = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.VERTEX]]|0);
                    ie1.v.set$org_jbox2d_common_Vec2(this.m_polygonB.vertices[i2]);
                    ie1.id.indexA = 0;
                    ie1.id.indexB = (<number>i2|0);
                    ie1.id.typeA = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.FACE]]|0);
                    ie1.id.typeB = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.VERTEX]]|0);
                    if(this.m_front) {
                        this.rf.i1 = 0;
                        this.rf.i2 = 1;
                        this.rf.v1.set$org_jbox2d_common_Vec2(this.m_v1);
                        this.rf.v2.set$org_jbox2d_common_Vec2(this.m_v2);
                        this.rf.normal.set$org_jbox2d_common_Vec2(this.m_normal1);
                    } else {
                        this.rf.i1 = 1;
                        this.rf.i2 = 0;
                        this.rf.v1.set$org_jbox2d_common_Vec2(this.m_v2);
                        this.rf.v2.set$org_jbox2d_common_Vec2(this.m_v1);
                        this.rf.normal.set$org_jbox2d_common_Vec2(this.m_normal1).negateLocal();
                    }
                } else {
                    manifold.type = org.jbox2d.collision.Manifold.ManifoldType.FACE_B;
                    ie0.v.set$org_jbox2d_common_Vec2(this.m_v1);
                    ie0.id.indexA = 0;
                    ie0.id.indexB = (<number>primaryAxis.index|0);
                    ie0.id.typeA = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.VERTEX]]|0);
                    ie0.id.typeB = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.FACE]]|0);
                    ie1.v.set$org_jbox2d_common_Vec2(this.m_v2);
                    ie1.id.indexA = 0;
                    ie1.id.indexB = (<number>primaryAxis.index|0);
                    ie1.id.typeA = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.VERTEX]]|0);
                    ie1.id.typeB = (<number>/* Enum.ordinal */org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type[org.jbox2d.collision.ContactID.Type.FACE]]|0);
                    this.rf.i1 = primaryAxis.index;
                    this.rf.i2 = this.rf.i1 + 1 < this.m_polygonB.count?this.rf.i1 + 1:0;
                    this.rf.v1.set$org_jbox2d_common_Vec2(this.m_polygonB.vertices[this.rf.i1]);
                    this.rf.v2.set$org_jbox2d_common_Vec2(this.m_polygonB.vertices[this.rf.i2]);
                    this.rf.normal.set$org_jbox2d_common_Vec2(this.m_polygonB.normals[this.rf.i1]);
                }
                this.rf.sideNormal1.set$float$float(this.rf.normal.y, -this.rf.normal.x);
                this.rf.sideNormal2.set$org_jbox2d_common_Vec2(this.rf.sideNormal1).negateLocal();
                this.rf.sideOffset1 = org.jbox2d.common.Vec2.dot(this.rf.sideNormal1, this.rf.v1);
                this.rf.sideOffset2 = org.jbox2d.common.Vec2.dot(this.rf.sideNormal2, this.rf.v2);
                let np : number;
                np = Collision.clipSegmentToLine(this.clipPoints1, this.ie, this.rf.sideNormal1, this.rf.sideOffset1, this.rf.i1);
                if(np < org.jbox2d.common.Settings.maxManifoldPoints) {
                    return;
                }
                np = Collision.clipSegmentToLine(this.clipPoints2, this.clipPoints1, this.rf.sideNormal2, this.rf.sideOffset2, this.rf.i2);
                if(np < org.jbox2d.common.Settings.maxManifoldPoints) {
                    return;
                }
                if(primaryAxis.type === Collision.EPAxis.Type.EDGE_A) {
                    manifold.localNormal.set$org_jbox2d_common_Vec2(this.rf.normal);
                    manifold.localPoint.set$org_jbox2d_common_Vec2(this.rf.v1);
                } else {
                    manifold.localNormal.set$org_jbox2d_common_Vec2(polygonB.m_normals[this.rf.i1]);
                    manifold.localPoint.set$org_jbox2d_common_Vec2(polygonB.m_vertices[this.rf.i1]);
                }
                let pointCount : number = 0;
                for(let i : number = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; ++i) {
                    let separation : number;
                    separation = org.jbox2d.common.Vec2.dot(this.rf.normal, this.temp.set$org_jbox2d_common_Vec2(this.clipPoints2[i].v).subLocal(this.rf.v1));
                    if(separation <= this.m_radius) {
                        let cp : org.jbox2d.collision.ManifoldPoint = manifold.points[pointCount];
                        if(primaryAxis.type === Collision.EPAxis.Type.EDGE_A) {
                            org.jbox2d.common.Transform.mulTransToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf, this.clipPoints2[i].v, cp.localPoint);
                            cp.id.set(this.clipPoints2[i].id);
                        } else {
                            cp.localPoint.set$org_jbox2d_common_Vec2(this.clipPoints2[i].v);
                            cp.id.typeA = this.clipPoints2[i].id.typeB;
                            cp.id.typeB = this.clipPoints2[i].id.typeA;
                            cp.id.indexA = this.clipPoints2[i].id.indexB;
                            cp.id.indexB = this.clipPoints2[i].id.indexA;
                        }
                        ++pointCount;
                    }
                };
                manifold.pointCount = pointCount;
            }

            public computeEdgeSeparation(axis : Collision.EPAxis) {
                axis.type = Collision.EPAxis.Type.EDGE_A;
                axis.index = this.m_front?0:1;
                axis.separation = Number.MAX_VALUE;
                let nx : number = this.m_normal.x;
                let ny : number = this.m_normal.y;
                for(let i : number = 0; i < this.m_polygonB.count; ++i) {
                    let v : org.jbox2d.common.Vec2 = this.m_polygonB.vertices[i];
                    let tempx : number = (<any>Math).fround(v.x - this.m_v1.x);
                    let tempy : number = (<any>Math).fround(v.y - this.m_v1.y);
                    let s : number = (<any>Math).fround((<any>Math).fround(nx * tempx) + (<any>Math).fround(ny * tempy));
                    if(s < axis.separation) {
                        axis.separation = s;
                    }
                };
            }

            perp : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            n : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            public computePolygonSeparation(axis : Collision.EPAxis) {
                axis.type = Collision.EPAxis.Type.UNKNOWN;
                axis.index = -1;
                axis.separation = -Number.MAX_VALUE;
                this.perp.x = -this.m_normal.y;
                this.perp.y = this.m_normal.x;
                for(let i : number = 0; i < this.m_polygonB.count; ++i) {
                    let normalB : org.jbox2d.common.Vec2 = this.m_polygonB.normals[i];
                    let vB : org.jbox2d.common.Vec2 = this.m_polygonB.vertices[i];
                    this.n.x = -normalB.x;
                    this.n.y = -normalB.y;
                    let tempx : number = (<any>Math).fround(vB.x - this.m_v1.x);
                    let tempy : number = (<any>Math).fround(vB.y - this.m_v1.y);
                    let s1 : number = (<any>Math).fround((<any>Math).fround(this.n.x * tempx) + (<any>Math).fround(this.n.y * tempy));
                    tempx = (<any>Math).fround(vB.x - this.m_v2.x);
                    tempy = (<any>Math).fround(vB.y - this.m_v2.y);
                    let s2 : number = (<any>Math).fround((<any>Math).fround(this.n.x * tempx) + (<any>Math).fround(this.n.y * tempy));
                    let s : number = org.jbox2d.common.MathUtils.min$float$float(s1, s2);
                    if(s > this.m_radius) {
                        axis.type = Collision.EPAxis.Type.EDGE_B;
                        axis.index = i;
                        axis.separation = s;
                        return;
                    }
                    if((<any>Math).fround((<any>Math).fround(this.n.x * this.perp.x) + (<any>Math).fround(this.n.y * this.perp.y)) >= 0.0) {
                        if(org.jbox2d.common.Vec2.dot(this.temp.set$org_jbox2d_common_Vec2(this.n).subLocal(this.m_upperLimit), this.m_normal) < -org.jbox2d.common.Settings.angularSlop_$LI$()) {
                            continue;
                        }
                    } else {
                        if(org.jbox2d.common.Vec2.dot(this.temp.set$org_jbox2d_common_Vec2(this.n).subLocal(this.m_lowerLimit), this.m_normal) < -org.jbox2d.common.Settings.angularSlop_$LI$()) {
                            continue;
                        }
                    }
                    if(s > axis.separation) {
                        axis.type = Collision.EPAxis.Type.EDGE_B;
                        axis.index = i;
                        axis.separation = s;
                    }
                };
            }
        }
        EPCollider["__class"] = "org.jbox2d.collision.Collision.EPCollider";


        export namespace EPCollider {

            export enum VertexType {
                ISOLATED, CONCAVE, CONVEX
            }
        }

    }

}
namespace org.jbox2d.common {
    /**
     * Initialize using a position vector and a rotation matrix.
     * @param {org.jbox2d.common.Vec2} _position
     * @param {org.jbox2d.common.Rot} _R
     * @class
     */
    export class Transform {
        static serialVersionUID : number = 1;

        /**
         * The translation caused by the transform
         */
        public p : org.jbox2d.common.Vec2;

        /**
         * A matrix representing a rotation
         */
        public q : org.jbox2d.common.Rot;

        public constructor(_position? : any, _R? : any) {
            if(((_position != null && _position instanceof <any>org.jbox2d.common.Vec2) || _position === null) && ((_R != null && _R instanceof <any>org.jbox2d.common.Rot) || _R === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.p===undefined) this.p = null;
                if(this.q===undefined) this.q = null;
                if(this.p===undefined) this.p = null;
                if(this.q===undefined) this.q = null;
                (() => {
                    this.p = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_position);
                    this.q = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_R);
                })();
            } else if(((_position != null && _position instanceof <any>org.jbox2d.common.Transform) || _position === null) && _R === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let xf : any = __args[0];
                if(this.p===undefined) this.p = null;
                if(this.q===undefined) this.q = null;
                if(this.p===undefined) this.p = null;
                if(this.q===undefined) this.q = null;
                (() => {
                    this.p = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(xf.p);
                    this.q = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(xf.q);
                })();
            } else if(_position === undefined && _R === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.p===undefined) this.p = null;
                if(this.q===undefined) this.q = null;
                if(this.p===undefined) this.p = null;
                if(this.q===undefined) this.q = null;
                (() => {
                    this.p = new org.jbox2d.common.Vec2();
                    this.q = new org.jbox2d.common.Rot();
                })();
            } else throw new Error('invalid overload');
        }

        public set$org_jbox2d_common_Transform(xf : Transform) : Transform {
            this.p.set$org_jbox2d_common_Vec2(xf.p);
            this.q.set$org_jbox2d_common_Rot(xf.q);
            return this;
        }

        public set$org_jbox2d_common_Vec2$float(p : org.jbox2d.common.Vec2, angle : number) {
            this.p.set$org_jbox2d_common_Vec2(p);
            this.q.set$float(angle);
        }

        /**
         * Set this based on the position and angle.
         * 
         * @param {org.jbox2d.common.Vec2} p
         * @param {number} angle
         */
        public set(p? : any, angle? : any) : any {
            if(((p != null && p instanceof <any>org.jbox2d.common.Vec2) || p === null) && ((typeof angle === 'number') || angle === null)) {
                return <any>this.set$org_jbox2d_common_Vec2$float(p, angle);
            } else if(((p != null && p instanceof <any>org.jbox2d.common.Transform) || p === null) && angle === undefined) {
                return <any>this.set$org_jbox2d_common_Transform(p);
            } else throw new Error('invalid overload');
        }

        /**
         * Set this to the identity transform.
         */
        public setIdentity() {
            this.p.setZero();
            this.q.setIdentity();
        }

        public static mul$org_jbox2d_common_Transform$org_jbox2d_common_Vec2(T : Transform, v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2((<any>Math).fround(((<any>Math).fround((<any>Math).fround(T.q.c * v.x) - (<any>Math).fround(T.q.s * v.y))) + T.p.x), (<any>Math).fround(((<any>Math).fround((<any>Math).fround(T.q.s * v.x) + (<any>Math).fround(T.q.c * v.y))) + T.p.y));
        }

        public static mul(T? : any, v? : any) : any {
            if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null)) {
                return <any>org.jbox2d.common.Transform.mul$org_jbox2d_common_Transform$org_jbox2d_common_Vec2(T, v);
            } else if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Transform) || v === null)) {
                return <any>org.jbox2d.common.Transform.mul$org_jbox2d_common_Transform$org_jbox2d_common_Transform(T, v);
            } else throw new Error('invalid overload');
        }

        public static mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(T : Transform, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempy : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(T.q.s * v.x) + (<any>Math).fround(T.q.c * v.y))) + T.p.y);
            out.x = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(T.q.c * v.x) - (<any>Math).fround(T.q.s * v.y))) + T.p.x);
            out.y = tempy;
        }

        public static mulToOut(T? : any, v? : any, out? : any) : any {
            if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(T, v, out);
            } else if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Transform) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Transform) || out === null)) {
                return <any>org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(T, v, out);
            } else throw new Error('invalid overload');
        }

        public static mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(T : Transform, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            out.x = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(T.q.c * v.x) - (<any>Math).fround(T.q.s * v.y))) + T.p.x);
            out.y = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(T.q.s * v.x) + (<any>Math).fround(T.q.c * v.y))) + T.p.y);
        }

        public static mulToOutUnsafe(T? : any, v? : any, out? : any) : any {
            if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(T, v, out);
            } else if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Transform) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Transform) || out === null)) {
                return <any>org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(T, v, out);
            } else throw new Error('invalid overload');
        }

        public static mulTrans$org_jbox2d_common_Transform$org_jbox2d_common_Vec2(T : Transform, v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let px : number = (<any>Math).fround(v.x - T.p.x);
            let py : number = (<any>Math).fround(v.y - T.p.y);
            return new org.jbox2d.common.Vec2(((<any>Math).fround((<any>Math).fround(T.q.c * px) + (<any>Math).fround(T.q.s * py))), ((<any>Math).fround((<any>Math).fround(-T.q.s * px) + (<any>Math).fround(T.q.c * py))));
        }

        public static mulTrans(T? : any, v? : any) : any {
            if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null)) {
                return <any>org.jbox2d.common.Transform.mulTrans$org_jbox2d_common_Transform$org_jbox2d_common_Vec2(T, v);
            } else if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Transform) || v === null)) {
                return <any>org.jbox2d.common.Transform.mulTrans$org_jbox2d_common_Transform$org_jbox2d_common_Transform(T, v);
            } else throw new Error('invalid overload');
        }

        public static mulTransToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(T : Transform, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let px : number = (<any>Math).fround(v.x - T.p.x);
            let py : number = (<any>Math).fround(v.y - T.p.y);
            let tempy : number = ((<any>Math).fround((<any>Math).fround(-T.q.s * px) + (<any>Math).fround(T.q.c * py)));
            out.x = ((<any>Math).fround((<any>Math).fround(T.q.c * px) + (<any>Math).fround(T.q.s * py)));
            out.y = tempy;
        }

        public static mulTransToOut(T? : any, v? : any, out? : any) : any {
            if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Transform.mulTransToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(T, v, out);
            } else if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Transform) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Transform) || out === null)) {
                return <any>org.jbox2d.common.Transform.mulTransToOut$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(T, v, out);
            } else throw new Error('invalid overload');
        }

        public static mulTransToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(T : Transform, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let px : number = (<any>Math).fround(v.x - T.p.x);
            let py : number = (<any>Math).fround(v.y - T.p.y);
            out.x = ((<any>Math).fround((<any>Math).fround(T.q.c * px) + (<any>Math).fround(T.q.s * py)));
            out.y = ((<any>Math).fround((<any>Math).fround(-T.q.s * px) + (<any>Math).fround(T.q.c * py)));
        }

        public static mulTransToOutUnsafe(T? : any, v? : any, out? : any) : any {
            if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Transform.mulTransToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(T, v, out);
            } else if(((T != null && T instanceof <any>org.jbox2d.common.Transform) || T === null) && ((v != null && v instanceof <any>org.jbox2d.common.Transform) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Transform) || out === null)) {
                return <any>org.jbox2d.common.Transform.mulTransToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(T, v, out);
            } else throw new Error('invalid overload');
        }

        public static mul$org_jbox2d_common_Transform$org_jbox2d_common_Transform(A : Transform, B : Transform) : Transform {
            let C : Transform = new Transform();
            org.jbox2d.common.Rot.mulUnsafe(A.q, B.q, C.q);
            org.jbox2d.common.Rot.mulToOutUnsafe(A.q, B.p, C.p);
            C.p.addLocal$org_jbox2d_common_Vec2(A.p);
            return C;
        }

        public static mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(A : Transform, B : Transform, out : Transform) {
            org.jbox2d.common.Rot.mul(A.q, B.q, out.q);
            org.jbox2d.common.Rot.mulToOut(A.q, B.p, out.p);
            out.p.addLocal$org_jbox2d_common_Vec2(A.p);
        }

        public static mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(A : Transform, B : Transform, out : Transform) {
            org.jbox2d.common.Rot.mulUnsafe(A.q, B.q, out.q);
            org.jbox2d.common.Rot.mulToOutUnsafe(A.q, B.p, out.p);
            out.p.addLocal$org_jbox2d_common_Vec2(A.p);
        }

        static pool : org.jbox2d.common.Vec2; public static pool_$LI$() : org.jbox2d.common.Vec2 { if(Transform.pool == null) Transform.pool = new org.jbox2d.common.Vec2(); return Transform.pool; };

        public static mulTrans$org_jbox2d_common_Transform$org_jbox2d_common_Transform(A : Transform, B : Transform) : Transform {
            let C : Transform = new Transform();
            org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Rot$org_jbox2d_common_Rot(A.q, B.q, C.q);
            Transform.pool_$LI$().set$org_jbox2d_common_Vec2(B.p).subLocal(A.p);
            org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(A.q, Transform.pool_$LI$(), C.p);
            return C;
        }

        public static mulTransToOut$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(A : Transform, B : Transform, out : Transform) {
            org.jbox2d.common.Rot.mulTrans$org_jbox2d_common_Rot$org_jbox2d_common_Rot$org_jbox2d_common_Rot(A.q, B.q, out.q);
            Transform.pool_$LI$().set$org_jbox2d_common_Vec2(B.p).subLocal(A.p);
            org.jbox2d.common.Rot.mulTrans$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(A.q, Transform.pool_$LI$(), out.p);
        }

        public static mulTransToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(A : Transform, B : Transform, out : Transform) {
            org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Rot$org_jbox2d_common_Rot(A.q, B.q, out.q);
            Transform.pool_$LI$().set$org_jbox2d_common_Vec2(B.p).subLocal(A.p);
            org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(A.q, Transform.pool_$LI$(), out.p);
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let s : string = "XForm:\n";
            s += "Position: " + this.p + "\n";
            s += "R: \n" + this.q + "\n";
            return s;
        }
    }
    Transform["__class"] = "org.jbox2d.common.Transform";
    Transform["__interfaces"] = ["java.io.Serializable"];


}
namespace org.jbox2d.common {
    /**
     * A 3-by-3 matrix. Stored in column-major order.
     * 
     * @author Daniel Murphy
     * @param {number} exx
     * @param {number} exy
     * @param {number} exz
     * @param {number} eyx
     * @param {number} eyy
     * @param {number} eyz
     * @param {number} ezx
     * @param {number} ezy
     * @param {number} ezz
     * @class
     */
    export class Mat33 {
        static serialVersionUID : number = 2;

        public static IDENTITY : Mat33; public static IDENTITY_$LI$() : Mat33 { if(Mat33.IDENTITY == null) Mat33.IDENTITY = new Mat33(new org.jbox2d.common.Vec3(1, 0, 0), new org.jbox2d.common.Vec3(0, 1, 0), new org.jbox2d.common.Vec3(0, 0, 1)); return Mat33.IDENTITY; };

        public ex : org.jbox2d.common.Vec3;

        public ey : org.jbox2d.common.Vec3;

        public ez : org.jbox2d.common.Vec3;

        public constructor(exx? : any, exy? : any, exz? : any, eyx? : any, eyy? : any, eyz? : any, ezx? : any, ezy? : any, ezz? : any) {
            if(((typeof exx === 'number') || exx === null) && ((typeof exy === 'number') || exy === null) && ((typeof exz === 'number') || exz === null) && ((typeof eyx === 'number') || eyx === null) && ((typeof eyy === 'number') || eyy === null) && ((typeof eyz === 'number') || eyz === null) && ((typeof ezx === 'number') || ezx === null) && ((typeof ezy === 'number') || ezy === null) && ((typeof ezz === 'number') || ezz === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                if(this.ez===undefined) this.ez = null;
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                if(this.ez===undefined) this.ez = null;
                (() => {
                    this.ex = new org.jbox2d.common.Vec3(exx, exy, exz);
                    this.ey = new org.jbox2d.common.Vec3(eyx, eyy, eyz);
                    this.ez = new org.jbox2d.common.Vec3(ezx, ezy, ezz);
                })();
            } else if(((exx != null && exx instanceof <any>org.jbox2d.common.Vec3) || exx === null) && ((exy != null && exy instanceof <any>org.jbox2d.common.Vec3) || exy === null) && ((exz != null && exz instanceof <any>org.jbox2d.common.Vec3) || exz === null) && eyx === undefined && eyy === undefined && eyz === undefined && ezx === undefined && ezy === undefined && ezz === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let argCol1 : any = __args[0];
                let argCol2 : any = __args[1];
                let argCol3 : any = __args[2];
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                if(this.ez===undefined) this.ez = null;
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                if(this.ez===undefined) this.ez = null;
                (() => {
                    this.ex = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(argCol1);
                    this.ey = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(argCol2);
                    this.ez = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(argCol3);
                })();
            } else if(exx === undefined && exy === undefined && exz === undefined && eyx === undefined && eyy === undefined && eyz === undefined && ezx === undefined && ezy === undefined && ezz === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                if(this.ez===undefined) this.ez = null;
                if(this.ex===undefined) this.ex = null;
                if(this.ey===undefined) this.ey = null;
                if(this.ez===undefined) this.ez = null;
                (() => {
                    this.ex = new org.jbox2d.common.Vec3();
                    this.ey = new org.jbox2d.common.Vec3();
                    this.ez = new org.jbox2d.common.Vec3();
                })();
            } else throw new Error('invalid overload');
        }

        public setZero() {
            this.ex.setZero();
            this.ey.setZero();
            this.ez.setZero();
        }

        public set$float$float$float$float$float$float$float$float$float(exx : number, exy : number, exz : number, eyx : number, eyy : number, eyz : number, ezx : number, ezy : number, ezz : number) {
            this.ex.x = exx;
            this.ex.y = exy;
            this.ex.z = exz;
            this.ey.x = eyx;
            this.ey.y = eyy;
            this.ey.z = eyz;
            this.ez.x = eyx;
            this.ez.y = eyy;
            this.ez.z = eyz;
        }

        public set(exx? : any, exy? : any, exz? : any, eyx? : any, eyy? : any, eyz? : any, ezx? : any, ezy? : any, ezz? : any) : any {
            if(((typeof exx === 'number') || exx === null) && ((typeof exy === 'number') || exy === null) && ((typeof exz === 'number') || exz === null) && ((typeof eyx === 'number') || eyx === null) && ((typeof eyy === 'number') || eyy === null) && ((typeof eyz === 'number') || eyz === null) && ((typeof ezx === 'number') || ezx === null) && ((typeof ezy === 'number') || ezy === null) && ((typeof ezz === 'number') || ezz === null)) {
                return <any>this.set$float$float$float$float$float$float$float$float$float(exx, exy, exz, eyx, eyy, eyz, ezx, ezy, ezz);
            } else if(((exx != null && exx instanceof <any>org.jbox2d.common.Mat33) || exx === null) && exy === undefined && exz === undefined && eyx === undefined && eyy === undefined && eyz === undefined && ezx === undefined && ezy === undefined && ezz === undefined) {
                return <any>this.set$org_jbox2d_common_Mat33(exx);
            } else throw new Error('invalid overload');
        }

        public set$org_jbox2d_common_Mat33(mat : Mat33) {
            let vec : org.jbox2d.common.Vec3 = mat.ex;
            this.ex.x = vec.x;
            this.ex.y = vec.y;
            this.ex.z = vec.z;
            let vec1 : org.jbox2d.common.Vec3 = mat.ey;
            this.ey.x = vec1.x;
            this.ey.y = vec1.y;
            this.ey.z = vec1.z;
            let vec2 : org.jbox2d.common.Vec3 = mat.ez;
            this.ez.x = vec2.x;
            this.ez.y = vec2.y;
            this.ez.z = vec2.z;
        }

        public setIdentity() {
            this.ex.x = <number>1;
            this.ex.y = <number>0;
            this.ex.z = <number>0;
            this.ey.x = <number>0;
            this.ey.y = <number>1;
            this.ey.z = <number>0;
            this.ez.x = <number>0;
            this.ez.y = <number>0;
            this.ez.z = <number>1;
        }

        public static mul(A : Mat33, v : org.jbox2d.common.Vec3) : org.jbox2d.common.Vec3 {
            return new org.jbox2d.common.Vec3((<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.ex.x) + (<any>Math).fround(v.y * A.ey.x)) + v.z) + A.ez.x), (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.ex.y) + (<any>Math).fround(v.y * A.ey.y)) + (<any>Math).fround(v.z * A.ez.y)), (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.ex.z) + (<any>Math).fround(v.y * A.ey.z)) + (<any>Math).fround(v.z * A.ez.z)));
        }

        public static mul22(A : Mat33, v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2((<any>Math).fround((<any>Math).fround(A.ex.x * v.x) + (<any>Math).fround(A.ey.x * v.y)), (<any>Math).fround((<any>Math).fround(A.ex.y * v.x) + (<any>Math).fround(A.ey.y * v.y)));
        }

        public static mul22ToOut(A : Mat33, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempx : number = (<any>Math).fround((<any>Math).fround(A.ex.x * v.x) + (<any>Math).fround(A.ey.x * v.y));
            out.y = (<any>Math).fround((<any>Math).fround(A.ex.y * v.x) + (<any>Math).fround(A.ey.y * v.y));
            out.x = tempx;
        }

        public static mul22ToOutUnsafe(A : Mat33, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            out.y = (<any>Math).fround((<any>Math).fround(A.ex.y * v.x) + (<any>Math).fround(A.ey.y * v.y));
            out.x = (<any>Math).fround((<any>Math).fround(A.ex.x * v.x) + (<any>Math).fround(A.ey.x * v.y));
        }

        public static mulToOut(A : Mat33, v : org.jbox2d.common.Vec3, out : org.jbox2d.common.Vec3) {
            let tempy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.ex.y) + (<any>Math).fround(v.y * A.ey.y)) + (<any>Math).fround(v.z * A.ez.y));
            let tempz : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.ex.z) + (<any>Math).fround(v.y * A.ey.z)) + (<any>Math).fround(v.z * A.ez.z));
            out.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.ex.x) + (<any>Math).fround(v.y * A.ey.x)) + (<any>Math).fround(v.z * A.ez.x));
            out.y = tempy;
            out.z = tempz;
        }

        public static mulToOutUnsafe(A : Mat33, v : org.jbox2d.common.Vec3, out : org.jbox2d.common.Vec3) {
            out.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.ex.x) + (<any>Math).fround(v.y * A.ey.x)) + (<any>Math).fround(v.z * A.ez.x));
            out.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.ex.y) + (<any>Math).fround(v.y * A.ey.y)) + (<any>Math).fround(v.z * A.ez.y));
            out.z = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.ex.z) + (<any>Math).fround(v.y * A.ey.z)) + (<any>Math).fround(v.z * A.ez.z));
        }

        /**
         * Solve A * x = b, where b is a column vector. This is more efficient than computing the inverse
         * in one-shot cases.
         * 
         * @param {org.jbox2d.common.Vec2} b
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public solve22(b : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let x : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.solve22ToOut(b, x);
            return x;
        }

        /**
         * Solve A * x = b, where b is a column vector. This is more efficient than computing the inverse
         * in one-shot cases.
         * 
         * @param {org.jbox2d.common.Vec2} b
         * @return
         * @param {org.jbox2d.common.Vec2} out
         */
        public solve22ToOut(b : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let a11 : number = this.ex.x;
            let a12 : number = this.ey.x;
            let a21 : number = this.ex.y;
            let a22 : number = this.ey.y;
            let det : number = (<any>Math).fround((<any>Math).fround(a11 * a22) - (<any>Math).fround(a12 * a21));
            if(det !== 0.0) {
                det = (<any>Math).fround(1.0 / det);
            }
            out.x = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a22 * b.x) - (<any>Math).fround(a12 * b.y))));
            out.y = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a11 * b.y) - (<any>Math).fround(a21 * b.x))));
        }

        /**
         * Solve A * x = b, where b is a column vector. This is more efficient than computing the inverse
         * in one-shot cases.
         * 
         * @param {org.jbox2d.common.Vec3} b
         * @return
         * @return {org.jbox2d.common.Vec3}
         */
        public solve33(b : org.jbox2d.common.Vec3) : org.jbox2d.common.Vec3 {
            let x : org.jbox2d.common.Vec3 = new org.jbox2d.common.Vec3();
            this.solve33ToOut(b, x);
            return x;
        }

        /**
         * Solve A * x = b, where b is a column vector. This is more efficient than computing the inverse
         * in one-shot cases.
         * 
         * @param {org.jbox2d.common.Vec3} b
         * @param {org.jbox2d.common.Vec3} out the result
         */
        public solve33ToOut(b : org.jbox2d.common.Vec3, out : org.jbox2d.common.Vec3) {
            org.jbox2d.common.Vec3.crossToOutUnsafe(this.ey, this.ez, out);
            let det : number = org.jbox2d.common.Vec3.dot(this.ex, out);
            if(det !== 0.0) {
                det = (<any>Math).fround(1.0 / det);
            }
            org.jbox2d.common.Vec3.crossToOutUnsafe(this.ey, this.ez, out);
            let x : number = (<any>Math).fround(det * org.jbox2d.common.Vec3.dot(b, out));
            org.jbox2d.common.Vec3.crossToOutUnsafe(b, this.ez, out);
            let y : number = (<any>Math).fround(det * org.jbox2d.common.Vec3.dot(this.ex, out));
            org.jbox2d.common.Vec3.crossToOutUnsafe(this.ey, b, out);
            let z : number = (<any>Math).fround(det * org.jbox2d.common.Vec3.dot(this.ex, out));
            out.x = x;
            out.y = y;
            out.z = z;
        }

        public getInverse22(M : Mat33) {
            let a : number = this.ex.x;
            let b : number = this.ey.x;
            let c : number = this.ex.y;
            let d : number = this.ey.y;
            let det : number = (<any>Math).fround((<any>Math).fround(a * d) - (<any>Math).fround(b * c));
            if(det !== 0.0) {
                det = (<any>Math).fround(1.0 / det);
            }
            M.ex.x = (<any>Math).fround(det * d);
            M.ey.x = (<any>Math).fround(-det * b);
            M.ex.z = 0.0;
            M.ex.y = (<any>Math).fround(-det * c);
            M.ey.y = (<any>Math).fround(det * a);
            M.ey.z = 0.0;
            M.ez.x = 0.0;
            M.ez.y = 0.0;
            M.ez.z = 0.0;
        }

        public getSymInverse33(M : Mat33) {
            let bx : number = (<any>Math).fround((<any>Math).fround(this.ey.y * this.ez.z) - (<any>Math).fround(this.ey.z * this.ez.y));
            let by : number = (<any>Math).fround((<any>Math).fround(this.ey.z * this.ez.x) - (<any>Math).fround(this.ey.x * this.ez.z));
            let bz : number = (<any>Math).fround((<any>Math).fround(this.ey.x * this.ez.y) - (<any>Math).fround(this.ey.y * this.ez.x));
            let det : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.ex.x * bx) + (<any>Math).fround(this.ex.y * by)) + (<any>Math).fround(this.ex.z * bz));
            if(det !== 0.0) {
                det = (<any>Math).fround(1.0 / det);
            }
            let a11 : number = this.ex.x;
            let a12 : number = this.ey.x;
            let a13 : number = this.ez.x;
            let a22 : number = this.ey.y;
            let a23 : number = this.ez.y;
            let a33 : number = this.ez.z;
            M.ex.x = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a22 * a33) - (<any>Math).fround(a23 * a23))));
            M.ex.y = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a13 * a23) - (<any>Math).fround(a12 * a33))));
            M.ex.z = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a12 * a23) - (<any>Math).fround(a13 * a22))));
            M.ey.x = M.ex.y;
            M.ey.y = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a11 * a33) - (<any>Math).fround(a13 * a13))));
            M.ey.z = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a13 * a12) - (<any>Math).fround(a11 * a23))));
            M.ez.x = M.ex.z;
            M.ez.y = M.ey.z;
            M.ez.z = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a11 * a22) - (<any>Math).fround(a12 * a12))));
        }

        public static setScaleTransform(scale : number, out : Mat33) {
            out.ex.x = scale;
            out.ey.y = scale;
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            let prime : number = 31;
            let result : number = 1;
            result = prime * result + ((this.ex == null)?0:/* hashCode */(<any>((o: any) => { if(o.hashCode) { return o.hashCode(); } else { return o.toString(); } })(this.ex)));
            result = prime * result + ((this.ey == null)?0:/* hashCode */(<any>((o: any) => { if(o.hashCode) { return o.hashCode(); } else { return o.toString(); } })(this.ey)));
            result = prime * result + ((this.ez == null)?0:/* hashCode */(<any>((o: any) => { if(o.hashCode) { return o.hashCode(); } else { return o.toString(); } })(this.ez)));
            return result;
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj : any) : boolean {
            if(this === obj) return true;
            if(obj == null) return false;
            if((<any>this.constructor) !== (<any>obj.constructor)) return false;
            let other : Mat33 = <Mat33>obj;
            if(this.ex == null) {
                if(other.ex != null) return false;
            } else if(!this.ex.equals(other.ex)) return false;
            if(this.ey == null) {
                if(other.ey != null) return false;
            } else if(!this.ey.equals(other.ey)) return false;
            if(this.ez == null) {
                if(other.ez != null) return false;
            } else if(!this.ez.equals(other.ez)) return false;
            return true;
        }
    }
    Mat33["__class"] = "org.jbox2d.common.Mat33";
    Mat33["__interfaces"] = ["java.io.Serializable"];


}
namespace org.jbox2d.dynamics.contacts {
    export class ChainAndCircleContact extends org.jbox2d.dynamics.contacts.Contact {
        public constructor(argPool : org.jbox2d.pooling.IWorldPool) {
            super(argPool);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.Fixture} fA
         * @param {number} indexA
         * @param {org.jbox2d.dynamics.Fixture} fB
         * @param {number} indexB
         */
        public init(fA : org.jbox2d.dynamics.Fixture, indexA : number, fB : org.jbox2d.dynamics.Fixture, indexB : number) {
            super.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fA, indexA, fB, indexB);
        }

        /*private*/ edge : org.jbox2d.collision.shapes.EdgeShape = new org.jbox2d.collision.shapes.EdgeShape();

        /**
         * 
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.common.Transform} xfB
         */
        public evaluate(manifold : org.jbox2d.collision.Manifold, xfA : org.jbox2d.common.Transform, xfB : org.jbox2d.common.Transform) {
            let chain : org.jbox2d.collision.shapes.ChainShape = <org.jbox2d.collision.shapes.ChainShape>this.m_fixtureA.getShape();
            chain.getChildEdge(this.edge, this.m_indexA);
            this.pool.getCollision().collideEdgeAndCircle(manifold, this.edge, xfA, <org.jbox2d.collision.shapes.CircleShape>this.m_fixtureB.getShape(), xfB);
        }
    }
    ChainAndCircleContact["__class"] = "org.jbox2d.dynamics.contacts.ChainAndCircleContact";

}
namespace org.jbox2d.dynamics.contacts {
    export class ChainAndPolygonContact extends org.jbox2d.dynamics.contacts.Contact {
        public constructor(argPool : org.jbox2d.pooling.IWorldPool) {
            super(argPool);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.Fixture} fA
         * @param {number} indexA
         * @param {org.jbox2d.dynamics.Fixture} fB
         * @param {number} indexB
         */
        public init(fA : org.jbox2d.dynamics.Fixture, indexA : number, fB : org.jbox2d.dynamics.Fixture, indexB : number) {
            super.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fA, indexA, fB, indexB);
        }

        /*private*/ edge : org.jbox2d.collision.shapes.EdgeShape = new org.jbox2d.collision.shapes.EdgeShape();

        /**
         * 
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.common.Transform} xfB
         */
        public evaluate(manifold : org.jbox2d.collision.Manifold, xfA : org.jbox2d.common.Transform, xfB : org.jbox2d.common.Transform) {
            let chain : org.jbox2d.collision.shapes.ChainShape = <org.jbox2d.collision.shapes.ChainShape>this.m_fixtureA.getShape();
            chain.getChildEdge(this.edge, this.m_indexA);
            this.pool.getCollision().collideEdgeAndPolygon(manifold, this.edge, xfA, <org.jbox2d.collision.shapes.PolygonShape>this.m_fixtureB.getShape(), xfB);
        }
    }
    ChainAndPolygonContact["__class"] = "org.jbox2d.dynamics.contacts.ChainAndPolygonContact";

}
namespace org.jbox2d.dynamics.contacts {
    export class CircleContact extends org.jbox2d.dynamics.contacts.Contact {
        public constructor(argPool : org.jbox2d.pooling.IWorldPool) {
            super(argPool);
        }

        public init(fA? : any, indexA? : any, fB? : any, indexB? : any) : any {
            if(((fA != null && fA instanceof <any>org.jbox2d.dynamics.Fixture) || fA === null) && ((typeof indexA === 'number') || indexA === null) && ((fB != null && fB instanceof <any>org.jbox2d.dynamics.Fixture) || fB === null) && ((typeof indexB === 'number') || indexB === null)) {
                super.init(fA, indexA, fB, indexB);
            } else if(((fA != null && fA instanceof <any>org.jbox2d.dynamics.Fixture) || fA === null) && ((indexA != null && indexA instanceof <any>org.jbox2d.dynamics.Fixture) || indexA === null) && fB === undefined && indexB === undefined) {
                return <any>this.init$org_jbox2d_dynamics_Fixture$org_jbox2d_dynamics_Fixture(fA, indexA);
            } else throw new Error('invalid overload');
        }

        public init$org_jbox2d_dynamics_Fixture$org_jbox2d_dynamics_Fixture(fixtureA : org.jbox2d.dynamics.Fixture, fixtureB : org.jbox2d.dynamics.Fixture) {
            super.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fixtureA, 0, fixtureB, 0);
        }

        /**
         * 
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.common.Transform} xfB
         */
        public evaluate(manifold : org.jbox2d.collision.Manifold, xfA : org.jbox2d.common.Transform, xfB : org.jbox2d.common.Transform) {
            this.pool.getCollision().collideCircles(manifold, <org.jbox2d.collision.shapes.CircleShape>this.m_fixtureA.getShape(), xfA, <org.jbox2d.collision.shapes.CircleShape>this.m_fixtureB.getShape(), xfB);
        }
    }
    CircleContact["__class"] = "org.jbox2d.dynamics.contacts.CircleContact";

}
namespace org.jbox2d.dynamics.contacts {
    export class EdgeAndCircleContact extends org.jbox2d.dynamics.contacts.Contact {
        public constructor(argPool : org.jbox2d.pooling.IWorldPool) {
            super(argPool);
        }

        public init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fA : org.jbox2d.dynamics.Fixture, indexA : number, fB : org.jbox2d.dynamics.Fixture, indexB : number) {
            super.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fA, indexA, fB, indexB);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.Fixture} fA
         * @param {number} indexA
         * @param {org.jbox2d.dynamics.Fixture} fB
         * @param {number} indexB
         */
        public init(fA? : any, indexA? : any, fB? : any, indexB? : any) : any {
            if(((fA != null && fA instanceof <any>org.jbox2d.dynamics.Fixture) || fA === null) && ((typeof indexA === 'number') || indexA === null) && ((fB != null && fB instanceof <any>org.jbox2d.dynamics.Fixture) || fB === null) && ((typeof indexB === 'number') || indexB === null)) {
                return <any>this.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fA, indexA, fB, indexB);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.common.Transform} xfB
         */
        public evaluate(manifold : org.jbox2d.collision.Manifold, xfA : org.jbox2d.common.Transform, xfB : org.jbox2d.common.Transform) {
            this.pool.getCollision().collideEdgeAndCircle(manifold, <org.jbox2d.collision.shapes.EdgeShape>this.m_fixtureA.getShape(), xfA, <org.jbox2d.collision.shapes.CircleShape>this.m_fixtureB.getShape(), xfB);
        }
    }
    EdgeAndCircleContact["__class"] = "org.jbox2d.dynamics.contacts.EdgeAndCircleContact";

}
namespace org.jbox2d.dynamics.contacts {
    export class EdgeAndPolygonContact extends org.jbox2d.dynamics.contacts.Contact {
        public constructor(argPool : org.jbox2d.pooling.IWorldPool) {
            super(argPool);
        }

        public init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fA : org.jbox2d.dynamics.Fixture, indexA : number, fB : org.jbox2d.dynamics.Fixture, indexB : number) {
            super.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fA, indexA, fB, indexB);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.Fixture} fA
         * @param {number} indexA
         * @param {org.jbox2d.dynamics.Fixture} fB
         * @param {number} indexB
         */
        public init(fA? : any, indexA? : any, fB? : any, indexB? : any) : any {
            if(((fA != null && fA instanceof <any>org.jbox2d.dynamics.Fixture) || fA === null) && ((typeof indexA === 'number') || indexA === null) && ((fB != null && fB instanceof <any>org.jbox2d.dynamics.Fixture) || fB === null) && ((typeof indexB === 'number') || indexB === null)) {
                return <any>this.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fA, indexA, fB, indexB);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.common.Transform} xfB
         */
        public evaluate(manifold : org.jbox2d.collision.Manifold, xfA : org.jbox2d.common.Transform, xfB : org.jbox2d.common.Transform) {
            this.pool.getCollision().collideEdgeAndPolygon(manifold, <org.jbox2d.collision.shapes.EdgeShape>this.m_fixtureA.getShape(), xfA, <org.jbox2d.collision.shapes.PolygonShape>this.m_fixtureB.getShape(), xfB);
        }
    }
    EdgeAndPolygonContact["__class"] = "org.jbox2d.dynamics.contacts.EdgeAndPolygonContact";

}
namespace org.jbox2d.dynamics.contacts {
    export class PolygonAndCircleContact extends org.jbox2d.dynamics.contacts.Contact {
        public constructor(argPool : org.jbox2d.pooling.IWorldPool) {
            super(argPool);
        }

        public init(fA? : any, indexA? : any, fB? : any, indexB? : any) : any {
            if(((fA != null && fA instanceof <any>org.jbox2d.dynamics.Fixture) || fA === null) && ((typeof indexA === 'number') || indexA === null) && ((fB != null && fB instanceof <any>org.jbox2d.dynamics.Fixture) || fB === null) && ((typeof indexB === 'number') || indexB === null)) {
                super.init(fA, indexA, fB, indexB);
            } else if(((fA != null && fA instanceof <any>org.jbox2d.dynamics.Fixture) || fA === null) && ((indexA != null && indexA instanceof <any>org.jbox2d.dynamics.Fixture) || indexA === null) && fB === undefined && indexB === undefined) {
                return <any>this.init$org_jbox2d_dynamics_Fixture$org_jbox2d_dynamics_Fixture(fA, indexA);
            } else throw new Error('invalid overload');
        }

        public init$org_jbox2d_dynamics_Fixture$org_jbox2d_dynamics_Fixture(fixtureA : org.jbox2d.dynamics.Fixture, fixtureB : org.jbox2d.dynamics.Fixture) {
            super.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fixtureA, 0, fixtureB, 0);
        }

        /**
         * 
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.common.Transform} xfB
         */
        public evaluate(manifold : org.jbox2d.collision.Manifold, xfA : org.jbox2d.common.Transform, xfB : org.jbox2d.common.Transform) {
            this.pool.getCollision().collidePolygonAndCircle(manifold, <org.jbox2d.collision.shapes.PolygonShape>this.m_fixtureA.getShape(), xfA, <org.jbox2d.collision.shapes.CircleShape>this.m_fixtureB.getShape(), xfB);
        }
    }
    PolygonAndCircleContact["__class"] = "org.jbox2d.dynamics.contacts.PolygonAndCircleContact";

}
namespace org.jbox2d.dynamics.contacts {
    export class PolygonContact extends org.jbox2d.dynamics.contacts.Contact {
        public constructor(argPool : org.jbox2d.pooling.IWorldPool) {
            super(argPool);
        }

        public init(fA? : any, indexA? : any, fB? : any, indexB? : any) : any {
            if(((fA != null && fA instanceof <any>org.jbox2d.dynamics.Fixture) || fA === null) && ((typeof indexA === 'number') || indexA === null) && ((fB != null && fB instanceof <any>org.jbox2d.dynamics.Fixture) || fB === null) && ((typeof indexB === 'number') || indexB === null)) {
                super.init(fA, indexA, fB, indexB);
            } else if(((fA != null && fA instanceof <any>org.jbox2d.dynamics.Fixture) || fA === null) && ((indexA != null && indexA instanceof <any>org.jbox2d.dynamics.Fixture) || indexA === null) && fB === undefined && indexB === undefined) {
                return <any>this.init$org_jbox2d_dynamics_Fixture$org_jbox2d_dynamics_Fixture(fA, indexA);
            } else throw new Error('invalid overload');
        }

        public init$org_jbox2d_dynamics_Fixture$org_jbox2d_dynamics_Fixture(fixtureA : org.jbox2d.dynamics.Fixture, fixtureB : org.jbox2d.dynamics.Fixture) {
            super.init$org_jbox2d_dynamics_Fixture$int$org_jbox2d_dynamics_Fixture$int(fixtureA, 0, fixtureB, 0);
        }

        /**
         * 
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.common.Transform} xfA
         * @param {org.jbox2d.common.Transform} xfB
         */
        public evaluate(manifold : org.jbox2d.collision.Manifold, xfA : org.jbox2d.common.Transform, xfB : org.jbox2d.common.Transform) {
            this.pool.getCollision().collidePolygons(manifold, <org.jbox2d.collision.shapes.PolygonShape>this.m_fixtureA.getShape(), xfA, <org.jbox2d.collision.shapes.PolygonShape>this.m_fixtureB.getShape(), xfB);
        }
    }
    PolygonContact["__class"] = "org.jbox2d.dynamics.contacts.PolygonContact";

}
namespace org.jbox2d.dynamics.joints {
    export class ConstantVolumeJoint extends org.jbox2d.dynamics.joints.Joint {
        /*private*/ bodies : org.jbox2d.dynamics.Body[];

        /*private*/ targetLengths : number[];

        /*private*/ targetVolume : number;

        /*private*/ normals : org.jbox2d.common.Vec2[];

        /*private*/ m_impulse : number = 0.0;

        /*private*/ world : org.jbox2d.dynamics.World;

        /*private*/ distanceJoints : org.jbox2d.dynamics.joints.DistanceJoint[];

        public getBodies() : org.jbox2d.dynamics.Body[] {
            return this.bodies;
        }

        public getJoints() : org.jbox2d.dynamics.joints.DistanceJoint[] {
            return this.distanceJoints;
        }

        public inflate(factor : number) {
            this.targetVolume *= factor;
        }

        public constructor(argWorld : org.jbox2d.dynamics.World, def : org.jbox2d.dynamics.joints.ConstantVolumeJointDef) {
            super(argWorld.getPool(), def);
            if(this.bodies===undefined) this.bodies = null;
            if(this.targetLengths===undefined) this.targetLengths = null;
            if(this.targetVolume===undefined) this.targetVolume = 0;
            if(this.normals===undefined) this.normals = null;
            if(this.world===undefined) this.world = null;
            if(this.distanceJoints===undefined) this.distanceJoints = null;
            this.world = argWorld;
            if(/* size */(<number>def.bodies.length) <= 2) {
                throw Object.defineProperty(new Error("You cannot create a constant volume joint with less than three bodies."), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
            }
            this.bodies = /* toArray */def.bodies.slice(0);
            this.targetLengths = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.bodies.length);
            for(let i : number = 0; i < this.targetLengths.length; ++i) {
                let next : number = (i === this.targetLengths.length - 1)?0:i + 1;
                let dist : number = this.bodies[i].getWorldCenter().sub(this.bodies[next].getWorldCenter()).length();
                this.targetLengths[i] = dist;
            };
            this.targetVolume = this.getBodyArea();
            if(def.joints != null && /* size */(<number>def.joints.length) !== /* size */(<number>def.bodies.length)) {
                throw Object.defineProperty(new Error("Incorrect joint definition.  Joints have to correspond to the bodies"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
            }
            if(def.joints == null) {
                let djd : org.jbox2d.dynamics.joints.DistanceJointDef = new org.jbox2d.dynamics.joints.DistanceJointDef();
                this.distanceJoints = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.bodies.length);
                for(let i : number = 0; i < this.targetLengths.length; ++i) {
                    let next : number = (i === this.targetLengths.length - 1)?0:i + 1;
                    djd.frequencyHz = def.frequencyHz;
                    djd.dampingRatio = def.dampingRatio;
                    djd.collideConnected = def.collideConnected;
                    djd.initialize(this.bodies[i], this.bodies[next], this.bodies[i].getWorldCenter(), this.bodies[next].getWorldCenter());
                    this.distanceJoints[i] = <org.jbox2d.dynamics.joints.DistanceJoint>this.world.createJoint(djd);
                };
            } else {
                this.distanceJoints = /* toArray */def.joints.slice(0);
            }
            this.normals = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.bodies.length);
            for(let i : number = 0; i < this.normals.length; ++i) {
                this.normals[i] = new org.jbox2d.common.Vec2();
            };
        }

        /**
         * 
         */
        public destructor() {
            for(let i : number = 0; i < this.distanceJoints.length; ++i) {
                this.world.destroyJoint(this.distanceJoints[i]);
            };
        }

        /*private*/ getBodyArea() : number {
            let area : number = 0.0;
            for(let i : number = 0; i < this.bodies.length; ++i) {
                let next : number = (i === this.bodies.length - 1)?0:i + 1;
                area += (<any>Math).fround((<any>Math).fround(this.bodies[i].getWorldCenter().x * this.bodies[next].getWorldCenter().y) - (<any>Math).fround(this.bodies[next].getWorldCenter().x * this.bodies[i].getWorldCenter().y));
            };
            area *= 0.5;
            return area;
        }

        /*private*/ getSolverArea(positions : org.jbox2d.dynamics.contacts.Position[]) : number {
            let area : number = 0.0;
            for(let i : number = 0; i < this.bodies.length; ++i) {
                let next : number = (i === this.bodies.length - 1)?0:i + 1;
                area += (<any>Math).fround((<any>Math).fround(positions[this.bodies[i].m_islandIndex].c.x * positions[this.bodies[next].m_islandIndex].c.y) - (<any>Math).fround(positions[this.bodies[next].m_islandIndex].c.x * positions[this.bodies[i].m_islandIndex].c.y));
            };
            area *= 0.5;
            return area;
        }

        /*private*/ constrainEdges(positions : org.jbox2d.dynamics.contacts.Position[]) : boolean {
            let perimeter : number = 0.0;
            for(let i : number = 0; i < this.bodies.length; ++i) {
                let next : number = (i === this.bodies.length - 1)?0:i + 1;
                let dx : number = (<any>Math).fround(positions[this.bodies[next].m_islandIndex].c.x - positions[this.bodies[i].m_islandIndex].c.x);
                let dy : number = (<any>Math).fround(positions[this.bodies[next].m_islandIndex].c.y - positions[this.bodies[i].m_islandIndex].c.y);
                let dist : number = org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy)));
                if(dist < org.jbox2d.common.Settings.EPSILON) {
                    dist = 1.0;
                }
                this.normals[i].x = (<any>Math).fround(dy / dist);
                this.normals[i].y = (<any>Math).fround(-dx / dist);
                perimeter += dist;
            };
            let delta : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let deltaArea : number = (<any>Math).fround(this.targetVolume - this.getSolverArea(positions));
            let toExtrude : number = (<any>Math).fround((<any>Math).fround(0.5 * deltaArea) / perimeter);
            let done : boolean = true;
            for(let i : number = 0; i < this.bodies.length; ++i) {
                let next : number = (i === this.bodies.length - 1)?0:i + 1;
                delta.set$float$float((<any>Math).fround(toExtrude * ((<any>Math).fround(this.normals[i].x + this.normals[next].x))), (<any>Math).fround(toExtrude * ((<any>Math).fround(this.normals[i].y + this.normals[next].y))));
                let normSqrd : number = delta.lengthSquared();
                if(normSqrd > (<any>Math).fround(org.jbox2d.common.Settings.maxLinearCorrection * org.jbox2d.common.Settings.maxLinearCorrection)) {
                    delta.mulLocal((<any>Math).fround(org.jbox2d.common.Settings.maxLinearCorrection / org.jbox2d.common.MathUtils.sqrt(normSqrd)));
                }
                if(normSqrd > (<any>Math).fround(org.jbox2d.common.Settings.linearSlop * org.jbox2d.common.Settings.linearSlop)) {
                    done = false;
                }
                positions[this.bodies[next].m_islandIndex].c.x += delta.x;
                positions[this.bodies[next].m_islandIndex].c.y += delta.y;
            };
            this.pool.pushVec2(1);
            return done;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} step
         */
        public initVelocityConstraints(step : org.jbox2d.dynamics.SolverData) {
            let velocities : org.jbox2d.dynamics.contacts.Velocity[] = step.velocities;
            let positions : org.jbox2d.dynamics.contacts.Position[] = step.positions;
            let d : org.jbox2d.common.Vec2[] = this.pool.getVec2Array(this.bodies.length);
            for(let i : number = 0; i < this.bodies.length; ++i) {
                let prev : number = (i === 0)?this.bodies.length - 1:i - 1;
                let next : number = (i === this.bodies.length - 1)?0:i + 1;
                d[i].set$org_jbox2d_common_Vec2(positions[this.bodies[next].m_islandIndex].c);
                d[i].subLocal(positions[this.bodies[prev].m_islandIndex].c);
            };
            if(step.step.warmStarting) {
                this.m_impulse *= step.step.dtRatio;
                for(let i : number = 0; i < this.bodies.length; ++i) {
                    velocities[this.bodies[i].m_islandIndex].v.x += (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.bodies[i].m_invMass * d[i].y) * 0.5) * this.m_impulse);
                    velocities[this.bodies[i].m_islandIndex].v.y += (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.bodies[i].m_invMass * -d[i].x) * 0.5) * this.m_impulse);
                };
            } else {
                this.m_impulse = 0.0;
            }
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} step
         * @return {boolean}
         */
        public solvePositionConstraints(step : org.jbox2d.dynamics.SolverData) : boolean {
            return this.constrainEdges(step.positions);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} step
         */
        public solveVelocityConstraints(step : org.jbox2d.dynamics.SolverData) {
            let crossMassSum : number = 0.0;
            let dotMassSum : number = 0.0;
            let velocities : org.jbox2d.dynamics.contacts.Velocity[] = step.velocities;
            let positions : org.jbox2d.dynamics.contacts.Position[] = step.positions;
            let d : org.jbox2d.common.Vec2[] = this.pool.getVec2Array(this.bodies.length);
            for(let i : number = 0; i < this.bodies.length; ++i) {
                let prev : number = (i === 0)?this.bodies.length - 1:i - 1;
                let next : number = (i === this.bodies.length - 1)?0:i + 1;
                d[i].set$org_jbox2d_common_Vec2(positions[this.bodies[next].m_islandIndex].c);
                d[i].subLocal(positions[this.bodies[prev].m_islandIndex].c);
                dotMassSum += (<any>Math).fround((d[i].lengthSquared()) / this.bodies[i].getMass());
                crossMassSum += org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(velocities[this.bodies[i].m_islandIndex].v, d[i]);
            };
            let lambda : number = (<any>Math).fround((<any>Math).fround(-2.0 * crossMassSum) / dotMassSum);
            this.m_impulse += lambda;
            for(let i : number = 0; i < this.bodies.length; ++i) {
                velocities[this.bodies[i].m_islandIndex].v.x += (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.bodies[i].m_invMass * d[i].y) * 0.5) * lambda);
                velocities[this.bodies[i].m_islandIndex].v.y += (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.bodies[i].m_invMass * -d[i].x) * 0.5) * lambda);
            };
        }

        /**
         * No-op
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
        }

        /**
         * No-op
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
        }

        /**
         * No-op
         * @param {number} inv_dt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(inv_dt : number, argOut : org.jbox2d.common.Vec2) {
        }

        /**
         * No-op
         * @param {number} inv_dt
         * @return {number}
         */
        public getReactionTorque(inv_dt : number) : number {
            return 0;
        }
    }
    ConstantVolumeJoint["__class"] = "org.jbox2d.dynamics.joints.ConstantVolumeJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A distance joint constrains two points on two bodies to remain at a fixed distance from each
     * other. You can view this as a massless, rigid rod.
     * @extends org.jbox2d.dynamics.joints.Joint
     * @class
     */
    export class DistanceJoint extends org.jbox2d.dynamics.joints.Joint {
        /*private*/ m_frequencyHz : number;

        /*private*/ m_dampingRatio : number;

        /*private*/ m_bias : number;

        /*private*/ m_localAnchorA : org.jbox2d.common.Vec2;

        /*private*/ m_localAnchorB : org.jbox2d.common.Vec2;

        /*private*/ m_gamma : number;

        /*private*/ m_impulse : number;

        /*private*/ m_length : number;

        /*private*/ m_indexA : number;

        /*private*/ m_indexB : number;

        /*private*/ m_u : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_rA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_rB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_invMassA : number;

        /*private*/ m_invMassB : number;

        /*private*/ m_invIA : number;

        /*private*/ m_invIB : number;

        /*private*/ m_mass : number;

        constructor(argWorld : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.DistanceJointDef) {
            super(argWorld, def);
            if(this.m_frequencyHz===undefined) this.m_frequencyHz = 0;
            if(this.m_dampingRatio===undefined) this.m_dampingRatio = 0;
            if(this.m_bias===undefined) this.m_bias = 0;
            if(this.m_localAnchorA===undefined) this.m_localAnchorA = null;
            if(this.m_localAnchorB===undefined) this.m_localAnchorB = null;
            if(this.m_gamma===undefined) this.m_gamma = 0;
            if(this.m_impulse===undefined) this.m_impulse = 0;
            if(this.m_length===undefined) this.m_length = 0;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_invMassA===undefined) this.m_invMassA = 0;
            if(this.m_invMassB===undefined) this.m_invMassB = 0;
            if(this.m_invIA===undefined) this.m_invIA = 0;
            if(this.m_invIB===undefined) this.m_invIB = 0;
            if(this.m_mass===undefined) this.m_mass = 0;
            this.m_localAnchorA = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAnchorA);
            this.m_localAnchorB = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAnchorB);
            this.m_length = def.length;
            this.m_impulse = 0.0;
            this.m_frequencyHz = def.frequencyHz;
            this.m_dampingRatio = def.dampingRatio;
            this.m_gamma = 0.0;
            this.m_bias = 0.0;
        }

        public setFrequency(hz : number) {
            this.m_frequencyHz = hz;
        }

        public getFrequency() : number {
            return this.m_frequencyHz;
        }

        public getLength() : number {
            return this.m_length;
        }

        public setLength(argLength : number) {
            this.m_length = argLength;
        }

        public setDampingRatio(damp : number) {
            this.m_dampingRatio = damp;
        }

        public getDampingRatio() : number {
            return this.m_dampingRatio;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, argOut);
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, argOut);
        }

        public getLocalAnchorA() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorA;
        }

        public getLocalAnchorB() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorB;
        }

        /**
         * Get the reaction force given the inverse time step. Unit is N.
         * @param {number} inv_dt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(inv_dt : number, argOut : org.jbox2d.common.Vec2) {
            argOut.x = (<any>Math).fround((<any>Math).fround(this.m_impulse * this.m_u.x) * inv_dt);
            argOut.y = (<any>Math).fround((<any>Math).fround(this.m_impulse * this.m_u.y) * inv_dt);
        }

        /**
         * Get the reaction torque given the inverse time step. Unit is N*m. This is always zero for a
         * distance joint.
         * @param {number} inv_dt
         * @return {number}
         */
        public getReactionTorque(inv_dt : number) : number {
            return 0.0;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexA = this.m_bodyA.m_islandIndex;
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_localCenterA.set$org_jbox2d_common_Vec2(this.m_bodyA.m_sweep.localCenter);
            this.m_localCenterB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, this.m_u.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), this.m_rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, this.m_u.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), this.m_rB);
            this.m_u.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(this.m_rB).subLocal(cA).subLocal(this.m_rA);
            this.pool.pushRot(2);
            let length : number = this.m_u.length();
            if(length > org.jbox2d.common.Settings.linearSlop) {
                this.m_u.x *= (<any>Math).fround(1.0 / length);
                this.m_u.y *= (<any>Math).fround(1.0 / length);
            } else {
                this.m_u.set$float$float(0.0, 0.0);
            }
            let crAu : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, this.m_u);
            let crBu : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, this.m_u);
            let invMass : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_invMassA + (<any>Math).fround((<any>Math).fround(this.m_invIA * crAu) * crAu)) + this.m_invMassB) + (<any>Math).fround((<any>Math).fround(this.m_invIB * crBu) * crBu));
            this.m_mass = invMass !== 0.0?(<any>Math).fround(1.0 / invMass):0.0;
            if(this.m_frequencyHz > 0.0) {
                let C : number = (<any>Math).fround(length - this.m_length);
                let omega : number = (<any>Math).fround((<any>Math).fround(2.0 * org.jbox2d.common.MathUtils.PI_$LI$()) * this.m_frequencyHz);
                let d : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(2.0 * this.m_mass) * this.m_dampingRatio) * omega);
                let k : number = (<any>Math).fround((<any>Math).fround(this.m_mass * omega) * omega);
                let h : number = data.step.dt;
                this.m_gamma = (<any>Math).fround(h * ((<any>Math).fround(d + (<any>Math).fround(h * k))));
                this.m_gamma = this.m_gamma !== 0.0?(<any>Math).fround(1.0 / this.m_gamma):0.0;
                this.m_bias = (<any>Math).fround((<any>Math).fround((<any>Math).fround(C * h) * k) * this.m_gamma);
                invMass += this.m_gamma;
                this.m_mass = invMass !== 0.0?(<any>Math).fround(1.0 / invMass):0.0;
            } else {
                this.m_gamma = 0.0;
                this.m_bias = 0.0;
            }
            if(data.step.warmStarting) {
                this.m_impulse *= data.step.dtRatio;
                let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
                P.set$org_jbox2d_common_Vec2(this.m_u).mulLocal(this.m_impulse);
                vA.x -= (<any>Math).fround(this.m_invMassA * P.x);
                vA.y -= (<any>Math).fround(this.m_invMassA * P.y);
                wA -= (<any>Math).fround(this.m_invIA * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, P));
                vB.x += (<any>Math).fround(this.m_invMassB * P.x);
                vB.y += (<any>Math).fround(this.m_invMassB * P.y);
                wB += (<any>Math).fround(this.m_invIB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, P));
                this.pool.pushVec2(1);
            } else {
                this.m_impulse = 0.0;
            }
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let vpA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let vpB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wA, this.m_rA, vpA);
            vpA.addLocal$org_jbox2d_common_Vec2(vA);
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wB, this.m_rB, vpB);
            vpB.addLocal$org_jbox2d_common_Vec2(vB);
            let Cdot : number = org.jbox2d.common.Vec2.dot(this.m_u, vpB.subLocal(vpA));
            let impulse : number = (<any>Math).fround(-this.m_mass * ((<any>Math).fround((<any>Math).fround(Cdot + this.m_bias) + (<any>Math).fround(this.m_gamma * this.m_impulse))));
            this.m_impulse += impulse;
            let Px : number = (<any>Math).fround(impulse * this.m_u.x);
            let Py : number = (<any>Math).fround(impulse * this.m_u.y);
            vA.x -= (<any>Math).fround(this.m_invMassA * Px);
            vA.y -= (<any>Math).fround(this.m_invMassA * Py);
            wA -= (<any>Math).fround(this.m_invIA * ((<any>Math).fround((<any>Math).fround(this.m_rA.x * Py) - (<any>Math).fround(this.m_rA.y * Px))));
            vB.x += (<any>Math).fround(this.m_invMassB * Px);
            vB.y += (<any>Math).fround(this.m_invMassB * Py);
            wB += (<any>Math).fround(this.m_invIB * ((<any>Math).fround((<any>Math).fround(this.m_rB.x * Py) - (<any>Math).fround(this.m_rB.y * Px))));
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(2);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            if(this.m_frequencyHz > 0.0) {
                return true;
            }
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let rA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let u : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, u.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, u.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), rB);
            u.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(rB).subLocal(cA).subLocal(rA);
            let length : number = u.normalize();
            let C : number = (<any>Math).fround(length - this.m_length);
            C = org.jbox2d.common.MathUtils.clamp$float$float$float(C, -org.jbox2d.common.Settings.maxLinearCorrection, org.jbox2d.common.Settings.maxLinearCorrection);
            let impulse : number = (<any>Math).fround(-this.m_mass * C);
            let Px : number = (<any>Math).fround(impulse * u.x);
            let Py : number = (<any>Math).fround(impulse * u.y);
            cA.x -= (<any>Math).fround(this.m_invMassA * Px);
            cA.y -= (<any>Math).fround(this.m_invMassA * Py);
            aA -= (<any>Math).fround(this.m_invIA * ((<any>Math).fround((<any>Math).fround(rA.x * Py) - (<any>Math).fround(rA.y * Px))));
            cB.x += (<any>Math).fround(this.m_invMassB * Px);
            cB.y += (<any>Math).fround(this.m_invMassB * Py);
            aB += (<any>Math).fround(this.m_invIB * ((<any>Math).fround((<any>Math).fround(rB.x * Py) - (<any>Math).fround(rB.y * Px))));
            data.positions[this.m_indexA].a = aA;
            data.positions[this.m_indexB].a = aB;
            this.pool.pushVec2(3);
            this.pool.pushRot(2);
            return org.jbox2d.common.MathUtils.abs$float(C) < org.jbox2d.common.Settings.linearSlop;
        }
    }
    DistanceJoint["__class"] = "org.jbox2d.dynamics.joints.DistanceJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * @author Daniel Murphy
     * @extends org.jbox2d.dynamics.joints.Joint
     * @class
     */
    export class FrictionJoint extends org.jbox2d.dynamics.joints.Joint {
        /*private*/ m_localAnchorA : org.jbox2d.common.Vec2;

        /*private*/ m_localAnchorB : org.jbox2d.common.Vec2;

        /*private*/ m_linearImpulse : org.jbox2d.common.Vec2;

        /*private*/ m_angularImpulse : number;

        /*private*/ m_maxForce : number;

        /*private*/ m_maxTorque : number;

        /*private*/ m_indexA : number;

        /*private*/ m_indexB : number;

        /*private*/ m_rA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_rB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_invMassA : number;

        /*private*/ m_invMassB : number;

        /*private*/ m_invIA : number;

        /*private*/ m_invIB : number;

        /*private*/ m_linearMass : org.jbox2d.common.Mat22 = new org.jbox2d.common.Mat22();

        /*private*/ m_angularMass : number;

        constructor(argWorldPool : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.FrictionJointDef) {
            super(argWorldPool, def);
            if(this.m_localAnchorA===undefined) this.m_localAnchorA = null;
            if(this.m_localAnchorB===undefined) this.m_localAnchorB = null;
            if(this.m_linearImpulse===undefined) this.m_linearImpulse = null;
            if(this.m_angularImpulse===undefined) this.m_angularImpulse = 0;
            if(this.m_maxForce===undefined) this.m_maxForce = 0;
            if(this.m_maxTorque===undefined) this.m_maxTorque = 0;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_invMassA===undefined) this.m_invMassA = 0;
            if(this.m_invMassB===undefined) this.m_invMassB = 0;
            if(this.m_invIA===undefined) this.m_invIA = 0;
            if(this.m_invIB===undefined) this.m_invIB = 0;
            if(this.m_angularMass===undefined) this.m_angularMass = 0;
            this.m_localAnchorA = new org.jbox2d.common.Vec2(def.localAnchorA);
            this.m_localAnchorB = new org.jbox2d.common.Vec2(def.localAnchorB);
            this.m_linearImpulse = new org.jbox2d.common.Vec2();
            this.m_angularImpulse = 0.0;
            this.m_maxForce = def.maxForce;
            this.m_maxTorque = def.maxTorque;
        }

        public getLocalAnchorA() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorA;
        }

        public getLocalAnchorB() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorB;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, argOut);
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, argOut);
        }

        /**
         * 
         * @param {number} inv_dt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(inv_dt : number, argOut : org.jbox2d.common.Vec2) {
            argOut.set$org_jbox2d_common_Vec2(this.m_linearImpulse).mulLocal(inv_dt);
        }

        /**
         * 
         * @param {number} inv_dt
         * @return {number}
         */
        public getReactionTorque(inv_dt : number) : number {
            return (<any>Math).fround(inv_dt * this.m_angularImpulse);
        }

        public setMaxForce(force : number) {
            this.m_maxForce = force;
        }

        public getMaxForce() : number {
            return this.m_maxForce;
        }

        public setMaxTorque(torque : number) {
            this.m_maxTorque = torque;
        }

        public getMaxTorque() : number {
            return this.m_maxTorque;
        }

        /**
         * @see org.jbox2d.dynamics.joints.Joint#initVelocityConstraints(org.jbox2d.dynamics.TimeStep)
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexA = this.m_bodyA.m_islandIndex;
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_localCenterA.set$org_jbox2d_common_Vec2(this.m_bodyA.m_sweep.localCenter);
            this.m_localCenterB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            let aA : number = data.positions[this.m_indexA].a;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), this.m_rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), this.m_rB);
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            let K : org.jbox2d.common.Mat22 = this.pool.popMat22();
            K.ex.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * this.m_rA.y) * this.m_rA.y)) + (<any>Math).fround((<any>Math).fround(iB * this.m_rB.y) * this.m_rB.y));
            K.ex.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-iA * this.m_rA.x) * this.m_rA.y) - (<any>Math).fround((<any>Math).fround(iB * this.m_rB.x) * this.m_rB.y));
            K.ey.x = K.ex.y;
            K.ey.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * this.m_rA.x) * this.m_rA.x)) + (<any>Math).fround((<any>Math).fround(iB * this.m_rB.x) * this.m_rB.x));
            K.invertToOut(this.m_linearMass);
            this.m_angularMass = (<any>Math).fround(iA + iB);
            if(this.m_angularMass > 0.0) {
                this.m_angularMass = (<any>Math).fround(1.0 / this.m_angularMass);
            }
            if(data.step.warmStarting) {
                this.m_linearImpulse.mulLocal(data.step.dtRatio);
                this.m_angularImpulse *= data.step.dtRatio;
                let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
                P.set$org_jbox2d_common_Vec2(this.m_linearImpulse);
                temp.set$org_jbox2d_common_Vec2(P).mulLocal(mA);
                vA.subLocal(temp);
                wA -= (<any>Math).fround(iA * ((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, P) + this.m_angularImpulse)));
                temp.set$org_jbox2d_common_Vec2(P).mulLocal(mB);
                vB.addLocal$org_jbox2d_common_Vec2(temp);
                wB += (<any>Math).fround(iB * ((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, P) + this.m_angularImpulse)));
                this.pool.pushVec2(1);
            } else {
                this.m_linearImpulse.setZero();
                this.m_angularImpulse = 0.0;
            }
            if(data.velocities[this.m_indexA].w !== wA) {
            }
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushRot(2);
            this.pool.pushVec2(1);
            this.pool.pushMat22(1);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            let h : number = data.step.dt;
            {
                let Cdot : number = (<any>Math).fround(wB - wA);
                let impulse : number = (<any>Math).fround(-this.m_angularMass * Cdot);
                let oldImpulse : number = this.m_angularImpulse;
                let maxImpulse : number = (<any>Math).fround(h * this.m_maxTorque);
                this.m_angularImpulse = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(this.m_angularImpulse + impulse), -maxImpulse, maxImpulse);
                impulse = (<any>Math).fround(this.m_angularImpulse - oldImpulse);
                wA -= (<any>Math).fround(iA * impulse);
                wB += (<any>Math).fround(iB * impulse);
            };
            {
                let Cdot : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
                org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wA, this.m_rA, temp);
                org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wB, this.m_rB, Cdot);
                Cdot.addLocal$org_jbox2d_common_Vec2(vB).subLocal(vA).subLocal(temp);
                let impulse : org.jbox2d.common.Vec2 = this.pool.popVec2();
                org.jbox2d.common.Mat22.mulToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_linearMass, Cdot, impulse);
                impulse.negateLocal();
                let oldImpulse : org.jbox2d.common.Vec2 = this.pool.popVec2();
                oldImpulse.set$org_jbox2d_common_Vec2(this.m_linearImpulse);
                this.m_linearImpulse.addLocal$org_jbox2d_common_Vec2(impulse);
                let maxImpulse : number = (<any>Math).fround(h * this.m_maxForce);
                if(this.m_linearImpulse.lengthSquared() > (<any>Math).fround(maxImpulse * maxImpulse)) {
                    this.m_linearImpulse.normalize();
                    this.m_linearImpulse.mulLocal(maxImpulse);
                }
                impulse.set$org_jbox2d_common_Vec2(this.m_linearImpulse).subLocal(oldImpulse);
                temp.set$org_jbox2d_common_Vec2(impulse).mulLocal(mA);
                vA.subLocal(temp);
                wA -= (<any>Math).fround(iA * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, impulse));
                temp.set$org_jbox2d_common_Vec2(impulse).mulLocal(mB);
                vB.addLocal$org_jbox2d_common_Vec2(temp);
                wB += (<any>Math).fround(iB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, impulse));
            };
            if(data.velocities[this.m_indexA].w !== wA) {
            }
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(4);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            return true;
        }
    }
    FrictionJoint["__class"] = "org.jbox2d.dynamics.joints.FrictionJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A gear joint is used to connect two joints together. Either joint can be a revolute or prismatic
     * joint. You specify a gear ratio to bind the motions together: coordinate1 + ratio * coordinate2 =
     * constant The ratio can be negative or positive. If one joint is a revolute joint and the other
     * joint is a prismatic joint, then the ratio will have units of length or units of 1/length.
     * 
     * @warning The revolute and prismatic joints must be attached to fixed bodies (which must be body1
     * on those joints).
     * @warning You have to manually destroy the gear joint if joint1 or joint2 is destroyed.
     * @author Daniel Murphy
     * @extends org.jbox2d.dynamics.joints.Joint
     * @class
     */
    export class GearJoint extends org.jbox2d.dynamics.joints.Joint {
        /*private*/ m_joint1 : org.jbox2d.dynamics.joints.Joint;

        /*private*/ m_joint2 : org.jbox2d.dynamics.joints.Joint;

        /*private*/ m_typeA : org.jbox2d.dynamics.joints.JointType;

        /*private*/ m_typeB : org.jbox2d.dynamics.joints.JointType;

        /*private*/ m_bodyC : org.jbox2d.dynamics.Body;

        /*private*/ m_bodyD : org.jbox2d.dynamics.Body;

        /*private*/ m_localAnchorA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localAnchorB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localAnchorC : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localAnchorD : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localAxisC : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localAxisD : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_referenceAngleA : number;

        /*private*/ m_referenceAngleB : number;

        /*private*/ m_constant : number;

        /*private*/ m_ratio : number;

        /*private*/ m_impulse : number;

        /*private*/ m_indexA : number;

        /*private*/ m_indexB : number;

        /*private*/ m_indexC : number;

        /*private*/ m_indexD : number;

        /*private*/ m_lcA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_lcB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_lcC : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_lcD : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_mA : number;

        /*private*/ m_mB : number;

        /*private*/ m_mC : number;

        /*private*/ m_mD : number;

        /*private*/ m_iA : number;

        /*private*/ m_iB : number;

        /*private*/ m_iC : number;

        /*private*/ m_iD : number;

        /*private*/ m_JvAC : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_JvBD : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_JwA : number;

        /*private*/ m_JwB : number;

        /*private*/ m_JwC : number;

        /*private*/ m_JwD : number;

        /*private*/ m_mass : number;

        constructor(argWorldPool : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.GearJointDef) {
            super(argWorldPool, def);
            if(this.m_joint1===undefined) this.m_joint1 = null;
            if(this.m_joint2===undefined) this.m_joint2 = null;
            if(this.m_typeA===undefined) this.m_typeA = null;
            if(this.m_typeB===undefined) this.m_typeB = null;
            if(this.m_bodyC===undefined) this.m_bodyC = null;
            if(this.m_bodyD===undefined) this.m_bodyD = null;
            if(this.m_referenceAngleA===undefined) this.m_referenceAngleA = 0;
            if(this.m_referenceAngleB===undefined) this.m_referenceAngleB = 0;
            if(this.m_constant===undefined) this.m_constant = 0;
            if(this.m_ratio===undefined) this.m_ratio = 0;
            if(this.m_impulse===undefined) this.m_impulse = 0;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_indexC===undefined) this.m_indexC = 0;
            if(this.m_indexD===undefined) this.m_indexD = 0;
            if(this.m_mA===undefined) this.m_mA = 0;
            if(this.m_mB===undefined) this.m_mB = 0;
            if(this.m_mC===undefined) this.m_mC = 0;
            if(this.m_mD===undefined) this.m_mD = 0;
            if(this.m_iA===undefined) this.m_iA = 0;
            if(this.m_iB===undefined) this.m_iB = 0;
            if(this.m_iC===undefined) this.m_iC = 0;
            if(this.m_iD===undefined) this.m_iD = 0;
            if(this.m_JwA===undefined) this.m_JwA = 0;
            if(this.m_JwB===undefined) this.m_JwB = 0;
            if(this.m_JwC===undefined) this.m_JwC = 0;
            if(this.m_JwD===undefined) this.m_JwD = 0;
            if(this.m_mass===undefined) this.m_mass = 0;
            this.m_joint1 = def.joint1;
            this.m_joint2 = def.joint2;
            this.m_typeA = this.m_joint1.getType();
            this.m_typeB = this.m_joint2.getType();
            let coordinateA : number;
            let coordinateB : number;
            this.m_bodyC = this.m_joint1.getBodyA();
            this.m_bodyA = this.m_joint1.getBodyB();
            let xfA : org.jbox2d.common.Transform = this.m_bodyA.m_xf;
            let aA : number = this.m_bodyA.m_sweep.a;
            let xfC : org.jbox2d.common.Transform = this.m_bodyC.m_xf;
            let aC : number = this.m_bodyC.m_sweep.a;
            if(this.m_typeA === org.jbox2d.dynamics.joints.JointType.REVOLUTE) {
                let revolute : org.jbox2d.dynamics.joints.RevoluteJoint = <org.jbox2d.dynamics.joints.RevoluteJoint>def.joint1;
                this.m_localAnchorC.set$org_jbox2d_common_Vec2(revolute.m_localAnchorA);
                this.m_localAnchorA.set$org_jbox2d_common_Vec2(revolute.m_localAnchorB);
                this.m_referenceAngleA = revolute.m_referenceAngle;
                this.m_localAxisC.setZero();
                coordinateA = (<any>Math).fround((<any>Math).fround(aA - aC) - this.m_referenceAngleA);
            } else {
                let pA : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let prismatic : org.jbox2d.dynamics.joints.PrismaticJoint = <org.jbox2d.dynamics.joints.PrismaticJoint>def.joint1;
                this.m_localAnchorC.set$org_jbox2d_common_Vec2(prismatic.m_localAnchorA);
                this.m_localAnchorA.set$org_jbox2d_common_Vec2(prismatic.m_localAnchorB);
                this.m_referenceAngleA = prismatic.m_referenceAngle;
                this.m_localAxisC.set$org_jbox2d_common_Vec2(prismatic.m_localXAxisA);
                let pC : org.jbox2d.common.Vec2 = this.m_localAnchorC;
                org.jbox2d.common.Rot.mulToOutUnsafe(xfA.q, this.m_localAnchorA, temp);
                temp.addLocal$org_jbox2d_common_Vec2(xfA.p).subLocal(xfC.p);
                org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xfC.q, temp, pA);
                coordinateA = org.jbox2d.common.Vec2.dot(pA.subLocal(pC), this.m_localAxisC);
                this.pool.pushVec2(2);
            }
            this.m_bodyD = this.m_joint2.getBodyA();
            this.m_bodyB = this.m_joint2.getBodyB();
            let xfB : org.jbox2d.common.Transform = this.m_bodyB.m_xf;
            let aB : number = this.m_bodyB.m_sweep.a;
            let xfD : org.jbox2d.common.Transform = this.m_bodyD.m_xf;
            let aD : number = this.m_bodyD.m_sweep.a;
            if(this.m_typeB === org.jbox2d.dynamics.joints.JointType.REVOLUTE) {
                let revolute : org.jbox2d.dynamics.joints.RevoluteJoint = <org.jbox2d.dynamics.joints.RevoluteJoint>def.joint2;
                this.m_localAnchorD.set$org_jbox2d_common_Vec2(revolute.m_localAnchorA);
                this.m_localAnchorB.set$org_jbox2d_common_Vec2(revolute.m_localAnchorB);
                this.m_referenceAngleB = revolute.m_referenceAngle;
                this.m_localAxisD.setZero();
                coordinateB = (<any>Math).fround((<any>Math).fround(aB - aD) - this.m_referenceAngleB);
            } else {
                let pB : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let prismatic : org.jbox2d.dynamics.joints.PrismaticJoint = <org.jbox2d.dynamics.joints.PrismaticJoint>def.joint2;
                this.m_localAnchorD.set$org_jbox2d_common_Vec2(prismatic.m_localAnchorA);
                this.m_localAnchorB.set$org_jbox2d_common_Vec2(prismatic.m_localAnchorB);
                this.m_referenceAngleB = prismatic.m_referenceAngle;
                this.m_localAxisD.set$org_jbox2d_common_Vec2(prismatic.m_localXAxisA);
                let pD : org.jbox2d.common.Vec2 = this.m_localAnchorD;
                org.jbox2d.common.Rot.mulToOutUnsafe(xfB.q, this.m_localAnchorB, temp);
                temp.addLocal$org_jbox2d_common_Vec2(xfB.p).subLocal(xfD.p);
                org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xfD.q, temp, pB);
                coordinateB = org.jbox2d.common.Vec2.dot(pB.subLocal(pD), this.m_localAxisD);
                this.pool.pushVec2(2);
            }
            this.m_ratio = def.ratio;
            this.m_constant = (<any>Math).fround(coordinateA + (<any>Math).fround(this.m_ratio * coordinateB));
            this.m_impulse = 0.0;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, argOut);
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, argOut);
        }

        /**
         * 
         * @param {number} inv_dt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(inv_dt : number, argOut : org.jbox2d.common.Vec2) {
            argOut.set$org_jbox2d_common_Vec2(this.m_JvAC).mulLocal(this.m_impulse);
            argOut.mulLocal(inv_dt);
        }

        /**
         * 
         * @param {number} inv_dt
         * @return {number}
         */
        public getReactionTorque(inv_dt : number) : number {
            let L : number = (<any>Math).fround(this.m_impulse * this.m_JwA);
            return (<any>Math).fround(inv_dt * L);
        }

        public setRatio(argRatio : number) {
            this.m_ratio = argRatio;
        }

        public getRatio() : number {
            return this.m_ratio;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexA = this.m_bodyA.m_islandIndex;
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_indexC = this.m_bodyC.m_islandIndex;
            this.m_indexD = this.m_bodyD.m_islandIndex;
            this.m_lcA.set$org_jbox2d_common_Vec2(this.m_bodyA.m_sweep.localCenter);
            this.m_lcB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_lcC.set$org_jbox2d_common_Vec2(this.m_bodyC.m_sweep.localCenter);
            this.m_lcD.set$org_jbox2d_common_Vec2(this.m_bodyD.m_sweep.localCenter);
            this.m_mA = this.m_bodyA.m_invMass;
            this.m_mB = this.m_bodyB.m_invMass;
            this.m_mC = this.m_bodyC.m_invMass;
            this.m_mD = this.m_bodyD.m_invMass;
            this.m_iA = this.m_bodyA.m_invI;
            this.m_iB = this.m_bodyB.m_invI;
            this.m_iC = this.m_bodyC.m_invI;
            this.m_iD = this.m_bodyD.m_invI;
            let aA : number = data.positions[this.m_indexA].a;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let aC : number = data.positions[this.m_indexC].a;
            let vC : org.jbox2d.common.Vec2 = data.velocities[this.m_indexC].v;
            let wC : number = data.velocities[this.m_indexC].w;
            let aD : number = data.positions[this.m_indexD].a;
            let vD : org.jbox2d.common.Vec2 = data.velocities[this.m_indexD].v;
            let wD : number = data.velocities[this.m_indexD].w;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let qC : org.jbox2d.common.Rot = this.pool.popRot();
            let qD : org.jbox2d.common.Rot = this.pool.popRot();
            qA.set$float(aA);
            qB.set$float(aB);
            qC.set$float(aC);
            qD.set$float(aD);
            this.m_mass = 0.0;
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            if(this.m_typeA === org.jbox2d.dynamics.joints.JointType.REVOLUTE) {
                this.m_JvAC.setZero();
                this.m_JwA = 1.0;
                this.m_JwC = 1.0;
                this.m_mass += (<any>Math).fround(this.m_iA + this.m_iC);
            } else {
                let rC : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let rA : org.jbox2d.common.Vec2 = this.pool.popVec2();
                org.jbox2d.common.Rot.mulToOutUnsafe(qC, this.m_localAxisC, this.m_JvAC);
                org.jbox2d.common.Rot.mulToOutUnsafe(qC, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorC).subLocal(this.m_lcC), rC);
                org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_lcA), rA);
                this.m_JwC = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rC, this.m_JvAC);
                this.m_JwA = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rA, this.m_JvAC);
                this.m_mass += (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_mC + this.m_mA) + (<any>Math).fround((<any>Math).fround(this.m_iC * this.m_JwC) * this.m_JwC)) + (<any>Math).fround((<any>Math).fround(this.m_iA * this.m_JwA) * this.m_JwA));
                this.pool.pushVec2(2);
            }
            if(this.m_typeB === org.jbox2d.dynamics.joints.JointType.REVOLUTE) {
                this.m_JvBD.setZero();
                this.m_JwB = this.m_ratio;
                this.m_JwD = this.m_ratio;
                this.m_mass += (<any>Math).fround((<any>Math).fround(this.m_ratio * this.m_ratio) * ((<any>Math).fround(this.m_iB + this.m_iD)));
            } else {
                let u : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let rD : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let rB : org.jbox2d.common.Vec2 = this.pool.popVec2();
                org.jbox2d.common.Rot.mulToOutUnsafe(qD, this.m_localAxisD, u);
                org.jbox2d.common.Rot.mulToOutUnsafe(qD, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorD).subLocal(this.m_lcD), rD);
                org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_lcB), rB);
                this.m_JvBD.set$org_jbox2d_common_Vec2(u).mulLocal(this.m_ratio);
                this.m_JwD = (<any>Math).fround(this.m_ratio * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rD, u));
                this.m_JwB = (<any>Math).fround(this.m_ratio * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, u));
                this.m_mass += (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_ratio * this.m_ratio) * ((<any>Math).fround(this.m_mD + this.m_mB))) + (<any>Math).fround((<any>Math).fround(this.m_iD * this.m_JwD) * this.m_JwD)) + (<any>Math).fround((<any>Math).fround(this.m_iB * this.m_JwB) * this.m_JwB));
                this.pool.pushVec2(3);
            }
            this.m_mass = this.m_mass > 0.0?(<any>Math).fround(1.0 / this.m_mass):0.0;
            if(data.step.warmStarting) {
                vA.x += (<any>Math).fround(((<any>Math).fround(this.m_mA * this.m_impulse)) * this.m_JvAC.x);
                vA.y += (<any>Math).fround(((<any>Math).fround(this.m_mA * this.m_impulse)) * this.m_JvAC.y);
                wA += (<any>Math).fround((<any>Math).fround(this.m_iA * this.m_impulse) * this.m_JwA);
                vB.x += (<any>Math).fround(((<any>Math).fround(this.m_mB * this.m_impulse)) * this.m_JvBD.x);
                vB.y += (<any>Math).fround(((<any>Math).fround(this.m_mB * this.m_impulse)) * this.m_JvBD.y);
                wB += (<any>Math).fround((<any>Math).fround(this.m_iB * this.m_impulse) * this.m_JwB);
                vC.x -= (<any>Math).fround(((<any>Math).fround(this.m_mC * this.m_impulse)) * this.m_JvAC.x);
                vC.y -= (<any>Math).fround(((<any>Math).fround(this.m_mC * this.m_impulse)) * this.m_JvAC.y);
                wC -= (<any>Math).fround((<any>Math).fround(this.m_iC * this.m_impulse) * this.m_JwC);
                vD.x -= (<any>Math).fround(((<any>Math).fround(this.m_mD * this.m_impulse)) * this.m_JvBD.x);
                vD.y -= (<any>Math).fround(((<any>Math).fround(this.m_mD * this.m_impulse)) * this.m_JvBD.y);
                wD -= (<any>Math).fround((<any>Math).fround(this.m_iD * this.m_impulse) * this.m_JwD);
            } else {
                this.m_impulse = 0.0;
            }
            this.pool.pushVec2(1);
            this.pool.pushRot(4);
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            data.velocities[this.m_indexC].w = wC;
            data.velocities[this.m_indexD].w = wD;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let vC : org.jbox2d.common.Vec2 = data.velocities[this.m_indexC].v;
            let wC : number = data.velocities[this.m_indexC].w;
            let vD : org.jbox2d.common.Vec2 = data.velocities[this.m_indexD].v;
            let wD : number = data.velocities[this.m_indexD].w;
            let temp1 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let temp2 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let Cdot : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(this.m_JvAC, temp1.set$org_jbox2d_common_Vec2(vA).subLocal(vC)) + org.jbox2d.common.Vec2.dot(this.m_JvBD, temp2.set$org_jbox2d_common_Vec2(vB).subLocal(vD)));
            Cdot += (<any>Math).fround(((<any>Math).fround((<any>Math).fround(this.m_JwA * wA) - (<any>Math).fround(this.m_JwC * wC))) + ((<any>Math).fround((<any>Math).fround(this.m_JwB * wB) - (<any>Math).fround(this.m_JwD * wD))));
            this.pool.pushVec2(2);
            let impulse : number = (<any>Math).fround(-this.m_mass * Cdot);
            this.m_impulse += impulse;
            vA.x += (<any>Math).fround(((<any>Math).fround(this.m_mA * impulse)) * this.m_JvAC.x);
            vA.y += (<any>Math).fround(((<any>Math).fround(this.m_mA * impulse)) * this.m_JvAC.y);
            wA += (<any>Math).fround((<any>Math).fround(this.m_iA * impulse) * this.m_JwA);
            vB.x += (<any>Math).fround(((<any>Math).fround(this.m_mB * impulse)) * this.m_JvBD.x);
            vB.y += (<any>Math).fround(((<any>Math).fround(this.m_mB * impulse)) * this.m_JvBD.y);
            wB += (<any>Math).fround((<any>Math).fround(this.m_iB * impulse) * this.m_JwB);
            vC.x -= (<any>Math).fround(((<any>Math).fround(this.m_mC * impulse)) * this.m_JvAC.x);
            vC.y -= (<any>Math).fround(((<any>Math).fround(this.m_mC * impulse)) * this.m_JvAC.y);
            wC -= (<any>Math).fround((<any>Math).fround(this.m_iC * impulse) * this.m_JwC);
            vD.x -= (<any>Math).fround(((<any>Math).fround(this.m_mD * impulse)) * this.m_JvBD.x);
            vD.y -= (<any>Math).fround(((<any>Math).fround(this.m_mD * impulse)) * this.m_JvBD.y);
            wD -= (<any>Math).fround((<any>Math).fround(this.m_iD * impulse) * this.m_JwD);
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            data.velocities[this.m_indexC].w = wC;
            data.velocities[this.m_indexD].w = wD;
        }

        public getJoint1() : org.jbox2d.dynamics.joints.Joint {
            return this.m_joint1;
        }

        public getJoint2() : org.jbox2d.dynamics.joints.Joint {
            return this.m_joint2;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let cC : org.jbox2d.common.Vec2 = data.positions[this.m_indexC].c;
            let aC : number = data.positions[this.m_indexC].a;
            let cD : org.jbox2d.common.Vec2 = data.positions[this.m_indexD].c;
            let aD : number = data.positions[this.m_indexD].a;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let qC : org.jbox2d.common.Rot = this.pool.popRot();
            let qD : org.jbox2d.common.Rot = this.pool.popRot();
            qA.set$float(aA);
            qB.set$float(aB);
            qC.set$float(aC);
            qD.set$float(aD);
            let linearError : number = 0.0;
            let coordinateA : number;
            let coordinateB : number;
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let JvAC : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let JvBD : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let JwA : number;
            let JwB : number;
            let JwC : number;
            let JwD : number;
            let mass : number = 0.0;
            if(this.m_typeA === org.jbox2d.dynamics.joints.JointType.REVOLUTE) {
                JvAC.setZero();
                JwA = 1.0;
                JwC = 1.0;
                mass += (<any>Math).fround(this.m_iA + this.m_iC);
                coordinateA = (<any>Math).fround((<any>Math).fround(aA - aC) - this.m_referenceAngleA);
            } else {
                let rC : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let rA : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let pC : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let pA : org.jbox2d.common.Vec2 = this.pool.popVec2();
                org.jbox2d.common.Rot.mulToOutUnsafe(qC, this.m_localAxisC, JvAC);
                org.jbox2d.common.Rot.mulToOutUnsafe(qC, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorC).subLocal(this.m_lcC), rC);
                org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_lcA), rA);
                JwC = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rC, JvAC);
                JwA = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rA, JvAC);
                mass += (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_mC + this.m_mA) + (<any>Math).fround((<any>Math).fround(this.m_iC * JwC) * JwC)) + (<any>Math).fround((<any>Math).fround(this.m_iA * JwA) * JwA));
                pC.set$org_jbox2d_common_Vec2(this.m_localAnchorC).subLocal(this.m_lcC);
                org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(qC, temp.set$org_jbox2d_common_Vec2(rA).addLocal$org_jbox2d_common_Vec2(cA).subLocal(cC), pA);
                coordinateA = org.jbox2d.common.Vec2.dot(pA.subLocal(pC), this.m_localAxisC);
                this.pool.pushVec2(4);
            }
            if(this.m_typeB === org.jbox2d.dynamics.joints.JointType.REVOLUTE) {
                JvBD.setZero();
                JwB = this.m_ratio;
                JwD = this.m_ratio;
                mass += (<any>Math).fround((<any>Math).fround(this.m_ratio * this.m_ratio) * ((<any>Math).fround(this.m_iB + this.m_iD)));
                coordinateB = (<any>Math).fround((<any>Math).fround(aB - aD) - this.m_referenceAngleB);
            } else {
                let u : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let rD : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let rB : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let pD : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let pB : org.jbox2d.common.Vec2 = this.pool.popVec2();
                org.jbox2d.common.Rot.mulToOutUnsafe(qD, this.m_localAxisD, u);
                org.jbox2d.common.Rot.mulToOutUnsafe(qD, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorD).subLocal(this.m_lcD), rD);
                org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_lcB), rB);
                JvBD.set$org_jbox2d_common_Vec2(u).mulLocal(this.m_ratio);
                JwD = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rD, u);
                JwB = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, u);
                mass += (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_ratio * this.m_ratio) * ((<any>Math).fround(this.m_mD + this.m_mB))) + (<any>Math).fround((<any>Math).fround(this.m_iD * JwD) * JwD)) + (<any>Math).fround((<any>Math).fround(this.m_iB * JwB) * JwB));
                pD.set$org_jbox2d_common_Vec2(this.m_localAnchorD).subLocal(this.m_lcD);
                org.jbox2d.common.Rot.mulTransUnsafe$org_jbox2d_common_Rot$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(qD, temp.set$org_jbox2d_common_Vec2(rB).addLocal$org_jbox2d_common_Vec2(cB).subLocal(cD), pB);
                coordinateB = org.jbox2d.common.Vec2.dot(pB.subLocal(pD), this.m_localAxisD);
                this.pool.pushVec2(5);
            }
            let C : number = (<any>Math).fround(((<any>Math).fround(coordinateA + (<any>Math).fround(this.m_ratio * coordinateB))) - this.m_constant);
            let impulse : number = 0.0;
            if(mass > 0.0) {
                impulse = (<any>Math).fround(-C / mass);
            }
            this.pool.pushVec2(3);
            this.pool.pushRot(4);
            cA.x += (<any>Math).fround(((<any>Math).fround(this.m_mA * impulse)) * JvAC.x);
            cA.y += (<any>Math).fround(((<any>Math).fround(this.m_mA * impulse)) * JvAC.y);
            aA += (<any>Math).fround((<any>Math).fround(this.m_iA * impulse) * JwA);
            cB.x += (<any>Math).fround(((<any>Math).fround(this.m_mB * impulse)) * JvBD.x);
            cB.y += (<any>Math).fround(((<any>Math).fround(this.m_mB * impulse)) * JvBD.y);
            aB += (<any>Math).fround((<any>Math).fround(this.m_iB * impulse) * JwB);
            cC.x -= (<any>Math).fround(((<any>Math).fround(this.m_mC * impulse)) * JvAC.x);
            cC.y -= (<any>Math).fround(((<any>Math).fround(this.m_mC * impulse)) * JvAC.y);
            aC -= (<any>Math).fround((<any>Math).fround(this.m_iC * impulse) * JwC);
            cD.x -= (<any>Math).fround(((<any>Math).fround(this.m_mD * impulse)) * JvBD.x);
            cD.y -= (<any>Math).fround(((<any>Math).fround(this.m_mD * impulse)) * JvBD.y);
            aD -= (<any>Math).fround((<any>Math).fround(this.m_iD * impulse) * JwD);
            data.positions[this.m_indexA].a = aA;
            data.positions[this.m_indexB].a = aB;
            data.positions[this.m_indexC].a = aC;
            data.positions[this.m_indexD].a = aD;
            return linearError < org.jbox2d.common.Settings.linearSlop;
        }
    }
    GearJoint["__class"] = "org.jbox2d.dynamics.joints.GearJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A motor joint is used to control the relative motion between two bodies. A typical usage is to
     * control the movement of a dynamic body with respect to the ground.
     * 
     * @author dmurph
     * @param {*} pool
     * @param {org.jbox2d.dynamics.joints.MotorJointDef} def
     * @class
     * @extends org.jbox2d.dynamics.joints.Joint
     */
    export class MotorJoint extends org.jbox2d.dynamics.joints.Joint {
        /*private*/ m_linearOffset : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_angularOffset : number;

        /*private*/ m_linearImpulse : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_angularImpulse : number;

        /*private*/ m_maxForce : number;

        /*private*/ m_maxTorque : number;

        /*private*/ m_correctionFactor : number;

        /*private*/ m_indexA : number;

        /*private*/ m_indexB : number;

        /*private*/ m_rA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_rB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_linearError : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_angularError : number;

        /*private*/ m_invMassA : number;

        /*private*/ m_invMassB : number;

        /*private*/ m_invIA : number;

        /*private*/ m_invIB : number;

        /*private*/ m_linearMass : org.jbox2d.common.Mat22 = new org.jbox2d.common.Mat22();

        /*private*/ m_angularMass : number;

        public constructor(pool : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.MotorJointDef) {
            super(pool, def);
            if(this.m_angularOffset===undefined) this.m_angularOffset = 0;
            if(this.m_angularImpulse===undefined) this.m_angularImpulse = 0;
            if(this.m_maxForce===undefined) this.m_maxForce = 0;
            if(this.m_maxTorque===undefined) this.m_maxTorque = 0;
            if(this.m_correctionFactor===undefined) this.m_correctionFactor = 0;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_angularError===undefined) this.m_angularError = 0;
            if(this.m_invMassA===undefined) this.m_invMassA = 0;
            if(this.m_invMassB===undefined) this.m_invMassB = 0;
            if(this.m_invIA===undefined) this.m_invIA = 0;
            if(this.m_invIB===undefined) this.m_invIB = 0;
            if(this.m_angularMass===undefined) this.m_angularMass = 0;
            this.m_linearOffset.set$org_jbox2d_common_Vec2(def.linearOffset);
            this.m_angularOffset = def.angularOffset;
            this.m_angularImpulse = 0.0;
            this.m_maxForce = def.maxForce;
            this.m_maxTorque = def.maxTorque;
            this.m_correctionFactor = def.correctionFactor;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} out
         */
        public getAnchorA(out : org.jbox2d.common.Vec2) {
            out.set$org_jbox2d_common_Vec2(this.m_bodyA.getPosition());
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} out
         */
        public getAnchorB(out : org.jbox2d.common.Vec2) {
            out.set$org_jbox2d_common_Vec2(this.m_bodyB.getPosition());
        }

        public getReactionForce(inv_dt : number, out : org.jbox2d.common.Vec2) {
            out.set$org_jbox2d_common_Vec2(this.m_linearImpulse).mulLocal(inv_dt);
        }

        public getReactionTorque(inv_dt : number) : number {
            return (<any>Math).fround(this.m_angularImpulse * inv_dt);
        }

        public getCorrectionFactor() : number {
            return this.m_correctionFactor;
        }

        public setCorrectionFactor(correctionFactor : number) {
            this.m_correctionFactor = correctionFactor;
        }

        /**
         * Set the target linear offset, in frame A, in meters.
         * @param {org.jbox2d.common.Vec2} linearOffset
         */
        public setLinearOffset(linearOffset : org.jbox2d.common.Vec2) {
            if(linearOffset.x !== this.m_linearOffset.x || linearOffset.y !== this.m_linearOffset.y) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_linearOffset.set$org_jbox2d_common_Vec2(linearOffset);
            }
        }

        public getLinearOffset$org_jbox2d_common_Vec2(out : org.jbox2d.common.Vec2) {
            out.set$org_jbox2d_common_Vec2(this.m_linearOffset);
        }

        /**
         * Get the target linear offset, in frame A, in meters.
         * @param {org.jbox2d.common.Vec2} out
         */
        public getLinearOffset(out? : any) : any {
            if(((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>this.getLinearOffset$org_jbox2d_common_Vec2(out);
            } else if(out === undefined) {
                return <any>this.getLinearOffset$();
            } else throw new Error('invalid overload');
        }

        public getLinearOffset$() : org.jbox2d.common.Vec2 {
            return this.m_linearOffset;
        }

        /**
         * Set the target angular offset, in radians.
         * 
         * @param {number} angularOffset
         */
        public setAngularOffset(angularOffset : number) {
            if(angularOffset !== this.m_angularOffset) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_angularOffset = angularOffset;
            }
        }

        public getAngularOffset() : number {
            return this.m_angularOffset;
        }

        /**
         * Set the maximum friction force in N.
         * 
         * @param {number} force
         */
        public setMaxForce(force : number) {
            this.m_maxForce = force;
        }

        /**
         * Get the maximum friction force in N.
         * @return {number}
         */
        public getMaxForce() : number {
            return this.m_maxForce;
        }

        /**
         * Set the maximum friction torque in N*m.
         * @param {number} torque
         */
        public setMaxTorque(torque : number) {
            this.m_maxTorque = torque;
        }

        /**
         * Get the maximum friction torque in N*m.
         * @return {number}
         */
        public getMaxTorque() : number {
            return this.m_maxTorque;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexA = this.m_bodyA.m_islandIndex;
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_localCenterA.set$org_jbox2d_common_Vec2(this.m_bodyA.m_sweep.localCenter);
            this.m_localCenterB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let K : org.jbox2d.common.Mat22 = this.pool.popMat22();
            qA.set$float(aA);
            qB.set$float(aB);
            this.m_rA.x = (<any>Math).fround((<any>Math).fround(qA.c * -this.m_localCenterA.x) - (<any>Math).fround(qA.s * -this.m_localCenterA.y));
            this.m_rA.y = (<any>Math).fround((<any>Math).fround(qA.s * -this.m_localCenterA.x) + (<any>Math).fround(qA.c * -this.m_localCenterA.y));
            this.m_rB.x = (<any>Math).fround((<any>Math).fround(qB.c * -this.m_localCenterB.x) - (<any>Math).fround(qB.s * -this.m_localCenterB.y));
            this.m_rB.y = (<any>Math).fround((<any>Math).fround(qB.s * -this.m_localCenterB.x) + (<any>Math).fround(qB.c * -this.m_localCenterB.y));
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            K.ex.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * this.m_rA.y) * this.m_rA.y)) + (<any>Math).fround((<any>Math).fround(iB * this.m_rB.y) * this.m_rB.y));
            K.ex.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-iA * this.m_rA.x) * this.m_rA.y) - (<any>Math).fround((<any>Math).fround(iB * this.m_rB.x) * this.m_rB.y));
            K.ey.x = K.ex.y;
            K.ey.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * this.m_rA.x) * this.m_rA.x)) + (<any>Math).fround((<any>Math).fround(iB * this.m_rB.x) * this.m_rB.x));
            K.invertToOut(this.m_linearMass);
            this.m_angularMass = (<any>Math).fround(iA + iB);
            if(this.m_angularMass > 0.0) {
                this.m_angularMass = (<any>Math).fround(1.0 / this.m_angularMass);
            }
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, this.m_linearOffset, temp);
            this.m_linearError.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(cB.x + this.m_rB.x) - cA.x) - this.m_rA.x) - temp.x);
            this.m_linearError.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(cB.y + this.m_rB.y) - cA.y) - this.m_rA.y) - temp.y);
            this.m_angularError = (<any>Math).fround((<any>Math).fround(aB - aA) - this.m_angularOffset);
            if(data.step.warmStarting) {
                this.m_linearImpulse.x *= data.step.dtRatio;
                this.m_linearImpulse.y *= data.step.dtRatio;
                this.m_angularImpulse *= data.step.dtRatio;
                let P : org.jbox2d.common.Vec2 = this.m_linearImpulse;
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_rA.x * P.y) - (<any>Math).fround(this.m_rA.y * P.x)) + this.m_angularImpulse)));
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_rB.x * P.y) - (<any>Math).fround(this.m_rB.y * P.x)) + this.m_angularImpulse)));
            } else {
                this.m_linearImpulse.setZero();
                this.m_angularImpulse = 0.0;
            }
            this.pool.pushVec2(1);
            this.pool.pushMat22(1);
            this.pool.pushRot(2);
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            let h : number = data.step.dt;
            let inv_h : number = data.step.inv_dt;
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            {
                let Cdot : number = (<any>Math).fround((<any>Math).fround(wB - wA) + (<any>Math).fround((<any>Math).fround(inv_h * this.m_correctionFactor) * this.m_angularError));
                let impulse : number = (<any>Math).fround(-this.m_angularMass * Cdot);
                let oldImpulse : number = this.m_angularImpulse;
                let maxImpulse : number = (<any>Math).fround(h * this.m_maxTorque);
                this.m_angularImpulse = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(this.m_angularImpulse + impulse), -maxImpulse, maxImpulse);
                impulse = (<any>Math).fround(this.m_angularImpulse - oldImpulse);
                wA -= (<any>Math).fround(iA * impulse);
                wB += (<any>Math).fround(iB * impulse);
            };
            let Cdot : org.jbox2d.common.Vec2 = this.pool.popVec2();
            {
                Cdot.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(vB.x + (<any>Math).fround(-wB * this.m_rB.y)) - vA.x) - (<any>Math).fround(-wA * this.m_rA.y)) + (<any>Math).fround((<any>Math).fround(inv_h * this.m_correctionFactor) * this.m_linearError.x));
                Cdot.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(vB.y + (<any>Math).fround(wB * this.m_rB.x)) - vA.y) - (<any>Math).fround(wA * this.m_rA.x)) + (<any>Math).fround((<any>Math).fround(inv_h * this.m_correctionFactor) * this.m_linearError.y));
                let impulse : org.jbox2d.common.Vec2 = temp;
                org.jbox2d.common.Mat22.mulToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_linearMass, Cdot, impulse);
                impulse.negateLocal();
                let oldImpulse : org.jbox2d.common.Vec2 = this.pool.popVec2();
                oldImpulse.set$org_jbox2d_common_Vec2(this.m_linearImpulse);
                this.m_linearImpulse.addLocal$org_jbox2d_common_Vec2(impulse);
                let maxImpulse : number = (<any>Math).fround(h * this.m_maxForce);
                if(this.m_linearImpulse.lengthSquared() > (<any>Math).fround(maxImpulse * maxImpulse)) {
                    this.m_linearImpulse.normalize();
                    this.m_linearImpulse.mulLocal(maxImpulse);
                }
                impulse.x = (<any>Math).fround(this.m_linearImpulse.x - oldImpulse.x);
                impulse.y = (<any>Math).fround(this.m_linearImpulse.y - oldImpulse.y);
                vA.x -= (<any>Math).fround(mA * impulse.x);
                vA.y -= (<any>Math).fround(mA * impulse.y);
                wA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround(this.m_rA.x * impulse.y) - (<any>Math).fround(this.m_rA.y * impulse.x))));
                vB.x += (<any>Math).fround(mB * impulse.x);
                vB.y += (<any>Math).fround(mB * impulse.y);
                wB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround(this.m_rB.x * impulse.y) - (<any>Math).fround(this.m_rB.y * impulse.x))));
            };
            this.pool.pushVec2(3);
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            return true;
        }
    }
    MotorJoint["__class"] = "org.jbox2d.dynamics.joints.MotorJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A mouse joint is used to make a point on a body track a specified world point. This a soft
     * constraint with a maximum force. This allows the constraint to stretch and without applying huge
     * forces. NOTE: this joint is not documented in the manual because it was developed to be used in
     * the testbed. If you want to learn how to use the mouse joint, look at the testbed.
     * 
     * @author Daniel
     * @extends org.jbox2d.dynamics.joints.Joint
     * @class
     */
    export class MouseJoint extends org.jbox2d.dynamics.joints.Joint {
        /*private*/ m_localAnchorB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_targetA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_frequencyHz : number;

        /*private*/ m_dampingRatio : number;

        /*private*/ m_beta : number;

        /*private*/ m_impulse : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_maxForce : number;

        /*private*/ m_gamma : number;

        /*private*/ m_indexB : number;

        /*private*/ m_rB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_invMassB : number;

        /*private*/ m_invIB : number;

        /*private*/ m_mass : org.jbox2d.common.Mat22 = new org.jbox2d.common.Mat22();

        /*private*/ m_C : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        constructor(argWorld : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.MouseJointDef) {
            super(argWorld, def);
            if(this.m_frequencyHz===undefined) this.m_frequencyHz = 0;
            if(this.m_dampingRatio===undefined) this.m_dampingRatio = 0;
            if(this.m_beta===undefined) this.m_beta = 0;
            if(this.m_maxForce===undefined) this.m_maxForce = 0;
            if(this.m_gamma===undefined) this.m_gamma = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_invMassB===undefined) this.m_invMassB = 0;
            if(this.m_invIB===undefined) this.m_invIB = 0;
            this.m_targetA.set$org_jbox2d_common_Vec2(def.target);
            org.jbox2d.common.Transform.mulTransToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_bodyB.getTransform(), this.m_targetA, this.m_localAnchorB);
            this.m_maxForce = def.maxForce;
            this.m_impulse.setZero();
            this.m_frequencyHz = def.frequencyHz;
            this.m_dampingRatio = def.dampingRatio;
            this.m_beta = 0;
            this.m_gamma = 0;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
            argOut.set$org_jbox2d_common_Vec2(this.m_targetA);
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, argOut);
        }

        /**
         * 
         * @param {number} invDt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(invDt : number, argOut : org.jbox2d.common.Vec2) {
            argOut.set$org_jbox2d_common_Vec2(this.m_impulse).mulLocal(invDt);
        }

        /**
         * 
         * @param {number} invDt
         * @return {number}
         */
        public getReactionTorque(invDt : number) : number {
            return (<any>Math).fround(invDt * 0.0);
        }

        public setTarget(target : org.jbox2d.common.Vec2) {
            if(this.m_bodyB.isAwake() === false) {
                this.m_bodyB.setAwake(true);
            }
            this.m_targetA.set$org_jbox2d_common_Vec2(target);
        }

        public getTarget() : org.jbox2d.common.Vec2 {
            return this.m_targetA;
        }

        public setMaxForce(force : number) {
            this.m_maxForce = force;
        }

        public getMaxForce() : number {
            return this.m_maxForce;
        }

        public setFrequency(hz : number) {
            this.m_frequencyHz = hz;
        }

        public getFrequency() : number {
            return this.m_frequencyHz;
        }

        public setDampingRatio(ratio : number) {
            this.m_dampingRatio = ratio;
        }

        public getDampingRatio() : number {
            return this.m_dampingRatio;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_localCenterB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIB = this.m_bodyB.m_invI;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            qB.set$float(aB);
            let mass : number = this.m_bodyB.getMass();
            let omega : number = (<any>Math).fround((<any>Math).fround(2.0 * org.jbox2d.common.MathUtils.PI_$LI$()) * this.m_frequencyHz);
            let d : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(2.0 * mass) * this.m_dampingRatio) * omega);
            let k : number = (<any>Math).fround(mass * ((<any>Math).fround(omega * omega)));
            let h : number = data.step.dt;
            this.m_gamma = (<any>Math).fround(h * ((<any>Math).fround(d + (<any>Math).fround(h * k))));
            if(this.m_gamma !== 0.0) {
                this.m_gamma = (<any>Math).fround(1.0 / this.m_gamma);
            }
            this.m_beta = (<any>Math).fround((<any>Math).fround(h * k) * this.m_gamma);
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), this.m_rB);
            let K : org.jbox2d.common.Mat22 = this.pool.popMat22();
            K.ex.x = (<any>Math).fround((<any>Math).fround(this.m_invMassB + (<any>Math).fround((<any>Math).fround(this.m_invIB * this.m_rB.y) * this.m_rB.y)) + this.m_gamma);
            K.ex.y = (<any>Math).fround((<any>Math).fround(-this.m_invIB * this.m_rB.x) * this.m_rB.y);
            K.ey.x = K.ex.y;
            K.ey.y = (<any>Math).fround((<any>Math).fround(this.m_invMassB + (<any>Math).fround((<any>Math).fround(this.m_invIB * this.m_rB.x) * this.m_rB.x)) + this.m_gamma);
            K.invertToOut(this.m_mass);
            this.m_C.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(this.m_rB).subLocal(this.m_targetA);
            this.m_C.mulLocal(this.m_beta);
            wB *= 0.98;
            if(data.step.warmStarting) {
                this.m_impulse.mulLocal(data.step.dtRatio);
                vB.x += (<any>Math).fround(this.m_invMassB * this.m_impulse.x);
                vB.y += (<any>Math).fround(this.m_invMassB * this.m_impulse.y);
                wB += (<any>Math).fround(this.m_invIB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, this.m_impulse));
            } else {
                this.m_impulse.setZero();
            }
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(1);
            this.pool.pushMat22(1);
            this.pool.pushRot(1);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            return true;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let Cdot : org.jbox2d.common.Vec2 = this.pool.popVec2();
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wB, this.m_rB, Cdot);
            Cdot.addLocal$org_jbox2d_common_Vec2(vB);
            let impulse : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            temp.set$org_jbox2d_common_Vec2(this.m_impulse).mulLocal(this.m_gamma).addLocal$org_jbox2d_common_Vec2(this.m_C).addLocal$org_jbox2d_common_Vec2(Cdot).negateLocal();
            org.jbox2d.common.Mat22.mulToOutUnsafe$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_mass, temp, impulse);
            let oldImpulse : org.jbox2d.common.Vec2 = temp;
            oldImpulse.set$org_jbox2d_common_Vec2(this.m_impulse);
            this.m_impulse.addLocal$org_jbox2d_common_Vec2(impulse);
            let maxImpulse : number = (<any>Math).fround(data.step.dt * this.m_maxForce);
            if(this.m_impulse.lengthSquared() > (<any>Math).fround(maxImpulse * maxImpulse)) {
                this.m_impulse.mulLocal((<any>Math).fround(maxImpulse / this.m_impulse.length()));
            }
            impulse.set$org_jbox2d_common_Vec2(this.m_impulse).subLocal(oldImpulse);
            vB.x += (<any>Math).fround(this.m_invMassB * impulse.x);
            vB.y += (<any>Math).fround(this.m_invMassB * impulse.y);
            wB += (<any>Math).fround(this.m_invIB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, impulse));
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(3);
        }
    }
    MouseJoint["__class"] = "org.jbox2d.dynamics.joints.MouseJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A prismatic joint. This joint provides one degree of freedom: translation along an axis fixed in
     * bodyA. Relative rotation is prevented. You can use a joint limit to restrict the range of motion
     * and a joint motor to drive the motion or to model joint friction.
     * 
     * @author Daniel
     * @extends org.jbox2d.dynamics.joints.Joint
     * @class
     */
    export class PrismaticJoint extends org.jbox2d.dynamics.joints.Joint {
        m_localAnchorA : org.jbox2d.common.Vec2;

        m_localAnchorB : org.jbox2d.common.Vec2;

        m_localXAxisA : org.jbox2d.common.Vec2;

        m_localYAxisA : org.jbox2d.common.Vec2;

        m_referenceAngle : number;

        /*private*/ m_impulse : org.jbox2d.common.Vec3;

        /*private*/ m_motorImpulse : number;

        /*private*/ m_lowerTranslation : number;

        /*private*/ m_upperTranslation : number;

        /*private*/ m_maxMotorForce : number;

        /*private*/ m_motorSpeed : number;

        /*private*/ m_enableLimit : boolean;

        /*private*/ m_enableMotor : boolean;

        /*private*/ m_limitState : org.jbox2d.dynamics.joints.LimitState;

        /*private*/ m_indexA : number;

        /*private*/ m_indexB : number;

        /*private*/ m_localCenterA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_invMassA : number;

        /*private*/ m_invMassB : number;

        /*private*/ m_invIA : number;

        /*private*/ m_invIB : number;

        /*private*/ m_axis : org.jbox2d.common.Vec2;

        /*private*/ m_perp : org.jbox2d.common.Vec2;

        /*private*/ m_s1 : number;

        /*private*/ m_s2 : number;

        /*private*/ m_a1 : number;

        /*private*/ m_a2 : number;

        /*private*/ m_K : org.jbox2d.common.Mat33;

        /*private*/ m_motorMass : number;

        constructor(argWorld : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.PrismaticJointDef) {
            super(argWorld, def);
            if(this.m_localAnchorA===undefined) this.m_localAnchorA = null;
            if(this.m_localAnchorB===undefined) this.m_localAnchorB = null;
            if(this.m_localXAxisA===undefined) this.m_localXAxisA = null;
            if(this.m_localYAxisA===undefined) this.m_localYAxisA = null;
            if(this.m_referenceAngle===undefined) this.m_referenceAngle = 0;
            if(this.m_impulse===undefined) this.m_impulse = null;
            if(this.m_motorImpulse===undefined) this.m_motorImpulse = 0;
            if(this.m_lowerTranslation===undefined) this.m_lowerTranslation = 0;
            if(this.m_upperTranslation===undefined) this.m_upperTranslation = 0;
            if(this.m_maxMotorForce===undefined) this.m_maxMotorForce = 0;
            if(this.m_motorSpeed===undefined) this.m_motorSpeed = 0;
            if(this.m_enableLimit===undefined) this.m_enableLimit = false;
            if(this.m_enableMotor===undefined) this.m_enableMotor = false;
            if(this.m_limitState===undefined) this.m_limitState = null;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_invMassA===undefined) this.m_invMassA = 0;
            if(this.m_invMassB===undefined) this.m_invMassB = 0;
            if(this.m_invIA===undefined) this.m_invIA = 0;
            if(this.m_invIB===undefined) this.m_invIB = 0;
            if(this.m_axis===undefined) this.m_axis = null;
            if(this.m_perp===undefined) this.m_perp = null;
            if(this.m_s1===undefined) this.m_s1 = 0;
            if(this.m_s2===undefined) this.m_s2 = 0;
            if(this.m_a1===undefined) this.m_a1 = 0;
            if(this.m_a2===undefined) this.m_a2 = 0;
            if(this.m_K===undefined) this.m_K = null;
            if(this.m_motorMass===undefined) this.m_motorMass = 0;
            this.m_localAnchorA = new org.jbox2d.common.Vec2(def.localAnchorA);
            this.m_localAnchorB = new org.jbox2d.common.Vec2(def.localAnchorB);
            this.m_localXAxisA = new org.jbox2d.common.Vec2(def.localAxisA);
            this.m_localXAxisA.normalize();
            this.m_localYAxisA = new org.jbox2d.common.Vec2();
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(1.0, this.m_localXAxisA, this.m_localYAxisA);
            this.m_referenceAngle = def.referenceAngle;
            this.m_impulse = new org.jbox2d.common.Vec3();
            this.m_motorMass = 0.0;
            this.m_motorImpulse = 0.0;
            this.m_lowerTranslation = def.lowerTranslation;
            this.m_upperTranslation = def.upperTranslation;
            this.m_maxMotorForce = def.maxMotorForce;
            this.m_motorSpeed = def.motorSpeed;
            this.m_enableLimit = def.enableLimit;
            this.m_enableMotor = def.enableMotor;
            this.m_limitState = org.jbox2d.dynamics.joints.LimitState.INACTIVE;
            this.m_K = new org.jbox2d.common.Mat33();
            this.m_axis = new org.jbox2d.common.Vec2();
            this.m_perp = new org.jbox2d.common.Vec2();
        }

        public getLocalAnchorA() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorA;
        }

        public getLocalAnchorB() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorB;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, argOut);
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, argOut);
        }

        /**
         * 
         * @param {number} inv_dt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(inv_dt : number, argOut : org.jbox2d.common.Vec2) {
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            temp.set$org_jbox2d_common_Vec2(this.m_axis).mulLocal((<any>Math).fround(this.m_motorImpulse + this.m_impulse.z));
            argOut.set$org_jbox2d_common_Vec2(this.m_perp).mulLocal(this.m_impulse.x).addLocal$org_jbox2d_common_Vec2(temp).mulLocal(inv_dt);
            this.pool.pushVec2(1);
        }

        /**
         * 
         * @param {number} inv_dt
         * @return {number}
         */
        public getReactionTorque(inv_dt : number) : number {
            return (<any>Math).fround(inv_dt * this.m_impulse.y);
        }

        /**
         * Get the current joint translation, usually in meters.
         * @return {number}
         */
        public getJointSpeed() : number {
            let bA : org.jbox2d.dynamics.Body = this.m_bodyA;
            let bB : org.jbox2d.dynamics.Body = this.m_bodyB;
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let p1 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let p2 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let d : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let axis : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let temp2 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let temp3 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(bA.m_sweep.localCenter);
            org.jbox2d.common.Rot.mulToOutUnsafe(bA.m_xf.q, temp, rA);
            temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(bB.m_sweep.localCenter);
            org.jbox2d.common.Rot.mulToOutUnsafe(bB.m_xf.q, temp, rB);
            p1.set$org_jbox2d_common_Vec2(bA.m_sweep.c).addLocal$org_jbox2d_common_Vec2(rA);
            p2.set$org_jbox2d_common_Vec2(bB.m_sweep.c).addLocal$org_jbox2d_common_Vec2(rB);
            d.set$org_jbox2d_common_Vec2(p2).subLocal(p1);
            org.jbox2d.common.Rot.mulToOutUnsafe(bA.m_xf.q, this.m_localXAxisA, axis);
            let vA : org.jbox2d.common.Vec2 = bA.m_linearVelocity;
            let vB : org.jbox2d.common.Vec2 = bB.m_linearVelocity;
            let wA : number = bA.m_angularVelocity;
            let wB : number = bB.m_angularVelocity;
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wA, axis, temp);
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wB, rB, temp2);
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wA, rA, temp3);
            temp2.addLocal$org_jbox2d_common_Vec2(vB).subLocal(vA).subLocal(temp3);
            let speed : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(d, temp) + org.jbox2d.common.Vec2.dot(axis, temp2));
            this.pool.pushVec2(9);
            return speed;
        }

        public getJointTranslation() : number {
            let pA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let pB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let axis : org.jbox2d.common.Vec2 = this.pool.popVec2();
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, pA);
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, pB);
            this.m_bodyA.getWorldVectorToOutUnsafe(this.m_localXAxisA, axis);
            pB.subLocal(pA);
            let translation : number = org.jbox2d.common.Vec2.dot(pB, axis);
            this.pool.pushVec2(3);
            return translation;
        }

        /**
         * Is the joint limit enabled?
         * 
         * @return
         * @return {boolean}
         */
        public isLimitEnabled() : boolean {
            return this.m_enableLimit;
        }

        /**
         * Enable/disable the joint limit.
         * 
         * @param {boolean} flag
         */
        public enableLimit(flag : boolean) {
            if(flag !== this.m_enableLimit) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_enableLimit = flag;
                this.m_impulse.z = 0.0;
            }
        }

        /**
         * Get the lower joint limit, usually in meters.
         * 
         * @return
         * @return {number}
         */
        public getLowerLimit() : number {
            return this.m_lowerTranslation;
        }

        /**
         * Get the upper joint limit, usually in meters.
         * 
         * @return
         * @return {number}
         */
        public getUpperLimit() : number {
            return this.m_upperTranslation;
        }

        /**
         * Set the joint limits, usually in meters.
         * 
         * @param {number} lower
         * @param {number} upper
         */
        public setLimits(lower : number, upper : number) {
            if(lower !== this.m_lowerTranslation || upper !== this.m_upperTranslation) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_lowerTranslation = lower;
                this.m_upperTranslation = upper;
                this.m_impulse.z = 0.0;
            }
        }

        /**
         * Is the joint motor enabled?
         * 
         * @return
         * @return {boolean}
         */
        public isMotorEnabled() : boolean {
            return this.m_enableMotor;
        }

        /**
         * Enable/disable the joint motor.
         * 
         * @param {boolean} flag
         */
        public enableMotor(flag : boolean) {
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_enableMotor = flag;
        }

        /**
         * Set the motor speed, usually in meters per second.
         * 
         * @param {number} speed
         */
        public setMotorSpeed(speed : number) {
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_motorSpeed = speed;
        }

        /**
         * Get the motor speed, usually in meters per second.
         * 
         * @return
         * @return {number}
         */
        public getMotorSpeed() : number {
            return this.m_motorSpeed;
        }

        /**
         * Set the maximum motor force, usually in N.
         * 
         * @param {number} force
         */
        public setMaxMotorForce(force : number) {
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_maxMotorForce = force;
        }

        /**
         * Get the current motor force, usually in N.
         * 
         * @param {number} inv_dt
         * @return
         * @return {number}
         */
        public getMotorForce(inv_dt : number) : number {
            return (<any>Math).fround(this.m_motorImpulse * inv_dt);
        }

        public getMaxMotorForce() : number {
            return this.m_maxMotorForce;
        }

        public getReferenceAngle() : number {
            return this.m_referenceAngle;
        }

        public getLocalAxisA() : org.jbox2d.common.Vec2 {
            return this.m_localXAxisA;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexA = this.m_bodyA.m_islandIndex;
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_localCenterA.set$org_jbox2d_common_Vec2(this.m_bodyA.m_sweep.localCenter);
            this.m_localCenterB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let d : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, d.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, d.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), rB);
            d.set$org_jbox2d_common_Vec2(cB).subLocal(cA).addLocal$org_jbox2d_common_Vec2(rB).subLocal(rA);
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            {
                org.jbox2d.common.Rot.mulToOutUnsafe(qA, this.m_localXAxisA, this.m_axis);
                temp.set$org_jbox2d_common_Vec2(d).addLocal$org_jbox2d_common_Vec2(rA);
                this.m_a1 = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(temp, this.m_axis);
                this.m_a2 = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, this.m_axis);
                this.m_motorMass = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * this.m_a1) * this.m_a1)) + (<any>Math).fround((<any>Math).fround(iB * this.m_a2) * this.m_a2));
                if(this.m_motorMass > 0.0) {
                    this.m_motorMass = (<any>Math).fround(1.0 / this.m_motorMass);
                }
            };
            {
                org.jbox2d.common.Rot.mulToOutUnsafe(qA, this.m_localYAxisA, this.m_perp);
                temp.set$org_jbox2d_common_Vec2(d).addLocal$org_jbox2d_common_Vec2(rA);
                this.m_s1 = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(temp, this.m_perp);
                this.m_s2 = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, this.m_perp);
                let k11 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * this.m_s1) * this.m_s1)) + (<any>Math).fround((<any>Math).fround(iB * this.m_s2) * this.m_s2));
                let k12 : number = (<any>Math).fround((<any>Math).fround(iA * this.m_s1) + (<any>Math).fround(iB * this.m_s2));
                let k13 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(iA * this.m_s1) * this.m_a1) + (<any>Math).fround((<any>Math).fround(iB * this.m_s2) * this.m_a2));
                let k22 : number = (<any>Math).fround(iA + iB);
                if(k22 === 0.0) {
                    k22 = 1.0;
                }
                let k23 : number = (<any>Math).fround((<any>Math).fround(iA * this.m_a1) + (<any>Math).fround(iB * this.m_a2));
                let k33 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * this.m_a1) * this.m_a1)) + (<any>Math).fround((<any>Math).fround(iB * this.m_a2) * this.m_a2));
                this.m_K.ex.set$float$float$float(k11, k12, k13);
                this.m_K.ey.set$float$float$float(k12, k22, k23);
                this.m_K.ez.set$float$float$float(k13, k23, k33);
            };
            if(this.m_enableLimit) {
                let jointTranslation : number = org.jbox2d.common.Vec2.dot(this.m_axis, d);
                if(org.jbox2d.common.MathUtils.abs$float((<any>Math).fround(this.m_upperTranslation - this.m_lowerTranslation)) < (<any>Math).fround(2.0 * org.jbox2d.common.Settings.linearSlop)) {
                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.EQUAL;
                } else if(jointTranslation <= this.m_lowerTranslation) {
                    if(this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_LOWER) {
                        this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_LOWER;
                        this.m_impulse.z = 0.0;
                    }
                } else if(jointTranslation >= this.m_upperTranslation) {
                    if(this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_UPPER) {
                        this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_UPPER;
                        this.m_impulse.z = 0.0;
                    }
                } else {
                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.INACTIVE;
                    this.m_impulse.z = 0.0;
                }
            } else {
                this.m_limitState = org.jbox2d.dynamics.joints.LimitState.INACTIVE;
                this.m_impulse.z = 0.0;
            }
            if(this.m_enableMotor === false) {
                this.m_motorImpulse = 0.0;
            }
            if(data.step.warmStarting) {
                this.m_impulse.mulLocal(data.step.dtRatio);
                this.m_motorImpulse *= data.step.dtRatio;
                let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
                temp.set$org_jbox2d_common_Vec2(this.m_axis).mulLocal((<any>Math).fround(this.m_motorImpulse + this.m_impulse.z));
                P.set$org_jbox2d_common_Vec2(this.m_perp).mulLocal(this.m_impulse.x).addLocal$org_jbox2d_common_Vec2(temp);
                let LA : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_impulse.x * this.m_s1) + this.m_impulse.y) + (<any>Math).fround(((<any>Math).fround(this.m_motorImpulse + this.m_impulse.z)) * this.m_a1));
                let LB : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_impulse.x * this.m_s2) + this.m_impulse.y) + (<any>Math).fround(((<any>Math).fround(this.m_motorImpulse + this.m_impulse.z)) * this.m_a2));
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * LA);
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * LB);
                this.pool.pushVec2(1);
            } else {
                this.m_impulse.setZero();
                this.m_motorImpulse = 0.0;
            }
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushRot(2);
            this.pool.pushVec2(4);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            if(this.m_enableMotor && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.EQUAL) {
                temp.set$org_jbox2d_common_Vec2(vB).subLocal(vA);
                let Cdot : number = (<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.dot(this.m_axis, temp) + (<any>Math).fround(this.m_a2 * wB)) - (<any>Math).fround(this.m_a1 * wA));
                let impulse : number = (<any>Math).fround(this.m_motorMass * ((<any>Math).fround(this.m_motorSpeed - Cdot)));
                let oldImpulse : number = this.m_motorImpulse;
                let maxImpulse : number = (<any>Math).fround(data.step.dt * this.m_maxMotorForce);
                this.m_motorImpulse = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(this.m_motorImpulse + impulse), -maxImpulse, maxImpulse);
                impulse = (<any>Math).fround(this.m_motorImpulse - oldImpulse);
                let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
                P.set$org_jbox2d_common_Vec2(this.m_axis).mulLocal(impulse);
                let LA : number = (<any>Math).fround(impulse * this.m_a1);
                let LB : number = (<any>Math).fround(impulse * this.m_a2);
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * LA);
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * LB);
                this.pool.pushVec2(1);
            }
            let Cdot1 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            temp.set$org_jbox2d_common_Vec2(vB).subLocal(vA);
            Cdot1.x = (<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.dot(this.m_perp, temp) + (<any>Math).fround(this.m_s2 * wB)) - (<any>Math).fround(this.m_s1 * wA));
            Cdot1.y = (<any>Math).fround(wB - wA);
            if(this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE) {
                let Cdot2 : number;
                temp.set$org_jbox2d_common_Vec2(vB).subLocal(vA);
                Cdot2 = (<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.dot(this.m_axis, temp) + (<any>Math).fround(this.m_a2 * wB)) - (<any>Math).fround(this.m_a1 * wA));
                let Cdot : org.jbox2d.common.Vec3 = this.pool.popVec3();
                Cdot.set$float$float$float(Cdot1.x, Cdot1.y, Cdot2);
                let f1 : org.jbox2d.common.Vec3 = this.pool.popVec3();
                let df : org.jbox2d.common.Vec3 = this.pool.popVec3();
                f1.set$org_jbox2d_common_Vec3(this.m_impulse);
                this.m_K.solve33ToOut(Cdot.negateLocal(), df);
                this.m_impulse.addLocal(df);
                if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER) {
                    this.m_impulse.z = org.jbox2d.common.MathUtils.max$float$float(this.m_impulse.z, 0.0);
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER) {
                    this.m_impulse.z = org.jbox2d.common.MathUtils.min$float$float(this.m_impulse.z, 0.0);
                }
                let b : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let f2r : org.jbox2d.common.Vec2 = this.pool.popVec2();
                temp.set$float$float(this.m_K.ez.x, this.m_K.ez.y).mulLocal((<any>Math).fround(this.m_impulse.z - f1.z));
                b.set$org_jbox2d_common_Vec2(Cdot1).negateLocal().subLocal(temp);
                this.m_K.solve22ToOut(b, f2r);
                f2r.addLocal$float$float(f1.x, f1.y);
                this.m_impulse.x = f2r.x;
                this.m_impulse.y = f2r.y;
                df.set$org_jbox2d_common_Vec3(this.m_impulse).subLocal(f1);
                let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
                temp.set$org_jbox2d_common_Vec2(this.m_axis).mulLocal(df.z);
                P.set$org_jbox2d_common_Vec2(this.m_perp).mulLocal(df.x).addLocal$org_jbox2d_common_Vec2(temp);
                let LA : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(df.x * this.m_s1) + df.y) + (<any>Math).fround(df.z * this.m_a1));
                let LB : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(df.x * this.m_s2) + df.y) + (<any>Math).fround(df.z * this.m_a2));
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * LA);
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * LB);
                this.pool.pushVec2(3);
                this.pool.pushVec3(3);
            } else {
                let df : org.jbox2d.common.Vec2 = this.pool.popVec2();
                this.m_K.solve22ToOut(Cdot1.negateLocal(), df);
                Cdot1.negateLocal();
                this.m_impulse.x += df.x;
                this.m_impulse.y += df.y;
                let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
                P.set$org_jbox2d_common_Vec2(this.m_perp).mulLocal(df.x);
                let LA : number = (<any>Math).fround((<any>Math).fround(df.x * this.m_s1) + df.y);
                let LB : number = (<any>Math).fround((<any>Math).fround(df.x * this.m_s2) + df.y);
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * LA);
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * LB);
                this.pool.pushVec2(2);
            }
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(2);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let rA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let d : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let axis : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let perp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let C1 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let impulse : org.jbox2d.common.Vec3 = this.pool.popVec3();
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            qA.set$float(aA);
            qB.set$float(aB);
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), rB);
            d.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(rB).subLocal(cA).subLocal(rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, this.m_localXAxisA, axis);
            let a1 : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(temp.set$org_jbox2d_common_Vec2(d).addLocal$org_jbox2d_common_Vec2(rA), axis);
            let a2 : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, axis);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, this.m_localYAxisA, perp);
            let s1 : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(temp.set$org_jbox2d_common_Vec2(d).addLocal$org_jbox2d_common_Vec2(rA), perp);
            let s2 : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, perp);
            C1.x = org.jbox2d.common.Vec2.dot(perp, d);
            C1.y = (<any>Math).fround((<any>Math).fround(aB - aA) - this.m_referenceAngle);
            let linearError : number = org.jbox2d.common.MathUtils.abs$float(C1.x);
            let angularError : number = org.jbox2d.common.MathUtils.abs$float(C1.y);
            let active : boolean = false;
            let C2 : number = 0.0;
            if(this.m_enableLimit) {
                let translation : number = org.jbox2d.common.Vec2.dot(axis, d);
                if(org.jbox2d.common.MathUtils.abs$float((<any>Math).fround(this.m_upperTranslation - this.m_lowerTranslation)) < (<any>Math).fround(2.0 * org.jbox2d.common.Settings.linearSlop)) {
                    C2 = org.jbox2d.common.MathUtils.clamp$float$float$float(translation, -org.jbox2d.common.Settings.maxLinearCorrection, org.jbox2d.common.Settings.maxLinearCorrection);
                    linearError = org.jbox2d.common.MathUtils.max$float$float(linearError, org.jbox2d.common.MathUtils.abs$float(translation));
                    active = true;
                } else if(translation <= this.m_lowerTranslation) {
                    C2 = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround((<any>Math).fround(translation - this.m_lowerTranslation) + org.jbox2d.common.Settings.linearSlop), -org.jbox2d.common.Settings.maxLinearCorrection, 0.0);
                    linearError = org.jbox2d.common.MathUtils.max$float$float(linearError, (<any>Math).fround(this.m_lowerTranslation - translation));
                    active = true;
                } else if(translation >= this.m_upperTranslation) {
                    C2 = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround((<any>Math).fround(translation - this.m_upperTranslation) - org.jbox2d.common.Settings.linearSlop), 0.0, org.jbox2d.common.Settings.maxLinearCorrection);
                    linearError = org.jbox2d.common.MathUtils.max$float$float(linearError, (<any>Math).fround(translation - this.m_upperTranslation));
                    active = true;
                }
            }
            if(active) {
                let k11 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * s1) * s1)) + (<any>Math).fround((<any>Math).fround(iB * s2) * s2));
                let k12 : number = (<any>Math).fround((<any>Math).fround(iA * s1) + (<any>Math).fround(iB * s2));
                let k13 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(iA * s1) * a1) + (<any>Math).fround((<any>Math).fround(iB * s2) * a2));
                let k22 : number = (<any>Math).fround(iA + iB);
                if(k22 === 0.0) {
                    k22 = 1.0;
                }
                let k23 : number = (<any>Math).fround((<any>Math).fround(iA * a1) + (<any>Math).fround(iB * a2));
                let k33 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * a1) * a1)) + (<any>Math).fround((<any>Math).fround(iB * a2) * a2));
                let K : org.jbox2d.common.Mat33 = this.pool.popMat33();
                K.ex.set$float$float$float(k11, k12, k13);
                K.ey.set$float$float$float(k12, k22, k23);
                K.ez.set$float$float$float(k13, k23, k33);
                let C : org.jbox2d.common.Vec3 = this.pool.popVec3();
                C.x = C1.x;
                C.y = C1.y;
                C.z = C2;
                K.solve33ToOut(C.negateLocal(), impulse);
                this.pool.pushVec3(1);
                this.pool.pushMat33(1);
            } else {
                let k11 : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * s1) * s1)) + (<any>Math).fround((<any>Math).fround(iB * s2) * s2));
                let k12 : number = (<any>Math).fround((<any>Math).fround(iA * s1) + (<any>Math).fround(iB * s2));
                let k22 : number = (<any>Math).fround(iA + iB);
                if(k22 === 0.0) {
                    k22 = 1.0;
                }
                let K : org.jbox2d.common.Mat22 = this.pool.popMat22();
                K.ex.set$float$float(k11, k12);
                K.ey.set$float$float(k12, k22);
                K.solveToOut(C1.negateLocal(), temp);
                C1.negateLocal();
                impulse.x = temp.x;
                impulse.y = temp.y;
                impulse.z = 0.0;
                this.pool.pushMat22(1);
            }
            let Px : number = (<any>Math).fround((<any>Math).fround(impulse.x * perp.x) + (<any>Math).fround(impulse.z * axis.x));
            let Py : number = (<any>Math).fround((<any>Math).fround(impulse.x * perp.y) + (<any>Math).fround(impulse.z * axis.y));
            let LA : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(impulse.x * s1) + impulse.y) + (<any>Math).fround(impulse.z * a1));
            let LB : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(impulse.x * s2) + impulse.y) + (<any>Math).fround(impulse.z * a2));
            cA.x -= (<any>Math).fround(mA * Px);
            cA.y -= (<any>Math).fround(mA * Py);
            aA -= (<any>Math).fround(iA * LA);
            cB.x += (<any>Math).fround(mB * Px);
            cB.y += (<any>Math).fround(mB * Py);
            aB += (<any>Math).fround(iB * LB);
            data.positions[this.m_indexA].a = aA;
            data.positions[this.m_indexB].a = aB;
            this.pool.pushVec2(7);
            this.pool.pushVec3(1);
            this.pool.pushRot(2);
            return linearError <= org.jbox2d.common.Settings.linearSlop && angularError <= org.jbox2d.common.Settings.angularSlop_$LI$();
        }
    }
    PrismaticJoint["__class"] = "org.jbox2d.dynamics.joints.PrismaticJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * The pulley joint is connected to two bodies and two fixed ground points. The pulley supports a
     * ratio such that: length1 + ratio * length2 <= constant Yes, the force transmitted is scaled by
     * the ratio. Warning: the pulley joint can get a bit squirrelly by itself. They often work better
     * when combined with prismatic joints. You should also cover the the anchor points with static
     * shapes to prevent one side from going to zero length.
     * 
     * @author Daniel Murphy
     * @extends org.jbox2d.dynamics.joints.Joint
     * @class
     */
    export class PulleyJoint extends org.jbox2d.dynamics.joints.Joint {
        public static MIN_PULLEY_LENGTH : number = 2.0;

        /*private*/ m_groundAnchorA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_groundAnchorB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_lengthA : number;

        /*private*/ m_lengthB : number;

        /*private*/ m_localAnchorA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localAnchorB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_constant : number;

        /*private*/ m_ratio : number;

        /*private*/ m_impulse : number;

        /*private*/ m_indexA : number;

        /*private*/ m_indexB : number;

        /*private*/ m_uA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_uB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_rA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_rB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_invMassA : number;

        /*private*/ m_invMassB : number;

        /*private*/ m_invIA : number;

        /*private*/ m_invIB : number;

        /*private*/ m_mass : number;

        constructor(argWorldPool : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.PulleyJointDef) {
            super(argWorldPool, def);
            if(this.m_lengthA===undefined) this.m_lengthA = 0;
            if(this.m_lengthB===undefined) this.m_lengthB = 0;
            if(this.m_constant===undefined) this.m_constant = 0;
            if(this.m_ratio===undefined) this.m_ratio = 0;
            if(this.m_impulse===undefined) this.m_impulse = 0;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_invMassA===undefined) this.m_invMassA = 0;
            if(this.m_invMassB===undefined) this.m_invMassB = 0;
            if(this.m_invIA===undefined) this.m_invIA = 0;
            if(this.m_invIB===undefined) this.m_invIB = 0;
            if(this.m_mass===undefined) this.m_mass = 0;
            this.m_groundAnchorA.set$org_jbox2d_common_Vec2(def.groundAnchorA);
            this.m_groundAnchorB.set$org_jbox2d_common_Vec2(def.groundAnchorB);
            this.m_localAnchorA.set$org_jbox2d_common_Vec2(def.localAnchorA);
            this.m_localAnchorB.set$org_jbox2d_common_Vec2(def.localAnchorB);
            this.m_ratio = def.ratio;
            this.m_lengthA = def.lengthA;
            this.m_lengthB = def.lengthB;
            this.m_constant = (<any>Math).fround(def.lengthA + (<any>Math).fround(this.m_ratio * def.lengthB));
            this.m_impulse = 0.0;
        }

        public getLengthA() : number {
            return this.m_lengthA;
        }

        public getLengthB() : number {
            return this.m_lengthB;
        }

        public getCurrentLengthA() : number {
            let p : org.jbox2d.common.Vec2 = this.pool.popVec2();
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, p);
            p.subLocal(this.m_groundAnchorA);
            let length : number = p.length();
            this.pool.pushVec2(1);
            return length;
        }

        public getCurrentLengthB() : number {
            let p : org.jbox2d.common.Vec2 = this.pool.popVec2();
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, p);
            p.subLocal(this.m_groundAnchorB);
            let length : number = p.length();
            this.pool.pushVec2(1);
            return length;
        }

        public getLocalAnchorA() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorA;
        }

        public getLocalAnchorB() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorB;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, argOut);
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, argOut);
        }

        /**
         * 
         * @param {number} inv_dt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(inv_dt : number, argOut : org.jbox2d.common.Vec2) {
            argOut.set$org_jbox2d_common_Vec2(this.m_uB).mulLocal(this.m_impulse).mulLocal(inv_dt);
        }

        /**
         * 
         * @param {number} inv_dt
         * @return {number}
         */
        public getReactionTorque(inv_dt : number) : number {
            return 0.0;
        }

        public getGroundAnchorA() : org.jbox2d.common.Vec2 {
            return this.m_groundAnchorA;
        }

        public getGroundAnchorB() : org.jbox2d.common.Vec2 {
            return this.m_groundAnchorB;
        }

        public getLength1() : number {
            let p : org.jbox2d.common.Vec2 = this.pool.popVec2();
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, p);
            p.subLocal(this.m_groundAnchorA);
            let len : number = p.length();
            this.pool.pushVec2(1);
            return len;
        }

        public getLength2() : number {
            let p : org.jbox2d.common.Vec2 = this.pool.popVec2();
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, p);
            p.subLocal(this.m_groundAnchorB);
            let len : number = p.length();
            this.pool.pushVec2(1);
            return len;
        }

        public getRatio() : number {
            return this.m_ratio;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexA = this.m_bodyA.m_islandIndex;
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_localCenterA.set$org_jbox2d_common_Vec2(this.m_bodyA.m_sweep.localCenter);
            this.m_localCenterB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), this.m_rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), this.m_rB);
            this.m_uA.set$org_jbox2d_common_Vec2(cA).addLocal$org_jbox2d_common_Vec2(this.m_rA).subLocal(this.m_groundAnchorA);
            this.m_uB.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(this.m_rB).subLocal(this.m_groundAnchorB);
            let lengthA : number = this.m_uA.length();
            let lengthB : number = this.m_uB.length();
            if(lengthA > (<any>Math).fround(10.0 * org.jbox2d.common.Settings.linearSlop)) {
                this.m_uA.mulLocal((<any>Math).fround(1.0 / lengthA));
            } else {
                this.m_uA.setZero();
            }
            if(lengthB > (<any>Math).fround(10.0 * org.jbox2d.common.Settings.linearSlop)) {
                this.m_uB.mulLocal((<any>Math).fround(1.0 / lengthB));
            } else {
                this.m_uB.setZero();
            }
            let ruA : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, this.m_uA);
            let ruB : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, this.m_uB);
            let mA : number = (<any>Math).fround(this.m_invMassA + (<any>Math).fround((<any>Math).fround(this.m_invIA * ruA) * ruA));
            let mB : number = (<any>Math).fround(this.m_invMassB + (<any>Math).fround((<any>Math).fround(this.m_invIB * ruB) * ruB));
            this.m_mass = (<any>Math).fround(mA + (<any>Math).fround((<any>Math).fround(this.m_ratio * this.m_ratio) * mB));
            if(this.m_mass > 0.0) {
                this.m_mass = (<any>Math).fround(1.0 / this.m_mass);
            }
            if(data.step.warmStarting) {
                this.m_impulse *= data.step.dtRatio;
                let PA : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let PB : org.jbox2d.common.Vec2 = this.pool.popVec2();
                PA.set$org_jbox2d_common_Vec2(this.m_uA).mulLocal(-this.m_impulse);
                PB.set$org_jbox2d_common_Vec2(this.m_uB).mulLocal((<any>Math).fround(-this.m_ratio * this.m_impulse));
                vA.x += (<any>Math).fround(this.m_invMassA * PA.x);
                vA.y += (<any>Math).fround(this.m_invMassA * PA.y);
                wA += (<any>Math).fround(this.m_invIA * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, PA));
                vB.x += (<any>Math).fround(this.m_invMassB * PB.x);
                vB.y += (<any>Math).fround(this.m_invMassB * PB.y);
                wB += (<any>Math).fround(this.m_invIB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, PB));
                this.pool.pushVec2(2);
            } else {
                this.m_impulse = 0.0;
            }
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(1);
            this.pool.pushRot(2);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let vpA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let vpB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let PA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let PB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wA, this.m_rA, vpA);
            vpA.addLocal$org_jbox2d_common_Vec2(vA);
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wB, this.m_rB, vpB);
            vpB.addLocal$org_jbox2d_common_Vec2(vB);
            let Cdot : number = (<any>Math).fround(-org.jbox2d.common.Vec2.dot(this.m_uA, vpA) - (<any>Math).fround(this.m_ratio * org.jbox2d.common.Vec2.dot(this.m_uB, vpB)));
            let impulse : number = (<any>Math).fround(-this.m_mass * Cdot);
            this.m_impulse += impulse;
            PA.set$org_jbox2d_common_Vec2(this.m_uA).mulLocal(-impulse);
            PB.set$org_jbox2d_common_Vec2(this.m_uB).mulLocal((<any>Math).fround(-this.m_ratio * impulse));
            vA.x += (<any>Math).fround(this.m_invMassA * PA.x);
            vA.y += (<any>Math).fround(this.m_invMassA * PA.y);
            wA += (<any>Math).fround(this.m_invIA * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, PA));
            vB.x += (<any>Math).fround(this.m_invMassB * PB.x);
            vB.y += (<any>Math).fround(this.m_invMassB * PB.y);
            wB += (<any>Math).fround(this.m_invIB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, PB));
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(4);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let rA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let uA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let uB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let PA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let PB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), rB);
            uA.set$org_jbox2d_common_Vec2(cA).addLocal$org_jbox2d_common_Vec2(rA).subLocal(this.m_groundAnchorA);
            uB.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(rB).subLocal(this.m_groundAnchorB);
            let lengthA : number = uA.length();
            let lengthB : number = uB.length();
            if(lengthA > (<any>Math).fround(10.0 * org.jbox2d.common.Settings.linearSlop)) {
                uA.mulLocal((<any>Math).fround(1.0 / lengthA));
            } else {
                uA.setZero();
            }
            if(lengthB > (<any>Math).fround(10.0 * org.jbox2d.common.Settings.linearSlop)) {
                uB.mulLocal((<any>Math).fround(1.0 / lengthB));
            } else {
                uB.setZero();
            }
            let ruA : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rA, uA);
            let ruB : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, uB);
            let mA : number = (<any>Math).fround(this.m_invMassA + (<any>Math).fround((<any>Math).fround(this.m_invIA * ruA) * ruA));
            let mB : number = (<any>Math).fround(this.m_invMassB + (<any>Math).fround((<any>Math).fround(this.m_invIB * ruB) * ruB));
            let mass : number = (<any>Math).fround(mA + (<any>Math).fround((<any>Math).fround(this.m_ratio * this.m_ratio) * mB));
            if(mass > 0.0) {
                mass = (<any>Math).fround(1.0 / mass);
            }
            let C : number = (<any>Math).fround((<any>Math).fround(this.m_constant - lengthA) - (<any>Math).fround(this.m_ratio * lengthB));
            let linearError : number = org.jbox2d.common.MathUtils.abs$float(C);
            let impulse : number = (<any>Math).fround(-mass * C);
            PA.set$org_jbox2d_common_Vec2(uA).mulLocal(-impulse);
            PB.set$org_jbox2d_common_Vec2(uB).mulLocal((<any>Math).fround(-this.m_ratio * impulse));
            cA.x += (<any>Math).fround(this.m_invMassA * PA.x);
            cA.y += (<any>Math).fround(this.m_invMassA * PA.y);
            aA += (<any>Math).fround(this.m_invIA * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rA, PA));
            cB.x += (<any>Math).fround(this.m_invMassB * PB.x);
            cB.y += (<any>Math).fround(this.m_invMassB * PB.y);
            aB += (<any>Math).fround(this.m_invIB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, PB));
            data.positions[this.m_indexA].a = aA;
            data.positions[this.m_indexB].a = aB;
            this.pool.pushRot(2);
            this.pool.pushVec2(7);
            return linearError < org.jbox2d.common.Settings.linearSlop;
        }
    }
    PulleyJoint["__class"] = "org.jbox2d.dynamics.joints.PulleyJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A revolute joint constrains two bodies to share a common point while they are free to rotate
     * about the point. The relative rotation about the shared point is the joint angle. You can limit
     * the relative rotation with a joint limit that specifies a lower and upper angle. You can use a
     * motor to drive the relative rotation about the shared point. A maximum motor torque is provided
     * so that infinite forces are not generated.
     * 
     * @author Daniel Murphy
     * @extends org.jbox2d.dynamics.joints.Joint
     * @class
     */
    export class RevoluteJoint extends org.jbox2d.dynamics.joints.Joint {
        m_localAnchorA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        m_localAnchorB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_impulse : org.jbox2d.common.Vec3 = new org.jbox2d.common.Vec3();

        /*private*/ m_motorImpulse : number;

        /*private*/ m_enableMotor : boolean;

        /*private*/ m_maxMotorTorque : number;

        /*private*/ m_motorSpeed : number;

        /*private*/ m_enableLimit : boolean;

        m_referenceAngle : number;

        /*private*/ m_lowerAngle : number;

        /*private*/ m_upperAngle : number;

        /*private*/ m_indexA : number;

        /*private*/ m_indexB : number;

        /*private*/ m_rA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_rB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_invMassA : number;

        /*private*/ m_invMassB : number;

        /*private*/ m_invIA : number;

        /*private*/ m_invIB : number;

        /*private*/ m_mass : org.jbox2d.common.Mat33 = new org.jbox2d.common.Mat33();

        /*private*/ m_motorMass : number;

        /*private*/ m_limitState : org.jbox2d.dynamics.joints.LimitState;

        constructor(argWorld : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.RevoluteJointDef) {
            super(argWorld, def);
            if(this.m_motorImpulse===undefined) this.m_motorImpulse = 0;
            if(this.m_enableMotor===undefined) this.m_enableMotor = false;
            if(this.m_maxMotorTorque===undefined) this.m_maxMotorTorque = 0;
            if(this.m_motorSpeed===undefined) this.m_motorSpeed = 0;
            if(this.m_enableLimit===undefined) this.m_enableLimit = false;
            if(this.m_referenceAngle===undefined) this.m_referenceAngle = 0;
            if(this.m_lowerAngle===undefined) this.m_lowerAngle = 0;
            if(this.m_upperAngle===undefined) this.m_upperAngle = 0;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_invMassA===undefined) this.m_invMassA = 0;
            if(this.m_invMassB===undefined) this.m_invMassB = 0;
            if(this.m_invIA===undefined) this.m_invIA = 0;
            if(this.m_invIB===undefined) this.m_invIB = 0;
            if(this.m_motorMass===undefined) this.m_motorMass = 0;
            if(this.m_limitState===undefined) this.m_limitState = null;
            this.m_localAnchorA.set$org_jbox2d_common_Vec2(def.localAnchorA);
            this.m_localAnchorB.set$org_jbox2d_common_Vec2(def.localAnchorB);
            this.m_referenceAngle = def.referenceAngle;
            this.m_motorImpulse = 0;
            this.m_lowerAngle = def.lowerAngle;
            this.m_upperAngle = def.upperAngle;
            this.m_maxMotorTorque = def.maxMotorTorque;
            this.m_motorSpeed = def.motorSpeed;
            this.m_enableLimit = def.enableLimit;
            this.m_enableMotor = def.enableMotor;
            this.m_limitState = org.jbox2d.dynamics.joints.LimitState.INACTIVE;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexA = this.m_bodyA.m_islandIndex;
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_localCenterA.set$org_jbox2d_common_Vec2(this.m_bodyA.m_sweep.localCenter);
            this.m_localCenterB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            let aA : number = data.positions[this.m_indexA].a;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), this.m_rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), this.m_rB);
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            let fixedRotation : boolean = ((<any>Math).fround(iA + iB) === 0.0);
            this.m_mass.ex.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(this.m_rA.y * this.m_rA.y) * iA)) + (<any>Math).fround((<any>Math).fround(this.m_rB.y * this.m_rB.y) * iB));
            this.m_mass.ey.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-this.m_rA.y * this.m_rA.x) * iA) - (<any>Math).fround((<any>Math).fround(this.m_rB.y * this.m_rB.x) * iB));
            this.m_mass.ez.x = (<any>Math).fround((<any>Math).fround(-this.m_rA.y * iA) - (<any>Math).fround(this.m_rB.y * iB));
            this.m_mass.ex.y = this.m_mass.ey.x;
            this.m_mass.ey.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(this.m_rA.x * this.m_rA.x) * iA)) + (<any>Math).fround((<any>Math).fround(this.m_rB.x * this.m_rB.x) * iB));
            this.m_mass.ez.y = (<any>Math).fround((<any>Math).fround(this.m_rA.x * iA) + (<any>Math).fround(this.m_rB.x * iB));
            this.m_mass.ex.z = this.m_mass.ez.x;
            this.m_mass.ey.z = this.m_mass.ez.y;
            this.m_mass.ez.z = (<any>Math).fround(iA + iB);
            this.m_motorMass = (<any>Math).fround(iA + iB);
            if(this.m_motorMass > 0.0) {
                this.m_motorMass = (<any>Math).fround(1.0 / this.m_motorMass);
            }
            if(this.m_enableMotor === false || fixedRotation) {
                this.m_motorImpulse = 0.0;
            }
            if(this.m_enableLimit && fixedRotation === false) {
                let jointAngle : number = (<any>Math).fround((<any>Math).fround(aB - aA) - this.m_referenceAngle);
                if(org.jbox2d.common.MathUtils.abs$float((<any>Math).fround(this.m_upperAngle - this.m_lowerAngle)) < (<any>Math).fround(2.0 * org.jbox2d.common.Settings.angularSlop_$LI$())) {
                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.EQUAL;
                } else if(jointAngle <= this.m_lowerAngle) {
                    if(this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_LOWER) {
                        this.m_impulse.z = 0.0;
                    }
                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_LOWER;
                } else if(jointAngle >= this.m_upperAngle) {
                    if(this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_UPPER) {
                        this.m_impulse.z = 0.0;
                    }
                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_UPPER;
                } else {
                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.INACTIVE;
                    this.m_impulse.z = 0.0;
                }
            } else {
                this.m_limitState = org.jbox2d.dynamics.joints.LimitState.INACTIVE;
            }
            if(data.step.warmStarting) {
                let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
                this.m_impulse.x *= data.step.dtRatio;
                this.m_impulse.y *= data.step.dtRatio;
                this.m_motorImpulse *= data.step.dtRatio;
                P.x = this.m_impulse.x;
                P.y = this.m_impulse.y;
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * ((<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, P) + this.m_motorImpulse) + this.m_impulse.z)));
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * ((<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, P) + this.m_motorImpulse) + this.m_impulse.z)));
                this.pool.pushVec2(1);
            } else {
                this.m_impulse.setZero();
                this.m_motorImpulse = 0.0;
            }
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(1);
            this.pool.pushRot(2);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            let fixedRotation : boolean = ((<any>Math).fround(iA + iB) === 0.0);
            if(this.m_enableMotor && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.EQUAL && fixedRotation === false) {
                let Cdot : number = (<any>Math).fround((<any>Math).fround(wB - wA) - this.m_motorSpeed);
                let impulse : number = (<any>Math).fround(-this.m_motorMass * Cdot);
                let oldImpulse : number = this.m_motorImpulse;
                let maxImpulse : number = (<any>Math).fround(data.step.dt * this.m_maxMotorTorque);
                this.m_motorImpulse = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(this.m_motorImpulse + impulse), -maxImpulse, maxImpulse);
                impulse = (<any>Math).fround(this.m_motorImpulse - oldImpulse);
                wA -= (<any>Math).fround(iA * impulse);
                wB += (<any>Math).fround(iB * impulse);
            }
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            if(this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE && fixedRotation === false) {
                let Cdot1 : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let Cdot : org.jbox2d.common.Vec3 = this.pool.popVec3();
                org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wA, this.m_rA, temp);
                org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wB, this.m_rB, Cdot1);
                Cdot1.addLocal$org_jbox2d_common_Vec2(vB).subLocal(vA).subLocal(temp);
                let Cdot2 : number = (<any>Math).fround(wB - wA);
                Cdot.set$float$float$float(Cdot1.x, Cdot1.y, Cdot2);
                let impulse : org.jbox2d.common.Vec3 = this.pool.popVec3();
                this.m_mass.solve33ToOut(Cdot, impulse);
                impulse.negateLocal();
                if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.EQUAL) {
                    this.m_impulse.addLocal(impulse);
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER) {
                    let newImpulse : number = (<any>Math).fround(this.m_impulse.z + impulse.z);
                    if(newImpulse < 0.0) {
                        let rhs : org.jbox2d.common.Vec2 = this.pool.popVec2();
                        rhs.set$float$float(this.m_mass.ez.x, this.m_mass.ez.y).mulLocal(this.m_impulse.z).subLocal(Cdot1);
                        this.m_mass.solve22ToOut(rhs, temp);
                        impulse.x = temp.x;
                        impulse.y = temp.y;
                        impulse.z = -this.m_impulse.z;
                        this.m_impulse.x += temp.x;
                        this.m_impulse.y += temp.y;
                        this.m_impulse.z = 0.0;
                        this.pool.pushVec2(1);
                    } else {
                        this.m_impulse.addLocal(impulse);
                    }
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER) {
                    let newImpulse : number = (<any>Math).fround(this.m_impulse.z + impulse.z);
                    if(newImpulse > 0.0) {
                        let rhs : org.jbox2d.common.Vec2 = this.pool.popVec2();
                        rhs.set$float$float(this.m_mass.ez.x, this.m_mass.ez.y).mulLocal(this.m_impulse.z).subLocal(Cdot1);
                        this.m_mass.solve22ToOut(rhs, temp);
                        impulse.x = temp.x;
                        impulse.y = temp.y;
                        impulse.z = -this.m_impulse.z;
                        this.m_impulse.x += temp.x;
                        this.m_impulse.y += temp.y;
                        this.m_impulse.z = 0.0;
                        this.pool.pushVec2(1);
                    } else {
                        this.m_impulse.addLocal(impulse);
                    }
                }
                let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
                P.set$float$float(impulse.x, impulse.y);
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * ((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, P) + impulse.z)));
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * ((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, P) + impulse.z)));
                this.pool.pushVec2(2);
                this.pool.pushVec3(2);
            } else {
                let Cdot : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let impulse : org.jbox2d.common.Vec2 = this.pool.popVec2();
                org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wA, this.m_rA, temp);
                org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wB, this.m_rB, Cdot);
                Cdot.addLocal$org_jbox2d_common_Vec2(vB).subLocal(vA).subLocal(temp);
                this.m_mass.solve22ToOut(Cdot.negateLocal(), impulse);
                this.m_impulse.x += impulse.x;
                this.m_impulse.y += impulse.y;
                vA.x -= (<any>Math).fround(mA * impulse.x);
                vA.y -= (<any>Math).fround(mA * impulse.y);
                wA -= (<any>Math).fround(iA * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, impulse));
                vB.x += (<any>Math).fround(mB * impulse.x);
                vB.y += (<any>Math).fround(mB * impulse.y);
                wB += (<any>Math).fround(iB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, impulse));
                this.pool.pushVec2(2);
            }
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(1);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            qA.set$float(aA);
            qB.set$float(aB);
            let angularError : number = 0.0;
            let positionError : number = 0.0;
            let fixedRotation : boolean = ((<any>Math).fround(this.m_invIA + this.m_invIB) === 0.0);
            if(this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE && fixedRotation === false) {
                let angle : number = (<any>Math).fround((<any>Math).fround(aB - aA) - this.m_referenceAngle);
                let limitImpulse : number = 0.0;
                if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.EQUAL) {
                    let C : number = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(angle - this.m_lowerAngle), -org.jbox2d.common.Settings.maxAngularCorrection_$LI$(), org.jbox2d.common.Settings.maxAngularCorrection_$LI$());
                    limitImpulse = (<any>Math).fround(-this.m_motorMass * C);
                    angularError = org.jbox2d.common.MathUtils.abs$float(C);
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER) {
                    let C : number = (<any>Math).fround(angle - this.m_lowerAngle);
                    angularError = -C;
                    C = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(C + org.jbox2d.common.Settings.angularSlop_$LI$()), -org.jbox2d.common.Settings.maxAngularCorrection_$LI$(), 0.0);
                    limitImpulse = (<any>Math).fround(-this.m_motorMass * C);
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER) {
                    let C : number = (<any>Math).fround(angle - this.m_upperAngle);
                    angularError = C;
                    C = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(C - org.jbox2d.common.Settings.angularSlop_$LI$()), 0.0, org.jbox2d.common.Settings.maxAngularCorrection_$LI$());
                    limitImpulse = (<any>Math).fround(-this.m_motorMass * C);
                }
                aA -= (<any>Math).fround(this.m_invIA * limitImpulse);
                aB += (<any>Math).fround(this.m_invIB * limitImpulse);
            }
            {
                qA.set$float(aA);
                qB.set$float(aB);
                let rA : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let rB : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let C : org.jbox2d.common.Vec2 = this.pool.popVec2();
                let impulse : org.jbox2d.common.Vec2 = this.pool.popVec2();
                org.jbox2d.common.Rot.mulToOutUnsafe(qA, C.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), rA);
                org.jbox2d.common.Rot.mulToOutUnsafe(qB, C.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), rB);
                C.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(rB).subLocal(cA).subLocal(rA);
                positionError = C.length();
                let mA : number = this.m_invMassA;
                let mB : number = this.m_invMassB;
                let iA : number = this.m_invIA;
                let iB : number = this.m_invIB;
                let K : org.jbox2d.common.Mat22 = this.pool.popMat22();
                K.ex.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * rA.y) * rA.y)) + (<any>Math).fround((<any>Math).fround(iB * rB.y) * rB.y));
                K.ex.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-iA * rA.x) * rA.y) - (<any>Math).fround((<any>Math).fround(iB * rB.x) * rB.y));
                K.ey.x = K.ex.y;
                K.ey.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * rA.x) * rA.x)) + (<any>Math).fround((<any>Math).fround(iB * rB.x) * rB.x));
                K.solveToOut(C, impulse);
                impulse.negateLocal();
                cA.x -= (<any>Math).fround(mA * impulse.x);
                cA.y -= (<any>Math).fround(mA * impulse.y);
                aA -= (<any>Math).fround(iA * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rA, impulse));
                cB.x += (<any>Math).fround(mB * impulse.x);
                cB.y += (<any>Math).fround(mB * impulse.y);
                aB += (<any>Math).fround(iB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, impulse));
                this.pool.pushVec2(4);
                this.pool.pushMat22(1);
            };
            data.positions[this.m_indexA].a = aA;
            data.positions[this.m_indexB].a = aB;
            this.pool.pushRot(2);
            return positionError <= org.jbox2d.common.Settings.linearSlop && angularError <= org.jbox2d.common.Settings.angularSlop_$LI$();
        }

        public getLocalAnchorA() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorA;
        }

        public getLocalAnchorB() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorB;
        }

        public getReferenceAngle() : number {
            return this.m_referenceAngle;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, argOut);
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, argOut);
        }

        /**
         * 
         * @param {number} inv_dt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(inv_dt : number, argOut : org.jbox2d.common.Vec2) {
            argOut.set$float$float(this.m_impulse.x, this.m_impulse.y).mulLocal(inv_dt);
        }

        /**
         * 
         * @param {number} inv_dt
         * @return {number}
         */
        public getReactionTorque(inv_dt : number) : number {
            return (<any>Math).fround(inv_dt * this.m_impulse.z);
        }

        public getJointAngle() : number {
            let b1 : org.jbox2d.dynamics.Body = this.m_bodyA;
            let b2 : org.jbox2d.dynamics.Body = this.m_bodyB;
            return (<any>Math).fround((<any>Math).fround(b2.m_sweep.a - b1.m_sweep.a) - this.m_referenceAngle);
        }

        public getJointSpeed() : number {
            let b1 : org.jbox2d.dynamics.Body = this.m_bodyA;
            let b2 : org.jbox2d.dynamics.Body = this.m_bodyB;
            return (<any>Math).fround(b2.m_angularVelocity - b1.m_angularVelocity);
        }

        public isMotorEnabled() : boolean {
            return this.m_enableMotor;
        }

        public enableMotor(flag : boolean) {
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_enableMotor = flag;
        }

        public getMotorTorque(inv_dt : number) : number {
            return (<any>Math).fround(this.m_motorImpulse * inv_dt);
        }

        public setMotorSpeed(speed : number) {
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_motorSpeed = speed;
        }

        public setMaxMotorTorque(torque : number) {
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_maxMotorTorque = torque;
        }

        public getMotorSpeed() : number {
            return this.m_motorSpeed;
        }

        public getMaxMotorTorque() : number {
            return this.m_maxMotorTorque;
        }

        public isLimitEnabled() : boolean {
            return this.m_enableLimit;
        }

        public enableLimit(flag : boolean) {
            if(flag !== this.m_enableLimit) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_enableLimit = flag;
                this.m_impulse.z = 0.0;
            }
        }

        public getLowerLimit() : number {
            return this.m_lowerAngle;
        }

        public getUpperLimit() : number {
            return this.m_upperAngle;
        }

        public setLimits(lower : number, upper : number) {
            if(lower !== this.m_lowerAngle || upper !== this.m_upperAngle) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_impulse.z = 0.0;
                this.m_lowerAngle = lower;
                this.m_upperAngle = upper;
            }
        }
    }
    RevoluteJoint["__class"] = "org.jbox2d.dynamics.joints.RevoluteJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A rope joint enforces a maximum distance between two points on two bodies. It has no other
     * effect. Warning: if you attempt to change the maximum length during the simulation you will get
     * some non-physical behavior. A model that would allow you to dynamically modify the length would
     * have some sponginess, so I chose not to implement it that way. See DistanceJoint if you want to
     * dynamically control length.
     * 
     * @author Daniel Murphy
     * @extends org.jbox2d.dynamics.joints.Joint
     * @class
     */
    export class RopeJoint extends org.jbox2d.dynamics.joints.Joint {
        /*private*/ m_localAnchorA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localAnchorB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_maxLength : number;

        /*private*/ m_length : number;

        /*private*/ m_impulse : number;

        /*private*/ m_indexA : number;

        /*private*/ m_indexB : number;

        /*private*/ m_u : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_rA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_rB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_invMassA : number;

        /*private*/ m_invMassB : number;

        /*private*/ m_invIA : number;

        /*private*/ m_invIB : number;

        /*private*/ m_mass : number;

        /*private*/ m_state : org.jbox2d.dynamics.joints.LimitState;

        constructor(worldPool : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.RopeJointDef) {
            super(worldPool, def);
            if(this.m_maxLength===undefined) this.m_maxLength = 0;
            if(this.m_length===undefined) this.m_length = 0;
            if(this.m_impulse===undefined) this.m_impulse = 0;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_invMassA===undefined) this.m_invMassA = 0;
            if(this.m_invMassB===undefined) this.m_invMassB = 0;
            if(this.m_invIA===undefined) this.m_invIA = 0;
            if(this.m_invIB===undefined) this.m_invIB = 0;
            if(this.m_mass===undefined) this.m_mass = 0;
            if(this.m_state===undefined) this.m_state = null;
            this.m_localAnchorA.set$org_jbox2d_common_Vec2(def.localAnchorA);
            this.m_localAnchorB.set$org_jbox2d_common_Vec2(def.localAnchorB);
            this.m_maxLength = def.maxLength;
            this.m_mass = 0.0;
            this.m_impulse = 0.0;
            this.m_state = org.jbox2d.dynamics.joints.LimitState.INACTIVE;
            this.m_length = 0.0;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexA = this.m_bodyA.m_islandIndex;
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_localCenterA.set$org_jbox2d_common_Vec2(this.m_bodyA.m_sweep.localCenter);
            this.m_localCenterB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), this.m_rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), this.m_rB);
            this.m_u.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(this.m_rB).subLocal(cA).subLocal(this.m_rA);
            this.m_length = this.m_u.length();
            let C : number = (<any>Math).fround(this.m_length - this.m_maxLength);
            if(C > 0.0) {
                this.m_state = org.jbox2d.dynamics.joints.LimitState.AT_UPPER;
            } else {
                this.m_state = org.jbox2d.dynamics.joints.LimitState.INACTIVE;
            }
            if(this.m_length > org.jbox2d.common.Settings.linearSlop) {
                this.m_u.mulLocal((<any>Math).fround(1.0 / this.m_length));
            } else {
                this.m_u.setZero();
                this.m_mass = 0.0;
                this.m_impulse = 0.0;
                this.pool.pushRot(2);
                this.pool.pushVec2(1);
                return;
            }
            let crA : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, this.m_u);
            let crB : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, this.m_u);
            let invMass : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_invMassA + (<any>Math).fround((<any>Math).fround(this.m_invIA * crA) * crA)) + this.m_invMassB) + (<any>Math).fround((<any>Math).fround(this.m_invIB * crB) * crB));
            this.m_mass = invMass !== 0.0?(<any>Math).fround(1.0 / invMass):0.0;
            if(data.step.warmStarting) {
                this.m_impulse *= data.step.dtRatio;
                let Px : number = (<any>Math).fround(this.m_impulse * this.m_u.x);
                let Py : number = (<any>Math).fround(this.m_impulse * this.m_u.y);
                vA.x -= (<any>Math).fround(this.m_invMassA * Px);
                vA.y -= (<any>Math).fround(this.m_invMassA * Py);
                wA -= (<any>Math).fround(this.m_invIA * ((<any>Math).fround((<any>Math).fround(this.m_rA.x * Py) - (<any>Math).fround(this.m_rA.y * Px))));
                vB.x += (<any>Math).fround(this.m_invMassB * Px);
                vB.y += (<any>Math).fround(this.m_invMassB * Py);
                wB += (<any>Math).fround(this.m_invIB * ((<any>Math).fround((<any>Math).fround(this.m_rB.x * Py) - (<any>Math).fround(this.m_rB.y * Px))));
            } else {
                this.m_impulse = 0.0;
            }
            this.pool.pushRot(2);
            this.pool.pushVec2(1);
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let vpA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let vpB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wA, this.m_rA, vpA);
            vpA.addLocal$org_jbox2d_common_Vec2(vA);
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wB, this.m_rB, vpB);
            vpB.addLocal$org_jbox2d_common_Vec2(vB);
            let C : number = (<any>Math).fround(this.m_length - this.m_maxLength);
            let Cdot : number = org.jbox2d.common.Vec2.dot(this.m_u, temp.set$org_jbox2d_common_Vec2(vpB).subLocal(vpA));
            if(C < 0.0) {
                Cdot += (<any>Math).fround(data.step.inv_dt * C);
            }
            let impulse : number = (<any>Math).fround(-this.m_mass * Cdot);
            let oldImpulse : number = this.m_impulse;
            this.m_impulse = org.jbox2d.common.MathUtils.min$float$float(0.0, (<any>Math).fround(this.m_impulse + impulse));
            impulse = (<any>Math).fround(this.m_impulse - oldImpulse);
            let Px : number = (<any>Math).fround(impulse * this.m_u.x);
            let Py : number = (<any>Math).fround(impulse * this.m_u.y);
            vA.x -= (<any>Math).fround(this.m_invMassA * Px);
            vA.y -= (<any>Math).fround(this.m_invMassA * Py);
            wA -= (<any>Math).fround(this.m_invIA * ((<any>Math).fround((<any>Math).fround(this.m_rA.x * Py) - (<any>Math).fround(this.m_rA.y * Px))));
            vB.x += (<any>Math).fround(this.m_invMassB * Px);
            vB.y += (<any>Math).fround(this.m_invMassB * Py);
            wB += (<any>Math).fround(this.m_invIB * ((<any>Math).fround((<any>Math).fround(this.m_rB.x * Py) - (<any>Math).fround(this.m_rB.y * Px))));
            this.pool.pushVec2(3);
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let u : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), rB);
            u.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(rB).subLocal(cA).subLocal(rA);
            let length : number = u.normalize();
            let C : number = (<any>Math).fround(length - this.m_maxLength);
            C = org.jbox2d.common.MathUtils.clamp$float$float$float(C, 0.0, org.jbox2d.common.Settings.maxLinearCorrection);
            let impulse : number = (<any>Math).fround(-this.m_mass * C);
            let Px : number = (<any>Math).fround(impulse * u.x);
            let Py : number = (<any>Math).fround(impulse * u.y);
            cA.x -= (<any>Math).fround(this.m_invMassA * Px);
            cA.y -= (<any>Math).fround(this.m_invMassA * Py);
            aA -= (<any>Math).fround(this.m_invIA * ((<any>Math).fround((<any>Math).fround(rA.x * Py) - (<any>Math).fround(rA.y * Px))));
            cB.x += (<any>Math).fround(this.m_invMassB * Px);
            cB.y += (<any>Math).fround(this.m_invMassB * Py);
            aB += (<any>Math).fround(this.m_invIB * ((<any>Math).fround((<any>Math).fround(rB.x * Py) - (<any>Math).fround(rB.y * Px))));
            this.pool.pushRot(2);
            this.pool.pushVec2(4);
            data.positions[this.m_indexA].a = aA;
            data.positions[this.m_indexB].a = aB;
            return (<any>Math).fround(length - this.m_maxLength) < org.jbox2d.common.Settings.linearSlop;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, argOut);
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, argOut);
        }

        /**
         * 
         * @param {number} inv_dt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(inv_dt : number, argOut : org.jbox2d.common.Vec2) {
            argOut.set$org_jbox2d_common_Vec2(this.m_u).mulLocal(inv_dt).mulLocal(this.m_impulse);
        }

        /**
         * 
         * @param {number} inv_dt
         * @return {number}
         */
        public getReactionTorque(inv_dt : number) : number {
            return 0.0;
        }

        public getLocalAnchorA() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorA;
        }

        public getLocalAnchorB() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorB;
        }

        public getMaxLength() : number {
            return this.m_maxLength;
        }

        public setMaxLength(maxLength : number) {
            this.m_maxLength = maxLength;
        }

        public getLimitState() : org.jbox2d.dynamics.joints.LimitState {
            return this.m_state;
        }
    }
    RopeJoint["__class"] = "org.jbox2d.dynamics.joints.RopeJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A weld joint essentially glues two bodies together. A weld joint may distort somewhat because the
     * island constraint solver is approximate.
     * 
     * @author Daniel Murphy
     * @extends org.jbox2d.dynamics.joints.Joint
     * @class
     */
    export class WeldJoint extends org.jbox2d.dynamics.joints.Joint {
        /*private*/ m_frequencyHz : number;

        /*private*/ m_dampingRatio : number;

        /*private*/ m_bias : number;

        /*private*/ m_localAnchorA : org.jbox2d.common.Vec2;

        /*private*/ m_localAnchorB : org.jbox2d.common.Vec2;

        /*private*/ m_referenceAngle : number;

        /*private*/ m_gamma : number;

        /*private*/ m_impulse : org.jbox2d.common.Vec3;

        /*private*/ m_indexA : number;

        /*private*/ m_indexB : number;

        /*private*/ m_rA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_rB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_invMassA : number;

        /*private*/ m_invMassB : number;

        /*private*/ m_invIA : number;

        /*private*/ m_invIB : number;

        /*private*/ m_mass : org.jbox2d.common.Mat33 = new org.jbox2d.common.Mat33();

        constructor(argWorld : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.WeldJointDef) {
            super(argWorld, def);
            if(this.m_frequencyHz===undefined) this.m_frequencyHz = 0;
            if(this.m_dampingRatio===undefined) this.m_dampingRatio = 0;
            if(this.m_bias===undefined) this.m_bias = 0;
            if(this.m_localAnchorA===undefined) this.m_localAnchorA = null;
            if(this.m_localAnchorB===undefined) this.m_localAnchorB = null;
            if(this.m_referenceAngle===undefined) this.m_referenceAngle = 0;
            if(this.m_gamma===undefined) this.m_gamma = 0;
            if(this.m_impulse===undefined) this.m_impulse = null;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_invMassA===undefined) this.m_invMassA = 0;
            if(this.m_invMassB===undefined) this.m_invMassB = 0;
            if(this.m_invIA===undefined) this.m_invIA = 0;
            if(this.m_invIB===undefined) this.m_invIB = 0;
            this.m_localAnchorA = new org.jbox2d.common.Vec2(def.localAnchorA);
            this.m_localAnchorB = new org.jbox2d.common.Vec2(def.localAnchorB);
            this.m_referenceAngle = def.referenceAngle;
            this.m_frequencyHz = def.frequencyHz;
            this.m_dampingRatio = def.dampingRatio;
            this.m_impulse = new org.jbox2d.common.Vec3();
            this.m_impulse.setZero();
        }

        public getReferenceAngle() : number {
            return this.m_referenceAngle;
        }

        public getLocalAnchorA() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorA;
        }

        public getLocalAnchorB() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorB;
        }

        public getFrequency() : number {
            return this.m_frequencyHz;
        }

        public setFrequency(frequencyHz : number) {
            this.m_frequencyHz = frequencyHz;
        }

        public getDampingRatio() : number {
            return this.m_dampingRatio;
        }

        public setDampingRatio(dampingRatio : number) {
            this.m_dampingRatio = dampingRatio;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, argOut);
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, argOut);
        }

        /**
         * 
         * @param {number} inv_dt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(inv_dt : number, argOut : org.jbox2d.common.Vec2) {
            argOut.set$float$float(this.m_impulse.x, this.m_impulse.y);
            argOut.mulLocal(inv_dt);
        }

        /**
         * 
         * @param {number} inv_dt
         * @return {number}
         */
        public getReactionTorque(inv_dt : number) : number {
            return (<any>Math).fround(inv_dt * this.m_impulse.z);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexA = this.m_bodyA.m_islandIndex;
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_localCenterA.set$org_jbox2d_common_Vec2(this.m_bodyA.m_sweep.localCenter);
            this.m_localCenterB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            let aA : number = data.positions[this.m_indexA].a;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), this.m_rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), this.m_rB);
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            let K : org.jbox2d.common.Mat33 = this.pool.popMat33();
            K.ex.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(this.m_rA.y * this.m_rA.y) * iA)) + (<any>Math).fround((<any>Math).fround(this.m_rB.y * this.m_rB.y) * iB));
            K.ey.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-this.m_rA.y * this.m_rA.x) * iA) - (<any>Math).fround((<any>Math).fround(this.m_rB.y * this.m_rB.x) * iB));
            K.ez.x = (<any>Math).fround((<any>Math).fround(-this.m_rA.y * iA) - (<any>Math).fround(this.m_rB.y * iB));
            K.ex.y = K.ey.x;
            K.ey.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(this.m_rA.x * this.m_rA.x) * iA)) + (<any>Math).fround((<any>Math).fround(this.m_rB.x * this.m_rB.x) * iB));
            K.ez.y = (<any>Math).fround((<any>Math).fround(this.m_rA.x * iA) + (<any>Math).fround(this.m_rB.x * iB));
            K.ex.z = K.ez.x;
            K.ey.z = K.ez.y;
            K.ez.z = (<any>Math).fround(iA + iB);
            if(this.m_frequencyHz > 0.0) {
                K.getInverse22(this.m_mass);
                let invM : number = (<any>Math).fround(iA + iB);
                let m : number = invM > 0.0?(<any>Math).fround(1.0 / invM):0.0;
                let C : number = (<any>Math).fround((<any>Math).fround(aB - aA) - this.m_referenceAngle);
                let omega : number = (<any>Math).fround((<any>Math).fround(2.0 * org.jbox2d.common.MathUtils.PI_$LI$()) * this.m_frequencyHz);
                let d : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(2.0 * m) * this.m_dampingRatio) * omega);
                let k : number = (<any>Math).fround((<any>Math).fround(m * omega) * omega);
                let h : number = data.step.dt;
                this.m_gamma = (<any>Math).fround(h * ((<any>Math).fround(d + (<any>Math).fround(h * k))));
                this.m_gamma = this.m_gamma !== 0.0?(<any>Math).fround(1.0 / this.m_gamma):0.0;
                this.m_bias = (<any>Math).fround((<any>Math).fround((<any>Math).fround(C * h) * k) * this.m_gamma);
                invM += this.m_gamma;
                this.m_mass.ez.z = invM !== 0.0?(<any>Math).fround(1.0 / invM):0.0;
            } else {
                K.getSymInverse33(this.m_mass);
                this.m_gamma = 0.0;
                this.m_bias = 0.0;
            }
            if(data.step.warmStarting) {
                let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
                this.m_impulse.mulLocal(data.step.dtRatio);
                P.set$float$float(this.m_impulse.x, this.m_impulse.y);
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * ((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, P) + this.m_impulse.z)));
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * ((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, P) + this.m_impulse.z)));
                this.pool.pushVec2(1);
            } else {
                this.m_impulse.setZero();
            }
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(1);
            this.pool.pushRot(2);
            this.pool.pushMat33(1);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            let Cdot1 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            if(this.m_frequencyHz > 0.0) {
                let Cdot2 : number = (<any>Math).fround(wB - wA);
                let impulse2 : number = (<any>Math).fround(-this.m_mass.ez.z * ((<any>Math).fround((<any>Math).fround(Cdot2 + this.m_bias) + (<any>Math).fround(this.m_gamma * this.m_impulse.z))));
                this.m_impulse.z += impulse2;
                wA -= (<any>Math).fround(iA * impulse2);
                wB += (<any>Math).fround(iB * impulse2);
                org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wB, this.m_rB, Cdot1);
                org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wA, this.m_rA, temp);
                Cdot1.addLocal$org_jbox2d_common_Vec2(vB).subLocal(vA).subLocal(temp);
                let impulse1 : org.jbox2d.common.Vec2 = P;
                org.jbox2d.common.Mat33.mul22ToOutUnsafe(this.m_mass, Cdot1, impulse1);
                impulse1.negateLocal();
                this.m_impulse.x += impulse1.x;
                this.m_impulse.y += impulse1.y;
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, P));
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, P));
            } else {
                org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wA, this.m_rA, temp);
                org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(wB, this.m_rB, Cdot1);
                Cdot1.addLocal$org_jbox2d_common_Vec2(vB).subLocal(vA).subLocal(temp);
                let Cdot2 : number = (<any>Math).fround(wB - wA);
                let Cdot : org.jbox2d.common.Vec3 = this.pool.popVec3();
                Cdot.set$float$float$float(Cdot1.x, Cdot1.y, Cdot2);
                let impulse : org.jbox2d.common.Vec3 = this.pool.popVec3();
                org.jbox2d.common.Mat33.mulToOutUnsafe(this.m_mass, Cdot, impulse);
                impulse.negateLocal();
                this.m_impulse.addLocal(impulse);
                P.set$float$float(impulse.x, impulse.y);
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * ((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rA, P) + impulse.z)));
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * ((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_rB, P) + impulse.z)));
                this.pool.pushVec3(2);
            }
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
            this.pool.pushVec2(3);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rA : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let rB : org.jbox2d.common.Vec2 = this.pool.popVec2();
            qA.set$float(aA);
            qB.set$float(aB);
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), rB);
            let positionError : number;
            let angularError : number;
            let K : org.jbox2d.common.Mat33 = this.pool.popMat33();
            let C1 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
            K.ex.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(rA.y * rA.y) * iA)) + (<any>Math).fround((<any>Math).fround(rB.y * rB.y) * iB));
            K.ey.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-rA.y * rA.x) * iA) - (<any>Math).fround((<any>Math).fround(rB.y * rB.x) * iB));
            K.ez.x = (<any>Math).fround((<any>Math).fround(-rA.y * iA) - (<any>Math).fround(rB.y * iB));
            K.ex.y = K.ey.x;
            K.ey.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(rA.x * rA.x) * iA)) + (<any>Math).fround((<any>Math).fround(rB.x * rB.x) * iB));
            K.ez.y = (<any>Math).fround((<any>Math).fround(rA.x * iA) + (<any>Math).fround(rB.x * iB));
            K.ex.z = K.ez.x;
            K.ey.z = K.ez.y;
            K.ez.z = (<any>Math).fround(iA + iB);
            if(this.m_frequencyHz > 0.0) {
                C1.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(rB).subLocal(cA).subLocal(rA);
                positionError = C1.length();
                angularError = 0.0;
                K.solve22ToOut(C1, P);
                P.negateLocal();
                cA.x -= (<any>Math).fround(mA * P.x);
                cA.y -= (<any>Math).fround(mA * P.y);
                aA -= (<any>Math).fround(iA * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rA, P));
                cB.x += (<any>Math).fround(mB * P.x);
                cB.y += (<any>Math).fround(mB * P.y);
                aB += (<any>Math).fround(iB * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, P));
            } else {
                C1.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(rB).subLocal(cA).subLocal(rA);
                let C2 : number = (<any>Math).fround((<any>Math).fround(aB - aA) - this.m_referenceAngle);
                positionError = C1.length();
                angularError = org.jbox2d.common.MathUtils.abs$float(C2);
                let C : org.jbox2d.common.Vec3 = this.pool.popVec3();
                let impulse : org.jbox2d.common.Vec3 = this.pool.popVec3();
                C.set$float$float$float(C1.x, C1.y, C2);
                K.solve33ToOut(C, impulse);
                impulse.negateLocal();
                P.set$float$float(impulse.x, impulse.y);
                cA.x -= (<any>Math).fround(mA * P.x);
                cA.y -= (<any>Math).fround(mA * P.y);
                aA -= (<any>Math).fround(iA * ((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rA, P) + impulse.z)));
                cB.x += (<any>Math).fround(mB * P.x);
                cB.y += (<any>Math).fround(mB * P.y);
                aB += (<any>Math).fround(iB * ((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(rB, P) + impulse.z)));
                this.pool.pushVec3(2);
            }
            data.positions[this.m_indexA].a = aA;
            data.positions[this.m_indexB].a = aB;
            this.pool.pushVec2(5);
            this.pool.pushRot(2);
            this.pool.pushMat33(1);
            return positionError <= org.jbox2d.common.Settings.linearSlop && angularError <= org.jbox2d.common.Settings.angularSlop_$LI$();
        }
    }
    WeldJoint["__class"] = "org.jbox2d.dynamics.joints.WeldJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A wheel joint. This joint provides two degrees of freedom: translation along an axis fixed in
     * bodyA and rotation in the plane. You can use a joint limit to restrict the range of motion and a
     * joint motor to drive the rotation or to model rotational friction. This joint is designed for
     * vehicle suspensions.
     * 
     * @author Daniel Murphy
     * @extends org.jbox2d.dynamics.joints.Joint
     * @class
     */
    export class WheelJoint extends org.jbox2d.dynamics.joints.Joint {
        /*private*/ m_frequencyHz : number;

        /*private*/ m_dampingRatio : number;

        /*private*/ m_localAnchorA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localAnchorB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localXAxisA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localYAxisA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_impulse : number;

        /*private*/ m_motorImpulse : number;

        /*private*/ m_springImpulse : number;

        /*private*/ m_maxMotorTorque : number;

        /*private*/ m_motorSpeed : number;

        /*private*/ m_enableMotor : boolean;

        /*private*/ m_indexA : number;

        /*private*/ m_indexB : number;

        /*private*/ m_localCenterA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_localCenterB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_invMassA : number;

        /*private*/ m_invMassB : number;

        /*private*/ m_invIA : number;

        /*private*/ m_invIB : number;

        /*private*/ m_ax : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_ay : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ m_sAx : number;

        /*private*/ m_sBx : number;

        /*private*/ m_sAy : number;

        /*private*/ m_sBy : number;

        /*private*/ m_mass : number;

        /*private*/ m_motorMass : number;

        /*private*/ m_springMass : number;

        /*private*/ m_bias : number;

        /*private*/ m_gamma : number;

        constructor(argPool : org.jbox2d.pooling.IWorldPool, def : org.jbox2d.dynamics.joints.WheelJointDef) {
            super(argPool, def);
            if(this.m_frequencyHz===undefined) this.m_frequencyHz = 0;
            if(this.m_dampingRatio===undefined) this.m_dampingRatio = 0;
            if(this.m_impulse===undefined) this.m_impulse = 0;
            if(this.m_motorImpulse===undefined) this.m_motorImpulse = 0;
            if(this.m_springImpulse===undefined) this.m_springImpulse = 0;
            if(this.m_maxMotorTorque===undefined) this.m_maxMotorTorque = 0;
            if(this.m_motorSpeed===undefined) this.m_motorSpeed = 0;
            if(this.m_enableMotor===undefined) this.m_enableMotor = false;
            if(this.m_indexA===undefined) this.m_indexA = 0;
            if(this.m_indexB===undefined) this.m_indexB = 0;
            if(this.m_invMassA===undefined) this.m_invMassA = 0;
            if(this.m_invMassB===undefined) this.m_invMassB = 0;
            if(this.m_invIA===undefined) this.m_invIA = 0;
            if(this.m_invIB===undefined) this.m_invIB = 0;
            if(this.m_sAx===undefined) this.m_sAx = 0;
            if(this.m_sBx===undefined) this.m_sBx = 0;
            if(this.m_sAy===undefined) this.m_sAy = 0;
            if(this.m_sBy===undefined) this.m_sBy = 0;
            if(this.m_mass===undefined) this.m_mass = 0;
            if(this.m_motorMass===undefined) this.m_motorMass = 0;
            if(this.m_springMass===undefined) this.m_springMass = 0;
            if(this.m_bias===undefined) this.m_bias = 0;
            if(this.m_gamma===undefined) this.m_gamma = 0;
            this.m_localAnchorA.set$org_jbox2d_common_Vec2(def.localAnchorA);
            this.m_localAnchorB.set$org_jbox2d_common_Vec2(def.localAnchorB);
            this.m_localXAxisA.set$org_jbox2d_common_Vec2(def.localAxisA);
            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(1.0, this.m_localXAxisA, this.m_localYAxisA);
            this.m_motorMass = 0.0;
            this.m_motorImpulse = 0.0;
            this.m_maxMotorTorque = def.maxMotorTorque;
            this.m_motorSpeed = def.motorSpeed;
            this.m_enableMotor = def.enableMotor;
            this.m_frequencyHz = def.frequencyHz;
            this.m_dampingRatio = def.dampingRatio;
        }

        public getLocalAnchorA() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorA;
        }

        public getLocalAnchorB() : org.jbox2d.common.Vec2 {
            return this.m_localAnchorB;
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorA(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyA.getWorldPointToOut(this.m_localAnchorA, argOut);
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getAnchorB(argOut : org.jbox2d.common.Vec2) {
            this.m_bodyB.getWorldPointToOut(this.m_localAnchorB, argOut);
        }

        /**
         * 
         * @param {number} inv_dt
         * @param {org.jbox2d.common.Vec2} argOut
         */
        public getReactionForce(inv_dt : number, argOut : org.jbox2d.common.Vec2) {
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            temp.set$org_jbox2d_common_Vec2(this.m_ay).mulLocal(this.m_impulse);
            argOut.set$org_jbox2d_common_Vec2(this.m_ax).mulLocal(this.m_springImpulse).addLocal$org_jbox2d_common_Vec2(temp).mulLocal(inv_dt);
            this.pool.pushVec2(1);
        }

        /**
         * 
         * @param {number} inv_dt
         * @return {number}
         */
        public getReactionTorque(inv_dt : number) : number {
            return (<any>Math).fround(inv_dt * this.m_motorImpulse);
        }

        public getJointTranslation() : number {
            let b1 : org.jbox2d.dynamics.Body = this.m_bodyA;
            let b2 : org.jbox2d.dynamics.Body = this.m_bodyB;
            let p1 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let p2 : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let axis : org.jbox2d.common.Vec2 = this.pool.popVec2();
            b1.getWorldPointToOut(this.m_localAnchorA, p1);
            b2.getWorldPointToOut(this.m_localAnchorA, p2);
            p2.subLocal(p1);
            b1.getWorldVectorToOut(this.m_localXAxisA, axis);
            let translation : number = org.jbox2d.common.Vec2.dot(p2, axis);
            this.pool.pushVec2(3);
            return translation;
        }

        /**
         * For serialization
         * @return {org.jbox2d.common.Vec2}
         */
        public getLocalAxisA() : org.jbox2d.common.Vec2 {
            return this.m_localXAxisA;
        }

        public getJointSpeed() : number {
            return (<any>Math).fround(this.m_bodyA.m_angularVelocity - this.m_bodyB.m_angularVelocity);
        }

        public isMotorEnabled() : boolean {
            return this.m_enableMotor;
        }

        public enableMotor(flag : boolean) {
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_enableMotor = flag;
        }

        public setMotorSpeed(speed : number) {
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_motorSpeed = speed;
        }

        public getMotorSpeed() : number {
            return this.m_motorSpeed;
        }

        public getMaxMotorTorque() : number {
            return this.m_maxMotorTorque;
        }

        public setMaxMotorTorque(torque : number) {
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_maxMotorTorque = torque;
        }

        public getMotorTorque(inv_dt : number) : number {
            return (<any>Math).fround(this.m_motorImpulse * inv_dt);
        }

        public setSpringFrequencyHz(hz : number) {
            this.m_frequencyHz = hz;
        }

        public getSpringFrequencyHz() : number {
            return this.m_frequencyHz;
        }

        public setSpringDampingRatio(ratio : number) {
            this.m_dampingRatio = ratio;
        }

        public getSpringDampingRatio() : number {
            return this.m_dampingRatio;
        }

        /*private*/ rA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ rB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ d : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public initVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            this.m_indexA = this.m_bodyA.m_islandIndex;
            this.m_indexB = this.m_bodyB.m_islandIndex;
            this.m_localCenterA.set$org_jbox2d_common_Vec2(this.m_bodyA.m_sweep.localCenter);
            this.m_localCenterB.set$org_jbox2d_common_Vec2(this.m_bodyB.m_sweep.localCenter);
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOutUnsafe(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), this.rA);
            org.jbox2d.common.Rot.mulToOutUnsafe(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), this.rB);
            this.d.set$org_jbox2d_common_Vec2(cB).addLocal$org_jbox2d_common_Vec2(this.rB).subLocal(cA).subLocal(this.rA);
            {
                org.jbox2d.common.Rot.mulToOut(qA, this.m_localYAxisA, this.m_ay);
                this.m_sAy = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(temp.set$org_jbox2d_common_Vec2(this.d).addLocal$org_jbox2d_common_Vec2(this.rA), this.m_ay);
                this.m_sBy = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.rB, this.m_ay);
                this.m_mass = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * this.m_sAy) * this.m_sAy)) + (<any>Math).fround((<any>Math).fround(iB * this.m_sBy) * this.m_sBy));
                if(this.m_mass > 0.0) {
                    this.m_mass = (<any>Math).fround(1.0 / this.m_mass);
                }
            };
            this.m_springMass = 0.0;
            this.m_bias = 0.0;
            this.m_gamma = 0.0;
            if(this.m_frequencyHz > 0.0) {
                org.jbox2d.common.Rot.mulToOut(qA, this.m_localXAxisA, this.m_ax);
                this.m_sAx = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(temp.set$org_jbox2d_common_Vec2(this.d).addLocal$org_jbox2d_common_Vec2(this.rA), this.m_ax);
                this.m_sBx = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.rB, this.m_ax);
                let invMass : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(mA + mB) + (<any>Math).fround((<any>Math).fround(iA * this.m_sAx) * this.m_sAx)) + (<any>Math).fround((<any>Math).fround(iB * this.m_sBx) * this.m_sBx));
                if(invMass > 0.0) {
                    this.m_springMass = (<any>Math).fround(1.0 / invMass);
                    let C : number = org.jbox2d.common.Vec2.dot(this.d, this.m_ax);
                    let omega : number = (<any>Math).fround((<any>Math).fround(2.0 * org.jbox2d.common.MathUtils.PI_$LI$()) * this.m_frequencyHz);
                    let d : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(2.0 * this.m_springMass) * this.m_dampingRatio) * omega);
                    let k : number = (<any>Math).fround((<any>Math).fround(this.m_springMass * omega) * omega);
                    let h : number = data.step.dt;
                    this.m_gamma = (<any>Math).fround(h * ((<any>Math).fround(d + (<any>Math).fround(h * k))));
                    if(this.m_gamma > 0.0) {
                        this.m_gamma = (<any>Math).fround(1.0 / this.m_gamma);
                    }
                    this.m_bias = (<any>Math).fround((<any>Math).fround((<any>Math).fround(C * h) * k) * this.m_gamma);
                    this.m_springMass = (<any>Math).fround(invMass + this.m_gamma);
                    if(this.m_springMass > 0.0) {
                        this.m_springMass = (<any>Math).fround(1.0 / this.m_springMass);
                    }
                }
            } else {
                this.m_springImpulse = 0.0;
            }
            if(this.m_enableMotor) {
                this.m_motorMass = (<any>Math).fround(iA + iB);
                if(this.m_motorMass > 0.0) {
                    this.m_motorMass = (<any>Math).fround(1.0 / this.m_motorMass);
                }
            } else {
                this.m_motorMass = 0.0;
                this.m_motorImpulse = 0.0;
            }
            if(data.step.warmStarting) {
                let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
                this.m_impulse *= data.step.dtRatio;
                this.m_springImpulse *= data.step.dtRatio;
                this.m_motorImpulse *= data.step.dtRatio;
                P.x = (<any>Math).fround((<any>Math).fround(this.m_impulse * this.m_ay.x) + (<any>Math).fround(this.m_springImpulse * this.m_ax.x));
                P.y = (<any>Math).fround((<any>Math).fround(this.m_impulse * this.m_ay.y) + (<any>Math).fround(this.m_springImpulse * this.m_ax.y));
                let LA : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_impulse * this.m_sAy) + (<any>Math).fround(this.m_springImpulse * this.m_sAx)) + this.m_motorImpulse);
                let LB : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_impulse * this.m_sBy) + (<any>Math).fround(this.m_springImpulse * this.m_sBx)) + this.m_motorImpulse);
                vA.x -= (<any>Math).fround(this.m_invMassA * P.x);
                vA.y -= (<any>Math).fround(this.m_invMassA * P.y);
                wA -= (<any>Math).fround(this.m_invIA * LA);
                vB.x += (<any>Math).fround(this.m_invMassB * P.x);
                vB.y += (<any>Math).fround(this.m_invMassB * P.y);
                wB += (<any>Math).fround(this.m_invIB * LB);
                this.pool.pushVec2(1);
            } else {
                this.m_impulse = 0.0;
                this.m_springImpulse = 0.0;
                this.m_motorImpulse = 0.0;
            }
            this.pool.pushRot(2);
            this.pool.pushVec2(1);
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         */
        public solveVelocityConstraints(data : org.jbox2d.dynamics.SolverData) {
            let mA : number = this.m_invMassA;
            let mB : number = this.m_invMassB;
            let iA : number = this.m_invIA;
            let iB : number = this.m_invIB;
            let vA : org.jbox2d.common.Vec2 = data.velocities[this.m_indexA].v;
            let wA : number = data.velocities[this.m_indexA].w;
            let vB : org.jbox2d.common.Vec2 = data.velocities[this.m_indexB].v;
            let wB : number = data.velocities[this.m_indexB].w;
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
            {
                let Cdot : number = (<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.dot(this.m_ax, temp.set$org_jbox2d_common_Vec2(vB).subLocal(vA)) + (<any>Math).fround(this.m_sBx * wB)) - (<any>Math).fround(this.m_sAx * wA));
                let impulse : number = (<any>Math).fround(-this.m_springMass * ((<any>Math).fround((<any>Math).fround(Cdot + this.m_bias) + (<any>Math).fround(this.m_gamma * this.m_springImpulse))));
                this.m_springImpulse += impulse;
                P.x = (<any>Math).fround(impulse * this.m_ax.x);
                P.y = (<any>Math).fround(impulse * this.m_ax.y);
                let LA : number = (<any>Math).fround(impulse * this.m_sAx);
                let LB : number = (<any>Math).fround(impulse * this.m_sBx);
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * LA);
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * LB);
            };
            {
                let Cdot : number = (<any>Math).fround((<any>Math).fround(wB - wA) - this.m_motorSpeed);
                let impulse : number = (<any>Math).fround(-this.m_motorMass * Cdot);
                let oldImpulse : number = this.m_motorImpulse;
                let maxImpulse : number = (<any>Math).fround(data.step.dt * this.m_maxMotorTorque);
                this.m_motorImpulse = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(this.m_motorImpulse + impulse), -maxImpulse, maxImpulse);
                impulse = (<any>Math).fround(this.m_motorImpulse - oldImpulse);
                wA -= (<any>Math).fround(iA * impulse);
                wB += (<any>Math).fround(iB * impulse);
            };
            {
                let Cdot : number = (<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.dot(this.m_ay, temp.set$org_jbox2d_common_Vec2(vB).subLocal(vA)) + (<any>Math).fround(this.m_sBy * wB)) - (<any>Math).fround(this.m_sAy * wA));
                let impulse : number = (<any>Math).fround(-this.m_mass * Cdot);
                this.m_impulse += impulse;
                P.x = (<any>Math).fround(impulse * this.m_ay.x);
                P.y = (<any>Math).fround(impulse * this.m_ay.y);
                let LA : number = (<any>Math).fround(impulse * this.m_sAy);
                let LB : number = (<any>Math).fround(impulse * this.m_sBy);
                vA.x -= (<any>Math).fround(mA * P.x);
                vA.y -= (<any>Math).fround(mA * P.y);
                wA -= (<any>Math).fround(iA * LA);
                vB.x += (<any>Math).fround(mB * P.x);
                vB.y += (<any>Math).fround(mB * P.y);
                wB += (<any>Math).fround(iB * LB);
            };
            this.pool.pushVec2(2);
            data.velocities[this.m_indexA].w = wA;
            data.velocities[this.m_indexB].w = wB;
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.SolverData} data
         * @return {boolean}
         */
        public solvePositionConstraints(data : org.jbox2d.dynamics.SolverData) : boolean {
            let cA : org.jbox2d.common.Vec2 = data.positions[this.m_indexA].c;
            let aA : number = data.positions[this.m_indexA].a;
            let cB : org.jbox2d.common.Vec2 = data.positions[this.m_indexB].c;
            let aB : number = data.positions[this.m_indexB].a;
            let qA : org.jbox2d.common.Rot = this.pool.popRot();
            let qB : org.jbox2d.common.Rot = this.pool.popRot();
            let temp : org.jbox2d.common.Vec2 = this.pool.popVec2();
            qA.set$float(aA);
            qB.set$float(aB);
            org.jbox2d.common.Rot.mulToOut(qA, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorA).subLocal(this.m_localCenterA), this.rA);
            org.jbox2d.common.Rot.mulToOut(qB, temp.set$org_jbox2d_common_Vec2(this.m_localAnchorB).subLocal(this.m_localCenterB), this.rB);
            this.d.set$org_jbox2d_common_Vec2(cB).subLocal(cA).addLocal$org_jbox2d_common_Vec2(this.rB).subLocal(this.rA);
            let ay : org.jbox2d.common.Vec2 = this.pool.popVec2();
            org.jbox2d.common.Rot.mulToOut(qA, this.m_localYAxisA, ay);
            let sAy : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(temp.set$org_jbox2d_common_Vec2(this.d).addLocal$org_jbox2d_common_Vec2(this.rA), ay);
            let sBy : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.rB, ay);
            let C : number = org.jbox2d.common.Vec2.dot(this.d, ay);
            let k : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_invMassA + this.m_invMassB) + (<any>Math).fround((<any>Math).fround(this.m_invIA * this.m_sAy) * this.m_sAy)) + (<any>Math).fround((<any>Math).fround(this.m_invIB * this.m_sBy) * this.m_sBy));
            let impulse : number;
            if(k !== 0.0) {
                impulse = (<any>Math).fround(-C / k);
            } else {
                impulse = 0.0;
            }
            let P : org.jbox2d.common.Vec2 = this.pool.popVec2();
            P.x = (<any>Math).fround(impulse * ay.x);
            P.y = (<any>Math).fround(impulse * ay.y);
            let LA : number = (<any>Math).fround(impulse * sAy);
            let LB : number = (<any>Math).fround(impulse * sBy);
            cA.x -= (<any>Math).fround(this.m_invMassA * P.x);
            cA.y -= (<any>Math).fround(this.m_invMassA * P.y);
            aA -= (<any>Math).fround(this.m_invIA * LA);
            cB.x += (<any>Math).fround(this.m_invMassB * P.x);
            cB.y += (<any>Math).fround(this.m_invMassB * P.y);
            aB += (<any>Math).fround(this.m_invIB * LB);
            this.pool.pushVec2(3);
            this.pool.pushRot(2);
            data.positions[this.m_indexA].a = aA;
            data.positions[this.m_indexB].a = aB;
            return org.jbox2d.common.MathUtils.abs$float(C) <= org.jbox2d.common.Settings.linearSlop;
        }
    }
    WheelJoint["__class"] = "org.jbox2d.dynamics.joints.WheelJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Definition for a {@link ConstantVolumeJoint}, which connects a group a bodies together so they
     * maintain a constant volume within them.
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class ConstantVolumeJointDef extends org.jbox2d.dynamics.joints.JointDef {
        public frequencyHz : number;

        public dampingRatio : number;

        bodies : Array<org.jbox2d.dynamics.Body>;

        joints : Array<org.jbox2d.dynamics.joints.DistanceJoint>;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.CONSTANT_VOLUME);
            if(this.frequencyHz===undefined) this.frequencyHz = 0;
            if(this.dampingRatio===undefined) this.dampingRatio = 0;
            if(this.bodies===undefined) this.bodies = null;
            if(this.joints===undefined) this.joints = null;
            this.bodies = <any>([]);
            this.joints = null;
            this.collideConnected = false;
            this.frequencyHz = 0.0;
            this.dampingRatio = 0.0;
        }

        /**
         * Adds a body to the group
         * 
         * @param {org.jbox2d.dynamics.Body} argBody
         */
        public addBody(argBody : org.jbox2d.dynamics.Body) {
            /* add */(this.bodies.push(argBody)>0);
            if(/* size */(<number>this.bodies.length) === 1) {
                this.bodyA = argBody;
            }
            if(/* size */(<number>this.bodies.length) === 2) {
                this.bodyB = argBody;
            }
        }

        /**
         * Adds a body and the pre-made distance joint. Should only be used for deserialization.
         * @param {org.jbox2d.dynamics.Body} argBody
         * @param {org.jbox2d.dynamics.joints.DistanceJoint} argJoint
         */
        public addBodyAndJoint(argBody : org.jbox2d.dynamics.Body, argJoint : org.jbox2d.dynamics.joints.DistanceJoint) {
            this.addBody(argBody);
            if(this.joints == null) {
                this.joints = <any>([]);
            }
            /* add */(this.joints.push(argJoint)>0);
        }
    }
    ConstantVolumeJointDef["__class"] = "org.jbox2d.dynamics.joints.ConstantVolumeJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Distance joint definition. This requires defining an anchor point on both bodies and the non-zero
     * length of the distance joint. The definition uses local anchor points so that the initial
     * configuration can violate the constraint slightly. This helps when saving and loading a game.
     * 
     * @warning Do not use a zero or short length.
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class DistanceJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The local anchor point relative to body1's origin.
         */
        public localAnchorA : org.jbox2d.common.Vec2;

        /**
         * The local anchor point relative to body2's origin.
         */
        public localAnchorB : org.jbox2d.common.Vec2;

        /**
         * The equilibrium length between the anchor points.
         */
        public length : number;

        /**
         * The mass-spring-damper frequency in Hertz.
         */
        public frequencyHz : number;

        /**
         * The damping ratio. 0 = no damping, 1 = critical damping.
         */
        public dampingRatio : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.DISTANCE);
            if(this.localAnchorA===undefined) this.localAnchorA = null;
            if(this.localAnchorB===undefined) this.localAnchorB = null;
            if(this.length===undefined) this.length = 0;
            if(this.frequencyHz===undefined) this.frequencyHz = 0;
            if(this.dampingRatio===undefined) this.dampingRatio = 0;
            this.localAnchorA = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.localAnchorB = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.length = 1.0;
            this.frequencyHz = 0.0;
            this.dampingRatio = 0.0;
        }

        /**
         * Initialize the bodies, anchors, and length using the world anchors.
         * 
         * @param {org.jbox2d.dynamics.Body} b1 First body
         * @param {org.jbox2d.dynamics.Body} b2 Second body
         * @param {org.jbox2d.common.Vec2} anchor1 World anchor on first body
         * @param {org.jbox2d.common.Vec2} anchor2 World anchor on second body
         */
        public initialize(b1 : org.jbox2d.dynamics.Body, b2 : org.jbox2d.dynamics.Body, anchor1 : org.jbox2d.common.Vec2, anchor2 : org.jbox2d.common.Vec2) {
            this.bodyA = b1;
            this.bodyB = b2;
            this.localAnchorA.set$org_jbox2d_common_Vec2(this.bodyA.getLocalPoint(anchor1));
            this.localAnchorB.set$org_jbox2d_common_Vec2(this.bodyB.getLocalPoint(anchor2));
            let d : org.jbox2d.common.Vec2 = anchor2.sub(anchor1);
            this.length = d.length();
        }
    }
    DistanceJointDef["__class"] = "org.jbox2d.dynamics.joints.DistanceJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Friction joint definition.
     * 
     * @author Daniel Murphy
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class FrictionJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The local anchor point relative to bodyA's origin.
         */
        public localAnchorA : org.jbox2d.common.Vec2;

        /**
         * The local anchor point relative to bodyB's origin.
         */
        public localAnchorB : org.jbox2d.common.Vec2;

        /**
         * The maximum friction force in N.
         */
        public maxForce : number;

        /**
         * The maximum friction torque in N-m.
         */
        public maxTorque : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.FRICTION);
            if(this.localAnchorA===undefined) this.localAnchorA = null;
            if(this.localAnchorB===undefined) this.localAnchorB = null;
            if(this.maxForce===undefined) this.maxForce = 0;
            if(this.maxTorque===undefined) this.maxTorque = 0;
            this.localAnchorA = new org.jbox2d.common.Vec2();
            this.localAnchorB = new org.jbox2d.common.Vec2();
            this.maxForce = 0.0;
            this.maxTorque = 0.0;
        }

        /**
         * Initialize the bodies, anchors, axis, and reference angle using the world anchor and world
         * axis.
         * @param {org.jbox2d.dynamics.Body} bA
         * @param {org.jbox2d.dynamics.Body} bB
         * @param {org.jbox2d.common.Vec2} anchor
         */
        public initialize(bA : org.jbox2d.dynamics.Body, bB : org.jbox2d.dynamics.Body, anchor : org.jbox2d.common.Vec2) {
            this.bodyA = bA;
            this.bodyB = bB;
            bA.getLocalPointToOut(anchor, this.localAnchorA);
            bB.getLocalPointToOut(anchor, this.localAnchorB);
        }
    }
    FrictionJointDef["__class"] = "org.jbox2d.dynamics.joints.FrictionJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Gear joint definition. This definition requires two existing revolute or prismatic joints (any
     * combination will work). The provided joints must attach a dynamic body to a static body.
     * 
     * @author Daniel Murphy
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class GearJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The first revolute/prismatic joint attached to the gear joint.
         */
        public joint1 : org.jbox2d.dynamics.joints.Joint;

        /**
         * The second revolute/prismatic joint attached to the gear joint.
         */
        public joint2 : org.jbox2d.dynamics.joints.Joint;

        /**
         * Gear ratio.
         * 
         * @see GearJoint
         */
        public ratio : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.GEAR);
            if(this.joint1===undefined) this.joint1 = null;
            if(this.joint2===undefined) this.joint2 = null;
            if(this.ratio===undefined) this.ratio = 0;
            this.joint1 = null;
            this.joint2 = null;
        }
    }
    GearJointDef["__class"] = "org.jbox2d.dynamics.joints.GearJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Motor joint definition.
     * 
     * @author dmurph
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class MotorJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * Position of bodyB minus the position of bodyA, in bodyA's frame, in meters.
         */
        public linearOffset : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The bodyB angle minus bodyA angle in radians.
         */
        public angularOffset : number;

        /**
         * The maximum motor force in N.
         */
        public maxForce : number;

        /**
         * The maximum motor torque in N-m.
         */
        public maxTorque : number;

        /**
         * Position correction factor in the range [0,1].
         */
        public correctionFactor : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.MOTOR);
            if(this.angularOffset===undefined) this.angularOffset = 0;
            if(this.maxForce===undefined) this.maxForce = 0;
            if(this.maxTorque===undefined) this.maxTorque = 0;
            if(this.correctionFactor===undefined) this.correctionFactor = 0;
            this.angularOffset = 0;
            this.maxForce = 1;
            this.maxTorque = 1;
            this.correctionFactor = 0.3;
        }

        public initialize(bA : org.jbox2d.dynamics.Body, bB : org.jbox2d.dynamics.Body) {
            this.bodyA = bA;
            this.bodyB = bB;
            let xB : org.jbox2d.common.Vec2 = this.bodyB.getPosition();
            this.bodyA.getLocalPointToOut(xB, this.linearOffset);
            let angleA : number = this.bodyA.getAngle();
            let angleB : number = this.bodyB.getAngle();
            this.angularOffset = (<any>Math).fround(angleB - angleA);
        }
    }
    MotorJointDef["__class"] = "org.jbox2d.dynamics.joints.MotorJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Mouse joint definition. This requires a world target point, tuning parameters, and the time step.
     * 
     * @author Daniel
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class MouseJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The initial world target point. This is assumed to coincide with the body anchor initially.
         */
        public target : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The maximum constraint force that can be exerted to move the candidate body. Usually you will
         * express as some multiple of the weight (multiplier * mass * gravity).
         */
        public maxForce : number;

        /**
         * The response speed.
         */
        public frequencyHz : number;

        /**
         * The damping ratio. 0 = no damping, 1 = critical damping.
         */
        public dampingRatio : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.MOUSE);
            if(this.maxForce===undefined) this.maxForce = 0;
            if(this.frequencyHz===undefined) this.frequencyHz = 0;
            if(this.dampingRatio===undefined) this.dampingRatio = 0;
            this.target.set$float$float(0, 0);
            this.maxForce = 0;
            this.frequencyHz = 5;
            this.dampingRatio = 0.7;
        }
    }
    MouseJointDef["__class"] = "org.jbox2d.dynamics.joints.MouseJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Prismatic joint definition. This requires defining a line of motion using an axis and an anchor
     * point. The definition uses local anchor points and a local axis so that the initial configuration
     * can violate the constraint slightly. The joint translation is zero when the local anchor points
     * coincide in world space. Using local anchors and a local axis helps when saving and loading a
     * game.
     * 
     * @warning at least one body should by dynamic with a non-fixed rotation.
     * @author Daniel
     * 
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class PrismaticJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The local anchor point relative to body1's origin.
         */
        public localAnchorA : org.jbox2d.common.Vec2;

        /**
         * The local anchor point relative to body2's origin.
         */
        public localAnchorB : org.jbox2d.common.Vec2;

        /**
         * The local translation axis in body1.
         */
        public localAxisA : org.jbox2d.common.Vec2;

        /**
         * The constrained angle between the bodies: body2_angle - body1_angle.
         */
        public referenceAngle : number;

        /**
         * Enable/disable the joint limit.
         */
        public enableLimit : boolean;

        /**
         * The lower translation limit, usually in meters.
         */
        public lowerTranslation : number;

        /**
         * The upper translation limit, usually in meters.
         */
        public upperTranslation : number;

        /**
         * Enable/disable the joint motor.
         */
        public enableMotor : boolean;

        /**
         * The maximum motor torque, usually in N-m.
         */
        public maxMotorForce : number;

        /**
         * The desired motor speed in radians per second.
         */
        public motorSpeed : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.PRISMATIC);
            if(this.localAnchorA===undefined) this.localAnchorA = null;
            if(this.localAnchorB===undefined) this.localAnchorB = null;
            if(this.localAxisA===undefined) this.localAxisA = null;
            if(this.referenceAngle===undefined) this.referenceAngle = 0;
            if(this.enableLimit===undefined) this.enableLimit = false;
            if(this.lowerTranslation===undefined) this.lowerTranslation = 0;
            if(this.upperTranslation===undefined) this.upperTranslation = 0;
            if(this.enableMotor===undefined) this.enableMotor = false;
            if(this.maxMotorForce===undefined) this.maxMotorForce = 0;
            if(this.motorSpeed===undefined) this.motorSpeed = 0;
            this.localAnchorA = new org.jbox2d.common.Vec2();
            this.localAnchorB = new org.jbox2d.common.Vec2();
            this.localAxisA = new org.jbox2d.common.Vec2(1.0, 0.0);
            this.referenceAngle = 0.0;
            this.enableLimit = false;
            this.lowerTranslation = 0.0;
            this.upperTranslation = 0.0;
            this.enableMotor = false;
            this.maxMotorForce = 0.0;
            this.motorSpeed = 0.0;
        }

        /**
         * Initialize the bodies, anchors, axis, and reference angle using the world anchor and world
         * axis.
         * @param {org.jbox2d.dynamics.Body} b1
         * @param {org.jbox2d.dynamics.Body} b2
         * @param {org.jbox2d.common.Vec2} anchor
         * @param {org.jbox2d.common.Vec2} axis
         */
        public initialize(b1 : org.jbox2d.dynamics.Body, b2 : org.jbox2d.dynamics.Body, anchor : org.jbox2d.common.Vec2, axis : org.jbox2d.common.Vec2) {
            this.bodyA = b1;
            this.bodyB = b2;
            this.bodyA.getLocalPointToOut(anchor, this.localAnchorA);
            this.bodyB.getLocalPointToOut(anchor, this.localAnchorB);
            this.bodyA.getLocalVectorToOut(axis, this.localAxisA);
            this.referenceAngle = (<any>Math).fround(this.bodyB.getAngle() - this.bodyA.getAngle());
        }
    }
    PrismaticJointDef["__class"] = "org.jbox2d.dynamics.joints.PrismaticJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Pulley joint definition. This requires two ground anchors, two dynamic body anchor points, and a
     * pulley ratio.
     * 
     * @author Daniel Murphy
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class PulleyJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The first ground anchor in world coordinates. This point never moves.
         */
        public groundAnchorA : org.jbox2d.common.Vec2;

        /**
         * The second ground anchor in world coordinates. This point never moves.
         */
        public groundAnchorB : org.jbox2d.common.Vec2;

        /**
         * The local anchor point relative to bodyA's origin.
         */
        public localAnchorA : org.jbox2d.common.Vec2;

        /**
         * The local anchor point relative to bodyB's origin.
         */
        public localAnchorB : org.jbox2d.common.Vec2;

        /**
         * The a reference length for the segment attached to bodyA.
         */
        public lengthA : number;

        /**
         * The a reference length for the segment attached to bodyB.
         */
        public lengthB : number;

        /**
         * The pulley ratio, used to simulate a block-and-tackle.
         */
        public ratio : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.PULLEY);
            if(this.groundAnchorA===undefined) this.groundAnchorA = null;
            if(this.groundAnchorB===undefined) this.groundAnchorB = null;
            if(this.localAnchorA===undefined) this.localAnchorA = null;
            if(this.localAnchorB===undefined) this.localAnchorB = null;
            if(this.lengthA===undefined) this.lengthA = 0;
            if(this.lengthB===undefined) this.lengthB = 0;
            if(this.ratio===undefined) this.ratio = 0;
            this.groundAnchorA = new org.jbox2d.common.Vec2(-1.0, 1.0);
            this.groundAnchorB = new org.jbox2d.common.Vec2(1.0, 1.0);
            this.localAnchorA = new org.jbox2d.common.Vec2(-1.0, 0.0);
            this.localAnchorB = new org.jbox2d.common.Vec2(1.0, 0.0);
            this.lengthA = 0.0;
            this.lengthB = 0.0;
            this.ratio = 1.0;
            this.collideConnected = true;
        }

        /**
         * Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.
         * @param {org.jbox2d.dynamics.Body} b1
         * @param {org.jbox2d.dynamics.Body} b2
         * @param {org.jbox2d.common.Vec2} ga1
         * @param {org.jbox2d.common.Vec2} ga2
         * @param {org.jbox2d.common.Vec2} anchor1
         * @param {org.jbox2d.common.Vec2} anchor2
         * @param {number} r
         */
        public initialize(b1 : org.jbox2d.dynamics.Body, b2 : org.jbox2d.dynamics.Body, ga1 : org.jbox2d.common.Vec2, ga2 : org.jbox2d.common.Vec2, anchor1 : org.jbox2d.common.Vec2, anchor2 : org.jbox2d.common.Vec2, r : number) {
            this.bodyA = b1;
            this.bodyB = b2;
            this.groundAnchorA = ga1;
            this.groundAnchorB = ga2;
            this.localAnchorA = this.bodyA.getLocalPoint(anchor1);
            this.localAnchorB = this.bodyB.getLocalPoint(anchor2);
            let d1 : org.jbox2d.common.Vec2 = anchor1.sub(ga1);
            this.lengthA = d1.length();
            let d2 : org.jbox2d.common.Vec2 = anchor2.sub(ga2);
            this.lengthB = d2.length();
            this.ratio = r;
        }
    }
    PulleyJointDef["__class"] = "org.jbox2d.dynamics.joints.PulleyJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Revolute joint definition. This requires defining an anchor point where the bodies are joined.
     * The definition uses local anchor points so that the initial configuration can violate the
     * constraint slightly. You also need to specify the initial relative angle for joint limits. This
     * helps when saving and loading a game. The local anchor points are measured from the body's origin
     * rather than the center of mass because:<br/>
     * <ul>
     * <li>you might not know where the center of mass will be.</li>
     * <li>if you add/remove shapes from a body and recompute the mass, the joints will be broken.</li>
     * </ul>
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class RevoluteJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The local anchor point relative to body1's origin.
         */
        public localAnchorA : org.jbox2d.common.Vec2;

        /**
         * The local anchor point relative to body2's origin.
         */
        public localAnchorB : org.jbox2d.common.Vec2;

        /**
         * The body2 angle minus body1 angle in the reference state (radians).
         */
        public referenceAngle : number;

        /**
         * A flag to enable joint limits.
         */
        public enableLimit : boolean;

        /**
         * The lower angle for the joint limit (radians).
         */
        public lowerAngle : number;

        /**
         * The upper angle for the joint limit (radians).
         */
        public upperAngle : number;

        /**
         * A flag to enable the joint motor.
         */
        public enableMotor : boolean;

        /**
         * The desired motor speed. Usually in radians per second.
         */
        public motorSpeed : number;

        /**
         * The maximum motor torque used to achieve the desired motor speed. Usually in N-m.
         */
        public maxMotorTorque : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.REVOLUTE);
            if(this.localAnchorA===undefined) this.localAnchorA = null;
            if(this.localAnchorB===undefined) this.localAnchorB = null;
            if(this.referenceAngle===undefined) this.referenceAngle = 0;
            if(this.enableLimit===undefined) this.enableLimit = false;
            if(this.lowerAngle===undefined) this.lowerAngle = 0;
            if(this.upperAngle===undefined) this.upperAngle = 0;
            if(this.enableMotor===undefined) this.enableMotor = false;
            if(this.motorSpeed===undefined) this.motorSpeed = 0;
            if(this.maxMotorTorque===undefined) this.maxMotorTorque = 0;
            this.localAnchorA = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.localAnchorB = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.referenceAngle = 0.0;
            this.lowerAngle = 0.0;
            this.upperAngle = 0.0;
            this.maxMotorTorque = 0.0;
            this.motorSpeed = 0.0;
            this.enableLimit = false;
            this.enableMotor = false;
        }

        /**
         * Initialize the bodies, anchors, and reference angle using the world anchor.
         * 
         * @param {org.jbox2d.dynamics.Body} b1
         * @param {org.jbox2d.dynamics.Body} b2
         * @param {org.jbox2d.common.Vec2} anchor
         */
        public initialize(b1 : org.jbox2d.dynamics.Body, b2 : org.jbox2d.dynamics.Body, anchor : org.jbox2d.common.Vec2) {
            this.bodyA = b1;
            this.bodyB = b2;
            this.bodyA.getLocalPointToOut(anchor, this.localAnchorA);
            this.bodyB.getLocalPointToOut(anchor, this.localAnchorB);
            this.referenceAngle = (<any>Math).fround(this.bodyB.getAngle() - this.bodyA.getAngle());
        }
    }
    RevoluteJointDef["__class"] = "org.jbox2d.dynamics.joints.RevoluteJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Rope joint definition. This requires two body anchor points and a maximum lengths. Note: by
     * default the connected objects will not collide. see collideConnected in b2JointDef.
     * 
     * @author Daniel Murphy
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class RopeJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The local anchor point relative to bodyA's origin.
         */
        public localAnchorA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The local anchor point relative to bodyB's origin.
         */
        public localAnchorB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The maximum length of the rope. Warning: this must be larger than b2_linearSlop or the joint
         * will have no effect.
         */
        public maxLength : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.ROPE);
            if(this.maxLength===undefined) this.maxLength = 0;
            this.localAnchorA.set$float$float(-1.0, 0.0);
            this.localAnchorB.set$float$float(1.0, 0.0);
        }
    }
    RopeJointDef["__class"] = "org.jbox2d.dynamics.joints.RopeJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * @author Daniel Murphy
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class WeldJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The local anchor point relative to body1's origin.
         */
        public localAnchorA : org.jbox2d.common.Vec2;

        /**
         * The local anchor point relative to body2's origin.
         */
        public localAnchorB : org.jbox2d.common.Vec2;

        /**
         * The body2 angle minus body1 angle in the reference state (radians).
         */
        public referenceAngle : number;

        /**
         * The mass-spring-damper frequency in Hertz. Rotation only. Disable softness with a value of 0.
         */
        public frequencyHz : number;

        /**
         * The damping ratio. 0 = no damping, 1 = critical damping.
         */
        public dampingRatio : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.WELD);
            if(this.localAnchorA===undefined) this.localAnchorA = null;
            if(this.localAnchorB===undefined) this.localAnchorB = null;
            if(this.referenceAngle===undefined) this.referenceAngle = 0;
            if(this.frequencyHz===undefined) this.frequencyHz = 0;
            if(this.dampingRatio===undefined) this.dampingRatio = 0;
            this.localAnchorA = new org.jbox2d.common.Vec2();
            this.localAnchorB = new org.jbox2d.common.Vec2();
            this.referenceAngle = 0.0;
        }

        /**
         * Initialize the bodies, anchors, and reference angle using a world anchor point.
         * 
         * @param {org.jbox2d.dynamics.Body} bA
         * @param {org.jbox2d.dynamics.Body} bB
         * @param {org.jbox2d.common.Vec2} anchor
         */
        public initialize(bA : org.jbox2d.dynamics.Body, bB : org.jbox2d.dynamics.Body, anchor : org.jbox2d.common.Vec2) {
            this.bodyA = bA;
            this.bodyB = bB;
            this.bodyA.getLocalPointToOut(anchor, this.localAnchorA);
            this.bodyB.getLocalPointToOut(anchor, this.localAnchorB);
            this.referenceAngle = (<any>Math).fround(this.bodyB.getAngle() - this.bodyA.getAngle());
        }
    }
    WeldJointDef["__class"] = "org.jbox2d.dynamics.joints.WeldJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Wheel joint definition. This requires defining a line of motion using an axis and an anchor
     * point. The definition uses local anchor points and a local axis so that the initial configuration
     * can violate the constraint slightly. The joint translation is zero when the local anchor points
     * coincide in world space. Using local anchors and a local axis helps when saving and loading a
     * game.
     * 
     * @author Daniel Murphy
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class WheelJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The local anchor point relative to body1's origin.
         */
        public localAnchorA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The local anchor point relative to body2's origin.
         */
        public localAnchorB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The local translation axis in body1.
         */
        public localAxisA : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * Enable/disable the joint motor.
         */
        public enableMotor : boolean;

        /**
         * The maximum motor torque, usually in N-m.
         */
        public maxMotorTorque : number;

        /**
         * The desired motor speed in radians per second.
         */
        public motorSpeed : number;

        /**
         * Suspension frequency, zero indicates no suspension
         */
        public frequencyHz : number;

        /**
         * Suspension damping ratio, one indicates critical damping
         */
        public dampingRatio : number;

        public constructor() {
            super(org.jbox2d.dynamics.joints.JointType.WHEEL);
            if(this.enableMotor===undefined) this.enableMotor = false;
            if(this.maxMotorTorque===undefined) this.maxMotorTorque = 0;
            if(this.motorSpeed===undefined) this.motorSpeed = 0;
            if(this.frequencyHz===undefined) this.frequencyHz = 0;
            if(this.dampingRatio===undefined) this.dampingRatio = 0;
            this.localAxisA.set$float$float(1, 0);
            this.enableMotor = false;
            this.maxMotorTorque = 0.0;
            this.motorSpeed = 0.0;
        }

        public initialize(b1 : org.jbox2d.dynamics.Body, b2 : org.jbox2d.dynamics.Body, anchor : org.jbox2d.common.Vec2, axis : org.jbox2d.common.Vec2) {
            this.bodyA = b1;
            this.bodyB = b2;
            b1.getLocalPointToOut(anchor, this.localAnchorA);
            b2.getLocalPointToOut(anchor, this.localAnchorB);
            this.bodyA.getLocalVectorToOut(axis, this.localAxisA);
        }
    }
    WheelJointDef["__class"] = "org.jbox2d.dynamics.joints.WheelJointDef";

}
namespace org.jbox2d.particle {
    export class ParticleSystem {
        /**
         * All particle types that require creating pairs
         */
        static k_pairFlags : number; public static k_pairFlags_$LI$() : number { if(ParticleSystem.k_pairFlags == null) ParticleSystem.k_pairFlags = org.jbox2d.particle.ParticleType.b2_springParticle_$LI$(); return ParticleSystem.k_pairFlags; };

        /**
         * All particle types that require creating triads
         */
        static k_triadFlags : number; public static k_triadFlags_$LI$() : number { if(ParticleSystem.k_triadFlags == null) ParticleSystem.k_triadFlags = org.jbox2d.particle.ParticleType.b2_elasticParticle_$LI$(); return ParticleSystem.k_triadFlags; };

        /**
         * All particle types that require computing depth
         */
        static k_noPressureFlags : number; public static k_noPressureFlags_$LI$() : number { if(ParticleSystem.k_noPressureFlags == null) ParticleSystem.k_noPressureFlags = org.jbox2d.particle.ParticleType.b2_powderParticle_$LI$(); return ParticleSystem.k_noPressureFlags; };

        static xTruncBits : number = 12;

        static yTruncBits : number = 12;

        static tagBits : number; public static tagBits_$LI$() : number { if(ParticleSystem.tagBits == null) ParticleSystem.tagBits = 8 * 4 - 1; return ParticleSystem.tagBits; };

        static yOffset : number; public static yOffset_$LI$() : number { if(ParticleSystem.yOffset == null) ParticleSystem.yOffset = 1 << (ParticleSystem.yTruncBits - 1); return ParticleSystem.yOffset; };

        static yShift : number; public static yShift_$LI$() : number { if(ParticleSystem.yShift == null) ParticleSystem.yShift = ParticleSystem.tagBits_$LI$() - ParticleSystem.yTruncBits; return ParticleSystem.yShift; };

        static xShift : number; public static xShift_$LI$() : number { if(ParticleSystem.xShift == null) ParticleSystem.xShift = ParticleSystem.tagBits_$LI$() - ParticleSystem.yTruncBits - ParticleSystem.xTruncBits; return ParticleSystem.xShift; };

        static xScale : number; public static xScale_$LI$() : number { if(ParticleSystem.xScale == null) ParticleSystem.xScale = 1 << ParticleSystem.xShift_$LI$(); return ParticleSystem.xScale; };

        static xOffset : number; public static xOffset_$LI$() : number { if(ParticleSystem.xOffset == null) ParticleSystem.xOffset = ParticleSystem.xScale_$LI$() * (1 << (ParticleSystem.xTruncBits - 1)); return ParticleSystem.xOffset; };

        static xMask : number; public static xMask_$LI$() : number { if(ParticleSystem.xMask == null) ParticleSystem.xMask = (1 << ParticleSystem.xTruncBits) - 1; return ParticleSystem.xMask; };

        static yMask : number; public static yMask_$LI$() : number { if(ParticleSystem.yMask == null) ParticleSystem.yMask = (1 << ParticleSystem.yTruncBits) - 1; return ParticleSystem.yMask; };

        static computeTag(x : number, y : number) : number {
            return (((n => n<0?Math.ceil(n):Math.floor(n))(<number>((<any>Math).fround(y + ParticleSystem.yOffset_$LI$())))) << ParticleSystem.yShift_$LI$()) + (((n => n<0?Math.ceil(n):Math.floor(n))(<number>((<any>Math).fround(ParticleSystem.xScale_$LI$() * x)))) + ParticleSystem.xOffset_$LI$());
        }

        static computeRelativeTag(tag : number, x : number, y : number) : number {
            return tag + (y << ParticleSystem.yShift_$LI$()) + (x << ParticleSystem.xShift_$LI$());
        }

        static limitCapacity(capacity : number, maxCount : number) : number {
            return maxCount !== 0 && capacity > maxCount?maxCount:capacity;
        }

        m_timestamp : number;

        m_allParticleFlags : number;

        m_allGroupFlags : number;

        m_density : number;

        m_inverseDensity : number;

        m_gravityScale : number;

        m_particleDiameter : number;

        m_inverseDiameter : number;

        m_squaredDiameter : number;

        m_count : number;

        m_internalAllocatedCapacity : number;

        m_maxCount : number;

        m_flagsBuffer : ParticleSystem.ParticleBufferInt;

        m_positionBuffer : ParticleSystem.ParticleBuffer<org.jbox2d.common.Vec2>;

        m_velocityBuffer : ParticleSystem.ParticleBuffer<org.jbox2d.common.Vec2>;

        m_accumulationBuffer : number[];

        m_accumulation2Buffer : org.jbox2d.common.Vec2[];

        m_depthBuffer : number[];

        public m_colorBuffer : ParticleSystem.ParticleBuffer<org.jbox2d.particle.ParticleColor>;

        m_groupBuffer : org.jbox2d.particle.ParticleGroup[];

        m_userDataBuffer : ParticleSystem.ParticleBuffer<any>;

        m_proxyCount : number;

        m_proxyCapacity : number;

        m_proxyBuffer : ParticleSystem.Proxy[];

        public m_contactCount : number;

        m_contactCapacity : number;

        public m_contactBuffer : org.jbox2d.particle.ParticleContact[];

        public m_bodyContactCount : number;

        m_bodyContactCapacity : number;

        public m_bodyContactBuffer : org.jbox2d.particle.ParticleBodyContact[];

        m_pairCount : number;

        m_pairCapacity : number;

        m_pairBuffer : ParticleSystem.Pair[];

        m_triadCount : number;

        m_triadCapacity : number;

        m_triadBuffer : ParticleSystem.Triad[];

        m_groupCount : number;

        m_groupList : org.jbox2d.particle.ParticleGroup;

        m_pressureStrength : number;

        m_dampingStrength : number;

        m_elasticStrength : number;

        m_springStrength : number;

        m_viscousStrength : number;

        m_surfaceTensionStrengthA : number;

        m_surfaceTensionStrengthB : number;

        m_powderStrength : number;

        m_ejectionStrength : number;

        m_colorMixingStrength : number;

        m_world : org.jbox2d.dynamics.World;

        public constructor(world : org.jbox2d.dynamics.World) {
            if(this.m_timestamp===undefined) this.m_timestamp = 0;
            if(this.m_allParticleFlags===undefined) this.m_allParticleFlags = 0;
            if(this.m_allGroupFlags===undefined) this.m_allGroupFlags = 0;
            if(this.m_density===undefined) this.m_density = 0;
            if(this.m_inverseDensity===undefined) this.m_inverseDensity = 0;
            if(this.m_gravityScale===undefined) this.m_gravityScale = 0;
            if(this.m_particleDiameter===undefined) this.m_particleDiameter = 0;
            if(this.m_inverseDiameter===undefined) this.m_inverseDiameter = 0;
            if(this.m_squaredDiameter===undefined) this.m_squaredDiameter = 0;
            if(this.m_count===undefined) this.m_count = 0;
            if(this.m_internalAllocatedCapacity===undefined) this.m_internalAllocatedCapacity = 0;
            if(this.m_maxCount===undefined) this.m_maxCount = 0;
            if(this.m_flagsBuffer===undefined) this.m_flagsBuffer = null;
            if(this.m_positionBuffer===undefined) this.m_positionBuffer = null;
            if(this.m_velocityBuffer===undefined) this.m_velocityBuffer = null;
            if(this.m_accumulationBuffer===undefined) this.m_accumulationBuffer = null;
            if(this.m_accumulation2Buffer===undefined) this.m_accumulation2Buffer = null;
            if(this.m_depthBuffer===undefined) this.m_depthBuffer = null;
            if(this.m_colorBuffer===undefined) this.m_colorBuffer = null;
            if(this.m_groupBuffer===undefined) this.m_groupBuffer = null;
            if(this.m_userDataBuffer===undefined) this.m_userDataBuffer = null;
            if(this.m_proxyCount===undefined) this.m_proxyCount = 0;
            if(this.m_proxyCapacity===undefined) this.m_proxyCapacity = 0;
            if(this.m_proxyBuffer===undefined) this.m_proxyBuffer = null;
            if(this.m_contactCount===undefined) this.m_contactCount = 0;
            if(this.m_contactCapacity===undefined) this.m_contactCapacity = 0;
            if(this.m_contactBuffer===undefined) this.m_contactBuffer = null;
            if(this.m_bodyContactCount===undefined) this.m_bodyContactCount = 0;
            if(this.m_bodyContactCapacity===undefined) this.m_bodyContactCapacity = 0;
            if(this.m_bodyContactBuffer===undefined) this.m_bodyContactBuffer = null;
            if(this.m_pairCount===undefined) this.m_pairCount = 0;
            if(this.m_pairCapacity===undefined) this.m_pairCapacity = 0;
            if(this.m_pairBuffer===undefined) this.m_pairBuffer = null;
            if(this.m_triadCount===undefined) this.m_triadCount = 0;
            if(this.m_triadCapacity===undefined) this.m_triadCapacity = 0;
            if(this.m_triadBuffer===undefined) this.m_triadBuffer = null;
            if(this.m_groupCount===undefined) this.m_groupCount = 0;
            if(this.m_groupList===undefined) this.m_groupList = null;
            if(this.m_pressureStrength===undefined) this.m_pressureStrength = 0;
            if(this.m_dampingStrength===undefined) this.m_dampingStrength = 0;
            if(this.m_elasticStrength===undefined) this.m_elasticStrength = 0;
            if(this.m_springStrength===undefined) this.m_springStrength = 0;
            if(this.m_viscousStrength===undefined) this.m_viscousStrength = 0;
            if(this.m_surfaceTensionStrengthA===undefined) this.m_surfaceTensionStrengthA = 0;
            if(this.m_surfaceTensionStrengthB===undefined) this.m_surfaceTensionStrengthB = 0;
            if(this.m_powderStrength===undefined) this.m_powderStrength = 0;
            if(this.m_ejectionStrength===undefined) this.m_ejectionStrength = 0;
            if(this.m_colorMixingStrength===undefined) this.m_colorMixingStrength = 0;
            if(this.m_world===undefined) this.m_world = null;
            this.m_world = world;
            this.m_timestamp = 0;
            this.m_allParticleFlags = 0;
            this.m_allGroupFlags = 0;
            this.m_density = 1;
            this.m_inverseDensity = 1;
            this.m_gravityScale = 1;
            this.m_particleDiameter = 1;
            this.m_inverseDiameter = 1;
            this.m_squaredDiameter = 1;
            this.m_count = 0;
            this.m_internalAllocatedCapacity = 0;
            this.m_maxCount = 0;
            this.m_proxyCount = 0;
            this.m_proxyCapacity = 0;
            this.m_contactCount = 0;
            this.m_contactCapacity = 0;
            this.m_bodyContactCount = 0;
            this.m_bodyContactCapacity = 0;
            this.m_pairCount = 0;
            this.m_pairCapacity = 0;
            this.m_triadCount = 0;
            this.m_triadCapacity = 0;
            this.m_groupCount = 0;
            this.m_pressureStrength = 0.05;
            this.m_dampingStrength = 1.0;
            this.m_elasticStrength = 0.25;
            this.m_springStrength = 0.25;
            this.m_viscousStrength = 0.25;
            this.m_surfaceTensionStrengthA = 0.1;
            this.m_surfaceTensionStrengthB = 0.2;
            this.m_powderStrength = 0.5;
            this.m_ejectionStrength = 0.5;
            this.m_colorMixingStrength = 0.5;
            this.m_flagsBuffer = new ParticleSystem.ParticleBufferInt();
            this.m_positionBuffer = <any>(new ParticleSystem.ParticleBuffer<org.jbox2d.common.Vec2>(org.jbox2d.common.Vec2));
            this.m_velocityBuffer = <any>(new ParticleSystem.ParticleBuffer<org.jbox2d.common.Vec2>(org.jbox2d.common.Vec2));
            this.m_colorBuffer = <any>(new ParticleSystem.ParticleBuffer<org.jbox2d.particle.ParticleColor>(org.jbox2d.particle.ParticleColor));
            this.m_userDataBuffer = <any>(new ParticleSystem.ParticleBuffer<any>(Object));
        }

        public createParticle(def : org.jbox2d.particle.ParticleDef) : number {
            if(this.m_count >= this.m_internalAllocatedCapacity) {
                let capacity : number = this.m_count !== 0?2 * this.m_count:org.jbox2d.common.Settings.minParticleBufferCapacity;
                capacity = ParticleSystem.limitCapacity(capacity, this.m_maxCount);
                capacity = ParticleSystem.limitCapacity(capacity, this.m_flagsBuffer.userSuppliedCapacity);
                capacity = ParticleSystem.limitCapacity(capacity, this.m_positionBuffer.userSuppliedCapacity);
                capacity = ParticleSystem.limitCapacity(capacity, this.m_velocityBuffer.userSuppliedCapacity);
                capacity = ParticleSystem.limitCapacity(capacity, this.m_colorBuffer.userSuppliedCapacity);
                capacity = ParticleSystem.limitCapacity(capacity, this.m_userDataBuffer.userSuppliedCapacity);
                if(this.m_internalAllocatedCapacity < capacity) {
                    this.m_flagsBuffer.data = ParticleSystem.reallocateBuffer$org_jbox2d_particle_ParticleSystem_ParticleBufferInt$int$int$boolean(this.m_flagsBuffer, this.m_internalAllocatedCapacity, capacity, false);
                    this.m_positionBuffer.data = ParticleSystem.reallocateBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$int$int$boolean(this.m_positionBuffer, this.m_internalAllocatedCapacity, capacity, false);
                    this.m_velocityBuffer.data = ParticleSystem.reallocateBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$int$int$boolean(this.m_velocityBuffer, this.m_internalAllocatedCapacity, capacity, false);
                    this.m_accumulationBuffer = org.jbox2d.common.BufferUtils.reallocateBuffer$float_A$int$int$int$boolean(this.m_accumulationBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);
                    this.m_accumulation2Buffer = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int$int$boolean(org.jbox2d.common.Vec2, this.m_accumulation2Buffer, 0, this.m_internalAllocatedCapacity, capacity, true);
                    this.m_depthBuffer = org.jbox2d.common.BufferUtils.reallocateBuffer$float_A$int$int$int$boolean(this.m_depthBuffer, 0, this.m_internalAllocatedCapacity, capacity, true);
                    this.m_colorBuffer.data = ParticleSystem.reallocateBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$int$int$boolean(this.m_colorBuffer, this.m_internalAllocatedCapacity, capacity, true);
                    this.m_groupBuffer = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int$int$boolean(org.jbox2d.particle.ParticleGroup, this.m_groupBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);
                    this.m_userDataBuffer.data = ParticleSystem.reallocateBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$int$int$boolean(this.m_userDataBuffer, this.m_internalAllocatedCapacity, capacity, true);
                    this.m_internalAllocatedCapacity = capacity;
                }
            }
            if(this.m_count >= this.m_internalAllocatedCapacity) {
                return org.jbox2d.common.Settings.invalidParticleIndex_$LI$();
            }
            let index : number = this.m_count++;
            this.m_flagsBuffer.data[index] = def.flags;
            this.m_positionBuffer.data[index].set$org_jbox2d_common_Vec2(def.position);
            this.m_velocityBuffer.data[index].set$org_jbox2d_common_Vec2(def.velocity);
            this.m_groupBuffer[index] = null;
            if(this.m_depthBuffer != null) {
                this.m_depthBuffer[index] = 0;
            }
            if(this.m_colorBuffer.data != null || def.color != null) {
                this.m_colorBuffer.data = this.requestParticleBuffer$java_lang_Class$java_lang_Object_A(this.m_colorBuffer.dataClass, this.m_colorBuffer.data);
                this.m_colorBuffer.data[index].set$org_jbox2d_particle_ParticleColor(def.color);
            }
            if(this.m_userDataBuffer.data != null || def.userData != null) {
                this.m_userDataBuffer.data = this.requestParticleBuffer$java_lang_Class$java_lang_Object_A(this.m_userDataBuffer.dataClass, this.m_userDataBuffer.data);
                this.m_userDataBuffer.data[index] = def.userData;
            }
            if(this.m_proxyCount >= this.m_proxyCapacity) {
                let oldCapacity : number = this.m_proxyCapacity;
                let newCapacity : number = this.m_proxyCount !== 0?2 * this.m_proxyCount:org.jbox2d.common.Settings.minParticleBufferCapacity;
                this.m_proxyBuffer = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(ParticleSystem.Proxy, this.m_proxyBuffer, oldCapacity, newCapacity);
                this.m_proxyCapacity = newCapacity;
            }
            this.m_proxyBuffer[this.m_proxyCount++].index = index;
            return index;
        }

        public destroyParticle(index : number, callDestructionListener : boolean) {
            let flags : number = org.jbox2d.particle.ParticleType.b2_zombieParticle_$LI$();
            if(callDestructionListener) {
                flags |= org.jbox2d.particle.ParticleType.b2_destructionListener_$LI$();
            }
            this.m_flagsBuffer.data[index] |= flags;
        }

        /*private*/ temp : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ dpcallback : ParticleSystem.DestroyParticlesInShapeCallback = new ParticleSystem.DestroyParticlesInShapeCallback();

        public destroyParticlesInShape(shape : org.jbox2d.collision.shapes.Shape, xf : org.jbox2d.common.Transform, callDestructionListener : boolean) : number {
            this.dpcallback.init(this, shape, xf, callDestructionListener);
            shape.computeAABB(this.temp, xf, 0);
            this.m_world.queryAABB$org_jbox2d_callbacks_ParticleQueryCallback$org_jbox2d_collision_AABB(this.dpcallback, this.temp);
            return this.dpcallback.destroyed;
        }

        public destroyParticlesInGroup(group : org.jbox2d.particle.ParticleGroup, callDestructionListener : boolean) {
            for(let i : number = group.m_firstIndex; i < group.m_lastIndex; i++) {
                this.destroyParticle(i, callDestructionListener);
            };
        }

        /*private*/ temp2 : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ tempVec : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ tempTransform : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /*private*/ tempTransform2 : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /*private*/ createParticleGroupCallback : ParticleSystem.CreateParticleGroupCallback = new ParticleSystem.CreateParticleGroupCallback();

        /*private*/ tempParticleDef : org.jbox2d.particle.ParticleDef = new org.jbox2d.particle.ParticleDef();

        public createParticleGroup(groupDef : org.jbox2d.particle.ParticleGroupDef) : org.jbox2d.particle.ParticleGroup {
            let stride : number = this.getParticleStride();
            let identity : org.jbox2d.common.Transform = this.tempTransform;
            identity.setIdentity();
            let transform : org.jbox2d.common.Transform = this.tempTransform2;
            transform.setIdentity();
            let firstIndex : number = this.m_count;
            if(groupDef.shape != null) {
                let particleDef : org.jbox2d.particle.ParticleDef = this.tempParticleDef;
                particleDef.flags = groupDef.flags;
                particleDef.color = groupDef.color;
                particleDef.userData = groupDef.userData;
                let shape : org.jbox2d.collision.shapes.Shape = groupDef.shape;
                transform.set$org_jbox2d_common_Vec2$float(groupDef.position, groupDef.angle);
                let aabb : org.jbox2d.collision.AABB = this.temp;
                let childCount : number = shape.getChildCount();
                for(let childIndex : number = 0; childIndex < childCount; childIndex++) {
                    if(childIndex === 0) {
                        shape.computeAABB(aabb, identity, childIndex);
                    } else {
                        let childAABB : org.jbox2d.collision.AABB = this.temp2;
                        shape.computeAABB(childAABB, identity, childIndex);
                        aabb.combine$org_jbox2d_collision_AABB(childAABB);
                    }
                };
                let upperBoundY : number = aabb.upperBound.y;
                let upperBoundX : number = aabb.upperBound.x;
                for(let y : number = (<any>Math).fround(org.jbox2d.common.MathUtils.floor((<any>Math).fround(aabb.lowerBound.y / stride)) * stride); y < upperBoundY; y += stride) {
                    for(let x : number = (<any>Math).fround(org.jbox2d.common.MathUtils.floor((<any>Math).fround(aabb.lowerBound.x / stride)) * stride); x < upperBoundX; x += stride) {
                        let p : org.jbox2d.common.Vec2 = this.tempVec;
                        p.x = x;
                        p.y = y;
                        if(shape.testPoint(identity, p)) {
                            org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform, p, p);
                            particleDef.position.x = p.x;
                            particleDef.position.y = p.y;
                            p.subLocal(groupDef.position);
                            org.jbox2d.common.Vec2.crossToOutUnsafe$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(groupDef.angularVelocity, p, particleDef.velocity);
                            particleDef.velocity.addLocal$org_jbox2d_common_Vec2(groupDef.linearVelocity);
                            this.createParticle(particleDef);
                        }
                    };
                };
            }
            let lastIndex : number = this.m_count;
            let group : org.jbox2d.particle.ParticleGroup = new org.jbox2d.particle.ParticleGroup();
            group.m_system = this;
            group.m_firstIndex = firstIndex;
            group.m_lastIndex = lastIndex;
            group.m_groupFlags = groupDef.groupFlags;
            group.m_strength = groupDef.strength;
            group.m_userData = groupDef.userData;
            group.m_transform.set$org_jbox2d_common_Transform(transform);
            group.m_destroyAutomatically = groupDef.destroyAutomatically;
            group.m_prev = null;
            group.m_next = this.m_groupList;
            if(this.m_groupList != null) {
                this.m_groupList.m_prev = group;
            }
            this.m_groupList = group;
            ++this.m_groupCount;
            for(let i : number = firstIndex; i < lastIndex; i++) {
                this.m_groupBuffer[i] = group;
            };
            this.updateContacts(true);
            if((groupDef.flags & ParticleSystem.k_pairFlags_$LI$()) !== 0) {
                for(let k : number = 0; k < this.m_contactCount; k++) {
                    let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                    let a : number = contact.indexA;
                    let b : number = contact.indexB;
                    if(a > b) {
                        let temp : number = a;
                        a = b;
                        b = temp;
                    }
                    if(firstIndex <= a && b < lastIndex) {
                        if(this.m_pairCount >= this.m_pairCapacity) {
                            let oldCapacity : number = this.m_pairCapacity;
                            let newCapacity : number = this.m_pairCount !== 0?2 * this.m_pairCount:org.jbox2d.common.Settings.minParticleBufferCapacity;
                            this.m_pairBuffer = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(ParticleSystem.Pair, this.m_pairBuffer, oldCapacity, newCapacity);
                            this.m_pairCapacity = newCapacity;
                        }
                        let pair : ParticleSystem.Pair = this.m_pairBuffer[this.m_pairCount];
                        pair.indexA = a;
                        pair.indexB = b;
                        pair.flags = contact.flags;
                        pair.strength = groupDef.strength;
                        pair.distance = org.jbox2d.common.MathUtils.distance(this.m_positionBuffer.data[a], this.m_positionBuffer.data[b]);
                        this.m_pairCount++;
                    }
                };
            }
            if((groupDef.flags & ParticleSystem.k_triadFlags_$LI$()) !== 0) {
                let diagram : org.jbox2d.particle.VoronoiDiagram = new org.jbox2d.particle.VoronoiDiagram(lastIndex - firstIndex);
                for(let i : number = firstIndex; i < lastIndex; i++) {
                    diagram.addGenerator(this.m_positionBuffer.data[i], i);
                };
                diagram.generate((<any>Math).fround(stride / 2));
                this.createParticleGroupCallback.system = this;
                this.createParticleGroupCallback.def = groupDef;
                this.createParticleGroupCallback.firstIndex = firstIndex;
                diagram.getNodes(this.createParticleGroupCallback);
            }
            if((groupDef.groupFlags & org.jbox2d.particle.ParticleGroupType.b2_solidParticleGroup_$LI$()) !== 0) {
                this.computeDepthForGroup(group);
            }
            return group;
        }

        public joinParticleGroups(groupA : org.jbox2d.particle.ParticleGroup, groupB : org.jbox2d.particle.ParticleGroup) {
            this.RotateBuffer(groupB.m_firstIndex, groupB.m_lastIndex, this.m_count);
            this.RotateBuffer(groupA.m_firstIndex, groupA.m_lastIndex, groupB.m_firstIndex);
            let particleFlags : number = 0;
            for(let i : number = groupA.m_firstIndex; i < groupB.m_lastIndex; i++) {
                particleFlags |= this.m_flagsBuffer.data[i];
            };
            this.updateContacts(true);
            if((particleFlags & ParticleSystem.k_pairFlags_$LI$()) !== 0) {
                for(let k : number = 0; k < this.m_contactCount; k++) {
                    let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                    let a : number = contact.indexA;
                    let b : number = contact.indexB;
                    if(a > b) {
                        let temp : number = a;
                        a = b;
                        b = temp;
                    }
                    if(groupA.m_firstIndex <= a && a < groupA.m_lastIndex && groupB.m_firstIndex <= b && b < groupB.m_lastIndex) {
                        if(this.m_pairCount >= this.m_pairCapacity) {
                            let oldCapacity : number = this.m_pairCapacity;
                            let newCapacity : number = this.m_pairCount !== 0?2 * this.m_pairCount:org.jbox2d.common.Settings.minParticleBufferCapacity;
                            this.m_pairBuffer = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(ParticleSystem.Pair, this.m_pairBuffer, oldCapacity, newCapacity);
                            this.m_pairCapacity = newCapacity;
                        }
                        let pair : ParticleSystem.Pair = this.m_pairBuffer[this.m_pairCount];
                        pair.indexA = a;
                        pair.indexB = b;
                        pair.flags = contact.flags;
                        pair.strength = org.jbox2d.common.MathUtils.min$float$float(groupA.m_strength, groupB.m_strength);
                        pair.distance = org.jbox2d.common.MathUtils.distance(this.m_positionBuffer.data[a], this.m_positionBuffer.data[b]);
                        this.m_pairCount++;
                    }
                };
            }
            if((particleFlags & ParticleSystem.k_triadFlags_$LI$()) !== 0) {
                let diagram : org.jbox2d.particle.VoronoiDiagram = new org.jbox2d.particle.VoronoiDiagram(groupB.m_lastIndex - groupA.m_firstIndex);
                for(let i : number = groupA.m_firstIndex; i < groupB.m_lastIndex; i++) {
                    if((this.m_flagsBuffer.data[i] & org.jbox2d.particle.ParticleType.b2_zombieParticle_$LI$()) === 0) {
                        diagram.addGenerator(this.m_positionBuffer.data[i], i);
                    }
                };
                diagram.generate((<any>Math).fround(this.getParticleStride() / 2));
                let callback : ParticleSystem.JoinParticleGroupsCallback = new ParticleSystem.JoinParticleGroupsCallback();
                callback.system = this;
                callback.groupA = groupA;
                callback.groupB = groupB;
                diagram.getNodes(callback);
            }
            for(let i : number = groupB.m_firstIndex; i < groupB.m_lastIndex; i++) {
                this.m_groupBuffer[i] = groupA;
            };
            let groupFlags : number = groupA.m_groupFlags | groupB.m_groupFlags;
            groupA.m_groupFlags = groupFlags;
            groupA.m_lastIndex = groupB.m_lastIndex;
            groupB.m_firstIndex = groupB.m_lastIndex;
            this.destroyParticleGroup(groupB);
            if((groupFlags & org.jbox2d.particle.ParticleGroupType.b2_solidParticleGroup_$LI$()) !== 0) {
                this.computeDepthForGroup(groupA);
            }
        }

        destroyParticleGroup(group : org.jbox2d.particle.ParticleGroup) {
            if(this.m_world.getParticleDestructionListener() != null) {
                this.m_world.getParticleDestructionListener()['sayGoodbye$org_jbox2d_particle_ParticleGroup'](group);
            }
            for(let i : number = group.m_firstIndex; i < group.m_lastIndex; i++) {
                this.m_groupBuffer[i] = null;
            };
            if(group.m_prev != null) {
                group.m_prev.m_next = group.m_next;
            }
            if(group.m_next != null) {
                group.m_next.m_prev = group.m_prev;
            }
            if(group === this.m_groupList) {
                this.m_groupList = group.m_next;
            }
            --this.m_groupCount;
        }

        public computeDepthForGroup(group : org.jbox2d.particle.ParticleGroup) {
            for(let i : number = group.m_firstIndex; i < group.m_lastIndex; i++) {
                this.m_accumulationBuffer[i] = 0;
            };
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                let a : number = contact.indexA;
                let b : number = contact.indexB;
                if(a >= group.m_firstIndex && a < group.m_lastIndex && b >= group.m_firstIndex && b < group.m_lastIndex) {
                    let w : number = contact.weight;
                    this.m_accumulationBuffer[a] += w;
                    this.m_accumulationBuffer[b] += w;
                }
            };
            this.m_depthBuffer = this.requestParticleBuffer$float_A(this.m_depthBuffer);
            for(let i : number = group.m_firstIndex; i < group.m_lastIndex; i++) {
                let w : number = this.m_accumulationBuffer[i];
                this.m_depthBuffer[i] = w < 0.8?0:Number.MAX_VALUE;
            };
            let interationCount : number = group.getParticleCount();
            for(let t : number = 0; t < interationCount; t++) {
                let updated : boolean = false;
                for(let k : number = 0; k < this.m_contactCount; k++) {
                    let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                    let a : number = contact.indexA;
                    let b : number = contact.indexB;
                    if(a >= group.m_firstIndex && a < group.m_lastIndex && b >= group.m_firstIndex && b < group.m_lastIndex) {
                        let r : number = (<any>Math).fround(1 - contact.weight);
                        let ap0 : number = this.m_depthBuffer[a];
                        let bp0 : number = this.m_depthBuffer[b];
                        let ap1 : number = (<any>Math).fround(bp0 + r);
                        let bp1 : number = (<any>Math).fround(ap0 + r);
                        if(ap0 > ap1) {
                            this.m_depthBuffer[a] = ap1;
                            updated = true;
                        }
                        if(bp0 > bp1) {
                            this.m_depthBuffer[b] = bp1;
                            updated = true;
                        }
                    }
                };
                if(!updated) {
                    break;
                }
            };
            for(let i : number = group.m_firstIndex; i < group.m_lastIndex; i++) {
                let p : number = this.m_depthBuffer[i];
                if(p < Number.MAX_VALUE) {
                    this.m_depthBuffer[i] *= this.m_particleDiameter;
                } else {
                    this.m_depthBuffer[i] = 0;
                }
            };
        }

        public addContact(a : number, b : number) {
            let pa : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[a];
            let pb : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[b];
            let dx : number = (<any>Math).fround(pb.x - pa.x);
            let dy : number = (<any>Math).fround(pb.y - pa.y);
            let d2 : number = (<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy));
            if(d2 < this.m_squaredDiameter) {
                if(this.m_contactCount >= this.m_contactCapacity) {
                    let oldCapacity : number = this.m_contactCapacity;
                    let newCapacity : number = this.m_contactCount !== 0?2 * this.m_contactCount:org.jbox2d.common.Settings.minParticleBufferCapacity;
                    this.m_contactBuffer = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(org.jbox2d.particle.ParticleContact, this.m_contactBuffer, oldCapacity, newCapacity);
                    this.m_contactCapacity = newCapacity;
                }
                let invD : number = d2 !== 0?org.jbox2d.common.MathUtils.sqrt((<any>Math).fround(1 / d2)):Number.MAX_VALUE;
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[this.m_contactCount];
                contact.indexA = a;
                contact.indexB = b;
                contact.flags = this.m_flagsBuffer.data[a] | this.m_flagsBuffer.data[b];
                contact.weight = (<any>Math).fround(1 - (<any>Math).fround((<any>Math).fround(d2 * invD) * this.m_inverseDiameter));
                contact.normal.x = (<any>Math).fround(invD * dx);
                contact.normal.y = (<any>Math).fround(invD * dy);
                this.m_contactCount++;
            }
        }

        public updateContacts(exceptZombie : boolean) {
            for(let p : number = 0; p < this.m_proxyCount; p++) {
                let proxy : ParticleSystem.Proxy = this.m_proxyBuffer[p];
                let i : number = proxy.index;
                let pos : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[i];
                proxy.tag = ParticleSystem.computeTag((<any>Math).fround(this.m_inverseDiameter * pos.x), (<any>Math).fround(this.m_inverseDiameter * pos.y));
            };
            /* sort */((arr, start, end, f?) => ((arr1, arr2) => arr1.splice.apply(arr1, (<any[]>[start, arr2.length]).concat(arr2)))(this.m_proxyBuffer, this.m_proxyBuffer.slice(start, end).sort(f)))(this.m_proxyBuffer, 0, this.m_proxyCount);
            this.m_contactCount = 0;
            let c_index : number = 0;
            for(let i : number = 0; i < this.m_proxyCount; i++) {
                let a : ParticleSystem.Proxy = this.m_proxyBuffer[i];
                let rightTag : number = ParticleSystem.computeRelativeTag(a.tag, 1, 0);
                for(let j : number = i + 1; j < this.m_proxyCount; j++) {
                    let b : ParticleSystem.Proxy = this.m_proxyBuffer[j];
                    if(rightTag < b.tag) {
                        break;
                    }
                    this.addContact(a.index, b.index);
                };
                let bottomLeftTag : number = ParticleSystem.computeRelativeTag(a.tag, -1, 1);
                for(; c_index < this.m_proxyCount; c_index++) {
                    let c : ParticleSystem.Proxy = this.m_proxyBuffer[c_index];
                    if(bottomLeftTag <= c.tag) {
                        break;
                    }
                };
                let bottomRightTag : number = ParticleSystem.computeRelativeTag(a.tag, 1, 1);
                for(let b_index : number = c_index; b_index < this.m_proxyCount; b_index++) {
                    let b : ParticleSystem.Proxy = this.m_proxyBuffer[b_index];
                    if(bottomRightTag < b.tag) {
                        break;
                    }
                    this.addContact(a.index, b.index);
                };
            };
            if(exceptZombie) {
                let j : number = this.m_contactCount;
                for(let i : number = 0; i < j; i++) {
                    if((this.m_contactBuffer[i].flags & org.jbox2d.particle.ParticleType.b2_zombieParticle_$LI$()) !== 0) {
                        --j;
                        let temp : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[j];
                        this.m_contactBuffer[j] = this.m_contactBuffer[i];
                        this.m_contactBuffer[i] = temp;
                        --i;
                    }
                };
                this.m_contactCount = j;
            }
        }

        /*private*/ ubccallback : ParticleSystem.UpdateBodyContactsCallback = new ParticleSystem.UpdateBodyContactsCallback();

        public updateBodyContacts() {
            let aabb : org.jbox2d.collision.AABB = this.temp;
            aabb.lowerBound.x = Number.MAX_VALUE;
            aabb.lowerBound.y = Number.MAX_VALUE;
            aabb.upperBound.x = -Number.MAX_VALUE;
            aabb.upperBound.y = -Number.MAX_VALUE;
            for(let i : number = 0; i < this.m_count; i++) {
                let p : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[i];
                org.jbox2d.common.Vec2.minToOut(aabb.lowerBound, p, aabb.lowerBound);
                org.jbox2d.common.Vec2.maxToOut(aabb.upperBound, p, aabb.upperBound);
            };
            aabb.lowerBound.x -= this.m_particleDiameter;
            aabb.lowerBound.y -= this.m_particleDiameter;
            aabb.upperBound.x += this.m_particleDiameter;
            aabb.upperBound.y += this.m_particleDiameter;
            this.m_bodyContactCount = 0;
            this.ubccallback.system = this;
            this.m_world.queryAABB$org_jbox2d_callbacks_QueryCallback$org_jbox2d_collision_AABB(this.ubccallback, aabb);
        }

        /*private*/ sccallback : ParticleSystem.SolveCollisionCallback = new ParticleSystem.SolveCollisionCallback();

        public solveCollision(step : org.jbox2d.dynamics.TimeStep) {
            let aabb : org.jbox2d.collision.AABB = this.temp;
            let lowerBound : org.jbox2d.common.Vec2 = aabb.lowerBound;
            let upperBound : org.jbox2d.common.Vec2 = aabb.upperBound;
            lowerBound.x = Number.MAX_VALUE;
            lowerBound.y = Number.MAX_VALUE;
            upperBound.x = -Number.MAX_VALUE;
            upperBound.y = -Number.MAX_VALUE;
            for(let i : number = 0; i < this.m_count; i++) {
                let v : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[i];
                let p1 : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[i];
                let p1x : number = p1.x;
                let p1y : number = p1.y;
                let p2x : number = (<any>Math).fround(p1x + (<any>Math).fround(step.dt * v.x));
                let p2y : number = (<any>Math).fround(p1y + (<any>Math).fround(step.dt * v.y));
                let bx : number = p1x < p2x?p1x:p2x;
                let by : number = p1y < p2y?p1y:p2y;
                lowerBound.x = lowerBound.x < bx?lowerBound.x:bx;
                lowerBound.y = lowerBound.y < by?lowerBound.y:by;
                let b1x : number = p1x > p2x?p1x:p2x;
                let b1y : number = p1y > p2y?p1y:p2y;
                upperBound.x = upperBound.x > b1x?upperBound.x:b1x;
                upperBound.y = upperBound.y > b1y?upperBound.y:b1y;
            };
            this.sccallback.step = step;
            this.sccallback.system = this;
            this.m_world.queryAABB$org_jbox2d_callbacks_QueryCallback$org_jbox2d_collision_AABB(this.sccallback, aabb);
        }

        public solve(step : org.jbox2d.dynamics.TimeStep) {
            ++this.m_timestamp;
            if(this.m_count === 0) {
                return;
            }
            this.m_allParticleFlags = 0;
            for(let i : number = 0; i < this.m_count; i++) {
                this.m_allParticleFlags |= this.m_flagsBuffer.data[i];
            };
            if((this.m_allParticleFlags & org.jbox2d.particle.ParticleType.b2_zombieParticle_$LI$()) !== 0) {
                this.solveZombie();
            }
            if(this.m_count === 0) {
                return;
            }
            this.m_allGroupFlags = 0;
            for(let group : org.jbox2d.particle.ParticleGroup = this.m_groupList; group != null; group = group.getNext()) {
                this.m_allGroupFlags |= group.m_groupFlags;
            };
            let gravityx : number = (<any>Math).fround((<any>Math).fround(step.dt * this.m_gravityScale) * this.m_world.getGravity().x);
            let gravityy : number = (<any>Math).fround((<any>Math).fround(step.dt * this.m_gravityScale) * this.m_world.getGravity().y);
            let criticalVelocytySquared : number = this.getCriticalVelocitySquared(step);
            for(let i : number = 0; i < this.m_count; i++) {
                let v : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[i];
                v.x += gravityx;
                v.y += gravityy;
                let v2 : number = (<any>Math).fround((<any>Math).fround(v.x * v.x) + (<any>Math).fround(v.y * v.y));
                if(v2 > criticalVelocytySquared) {
                    let a : number = v2 === 0?Number.MAX_VALUE:org.jbox2d.common.MathUtils.sqrt((<any>Math).fround(criticalVelocytySquared / v2));
                    v.x *= a;
                    v.y *= a;
                }
            };
            this.solveCollision(step);
            if((this.m_allGroupFlags & org.jbox2d.particle.ParticleGroupType.b2_rigidParticleGroup_$LI$()) !== 0) {
                this.solveRigid(step);
            }
            if((this.m_allParticleFlags & org.jbox2d.particle.ParticleType.b2_wallParticle_$LI$()) !== 0) {
                this.solveWall(step);
            }
            for(let i : number = 0; i < this.m_count; i++) {
                let pos : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[i];
                let vel : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[i];
                pos.x += (<any>Math).fround(step.dt * vel.x);
                pos.y += (<any>Math).fround(step.dt * vel.y);
            };
            this.updateBodyContacts();
            this.updateContacts(false);
            if((this.m_allParticleFlags & org.jbox2d.particle.ParticleType.b2_viscousParticle_$LI$()) !== 0) {
                this.solveViscous(step);
            }
            if((this.m_allParticleFlags & org.jbox2d.particle.ParticleType.b2_powderParticle_$LI$()) !== 0) {
                this.solvePowder(step);
            }
            if((this.m_allParticleFlags & org.jbox2d.particle.ParticleType.b2_tensileParticle_$LI$()) !== 0) {
                this.solveTensile(step);
            }
            if((this.m_allParticleFlags & org.jbox2d.particle.ParticleType.b2_elasticParticle_$LI$()) !== 0) {
                this.solveElastic(step);
            }
            if((this.m_allParticleFlags & org.jbox2d.particle.ParticleType.b2_springParticle_$LI$()) !== 0) {
                this.solveSpring(step);
            }
            if((this.m_allGroupFlags & org.jbox2d.particle.ParticleGroupType.b2_solidParticleGroup_$LI$()) !== 0) {
                this.solveSolid(step);
            }
            if((this.m_allParticleFlags & org.jbox2d.particle.ParticleType.b2_colorMixingParticle_$LI$()) !== 0) {
                this.solveColorMixing(step);
            }
            this.solvePressure(step);
            this.solveDamping(step);
        }

        solvePressure(step : org.jbox2d.dynamics.TimeStep) {
            for(let i : number = 0; i < this.m_count; i++) {
                this.m_accumulationBuffer[i] = 0;
            };
            for(let k : number = 0; k < this.m_bodyContactCount; k++) {
                let contact : org.jbox2d.particle.ParticleBodyContact = this.m_bodyContactBuffer[k];
                let a : number = contact.index;
                let w : number = contact.weight;
                this.m_accumulationBuffer[a] += w;
            };
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                let a : number = contact.indexA;
                let b : number = contact.indexB;
                let w : number = contact.weight;
                this.m_accumulationBuffer[a] += w;
                this.m_accumulationBuffer[b] += w;
            };
            if((this.m_allParticleFlags & ParticleSystem.k_noPressureFlags_$LI$()) !== 0) {
                for(let i : number = 0; i < this.m_count; i++) {
                    if((this.m_flagsBuffer.data[i] & ParticleSystem.k_noPressureFlags_$LI$()) !== 0) {
                        this.m_accumulationBuffer[i] = 0;
                    }
                };
            }
            let pressurePerWeight : number = (<any>Math).fround(this.m_pressureStrength * this.getCriticalPressure(step));
            for(let i : number = 0; i < this.m_count; i++) {
                let w : number = this.m_accumulationBuffer[i];
                let h : number = (<any>Math).fround(pressurePerWeight * org.jbox2d.common.MathUtils.max$float$float(0.0, (<any>Math).fround(org.jbox2d.common.MathUtils.min$float$float(w, org.jbox2d.common.Settings.maxParticleWeight) - org.jbox2d.common.Settings.minParticleWeight)));
                this.m_accumulationBuffer[i] = h;
            };
            let velocityPerPressure : number = (<any>Math).fround(step.dt / ((<any>Math).fround(this.m_density * this.m_particleDiameter)));
            for(let k : number = 0; k < this.m_bodyContactCount; k++) {
                let contact : org.jbox2d.particle.ParticleBodyContact = this.m_bodyContactBuffer[k];
                let a : number = contact.index;
                let b : org.jbox2d.dynamics.Body = contact.body;
                let w : number = contact.weight;
                let m : number = contact.mass;
                let n : org.jbox2d.common.Vec2 = contact.normal;
                let p : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[a];
                let h : number = (<any>Math).fround(this.m_accumulationBuffer[a] + (<any>Math).fround(pressurePerWeight * w));
                let f : org.jbox2d.common.Vec2 = this.tempVec;
                let coef : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(velocityPerPressure * w) * m) * h);
                f.x = (<any>Math).fround(coef * n.x);
                f.y = (<any>Math).fround(coef * n.y);
                let velData : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                let particleInvMass : number = this.getParticleInvMass();
                velData.x -= (<any>Math).fround(particleInvMass * f.x);
                velData.y -= (<any>Math).fround(particleInvMass * f.y);
                b.applyLinearImpulse(f, p, true);
            };
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                let a : number = contact.indexA;
                let b : number = contact.indexB;
                let w : number = contact.weight;
                let n : org.jbox2d.common.Vec2 = contact.normal;
                let h : number = (<any>Math).fround(this.m_accumulationBuffer[a] + this.m_accumulationBuffer[b]);
                let fx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(velocityPerPressure * w) * h) * n.x);
                let fy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(velocityPerPressure * w) * h) * n.y);
                let velDataA : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                let velDataB : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[b];
                velDataA.x -= fx;
                velDataA.y -= fy;
                velDataB.x += fx;
                velDataB.y += fy;
            };
        }

        solveDamping(step : org.jbox2d.dynamics.TimeStep) {
            let damping : number = this.m_dampingStrength;
            for(let k : number = 0; k < this.m_bodyContactCount; k++) {
                let contact : org.jbox2d.particle.ParticleBodyContact = this.m_bodyContactBuffer[k];
                let a : number = contact.index;
                let b : org.jbox2d.dynamics.Body = contact.body;
                let w : number = contact.weight;
                let m : number = contact.mass;
                let n : org.jbox2d.common.Vec2 = contact.normal;
                let p : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[a];
                let tempX : number = (<any>Math).fround(p.x - b.m_sweep.c.x);
                let tempY : number = (<any>Math).fround(p.y - b.m_sweep.c.y);
                let velA : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                let vx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-b.m_angularVelocity * tempY) + b.m_linearVelocity.x) - velA.x);
                let vy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b.m_angularVelocity * tempX) + b.m_linearVelocity.y) - velA.y);
                let vn : number = (<any>Math).fround((<any>Math).fround(vx * n.x) + (<any>Math).fround(vy * n.y));
                if(vn < 0) {
                    let f : org.jbox2d.common.Vec2 = this.tempVec;
                    f.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(damping * w) * m) * vn) * n.x);
                    f.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(damping * w) * m) * vn) * n.y);
                    let invMass : number = this.getParticleInvMass();
                    velA.x += (<any>Math).fround(invMass * f.x);
                    velA.y += (<any>Math).fround(invMass * f.y);
                    f.x = -f.x;
                    f.y = -f.y;
                    b.applyLinearImpulse(f, p, true);
                }
            };
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                let a : number = contact.indexA;
                let b : number = contact.indexB;
                let w : number = contact.weight;
                let n : org.jbox2d.common.Vec2 = contact.normal;
                let velA : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                let velB : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[b];
                let vx : number = (<any>Math).fround(velB.x - velA.x);
                let vy : number = (<any>Math).fround(velB.y - velA.y);
                let vn : number = (<any>Math).fround((<any>Math).fround(vx * n.x) + (<any>Math).fround(vy * n.y));
                if(vn < 0) {
                    let fx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(damping * w) * vn) * n.x);
                    let fy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(damping * w) * vn) * n.y);
                    velA.x += fx;
                    velA.y += fy;
                    velB.x -= fx;
                    velB.y -= fy;
                }
            };
        }

        public solveWall(step : org.jbox2d.dynamics.TimeStep) {
            for(let i : number = 0; i < this.m_count; i++) {
                if((this.m_flagsBuffer.data[i] & org.jbox2d.particle.ParticleType.b2_wallParticle_$LI$()) !== 0) {
                    let r : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[i];
                    r.x = 0.0;
                    r.y = 0.0;
                }
            };
        }

        /*private*/ tempVec2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ tempRot : org.jbox2d.common.Rot = new org.jbox2d.common.Rot();

        /*private*/ tempXf : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        /*private*/ tempXf2 : org.jbox2d.common.Transform = new org.jbox2d.common.Transform();

        solveRigid(step : org.jbox2d.dynamics.TimeStep) {
            for(let group : org.jbox2d.particle.ParticleGroup = this.m_groupList; group != null; group = group.getNext()) {
                if((group.m_groupFlags & org.jbox2d.particle.ParticleGroupType.b2_rigidParticleGroup_$LI$()) !== 0) {
                    group.updateStatistics();
                    let temp : org.jbox2d.common.Vec2 = this.tempVec;
                    let cross : org.jbox2d.common.Vec2 = this.tempVec2;
                    let rotation : org.jbox2d.common.Rot = this.tempRot;
                    rotation.set$float((<any>Math).fround(step.dt * group.m_angularVelocity));
                    org.jbox2d.common.Rot.mulToOutUnsafe(rotation, group.m_center, cross);
                    temp.set$org_jbox2d_common_Vec2(group.m_linearVelocity).mulLocal(step.dt).addLocal$org_jbox2d_common_Vec2(group.m_center).subLocal(cross);
                    this.tempXf.p.set$org_jbox2d_common_Vec2(temp);
                    this.tempXf.q.set$org_jbox2d_common_Rot(rotation);
                    org.jbox2d.common.Transform.mulToOut$org_jbox2d_common_Transform$org_jbox2d_common_Transform$org_jbox2d_common_Transform(this.tempXf, group.m_transform, group.m_transform);
                    let velocityTransform : org.jbox2d.common.Transform = this.tempXf2;
                    velocityTransform.p.x = (<any>Math).fround(step.inv_dt * this.tempXf.p.x);
                    velocityTransform.p.y = (<any>Math).fround(step.inv_dt * this.tempXf.p.y);
                    velocityTransform.q.s = (<any>Math).fround(step.inv_dt * this.tempXf.q.s);
                    velocityTransform.q.c = (<any>Math).fround(step.inv_dt * ((<any>Math).fround(this.tempXf.q.c - 1)));
                    for(let i : number = group.m_firstIndex; i < group.m_lastIndex; i++) {
                        org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(velocityTransform, this.m_positionBuffer.data[i], this.m_velocityBuffer.data[i]);
                    };
                }
            };
        }

        solveElastic(step : org.jbox2d.dynamics.TimeStep) {
            let elasticStrength : number = (<any>Math).fround(step.inv_dt * this.m_elasticStrength);
            for(let k : number = 0; k < this.m_triadCount; k++) {
                let triad : ParticleSystem.Triad = this.m_triadBuffer[k];
                if((triad.flags & org.jbox2d.particle.ParticleType.b2_elasticParticle_$LI$()) !== 0) {
                    let a : number = triad.indexA;
                    let b : number = triad.indexB;
                    let c : number = triad.indexC;
                    let oa : org.jbox2d.common.Vec2 = triad.pa;
                    let ob : org.jbox2d.common.Vec2 = triad.pb;
                    let oc : org.jbox2d.common.Vec2 = triad.pc;
                    let pa : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[a];
                    let pb : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[b];
                    let pc : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[c];
                    let px : number = (<any>Math).fround((<any>Math).fround(1.0 / 3) * ((<any>Math).fround((<any>Math).fround(pa.x + pb.x) + pc.x)));
                    let py : number = (<any>Math).fround((<any>Math).fround(1.0 / 3) * ((<any>Math).fround((<any>Math).fround(pa.y + pb.y) + pc.y)));
                    let rs : number = (<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(oa, pa) + org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(ob, pb)) + org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(oc, pc));
                    let rc : number = (<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.dot(oa, pa) + org.jbox2d.common.Vec2.dot(ob, pb)) + org.jbox2d.common.Vec2.dot(oc, pc));
                    let r2 : number = (<any>Math).fround((<any>Math).fround(rs * rs) + (<any>Math).fround(rc * rc));
                    let invR : number = r2 === 0?Number.MAX_VALUE:org.jbox2d.common.MathUtils.sqrt((<any>Math).fround(1.0 / r2));
                    rs *= invR;
                    rc *= invR;
                    let strength : number = (<any>Math).fround(elasticStrength * triad.strength);
                    let roax : number = (<any>Math).fround((<any>Math).fround(rc * oa.x) - (<any>Math).fround(rs * oa.y));
                    let roay : number = (<any>Math).fround((<any>Math).fround(rs * oa.x) + (<any>Math).fround(rc * oa.y));
                    let robx : number = (<any>Math).fround((<any>Math).fround(rc * ob.x) - (<any>Math).fround(rs * ob.y));
                    let roby : number = (<any>Math).fround((<any>Math).fround(rs * ob.x) + (<any>Math).fround(rc * ob.y));
                    let rocx : number = (<any>Math).fround((<any>Math).fround(rc * oc.x) - (<any>Math).fround(rs * oc.y));
                    let rocy : number = (<any>Math).fround((<any>Math).fround(rs * oc.x) + (<any>Math).fround(rc * oc.y));
                    let va : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                    let vb : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[b];
                    let vc : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[c];
                    va.x += (<any>Math).fround(strength * ((<any>Math).fround(roax - ((<any>Math).fround(pa.x - px)))));
                    va.y += (<any>Math).fround(strength * ((<any>Math).fround(roay - ((<any>Math).fround(pa.y - py)))));
                    vb.x += (<any>Math).fround(strength * ((<any>Math).fround(robx - ((<any>Math).fround(pb.x - px)))));
                    vb.y += (<any>Math).fround(strength * ((<any>Math).fround(roby - ((<any>Math).fround(pb.y - py)))));
                    vc.x += (<any>Math).fround(strength * ((<any>Math).fround(rocx - ((<any>Math).fround(pc.x - px)))));
                    vc.y += (<any>Math).fround(strength * ((<any>Math).fround(rocy - ((<any>Math).fround(pc.y - py)))));
                }
            };
        }

        solveSpring(step : org.jbox2d.dynamics.TimeStep) {
            let springStrength : number = (<any>Math).fround(step.inv_dt * this.m_springStrength);
            for(let k : number = 0; k < this.m_pairCount; k++) {
                let pair : ParticleSystem.Pair = this.m_pairBuffer[k];
                if((pair.flags & org.jbox2d.particle.ParticleType.b2_springParticle_$LI$()) !== 0) {
                    let a : number = pair.indexA;
                    let b : number = pair.indexB;
                    let pa : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[a];
                    let pb : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[b];
                    let dx : number = (<any>Math).fround(pb.x - pa.x);
                    let dy : number = (<any>Math).fround(pb.y - pa.y);
                    let r0 : number = pair.distance;
                    let r1 : number = org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy)));
                    if(r1 === 0) r1 = Number.MAX_VALUE;
                    let strength : number = (<any>Math).fround(springStrength * pair.strength);
                    let fx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(strength * ((<any>Math).fround(r0 - r1))) / r1) * dx);
                    let fy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(strength * ((<any>Math).fround(r0 - r1))) / r1) * dy);
                    let va : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                    let vb : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[b];
                    va.x -= fx;
                    va.y -= fy;
                    vb.x += fx;
                    vb.y += fy;
                }
            };
        }

        solveTensile(step : org.jbox2d.dynamics.TimeStep) {
            this.m_accumulation2Buffer = this.requestParticleBuffer$java_lang_Class$java_lang_Object_A(org.jbox2d.common.Vec2, this.m_accumulation2Buffer);
            for(let i : number = 0; i < this.m_count; i++) {
                this.m_accumulationBuffer[i] = 0;
                this.m_accumulation2Buffer[i].setZero();
            };
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                if((contact.flags & org.jbox2d.particle.ParticleType.b2_tensileParticle_$LI$()) !== 0) {
                    let a : number = contact.indexA;
                    let b : number = contact.indexB;
                    let w : number = contact.weight;
                    let n : org.jbox2d.common.Vec2 = contact.normal;
                    this.m_accumulationBuffer[a] += w;
                    this.m_accumulationBuffer[b] += w;
                    let a2A : org.jbox2d.common.Vec2 = this.m_accumulation2Buffer[a];
                    let a2B : org.jbox2d.common.Vec2 = this.m_accumulation2Buffer[b];
                    let inter : number = (<any>Math).fround(((<any>Math).fround(1 - w)) * w);
                    a2A.x -= (<any>Math).fround(inter * n.x);
                    a2A.y -= (<any>Math).fround(inter * n.y);
                    a2B.x += (<any>Math).fround(inter * n.x);
                    a2B.y += (<any>Math).fround(inter * n.y);
                }
            };
            let strengthA : number = (<any>Math).fround(this.m_surfaceTensionStrengthA * this.getCriticalVelocity(step));
            let strengthB : number = (<any>Math).fround(this.m_surfaceTensionStrengthB * this.getCriticalVelocity(step));
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                if((contact.flags & org.jbox2d.particle.ParticleType.b2_tensileParticle_$LI$()) !== 0) {
                    let a : number = contact.indexA;
                    let b : number = contact.indexB;
                    let w : number = contact.weight;
                    let n : org.jbox2d.common.Vec2 = contact.normal;
                    let a2A : org.jbox2d.common.Vec2 = this.m_accumulation2Buffer[a];
                    let a2B : org.jbox2d.common.Vec2 = this.m_accumulation2Buffer[b];
                    let h : number = (<any>Math).fround(this.m_accumulationBuffer[a] + this.m_accumulationBuffer[b]);
                    let sx : number = (<any>Math).fround(a2B.x - a2A.x);
                    let sy : number = (<any>Math).fround(a2B.y - a2A.y);
                    let fn : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(strengthA * ((<any>Math).fround(h - 2))) + (<any>Math).fround(strengthB * ((<any>Math).fround((<any>Math).fround(sx * n.x) + (<any>Math).fround(sy * n.y)))))) * w);
                    let fx : number = (<any>Math).fround(fn * n.x);
                    let fy : number = (<any>Math).fround(fn * n.y);
                    let va : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                    let vb : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[b];
                    va.x -= fx;
                    va.y -= fy;
                    vb.x += fx;
                    vb.y += fy;
                }
            };
        }

        solveViscous(step : org.jbox2d.dynamics.TimeStep) {
            let viscousStrength : number = this.m_viscousStrength;
            for(let k : number = 0; k < this.m_bodyContactCount; k++) {
                let contact : org.jbox2d.particle.ParticleBodyContact = this.m_bodyContactBuffer[k];
                let a : number = contact.index;
                if((this.m_flagsBuffer.data[a] & org.jbox2d.particle.ParticleType.b2_viscousParticle_$LI$()) !== 0) {
                    let b : org.jbox2d.dynamics.Body = contact.body;
                    let w : number = contact.weight;
                    let m : number = contact.mass;
                    let p : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[a];
                    let va : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                    let tempX : number = (<any>Math).fround(p.x - b.m_sweep.c.x);
                    let tempY : number = (<any>Math).fround(p.y - b.m_sweep.c.y);
                    let vx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-b.m_angularVelocity * tempY) + b.m_linearVelocity.x) - va.x);
                    let vy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b.m_angularVelocity * tempX) + b.m_linearVelocity.y) - va.y);
                    let f : org.jbox2d.common.Vec2 = this.tempVec;
                    let pInvMass : number = this.getParticleInvMass();
                    f.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(viscousStrength * m) * w) * vx);
                    f.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(viscousStrength * m) * w) * vy);
                    va.x += (<any>Math).fround(pInvMass * f.x);
                    va.y += (<any>Math).fround(pInvMass * f.y);
                    f.x = -f.x;
                    f.y = -f.y;
                    b.applyLinearImpulse(f, p, true);
                }
            };
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                if((contact.flags & org.jbox2d.particle.ParticleType.b2_viscousParticle_$LI$()) !== 0) {
                    let a : number = contact.indexA;
                    let b : number = contact.indexB;
                    let w : number = contact.weight;
                    let va : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                    let vb : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[b];
                    let vx : number = (<any>Math).fround(vb.x - va.x);
                    let vy : number = (<any>Math).fround(vb.y - va.y);
                    let fx : number = (<any>Math).fround((<any>Math).fround(viscousStrength * w) * vx);
                    let fy : number = (<any>Math).fround((<any>Math).fround(viscousStrength * w) * vy);
                    va.x += fx;
                    va.y += fy;
                    vb.x -= fx;
                    vb.y -= fy;
                }
            };
        }

        solvePowder(step : org.jbox2d.dynamics.TimeStep) {
            let powderStrength : number = (<any>Math).fround(this.m_powderStrength * this.getCriticalVelocity(step));
            let minWeight : number = (<any>Math).fround(1.0 - org.jbox2d.common.Settings.particleStride);
            for(let k : number = 0; k < this.m_bodyContactCount; k++) {
                let contact : org.jbox2d.particle.ParticleBodyContact = this.m_bodyContactBuffer[k];
                let a : number = contact.index;
                if((this.m_flagsBuffer.data[a] & org.jbox2d.particle.ParticleType.b2_powderParticle_$LI$()) !== 0) {
                    let w : number = contact.weight;
                    if(w > minWeight) {
                        let b : org.jbox2d.dynamics.Body = contact.body;
                        let m : number = contact.mass;
                        let p : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[a];
                        let n : org.jbox2d.common.Vec2 = contact.normal;
                        let f : org.jbox2d.common.Vec2 = this.tempVec;
                        let va : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                        let inter : number = (<any>Math).fround((<any>Math).fround(powderStrength * m) * ((<any>Math).fround(w - minWeight)));
                        let pInvMass : number = this.getParticleInvMass();
                        f.x = (<any>Math).fround(inter * n.x);
                        f.y = (<any>Math).fround(inter * n.y);
                        va.x -= (<any>Math).fround(pInvMass * f.x);
                        va.y -= (<any>Math).fround(pInvMass * f.y);
                        b.applyLinearImpulse(f, p, true);
                    }
                }
            };
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                if((contact.flags & org.jbox2d.particle.ParticleType.b2_powderParticle_$LI$()) !== 0) {
                    let w : number = contact.weight;
                    if(w > minWeight) {
                        let a : number = contact.indexA;
                        let b : number = contact.indexB;
                        let n : org.jbox2d.common.Vec2 = contact.normal;
                        let va : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                        let vb : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[b];
                        let inter : number = (<any>Math).fround(powderStrength * ((<any>Math).fround(w - minWeight)));
                        let fx : number = (<any>Math).fround(inter * n.x);
                        let fy : number = (<any>Math).fround(inter * n.y);
                        va.x -= fx;
                        va.y -= fy;
                        vb.x += fx;
                        vb.y += fy;
                    }
                }
            };
        }

        solveSolid(step : org.jbox2d.dynamics.TimeStep) {
            this.m_depthBuffer = this.requestParticleBuffer$float_A(this.m_depthBuffer);
            let ejectionStrength : number = (<any>Math).fround(step.inv_dt * this.m_ejectionStrength);
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                let a : number = contact.indexA;
                let b : number = contact.indexB;
                if(this.m_groupBuffer[a] !== this.m_groupBuffer[b]) {
                    let w : number = contact.weight;
                    let n : org.jbox2d.common.Vec2 = contact.normal;
                    let h : number = (<any>Math).fround(this.m_depthBuffer[a] + this.m_depthBuffer[b]);
                    let va : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                    let vb : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[b];
                    let inter : number = (<any>Math).fround((<any>Math).fround(ejectionStrength * h) * w);
                    let fx : number = (<any>Math).fround(inter * n.x);
                    let fy : number = (<any>Math).fround(inter * n.y);
                    va.x -= fx;
                    va.y -= fy;
                    vb.x += fx;
                    vb.y += fy;
                }
            };
        }

        solveColorMixing(step : org.jbox2d.dynamics.TimeStep) {
            this.m_colorBuffer.data = this.requestParticleBuffer$java_lang_Class$java_lang_Object_A(org.jbox2d.particle.ParticleColor, this.m_colorBuffer.data);
            let colorMixing256 : number = (<number>((<any>Math).fround(256 * this.m_colorMixingStrength))|0);
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                let a : number = contact.indexA;
                let b : number = contact.indexB;
                if((this.m_flagsBuffer.data[a] & this.m_flagsBuffer.data[b] & org.jbox2d.particle.ParticleType.b2_colorMixingParticle_$LI$()) !== 0) {
                    let colorA : org.jbox2d.particle.ParticleColor = this.m_colorBuffer.data[a];
                    let colorB : org.jbox2d.particle.ParticleColor = this.m_colorBuffer.data[b];
                    let dr : number = (colorMixing256 * (colorB.r - colorA.r)) >> 8;
                    let dg : number = (colorMixing256 * (colorB.g - colorA.g)) >> 8;
                    let db : number = (colorMixing256 * (colorB.b - colorA.b)) >> 8;
                    let da : number = (colorMixing256 * (colorB.a - colorA.a)) >> 8;
                    colorA.r += dr;
                    colorA.g += dg;
                    colorA.b += db;
                    colorA.a += da;
                    colorB.r -= dr;
                    colorB.g -= dg;
                    colorB.b -= db;
                    colorB.a -= da;
                }
            };
        }

        solveZombie() {
            let newCount : number = 0;
            let newIndices : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.m_count);
            for(let i : number = 0; i < this.m_count; i++) {
                let flags : number = this.m_flagsBuffer.data[i];
                if((flags & org.jbox2d.particle.ParticleType.b2_zombieParticle_$LI$()) !== 0) {
                    let destructionListener : org.jbox2d.callbacks.ParticleDestructionListener = this.m_world.getParticleDestructionListener();
                    if((flags & org.jbox2d.particle.ParticleType.b2_destructionListener_$LI$()) !== 0 && destructionListener != null) {
                        destructionListener['sayGoodbye$int'](i);
                    }
                    newIndices[i] = org.jbox2d.common.Settings.invalidParticleIndex_$LI$();
                } else {
                    newIndices[i] = newCount;
                    if(i !== newCount) {
                        this.m_flagsBuffer.data[newCount] = this.m_flagsBuffer.data[i];
                        this.m_positionBuffer.data[newCount].set$org_jbox2d_common_Vec2(this.m_positionBuffer.data[i]);
                        this.m_velocityBuffer.data[newCount].set$org_jbox2d_common_Vec2(this.m_velocityBuffer.data[i]);
                        this.m_groupBuffer[newCount] = this.m_groupBuffer[i];
                        if(this.m_depthBuffer != null) {
                            this.m_depthBuffer[newCount] = this.m_depthBuffer[i];
                        }
                        if(this.m_colorBuffer.data != null) {
                            this.m_colorBuffer.data[newCount].set$org_jbox2d_particle_ParticleColor(this.m_colorBuffer.data[i]);
                        }
                        if(this.m_userDataBuffer.data != null) {
                            this.m_userDataBuffer.data[newCount] = this.m_userDataBuffer.data[i];
                        }
                    }
                    newCount++;
                }
            };
            for(let k : number = 0; k < this.m_proxyCount; k++) {
                let proxy : ParticleSystem.Proxy = this.m_proxyBuffer[k];
                proxy.index = newIndices[proxy.index];
            };
            let j : number = this.m_proxyCount;
            for(let i : number = 0; i < j; i++) {
                if(ParticleSystem.Test.IsProxyInvalid(this.m_proxyBuffer[i])) {
                    --j;
                    let temp : ParticleSystem.Proxy = this.m_proxyBuffer[j];
                    this.m_proxyBuffer[j] = this.m_proxyBuffer[i];
                    this.m_proxyBuffer[i] = temp;
                    --i;
                }
            };
            this.m_proxyCount = j;
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                contact.indexA = newIndices[contact.indexA];
                contact.indexB = newIndices[contact.indexB];
            };
            j = this.m_contactCount;
            for(let i : number = 0; i < j; i++) {
                if(ParticleSystem.Test.IsContactInvalid(this.m_contactBuffer[i])) {
                    --j;
                    let temp : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[j];
                    this.m_contactBuffer[j] = this.m_contactBuffer[i];
                    this.m_contactBuffer[i] = temp;
                    --i;
                }
            };
            this.m_contactCount = j;
            for(let k : number = 0; k < this.m_bodyContactCount; k++) {
                let contact : org.jbox2d.particle.ParticleBodyContact = this.m_bodyContactBuffer[k];
                contact.index = newIndices[contact.index];
            };
            j = this.m_bodyContactCount;
            for(let i : number = 0; i < j; i++) {
                if(ParticleSystem.Test.IsBodyContactInvalid(this.m_bodyContactBuffer[i])) {
                    --j;
                    let temp : org.jbox2d.particle.ParticleBodyContact = this.m_bodyContactBuffer[j];
                    this.m_bodyContactBuffer[j] = this.m_bodyContactBuffer[i];
                    this.m_bodyContactBuffer[i] = temp;
                    --i;
                }
            };
            this.m_bodyContactCount = j;
            for(let k : number = 0; k < this.m_pairCount; k++) {
                let pair : ParticleSystem.Pair = this.m_pairBuffer[k];
                pair.indexA = newIndices[pair.indexA];
                pair.indexB = newIndices[pair.indexB];
            };
            j = this.m_pairCount;
            for(let i : number = 0; i < j; i++) {
                if(ParticleSystem.Test.IsPairInvalid(this.m_pairBuffer[i])) {
                    --j;
                    let temp : ParticleSystem.Pair = this.m_pairBuffer[j];
                    this.m_pairBuffer[j] = this.m_pairBuffer[i];
                    this.m_pairBuffer[i] = temp;
                    --i;
                }
            };
            this.m_pairCount = j;
            for(let k : number = 0; k < this.m_triadCount; k++) {
                let triad : ParticleSystem.Triad = this.m_triadBuffer[k];
                triad.indexA = newIndices[triad.indexA];
                triad.indexB = newIndices[triad.indexB];
                triad.indexC = newIndices[triad.indexC];
            };
            j = this.m_triadCount;
            for(let i : number = 0; i < j; i++) {
                if(ParticleSystem.Test.IsTriadInvalid(this.m_triadBuffer[i])) {
                    --j;
                    let temp : ParticleSystem.Triad = this.m_triadBuffer[j];
                    this.m_triadBuffer[j] = this.m_triadBuffer[i];
                    this.m_triadBuffer[i] = temp;
                    --i;
                }
            };
            this.m_triadCount = j;
            for(let group : org.jbox2d.particle.ParticleGroup = this.m_groupList; group != null; group = group.getNext()) {
                let firstIndex : number = newCount;
                let lastIndex : number = 0;
                let modified : boolean = false;
                for(let i : number = group.m_firstIndex; i < group.m_lastIndex; i++) {
                    j = newIndices[i];
                    if(j >= 0) {
                        firstIndex = org.jbox2d.common.MathUtils.min$int$int(firstIndex, j);
                        lastIndex = org.jbox2d.common.MathUtils.max$int$int(lastIndex, j + 1);
                    } else {
                        modified = true;
                    }
                };
                if(firstIndex < lastIndex) {
                    group.m_firstIndex = firstIndex;
                    group.m_lastIndex = lastIndex;
                    if(modified) {
                        if((group.m_groupFlags & org.jbox2d.particle.ParticleGroupType.b2_rigidParticleGroup_$LI$()) !== 0) {
                            group.m_toBeSplit = true;
                        }
                    }
                } else {
                    group.m_firstIndex = 0;
                    group.m_lastIndex = 0;
                    if(group.m_destroyAutomatically) {
                        group.m_toBeDestroyed = true;
                    }
                }
            };
            this.m_count = newCount;
            for(let group : org.jbox2d.particle.ParticleGroup = this.m_groupList; group != null; ) {
                let next : org.jbox2d.particle.ParticleGroup = group.getNext();
                if(group.m_toBeDestroyed) {
                    this.destroyParticleGroup(group);
                } else if(group.m_toBeSplit) {
                }
                group = next;
            };
        }

        /*private*/ newIndices : ParticleSystem.NewIndices = new ParticleSystem.NewIndices();

        RotateBuffer(start : number, mid : number, end : number) {
            if(start === mid || mid === end) {
                return;
            }
            this.newIndices.start = start;
            this.newIndices.mid = mid;
            this.newIndices.end = end;
            org.jbox2d.common.BufferUtils.rotate$int_A$int$int$int(this.m_flagsBuffer.data, start, mid, end);
            org.jbox2d.common.BufferUtils.rotate$java_lang_Object_A$int$int$int(this.m_positionBuffer.data, start, mid, end);
            org.jbox2d.common.BufferUtils.rotate$java_lang_Object_A$int$int$int(this.m_velocityBuffer.data, start, mid, end);
            org.jbox2d.common.BufferUtils.rotate$java_lang_Object_A$int$int$int(this.m_groupBuffer, start, mid, end);
            if(this.m_depthBuffer != null) {
                org.jbox2d.common.BufferUtils.rotate$float_A$int$int$int(this.m_depthBuffer, start, mid, end);
            }
            if(this.m_colorBuffer.data != null) {
                org.jbox2d.common.BufferUtils.rotate$java_lang_Object_A$int$int$int(this.m_colorBuffer.data, start, mid, end);
            }
            if(this.m_userDataBuffer.data != null) {
                org.jbox2d.common.BufferUtils.rotate$java_lang_Object_A$int$int$int(this.m_userDataBuffer.data, start, mid, end);
            }
            for(let k : number = 0; k < this.m_proxyCount; k++) {
                let proxy : ParticleSystem.Proxy = this.m_proxyBuffer[k];
                proxy.index = this.newIndices.getIndex(proxy.index);
            };
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                contact.indexA = this.newIndices.getIndex(contact.indexA);
                contact.indexB = this.newIndices.getIndex(contact.indexB);
            };
            for(let k : number = 0; k < this.m_bodyContactCount; k++) {
                let contact : org.jbox2d.particle.ParticleBodyContact = this.m_bodyContactBuffer[k];
                contact.index = this.newIndices.getIndex(contact.index);
            };
            for(let k : number = 0; k < this.m_pairCount; k++) {
                let pair : ParticleSystem.Pair = this.m_pairBuffer[k];
                pair.indexA = this.newIndices.getIndex(pair.indexA);
                pair.indexB = this.newIndices.getIndex(pair.indexB);
            };
            for(let k : number = 0; k < this.m_triadCount; k++) {
                let triad : ParticleSystem.Triad = this.m_triadBuffer[k];
                triad.indexA = this.newIndices.getIndex(triad.indexA);
                triad.indexB = this.newIndices.getIndex(triad.indexB);
                triad.indexC = this.newIndices.getIndex(triad.indexC);
            };
            for(let group : org.jbox2d.particle.ParticleGroup = this.m_groupList; group != null; group = group.getNext()) {
                group.m_firstIndex = this.newIndices.getIndex(group.m_firstIndex);
                group.m_lastIndex = this.newIndices.getIndex(group.m_lastIndex - 1) + 1;
            };
        }

        public setParticleRadius(radius : number) {
            this.m_particleDiameter = (<any>Math).fround(2 * radius);
            this.m_squaredDiameter = (<any>Math).fround(this.m_particleDiameter * this.m_particleDiameter);
            this.m_inverseDiameter = (<any>Math).fround(1 / this.m_particleDiameter);
        }

        public setParticleDensity(density : number) {
            this.m_density = density;
            this.m_inverseDensity = (<any>Math).fround(1 / this.m_density);
        }

        public getParticleDensity() : number {
            return this.m_density;
        }

        public setParticleGravityScale(gravityScale : number) {
            this.m_gravityScale = gravityScale;
        }

        public getParticleGravityScale() : number {
            return this.m_gravityScale;
        }

        public setParticleDamping(damping : number) {
            this.m_dampingStrength = damping;
        }

        public getParticleDamping() : number {
            return this.m_dampingStrength;
        }

        public getParticleRadius() : number {
            return (<any>Math).fround(this.m_particleDiameter / 2);
        }

        getCriticalVelocity(step : org.jbox2d.dynamics.TimeStep) : number {
            return (<any>Math).fround(this.m_particleDiameter * step.inv_dt);
        }

        getCriticalVelocitySquared(step : org.jbox2d.dynamics.TimeStep) : number {
            let velocity : number = this.getCriticalVelocity(step);
            return (<any>Math).fround(velocity * velocity);
        }

        getCriticalPressure(step : org.jbox2d.dynamics.TimeStep) : number {
            return (<any>Math).fround(this.m_density * this.getCriticalVelocitySquared(step));
        }

        getParticleStride() : number {
            return (<any>Math).fround(org.jbox2d.common.Settings.particleStride * this.m_particleDiameter);
        }

        getParticleMass() : number {
            let stride : number = this.getParticleStride();
            return (<any>Math).fround((<any>Math).fround(this.m_density * stride) * stride);
        }

        getParticleInvMass() : number {
            return (<any>Math).fround((<any>Math).fround((<any>Math).fround(1.777777 * this.m_inverseDensity) * this.m_inverseDiameter) * this.m_inverseDiameter);
        }

        public getParticleFlagsBuffer() : number[] {
            return this.m_flagsBuffer.data;
        }

        public getParticlePositionBuffer() : org.jbox2d.common.Vec2[] {
            return this.m_positionBuffer.data;
        }

        public getParticleVelocityBuffer() : org.jbox2d.common.Vec2[] {
            return this.m_velocityBuffer.data;
        }

        public getParticleColorBuffer() : org.jbox2d.particle.ParticleColor[] {
            this.m_colorBuffer.data = this.requestParticleBuffer$java_lang_Class$java_lang_Object_A(org.jbox2d.particle.ParticleColor, this.m_colorBuffer.data);
            return this.m_colorBuffer.data;
        }

        public getParticleUserDataBuffer() : any[] {
            this.m_userDataBuffer.data = this.requestParticleBuffer$java_lang_Class$java_lang_Object_A(Object, this.m_userDataBuffer.data);
            return this.m_userDataBuffer.data;
        }

        public getParticleMaxCount() : number {
            return this.m_maxCount;
        }

        public setParticleMaxCount(count : number) {
            this.m_maxCount = count;
        }

        public setParticleBuffer$org_jbox2d_particle_ParticleSystem_ParticleBufferInt$int_A$int(buffer : ParticleSystem.ParticleBufferInt, newData : number[], newCapacity : number) {
            if(buffer.userSuppliedCapacity !== 0) {
            }
            buffer.data = newData;
            buffer.userSuppliedCapacity = newCapacity;
        }

        public setParticleBuffer(buffer? : any, newData? : any, newCapacity? : any) : any {
            if(((buffer != null && buffer instanceof <any>org.jbox2d.particle.ParticleSystem.ParticleBufferInt) || buffer === null) && ((newData != null && newData instanceof <any>Array && (newData.length==0 || newData[0] == null ||(typeof newData[0] === 'number'))) || newData === null) && ((typeof newCapacity === 'number') || newCapacity === null)) {
                return <any>this.setParticleBuffer$org_jbox2d_particle_ParticleSystem_ParticleBufferInt$int_A$int(buffer, newData, newCapacity);
            } else if(((buffer != null && buffer instanceof <any>org.jbox2d.particle.ParticleSystem.ParticleBuffer) || buffer === null) && ((newData != null && newData instanceof <any>Array && (newData.length==0 || newData[0] == null ||(newData[0] != null))) || newData === null) && ((typeof newCapacity === 'number') || newCapacity === null)) {
                return <any>this.setParticleBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$java_lang_Object_A$int(buffer, newData, newCapacity);
            } else throw new Error('invalid overload');
        }

        setParticleBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$java_lang_Object_A$int<T>(buffer : ParticleSystem.ParticleBuffer<T>, newData : T[], newCapacity : number) {
            if(buffer.userSuppliedCapacity !== 0) {
            }
            buffer.data = newData;
            buffer.userSuppliedCapacity = newCapacity;
        }

        public setParticleFlagsBuffer(buffer : number[], capacity : number) {
            this.setParticleBuffer$org_jbox2d_particle_ParticleSystem_ParticleBufferInt$int_A$int(this.m_flagsBuffer, buffer, capacity);
        }

        public setParticlePositionBuffer(buffer : org.jbox2d.common.Vec2[], capacity : number) {
            this.setParticleBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$java_lang_Object_A$int(this.m_positionBuffer, buffer, capacity);
        }

        public setParticleVelocityBuffer(buffer : org.jbox2d.common.Vec2[], capacity : number) {
            this.setParticleBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$java_lang_Object_A$int(this.m_velocityBuffer, buffer, capacity);
        }

        public setParticleColorBuffer(buffer : org.jbox2d.particle.ParticleColor[], capacity : number) {
            this.setParticleBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$java_lang_Object_A$int(this.m_colorBuffer, buffer, capacity);
        }

        public getParticleGroupBuffer() : org.jbox2d.particle.ParticleGroup[] {
            return this.m_groupBuffer;
        }

        public getParticleGroupCount() : number {
            return this.m_groupCount;
        }

        public getParticleGroupList() : org.jbox2d.particle.ParticleGroup[] {
            return this.m_groupBuffer;
        }

        public getParticleCount() : number {
            return this.m_count;
        }

        public setParticleUserDataBuffer(buffer : any[], capacity : number) {
            this.setParticleBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$java_lang_Object_A$int(this.m_userDataBuffer, buffer, capacity);
        }

        static lowerBound(ray : ParticleSystem.Proxy[], length : number, tag : number) : number {
            let left : number = 0;
            let step : number;
            let curr : number;
            while((length > 0)) {
                step = (length / 2|0);
                curr = left + step;
                if(ray[curr].tag < tag) {
                    left = curr + 1;
                    length -= step + 1;
                } else {
                    length = step;
                }
            };
            return left;
        }

        static upperBound(ray : ParticleSystem.Proxy[], length : number, tag : number) : number {
            let left : number = 0;
            let step : number;
            let curr : number;
            while((length > 0)) {
                step = (length / 2|0);
                curr = left + step;
                if(ray[curr].tag <= tag) {
                    left = curr + 1;
                    length -= step + 1;
                } else {
                    length = step;
                }
            };
            return left;
        }

        public queryAABB(callback : org.jbox2d.callbacks.ParticleQueryCallback, aabb : org.jbox2d.collision.AABB) {
            if(this.m_proxyCount === 0) {
                return;
            }
            let lowerBoundX : number = aabb.lowerBound.x;
            let lowerBoundY : number = aabb.lowerBound.y;
            let upperBoundX : number = aabb.upperBound.x;
            let upperBoundY : number = aabb.upperBound.y;
            let firstProxy : number = ParticleSystem.lowerBound(this.m_proxyBuffer, this.m_proxyCount, ParticleSystem.computeTag((<any>Math).fround(this.m_inverseDiameter * lowerBoundX), (<any>Math).fround(this.m_inverseDiameter * lowerBoundY)));
            let lastProxy : number = ParticleSystem.upperBound(this.m_proxyBuffer, this.m_proxyCount, ParticleSystem.computeTag((<any>Math).fround(this.m_inverseDiameter * upperBoundX), (<any>Math).fround(this.m_inverseDiameter * upperBoundY)));
            for(let proxy : number = firstProxy; proxy < lastProxy; ++proxy) {
                let i : number = this.m_proxyBuffer[proxy].index;
                let p : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[i];
                if(lowerBoundX < p.x && p.x < upperBoundX && lowerBoundY < p.y && p.y < upperBoundY) {
                    if(!callback.reportParticle(i)) {
                        break;
                    }
                }
            };
        }

        /**
         * @param {*} callback
         * @param {org.jbox2d.common.Vec2} point1
         * @param {org.jbox2d.common.Vec2} point2
         */
        public raycast(callback : org.jbox2d.callbacks.ParticleRaycastCallback, point1 : org.jbox2d.common.Vec2, point2 : org.jbox2d.common.Vec2) {
            if(this.m_proxyCount === 0) {
                return;
            }
            let firstProxy : number = ParticleSystem.lowerBound(this.m_proxyBuffer, this.m_proxyCount, ParticleSystem.computeTag((<any>Math).fround((<any>Math).fround(this.m_inverseDiameter * org.jbox2d.common.MathUtils.min$float$float(point1.x, point2.x)) - 1), (<any>Math).fround((<any>Math).fround(this.m_inverseDiameter * org.jbox2d.common.MathUtils.min$float$float(point1.y, point2.y)) - 1)));
            let lastProxy : number = ParticleSystem.upperBound(this.m_proxyBuffer, this.m_proxyCount, ParticleSystem.computeTag((<any>Math).fround((<any>Math).fround(this.m_inverseDiameter * org.jbox2d.common.MathUtils.max$float$float(point1.x, point2.x)) + 1), (<any>Math).fround((<any>Math).fround(this.m_inverseDiameter * org.jbox2d.common.MathUtils.max$float$float(point1.y, point2.y)) + 1)));
            let fraction : number = 1;
            let vx : number = (<any>Math).fround(point2.x - point1.x);
            let vy : number = (<any>Math).fround(point2.y - point1.y);
            let v2 : number = (<any>Math).fround((<any>Math).fround(vx * vx) + (<any>Math).fround(vy * vy));
            if(v2 === 0) v2 = Number.MAX_VALUE;
            for(let proxy : number = firstProxy; proxy < lastProxy; ++proxy) {
                let i : number = this.m_proxyBuffer[proxy].index;
                let posI : org.jbox2d.common.Vec2 = this.m_positionBuffer.data[i];
                let px : number = (<any>Math).fround(point1.x - posI.x);
                let py : number = (<any>Math).fround(point1.y - posI.y);
                let pv : number = (<any>Math).fround((<any>Math).fround(px * vx) + (<any>Math).fround(py * vy));
                let p2 : number = (<any>Math).fround((<any>Math).fround(px * px) + (<any>Math).fround(py * py));
                let determinant : number = (<any>Math).fround((<any>Math).fround(pv * pv) - (<any>Math).fround(v2 * ((<any>Math).fround(p2 - this.m_squaredDiameter))));
                if(determinant >= 0) {
                    let sqrtDeterminant : number = org.jbox2d.common.MathUtils.sqrt(determinant);
                    let t : number = (<any>Math).fround(((<any>Math).fround(-pv - sqrtDeterminant)) / v2);
                    if(t > fraction) {
                        continue;
                    }
                    if(t < 0) {
                        t = (<any>Math).fround(((<any>Math).fround(-pv + sqrtDeterminant)) / v2);
                        if(t < 0 || t > fraction) {
                            continue;
                        }
                    }
                    let n : org.jbox2d.common.Vec2 = this.tempVec;
                    this.tempVec.x = (<any>Math).fround(px + (<any>Math).fround(t * vx));
                    this.tempVec.y = (<any>Math).fround(py + (<any>Math).fround(t * vy));
                    n.normalize();
                    let point : org.jbox2d.common.Vec2 = this.tempVec2;
                    point.x = (<any>Math).fround(point1.x + (<any>Math).fround(t * vx));
                    point.y = (<any>Math).fround(point1.y + (<any>Math).fround(t * vy));
                    let f : number = callback.reportParticle(i, point, n, t);
                    fraction = org.jbox2d.common.MathUtils.min$float$float(fraction, f);
                    if(fraction <= 0) {
                        break;
                    }
                }
            };
        }

        public computeParticleCollisionEnergy() : number {
            let sum_v2 : number = 0;
            for(let k : number = 0; k < this.m_contactCount; k++) {
                let contact : org.jbox2d.particle.ParticleContact = this.m_contactBuffer[k];
                let a : number = contact.indexA;
                let b : number = contact.indexB;
                let n : org.jbox2d.common.Vec2 = contact.normal;
                let va : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[a];
                let vb : org.jbox2d.common.Vec2 = this.m_velocityBuffer.data[b];
                let vx : number = (<any>Math).fround(vb.x - va.x);
                let vy : number = (<any>Math).fround(vb.y - va.y);
                let vn : number = (<any>Math).fround((<any>Math).fround(vx * n.x) + (<any>Math).fround(vy * n.y));
                if(vn < 0) {
                    sum_v2 += (<any>Math).fround(vn * vn);
                }
            };
            return (<any>Math).fround((<any>Math).fround(0.5 * this.getParticleMass()) * sum_v2);
        }

        public static reallocateBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$int$int$boolean<T>(buffer : ParticleSystem.ParticleBuffer<T>, oldCapacity : number, newCapacity : number, deferred : boolean) : T[] {
            return org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int$int$boolean(buffer.dataClass, buffer.data, buffer.userSuppliedCapacity, oldCapacity, newCapacity, deferred);
        }

        public static reallocateBuffer<T>(buffer? : any, oldCapacity? : any, newCapacity? : any, deferred? : any) : any {
            if(((buffer != null && buffer instanceof <any>org.jbox2d.particle.ParticleSystem.ParticleBuffer) || buffer === null) && ((typeof oldCapacity === 'number') || oldCapacity === null) && ((typeof newCapacity === 'number') || newCapacity === null) && ((typeof deferred === 'boolean') || deferred === null)) {
                return <any>org.jbox2d.particle.ParticleSystem.reallocateBuffer$org_jbox2d_particle_ParticleSystem_ParticleBuffer$int$int$boolean(buffer, oldCapacity, newCapacity, deferred);
            } else if(((buffer != null && buffer instanceof <any>org.jbox2d.particle.ParticleSystem.ParticleBufferInt) || buffer === null) && ((typeof oldCapacity === 'number') || oldCapacity === null) && ((typeof newCapacity === 'number') || newCapacity === null) && ((typeof deferred === 'boolean') || deferred === null)) {
                return <any>org.jbox2d.particle.ParticleSystem.reallocateBuffer$org_jbox2d_particle_ParticleSystem_ParticleBufferInt$int$int$boolean(buffer, oldCapacity, newCapacity, deferred);
            } else throw new Error('invalid overload');
        }

        static reallocateBuffer$org_jbox2d_particle_ParticleSystem_ParticleBufferInt$int$int$boolean(buffer : ParticleSystem.ParticleBufferInt, oldCapacity : number, newCapacity : number, deferred : boolean) : number[] {
            return org.jbox2d.common.BufferUtils.reallocateBuffer$int_A$int$int$int$boolean(buffer.data, buffer.userSuppliedCapacity, oldCapacity, newCapacity, deferred);
        }

        public requestParticleBuffer$java_lang_Class$java_lang_Object_A<T>(klass : any, buffer : T[]) : T[] {
            if(buffer == null) {
                buffer = <T[]>/* newInstance */new Array<any>(this.m_internalAllocatedCapacity);
                for(let i : number = 0; i < this.m_internalAllocatedCapacity; i++) {
                    try {
                        buffer[i] = /* newInstance */new (klass)();
                    } catch(e) {
                        throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                    };
                };
            }
            return buffer;
        }

        public requestParticleBuffer<T>(klass? : any, buffer? : any) : any {
            if(((klass != null) || klass === null) && ((buffer != null && buffer instanceof <any>Array && (buffer.length==0 || buffer[0] == null ||(buffer[0] != null))) || buffer === null)) {
                return <any>this.requestParticleBuffer$java_lang_Class$java_lang_Object_A(klass, buffer);
            } else if(((klass != null && klass instanceof <any>Array && (klass.length==0 || klass[0] == null ||(typeof klass[0] === 'number'))) || klass === null) && buffer === undefined) {
                return <any>this.requestParticleBuffer$float_A(klass);
            } else throw new Error('invalid overload');
        }

        requestParticleBuffer$float_A(buffer : number[]) : number[] {
            if(buffer == null) {
                buffer = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.m_internalAllocatedCapacity);
            }
            return buffer;
        }
    }
    ParticleSystem["__class"] = "org.jbox2d.particle.ParticleSystem";


    export namespace ParticleSystem {

        export class NewIndices {
            start : number;

            mid : number;

            end : number;

            getIndex(i : number) : number {
                if(i < this.start) {
                    return i;
                } else if(i < this.mid) {
                    return i + this.end - this.mid;
                } else if(i < this.end) {
                    return i + this.start - this.mid;
                } else {
                    return i;
                }
            }

            constructor() {
                if(this.start===undefined) this.start = 0;
                if(this.mid===undefined) this.mid = 0;
                if(this.end===undefined) this.end = 0;
            }
        }
        NewIndices["__class"] = "org.jbox2d.particle.ParticleSystem.NewIndices";


        export class ParticleBuffer<T> {
            public data : T[];

            dataClass : any;

            userSuppliedCapacity : number;

            public constructor(dataClass : any) {
                if(this.data===undefined) this.data = null;
                if(this.dataClass===undefined) this.dataClass = null;
                if(this.userSuppliedCapacity===undefined) this.userSuppliedCapacity = 0;
                this.dataClass = dataClass;
            }
        }
        ParticleBuffer["__class"] = "org.jbox2d.particle.ParticleSystem.ParticleBuffer";


        export class ParticleBufferInt {
            data : number[];

            userSuppliedCapacity : number;

            constructor() {
                if(this.data===undefined) this.data = null;
                if(this.userSuppliedCapacity===undefined) this.userSuppliedCapacity = 0;
            }
        }
        ParticleBufferInt["__class"] = "org.jbox2d.particle.ParticleSystem.ParticleBufferInt";


        /**
         * Used for detecting particle contacts
         * @class
         */
        export class Proxy {
            index : number;

            tag : number;

            /**
             * 
             * @param {org.jbox2d.particle.ParticleSystem.Proxy} o
             * @return {number}
             */
            public compareTo(o : ParticleSystem.Proxy) : number {
                return (this.tag - o.tag) < 0?-1:(o.tag === this.tag?0:1);
            }

            /**
             * 
             * @param {*} obj
             * @return {boolean}
             */
            public equals(obj : any) : boolean {
                if(this === obj) return true;
                if(obj == null) return false;
                if((<any>this.constructor) !== (<any>obj.constructor)) return false;
                let other : ParticleSystem.Proxy = <ParticleSystem.Proxy>obj;
                if(this.tag !== other.tag) return false;
                return true;
            }

            constructor() {
                if(this.index===undefined) this.index = 0;
                if(this.tag===undefined) this.tag = 0;
            }
        }
        Proxy["__class"] = "org.jbox2d.particle.ParticleSystem.Proxy";
        Proxy["__interfaces"] = ["java.lang.Comparable"];



        /**
         * Connection between two particles
         * @class
         */
        export class Pair {
            indexA : number;

            indexB : number;

            flags : number;

            strength : number;

            distance : number;

            constructor() {
                if(this.indexA===undefined) this.indexA = 0;
                if(this.indexB===undefined) this.indexB = 0;
                if(this.flags===undefined) this.flags = 0;
                if(this.strength===undefined) this.strength = 0;
                if(this.distance===undefined) this.distance = 0;
            }
        }
        Pair["__class"] = "org.jbox2d.particle.ParticleSystem.Pair";


        /**
         * Connection between three particles
         * @class
         */
        export class Triad {
            indexA : number;

            indexB : number;

            indexC : number;

            flags : number;

            strength : number;

            pa : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            pb : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            pc : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            ka : number;

            kb : number;

            kc : number;

            s : number;

            constructor() {
                if(this.indexA===undefined) this.indexA = 0;
                if(this.indexB===undefined) this.indexB = 0;
                if(this.indexC===undefined) this.indexC = 0;
                if(this.flags===undefined) this.flags = 0;
                if(this.strength===undefined) this.strength = 0;
                if(this.ka===undefined) this.ka = 0;
                if(this.kb===undefined) this.kb = 0;
                if(this.kc===undefined) this.kc = 0;
                if(this.s===undefined) this.s = 0;
            }
        }
        Triad["__class"] = "org.jbox2d.particle.ParticleSystem.Triad";


        export class CreateParticleGroupCallback implements org.jbox2d.particle.VoronoiDiagram.VoronoiDiagramCallback {
            public callback(a : number, b : number, c : number) {
                let pa : org.jbox2d.common.Vec2 = this.system.m_positionBuffer.data[a];
                let pb : org.jbox2d.common.Vec2 = this.system.m_positionBuffer.data[b];
                let pc : org.jbox2d.common.Vec2 = this.system.m_positionBuffer.data[c];
                let dabx : number = (<any>Math).fround(pa.x - pb.x);
                let daby : number = (<any>Math).fround(pa.y - pb.y);
                let dbcx : number = (<any>Math).fround(pb.x - pc.x);
                let dbcy : number = (<any>Math).fround(pb.y - pc.y);
                let dcax : number = (<any>Math).fround(pc.x - pa.x);
                let dcay : number = (<any>Math).fround(pc.y - pa.y);
                let maxDistanceSquared : number = (<any>Math).fround(org.jbox2d.common.Settings.maxTriadDistanceSquared_$LI$() * this.system.m_squaredDiameter);
                if((<any>Math).fround((<any>Math).fround(dabx * dabx) + (<any>Math).fround(daby * daby)) < maxDistanceSquared && (<any>Math).fround((<any>Math).fround(dbcx * dbcx) + (<any>Math).fround(dbcy * dbcy)) < maxDistanceSquared && (<any>Math).fround((<any>Math).fround(dcax * dcax) + (<any>Math).fround(dcay * dcay)) < maxDistanceSquared) {
                    if(this.system.m_triadCount >= this.system.m_triadCapacity) {
                        let oldCapacity : number = this.system.m_triadCapacity;
                        let newCapacity : number = this.system.m_triadCount !== 0?2 * this.system.m_triadCount:org.jbox2d.common.Settings.minParticleBufferCapacity;
                        this.system.m_triadBuffer = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(ParticleSystem.Triad, this.system.m_triadBuffer, oldCapacity, newCapacity);
                        this.system.m_triadCapacity = newCapacity;
                    }
                    let triad : ParticleSystem.Triad = this.system.m_triadBuffer[this.system.m_triadCount];
                    triad.indexA = a;
                    triad.indexB = b;
                    triad.indexC = c;
                    triad.flags = this.system.m_flagsBuffer.data[a] | this.system.m_flagsBuffer.data[b] | this.system.m_flagsBuffer.data[c];
                    triad.strength = this.def.strength;
                    let midPointx : number = (<any>Math).fround((<any>Math).fround(<number>1 / 3) * ((<any>Math).fround((<any>Math).fround(pa.x + pb.x) + pc.x)));
                    let midPointy : number = (<any>Math).fround((<any>Math).fround(<number>1 / 3) * ((<any>Math).fround((<any>Math).fround(pa.y + pb.y) + pc.y)));
                    triad.pa.x = (<any>Math).fround(pa.x - midPointx);
                    triad.pa.y = (<any>Math).fround(pa.y - midPointy);
                    triad.pb.x = (<any>Math).fround(pb.x - midPointx);
                    triad.pb.y = (<any>Math).fround(pb.y - midPointy);
                    triad.pc.x = (<any>Math).fround(pc.x - midPointx);
                    triad.pc.y = (<any>Math).fround(pc.y - midPointy);
                    triad.ka = -((<any>Math).fround((<any>Math).fround(dcax * dabx) + (<any>Math).fround(dcay * daby)));
                    triad.kb = -((<any>Math).fround((<any>Math).fround(dabx * dbcx) + (<any>Math).fround(daby * dbcy)));
                    triad.kc = -((<any>Math).fround((<any>Math).fround(dbcx * dcax) + (<any>Math).fround(dbcy * dcay)));
                    triad.s = (<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(pa, pb) + org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(pb, pc)) + org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(pc, pa));
                    this.system.m_triadCount++;
                }
            }

            system : org.jbox2d.particle.ParticleSystem;

            def : org.jbox2d.particle.ParticleGroupDef;

            firstIndex : number;

            constructor() {
                if(this.system===undefined) this.system = null;
                if(this.def===undefined) this.def = null;
                if(this.firstIndex===undefined) this.firstIndex = 0;
            }
        }
        CreateParticleGroupCallback["__class"] = "org.jbox2d.particle.ParticleSystem.CreateParticleGroupCallback";
        CreateParticleGroupCallback["__interfaces"] = ["org.jbox2d.particle.VoronoiDiagram.VoronoiDiagramCallback"];



        export class JoinParticleGroupsCallback implements org.jbox2d.particle.VoronoiDiagram.VoronoiDiagramCallback {
            public callback(a : number, b : number, c : number) {
                let countA : number = ((a < this.groupB.m_firstIndex)?1:0) + ((b < this.groupB.m_firstIndex)?1:0) + ((c < this.groupB.m_firstIndex)?1:0);
                if(countA > 0 && countA < 3) {
                    let af : number = this.system.m_flagsBuffer.data[a];
                    let bf : number = this.system.m_flagsBuffer.data[b];
                    let cf : number = this.system.m_flagsBuffer.data[c];
                    if((af & bf & cf & org.jbox2d.particle.ParticleSystem.k_triadFlags_$LI$()) !== 0) {
                        let pa : org.jbox2d.common.Vec2 = this.system.m_positionBuffer.data[a];
                        let pb : org.jbox2d.common.Vec2 = this.system.m_positionBuffer.data[b];
                        let pc : org.jbox2d.common.Vec2 = this.system.m_positionBuffer.data[c];
                        let dabx : number = (<any>Math).fround(pa.x - pb.x);
                        let daby : number = (<any>Math).fround(pa.y - pb.y);
                        let dbcx : number = (<any>Math).fround(pb.x - pc.x);
                        let dbcy : number = (<any>Math).fround(pb.y - pc.y);
                        let dcax : number = (<any>Math).fround(pc.x - pa.x);
                        let dcay : number = (<any>Math).fround(pc.y - pa.y);
                        let maxDistanceSquared : number = (<any>Math).fround(org.jbox2d.common.Settings.maxTriadDistanceSquared_$LI$() * this.system.m_squaredDiameter);
                        if((<any>Math).fround((<any>Math).fround(dabx * dabx) + (<any>Math).fround(daby * daby)) < maxDistanceSquared && (<any>Math).fround((<any>Math).fround(dbcx * dbcx) + (<any>Math).fround(dbcy * dbcy)) < maxDistanceSquared && (<any>Math).fround((<any>Math).fround(dcax * dcax) + (<any>Math).fround(dcay * dcay)) < maxDistanceSquared) {
                            if(this.system.m_triadCount >= this.system.m_triadCapacity) {
                                let oldCapacity : number = this.system.m_triadCapacity;
                                let newCapacity : number = this.system.m_triadCount !== 0?2 * this.system.m_triadCount:org.jbox2d.common.Settings.minParticleBufferCapacity;
                                this.system.m_triadBuffer = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(ParticleSystem.Triad, this.system.m_triadBuffer, oldCapacity, newCapacity);
                                this.system.m_triadCapacity = newCapacity;
                            }
                            let triad : ParticleSystem.Triad = this.system.m_triadBuffer[this.system.m_triadCount];
                            triad.indexA = a;
                            triad.indexB = b;
                            triad.indexC = c;
                            triad.flags = af | bf | cf;
                            triad.strength = org.jbox2d.common.MathUtils.min$float$float(this.groupA.m_strength, this.groupB.m_strength);
                            let midPointx : number = (<any>Math).fround((<any>Math).fround(<number>1 / 3) * ((<any>Math).fround((<any>Math).fround(pa.x + pb.x) + pc.x)));
                            let midPointy : number = (<any>Math).fround((<any>Math).fround(<number>1 / 3) * ((<any>Math).fround((<any>Math).fround(pa.y + pb.y) + pc.y)));
                            triad.pa.x = (<any>Math).fround(pa.x - midPointx);
                            triad.pa.y = (<any>Math).fround(pa.y - midPointy);
                            triad.pb.x = (<any>Math).fround(pb.x - midPointx);
                            triad.pb.y = (<any>Math).fround(pb.y - midPointy);
                            triad.pc.x = (<any>Math).fround(pc.x - midPointx);
                            triad.pc.y = (<any>Math).fround(pc.y - midPointy);
                            triad.ka = -((<any>Math).fround((<any>Math).fround(dcax * dabx) + (<any>Math).fround(dcay * daby)));
                            triad.kb = -((<any>Math).fround((<any>Math).fround(dabx * dbcx) + (<any>Math).fround(daby * dbcy)));
                            triad.kc = -((<any>Math).fround((<any>Math).fround(dbcx * dcax) + (<any>Math).fround(dbcy * dcay)));
                            triad.s = (<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(pa, pb) + org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(pb, pc)) + org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(pc, pa));
                            this.system.m_triadCount++;
                        }
                    }
                }
            }

            system : org.jbox2d.particle.ParticleSystem;

            groupA : org.jbox2d.particle.ParticleGroup;

            groupB : org.jbox2d.particle.ParticleGroup;

            constructor() {
                if(this.system===undefined) this.system = null;
                if(this.groupA===undefined) this.groupA = null;
                if(this.groupB===undefined) this.groupB = null;
            }
        }
        JoinParticleGroupsCallback["__class"] = "org.jbox2d.particle.ParticleSystem.JoinParticleGroupsCallback";
        JoinParticleGroupsCallback["__interfaces"] = ["org.jbox2d.particle.VoronoiDiagram.VoronoiDiagramCallback"];



        export class DestroyParticlesInShapeCallback implements org.jbox2d.callbacks.ParticleQueryCallback {
            system : org.jbox2d.particle.ParticleSystem;

            shape : org.jbox2d.collision.shapes.Shape;

            xf : org.jbox2d.common.Transform;

            callDestructionListener : boolean;

            destroyed : number;

            public constructor() {
                if(this.system===undefined) this.system = null;
                if(this.shape===undefined) this.shape = null;
                if(this.xf===undefined) this.xf = null;
                if(this.callDestructionListener===undefined) this.callDestructionListener = false;
                if(this.destroyed===undefined) this.destroyed = 0;
            }

            public init(system : org.jbox2d.particle.ParticleSystem, shape : org.jbox2d.collision.shapes.Shape, xf : org.jbox2d.common.Transform, callDestructionListener : boolean) {
                this.system = system;
                this.shape = shape;
                this.xf = xf;
                this.destroyed = 0;
                this.callDestructionListener = callDestructionListener;
            }

            /**
             * 
             * @param {number} index
             * @return {boolean}
             */
            public reportParticle(index : number) : boolean {
                if(this.shape.testPoint(this.xf, this.system.m_positionBuffer.data[index])) {
                    this.system.destroyParticle(index, this.callDestructionListener);
                    this.destroyed++;
                }
                return true;
            }
        }
        DestroyParticlesInShapeCallback["__class"] = "org.jbox2d.particle.ParticleSystem.DestroyParticlesInShapeCallback";
        DestroyParticlesInShapeCallback["__interfaces"] = ["org.jbox2d.callbacks.ParticleQueryCallback"];



        export class UpdateBodyContactsCallback implements org.jbox2d.callbacks.QueryCallback {
            system : org.jbox2d.particle.ParticleSystem;

            tempVec : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            /**
             * 
             * @param {org.jbox2d.dynamics.Fixture} fixture
             * @return {boolean}
             */
            public reportFixture(fixture : org.jbox2d.dynamics.Fixture) : boolean {
                if(fixture.isSensor()) {
                    return true;
                }
                let shape : org.jbox2d.collision.shapes.Shape = fixture.getShape();
                let b : org.jbox2d.dynamics.Body = fixture.getBody();
                let bp : org.jbox2d.common.Vec2 = b.getWorldCenter();
                let bm : number = b.getMass();
                let bI : number = (<any>Math).fround(b.getInertia() - (<any>Math).fround(bm * b.getLocalCenter().lengthSquared()));
                let invBm : number = bm > 0?(<any>Math).fround(1 / bm):0;
                let invBI : number = bI > 0?(<any>Math).fround(1 / bI):0;
                let childCount : number = shape.getChildCount();
                for(let childIndex : number = 0; childIndex < childCount; childIndex++) {
                    let aabb : org.jbox2d.collision.AABB = fixture.getAABB(childIndex);
                    let aabblowerBoundx : number = (<any>Math).fround(aabb.lowerBound.x - this.system.m_particleDiameter);
                    let aabblowerBoundy : number = (<any>Math).fround(aabb.lowerBound.y - this.system.m_particleDiameter);
                    let aabbupperBoundx : number = (<any>Math).fround(aabb.upperBound.x + this.system.m_particleDiameter);
                    let aabbupperBoundy : number = (<any>Math).fround(aabb.upperBound.y + this.system.m_particleDiameter);
                    let firstProxy : number = ParticleSystem.lowerBound(this.system.m_proxyBuffer, this.system.m_proxyCount, ParticleSystem.computeTag((<any>Math).fround(this.system.m_inverseDiameter * aabblowerBoundx), (<any>Math).fround(this.system.m_inverseDiameter * aabblowerBoundy)));
                    let lastProxy : number = ParticleSystem.upperBound(this.system.m_proxyBuffer, this.system.m_proxyCount, ParticleSystem.computeTag((<any>Math).fround(this.system.m_inverseDiameter * aabbupperBoundx), (<any>Math).fround(this.system.m_inverseDiameter * aabbupperBoundy)));
                    for(let proxy : number = firstProxy; proxy !== lastProxy; ++proxy) {
                        let a : number = this.system.m_proxyBuffer[proxy].index;
                        let ap : org.jbox2d.common.Vec2 = this.system.m_positionBuffer.data[a];
                        if(aabblowerBoundx <= ap.x && ap.x <= aabbupperBoundx && aabblowerBoundy <= ap.y && ap.y <= aabbupperBoundy) {
                            let d : number;
                            let n : org.jbox2d.common.Vec2 = this.tempVec;
                            d = fixture.computeDistance(ap, childIndex, n);
                            if(d < this.system.m_particleDiameter) {
                                let invAm : number = (this.system.m_flagsBuffer.data[a] & org.jbox2d.particle.ParticleType.b2_wallParticle_$LI$()) !== 0?0:this.system.getParticleInvMass();
                                let rpx : number = (<any>Math).fround(ap.x - bp.x);
                                let rpy : number = (<any>Math).fround(ap.y - bp.y);
                                let rpn : number = (<any>Math).fround((<any>Math).fround(rpx * n.y) - (<any>Math).fround(rpy * n.x));
                                if(this.system.m_bodyContactCount >= this.system.m_bodyContactCapacity) {
                                    let oldCapacity : number = this.system.m_bodyContactCapacity;
                                    let newCapacity : number = this.system.m_bodyContactCount !== 0?2 * this.system.m_bodyContactCount:org.jbox2d.common.Settings.minParticleBufferCapacity;
                                    this.system.m_bodyContactBuffer = org.jbox2d.common.BufferUtils.reallocateBuffer$java_lang_Class$java_lang_Object_A$int$int(org.jbox2d.particle.ParticleBodyContact, this.system.m_bodyContactBuffer, oldCapacity, newCapacity);
                                    this.system.m_bodyContactCapacity = newCapacity;
                                }
                                let contact : org.jbox2d.particle.ParticleBodyContact = this.system.m_bodyContactBuffer[this.system.m_bodyContactCount];
                                contact.index = a;
                                contact.body = b;
                                contact.weight = (<any>Math).fround(1 - (<any>Math).fround(d * this.system.m_inverseDiameter));
                                contact.normal.x = -n.x;
                                contact.normal.y = -n.y;
                                contact.mass = (<any>Math).fround(1 / ((<any>Math).fround((<any>Math).fround(invAm + invBm) + (<any>Math).fround((<any>Math).fround(invBI * rpn) * rpn))));
                                this.system.m_bodyContactCount++;
                            }
                        }
                    };
                };
                return true;
            }

            constructor() {
                if(this.system===undefined) this.system = null;
            }
        }
        UpdateBodyContactsCallback["__class"] = "org.jbox2d.particle.ParticleSystem.UpdateBodyContactsCallback";
        UpdateBodyContactsCallback["__interfaces"] = ["org.jbox2d.callbacks.QueryCallback"];



        export class SolveCollisionCallback implements org.jbox2d.callbacks.QueryCallback {
            system : org.jbox2d.particle.ParticleSystem;

            step : org.jbox2d.dynamics.TimeStep;

            input : org.jbox2d.collision.RayCastInput = new org.jbox2d.collision.RayCastInput();

            output : org.jbox2d.collision.RayCastOutput = new org.jbox2d.collision.RayCastOutput();

            tempVec : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            tempVec2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            /**
             * 
             * @param {org.jbox2d.dynamics.Fixture} fixture
             * @return {boolean}
             */
            public reportFixture(fixture : org.jbox2d.dynamics.Fixture) : boolean {
                if(fixture.isSensor()) {
                    return true;
                }
                let shape : org.jbox2d.collision.shapes.Shape = fixture.getShape();
                let body : org.jbox2d.dynamics.Body = fixture.getBody();
                let childCount : number = shape.getChildCount();
                for(let childIndex : number = 0; childIndex < childCount; childIndex++) {
                    let aabb : org.jbox2d.collision.AABB = fixture.getAABB(childIndex);
                    let aabblowerBoundx : number = (<any>Math).fround(aabb.lowerBound.x - this.system.m_particleDiameter);
                    let aabblowerBoundy : number = (<any>Math).fround(aabb.lowerBound.y - this.system.m_particleDiameter);
                    let aabbupperBoundx : number = (<any>Math).fround(aabb.upperBound.x + this.system.m_particleDiameter);
                    let aabbupperBoundy : number = (<any>Math).fround(aabb.upperBound.y + this.system.m_particleDiameter);
                    let firstProxy : number = ParticleSystem.lowerBound(this.system.m_proxyBuffer, this.system.m_proxyCount, ParticleSystem.computeTag((<any>Math).fround(this.system.m_inverseDiameter * aabblowerBoundx), (<any>Math).fround(this.system.m_inverseDiameter * aabblowerBoundy)));
                    let lastProxy : number = ParticleSystem.upperBound(this.system.m_proxyBuffer, this.system.m_proxyCount, ParticleSystem.computeTag((<any>Math).fround(this.system.m_inverseDiameter * aabbupperBoundx), (<any>Math).fround(this.system.m_inverseDiameter * aabbupperBoundy)));
                    for(let proxy : number = firstProxy; proxy !== lastProxy; ++proxy) {
                        let a : number = this.system.m_proxyBuffer[proxy].index;
                        let ap : org.jbox2d.common.Vec2 = this.system.m_positionBuffer.data[a];
                        if(aabblowerBoundx <= ap.x && ap.x <= aabbupperBoundx && aabblowerBoundy <= ap.y && ap.y <= aabbupperBoundy) {
                            let av : org.jbox2d.common.Vec2 = this.system.m_velocityBuffer.data[a];
                            let temp : org.jbox2d.common.Vec2 = this.tempVec;
                            org.jbox2d.common.Transform.mulTransToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(body.m_xf0, ap, temp);
                            org.jbox2d.common.Transform.mulToOutUnsafe$org_jbox2d_common_Transform$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(body.m_xf, temp, this.input.p1);
                            this.input.p2.x = (<any>Math).fround(ap.x + (<any>Math).fround(this.step.dt * av.x));
                            this.input.p2.y = (<any>Math).fround(ap.y + (<any>Math).fround(this.step.dt * av.y));
                            this.input.maxFraction = 1;
                            if(fixture.raycast(this.output, this.input, childIndex)) {
                                let p : org.jbox2d.common.Vec2 = this.tempVec;
                                p.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1 - this.output.fraction)) * this.input.p1.x) + (<any>Math).fround(this.output.fraction * this.input.p2.x)) + (<any>Math).fround(org.jbox2d.common.Settings.linearSlop * this.output.normal.x));
                                p.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1 - this.output.fraction)) * this.input.p1.y) + (<any>Math).fround(this.output.fraction * this.input.p2.y)) + (<any>Math).fround(org.jbox2d.common.Settings.linearSlop * this.output.normal.y));
                                let vx : number = (<any>Math).fround(this.step.inv_dt * ((<any>Math).fround(p.x - ap.x)));
                                let vy : number = (<any>Math).fround(this.step.inv_dt * ((<any>Math).fround(p.y - ap.y)));
                                av.x = vx;
                                av.y = vy;
                                let particleMass : number = this.system.getParticleMass();
                                let ax : number = (<any>Math).fround(particleMass * ((<any>Math).fround(av.x - vx)));
                                let ay : number = (<any>Math).fround(particleMass * ((<any>Math).fround(av.y - vy)));
                                let b : org.jbox2d.common.Vec2 = this.output.normal;
                                let fdn : number = (<any>Math).fround((<any>Math).fround(ax * b.x) + (<any>Math).fround(ay * b.y));
                                let f : org.jbox2d.common.Vec2 = this.tempVec2;
                                f.x = (<any>Math).fround(fdn * b.x);
                                f.y = (<any>Math).fround(fdn * b.y);
                                body.applyLinearImpulse(f, p, true);
                            }
                        }
                    };
                };
                return true;
            }

            constructor() {
                if(this.system===undefined) this.system = null;
                if(this.step===undefined) this.step = null;
            }
        }
        SolveCollisionCallback["__class"] = "org.jbox2d.particle.ParticleSystem.SolveCollisionCallback";
        SolveCollisionCallback["__interfaces"] = ["org.jbox2d.callbacks.QueryCallback"];



        export class Test {
            static IsProxyInvalid(proxy : ParticleSystem.Proxy) : boolean {
                return proxy.index < 0;
            }

            static IsContactInvalid(contact : org.jbox2d.particle.ParticleContact) : boolean {
                return contact.indexA < 0 || contact.indexB < 0;
            }

            static IsBodyContactInvalid(contact : org.jbox2d.particle.ParticleBodyContact) : boolean {
                return contact.index < 0;
            }

            static IsPairInvalid(pair : ParticleSystem.Pair) : boolean {
                return pair.indexA < 0 || pair.indexB < 0;
            }

            static IsTriadInvalid(triad : ParticleSystem.Triad) : boolean {
                return triad.indexA < 0 || triad.indexB < 0 || triad.indexC < 0;
            }

            constructor() {
            }
        }
        Test["__class"] = "org.jbox2d.particle.ParticleSystem.Test";

    }

}
namespace org.jbox2d.particle {
    export class VoronoiDiagram {
        /*private*/ m_generatorBuffer : VoronoiDiagram.Generator[];

        /*private*/ m_generatorCount : number;

        /*private*/ m_countX : number;

        /*private*/ m_countY : number;

        /*private*/ m_diagram : VoronoiDiagram.Generator[];

        public constructor(generatorCapacity : number) {
            if(this.m_generatorBuffer===undefined) this.m_generatorBuffer = null;
            if(this.m_generatorCount===undefined) this.m_generatorCount = 0;
            if(this.m_countX===undefined) this.m_countX = 0;
            if(this.m_countY===undefined) this.m_countY = 0;
            if(this.m_diagram===undefined) this.m_diagram = null;
            this.m_generatorBuffer = (s => { let a=[]; while(s-->0) a.push(null); return a; })(generatorCapacity);
            for(let i : number = 0; i < generatorCapacity; i++) {
                this.m_generatorBuffer[i] = new VoronoiDiagram.Generator();
            };
            this.m_generatorCount = 0;
            this.m_countX = 0;
            this.m_countY = 0;
            this.m_diagram = null;
        }

        public getNodes(callback : VoronoiDiagram.VoronoiDiagramCallback) {
            for(let y : number = 0; y < this.m_countY - 1; y++) {
                for(let x : number = 0; x < this.m_countX - 1; x++) {
                    let i : number = x + y * this.m_countX;
                    let a : VoronoiDiagram.Generator = this.m_diagram[i];
                    let b : VoronoiDiagram.Generator = this.m_diagram[i + 1];
                    let c : VoronoiDiagram.Generator = this.m_diagram[i + this.m_countX];
                    let d : VoronoiDiagram.Generator = this.m_diagram[i + 1 + this.m_countX];
                    if(b !== c) {
                        if(a !== b && a !== c) {
                            callback.callback(a.tag, b.tag, c.tag);
                        }
                        if(d !== b && d !== c) {
                            callback.callback(b.tag, d.tag, c.tag);
                        }
                    }
                };
            };
        }

        public addGenerator(center : org.jbox2d.common.Vec2, tag : number) {
            let g : VoronoiDiagram.Generator = this.m_generatorBuffer[this.m_generatorCount++];
            g.center.x = center.x;
            g.center.y = center.y;
            g.tag = tag;
        }

        /*private*/ lower : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ upper : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ taskPool : org.jbox2d.pooling.normal.MutableStack<VoronoiDiagram.VoronoiDiagramTask> = new VoronoiDiagram.VoronoiDiagram$0(this, 50);

        /*private*/ queue : org.jbox2d.particle.StackQueue<VoronoiDiagram.VoronoiDiagramTask> = <any>(new org.jbox2d.particle.StackQueue<VoronoiDiagram.VoronoiDiagramTask>());

        public generate(radius : number) {
            let inverseRadius : number = (<any>Math).fround(1 / radius);
            this.lower.x = Number.MAX_VALUE;
            this.lower.y = Number.MAX_VALUE;
            this.upper.x = -Number.MAX_VALUE;
            this.upper.y = -Number.MAX_VALUE;
            for(let k : number = 0; k < this.m_generatorCount; k++) {
                let g : VoronoiDiagram.Generator = this.m_generatorBuffer[k];
                org.jbox2d.common.Vec2.minToOut(this.lower, g.center, this.lower);
                org.jbox2d.common.Vec2.maxToOut(this.upper, g.center, this.upper);
            };
            this.m_countX = 1 + (<number>((<any>Math).fround(inverseRadius * ((<any>Math).fround(this.upper.x - this.lower.x))))|0);
            this.m_countY = 1 + (<number>((<any>Math).fround(inverseRadius * ((<any>Math).fround(this.upper.y - this.lower.y))))|0);
            this.m_diagram = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_countX * this.m_countY);
            this.queue.reset((s => { let a=[]; while(s-->0) a.push(null); return a; })(4 * this.m_countX * this.m_countX));
            for(let k : number = 0; k < this.m_generatorCount; k++) {
                let g : VoronoiDiagram.Generator = this.m_generatorBuffer[k];
                g.center.x = (<any>Math).fround(inverseRadius * ((<any>Math).fround(g.center.x - this.lower.x)));
                g.center.y = (<any>Math).fround(inverseRadius * ((<any>Math).fround(g.center.y - this.lower.y)));
                let x : number = org.jbox2d.common.MathUtils.max$int$int(0, org.jbox2d.common.MathUtils.min$int$int((<number>g.center.x|0), this.m_countX - 1));
                let y : number = org.jbox2d.common.MathUtils.max$int$int(0, org.jbox2d.common.MathUtils.min$int$int((<number>g.center.y|0), this.m_countY - 1));
                this.queue.push(this.taskPool.pop().set(x, y, x + y * this.m_countX, g));
            };
            while((!this.queue.empty())) {
                let front : VoronoiDiagram.VoronoiDiagramTask = this.queue.pop();
                let x : number = front.m_x;
                let y : number = front.m_y;
                let i : number = front.m_i;
                let g : VoronoiDiagram.Generator = front.m_generator;
                if(this.m_diagram[i] == null) {
                    this.m_diagram[i] = g;
                    if(x > 0) {
                        this.queue.push(this.taskPool.pop().set(x - 1, y, i - 1, g));
                    }
                    if(y > 0) {
                        this.queue.push(this.taskPool.pop().set(x, y - 1, i - this.m_countX, g));
                    }
                    if(x < this.m_countX - 1) {
                        this.queue.push(this.taskPool.pop().set(x + 1, y, i + 1, g));
                    }
                    if(y < this.m_countY - 1) {
                        this.queue.push(this.taskPool.pop().set(x, y + 1, i + this.m_countX, g));
                    }
                }
                this.taskPool.push(front);
            };
            let maxIteration : number = this.m_countX + this.m_countY;
            for(let iteration : number = 0; iteration < maxIteration; iteration++) {
                for(let y : number = 0; y < this.m_countY; y++) {
                    for(let x : number = 0; x < this.m_countX - 1; x++) {
                        let i : number = x + y * this.m_countX;
                        let a : VoronoiDiagram.Generator = this.m_diagram[i];
                        let b : VoronoiDiagram.Generator = this.m_diagram[i + 1];
                        if(a !== b) {
                            this.queue.push(this.taskPool.pop().set(x, y, i, b));
                            this.queue.push(this.taskPool.pop().set(x + 1, y, i + 1, a));
                        }
                    };
                };
                for(let y : number = 0; y < this.m_countY - 1; y++) {
                    for(let x : number = 0; x < this.m_countX; x++) {
                        let i : number = x + y * this.m_countX;
                        let a : VoronoiDiagram.Generator = this.m_diagram[i];
                        let b : VoronoiDiagram.Generator = this.m_diagram[i + this.m_countX];
                        if(a !== b) {
                            this.queue.push(this.taskPool.pop().set(x, y, i, b));
                            this.queue.push(this.taskPool.pop().set(x, y + 1, i + this.m_countX, a));
                        }
                    };
                };
                let updated : boolean = false;
                while((!this.queue.empty())) {
                    let front : VoronoiDiagram.VoronoiDiagramTask = this.queue.pop();
                    let x : number = front.m_x;
                    let y : number = front.m_y;
                    let i : number = front.m_i;
                    let k : VoronoiDiagram.Generator = front.m_generator;
                    let a : VoronoiDiagram.Generator = this.m_diagram[i];
                    let b : VoronoiDiagram.Generator = k;
                    if(a !== b) {
                        let ax : number = (<any>Math).fround(a.center.x - x);
                        let ay : number = (<any>Math).fround(a.center.y - y);
                        let bx : number = (<any>Math).fround(b.center.x - x);
                        let by : number = (<any>Math).fround(b.center.y - y);
                        let a2 : number = (<any>Math).fround((<any>Math).fround(ax * ax) + (<any>Math).fround(ay * ay));
                        let b2 : number = (<any>Math).fround((<any>Math).fround(bx * bx) + (<any>Math).fround(by * by));
                        if(a2 > b2) {
                            this.m_diagram[i] = b;
                            if(x > 0) {
                                this.queue.push(this.taskPool.pop().set(x - 1, y, i - 1, b));
                            }
                            if(y > 0) {
                                this.queue.push(this.taskPool.pop().set(x, y - 1, i - this.m_countX, b));
                            }
                            if(x < this.m_countX - 1) {
                                this.queue.push(this.taskPool.pop().set(x + 1, y, i + 1, b));
                            }
                            if(y < this.m_countY - 1) {
                                this.queue.push(this.taskPool.pop().set(x, y + 1, i + this.m_countX, b));
                            }
                            updated = true;
                        }
                    }
                    this.taskPool.push(front);
                };
                if(!updated) {
                    break;
                }
            };
        }
    }
    VoronoiDiagram["__class"] = "org.jbox2d.particle.VoronoiDiagram";


    export namespace VoronoiDiagram {

        export class Generator {
            center : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

            tag : number;

            constructor() {
                if(this.tag===undefined) this.tag = 0;
            }
        }
        Generator["__class"] = "org.jbox2d.particle.VoronoiDiagram.Generator";


        export class VoronoiDiagramTask {
            m_x : number;

            m_y : number;

            m_i : number;

            m_generator : VoronoiDiagram.Generator;

            public constructor(x? : any, y? : any, i? : any, g? : any) {
                if(((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof i === 'number') || i === null) && ((g != null && g instanceof <any>org.jbox2d.particle.VoronoiDiagram.Generator) || g === null)) {
                    let __args = Array.prototype.slice.call(arguments);
                    if(this.m_x===undefined) this.m_x = 0;
                    if(this.m_y===undefined) this.m_y = 0;
                    if(this.m_i===undefined) this.m_i = 0;
                    if(this.m_generator===undefined) this.m_generator = null;
                    if(this.m_x===undefined) this.m_x = 0;
                    if(this.m_y===undefined) this.m_y = 0;
                    if(this.m_i===undefined) this.m_i = 0;
                    if(this.m_generator===undefined) this.m_generator = null;
                    (() => {
                        this.m_x = x;
                        this.m_y = y;
                        this.m_i = i;
                        this.m_generator = g;
                    })();
                } else if(x === undefined && y === undefined && i === undefined && g === undefined) {
                    let __args = Array.prototype.slice.call(arguments);
                    if(this.m_x===undefined) this.m_x = 0;
                    if(this.m_y===undefined) this.m_y = 0;
                    if(this.m_i===undefined) this.m_i = 0;
                    if(this.m_generator===undefined) this.m_generator = null;
                    if(this.m_x===undefined) this.m_x = 0;
                    if(this.m_y===undefined) this.m_y = 0;
                    if(this.m_i===undefined) this.m_i = 0;
                    if(this.m_generator===undefined) this.m_generator = null;
                } else throw new Error('invalid overload');
            }

            public set(x : number, y : number, i : number, g : VoronoiDiagram.Generator) : VoronoiDiagram.VoronoiDiagramTask {
                this.m_x = x;
                this.m_y = y;
                this.m_i = i;
                this.m_generator = g;
                return this;
            }
        }
        VoronoiDiagramTask["__class"] = "org.jbox2d.particle.VoronoiDiagram.VoronoiDiagramTask";


        export interface VoronoiDiagramCallback {
            callback(aTag : number, bTag : number, cTag : number);
        }

        export class VoronoiDiagram$0 extends org.jbox2d.pooling.normal.MutableStack<org.jbox2d.particle.VoronoiDiagram.VoronoiDiagramTask> {
            public __parent: any;
            /**
             * 
             * @return {org.jbox2d.particle.VoronoiDiagram.VoronoiDiagramTask}
             */
            newInstance() : VoronoiDiagram.VoronoiDiagramTask {
                return new VoronoiDiagram.VoronoiDiagramTask();
            }

            /**
             * 
             * @param {number} size
             * @return {Array}
             */
            newArray(size : number) : VoronoiDiagram.VoronoiDiagramTask[] {
                return (s => { let a=[]; while(s-->0) a.push(null); return a; })(size);
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
            }
        }
        VoronoiDiagram$0["__interfaces"] = ["org.jbox2d.pooling.IDynamicStack"];


    }

}
namespace org.jbox2d.pooling.normal {
    /**
     * Provides object pooling for all objects used in the engine. Objects retrieved from here should
     * only be used temporarily, and then pushed back (with the exception of arrays).
     * 
     * @author Daniel Murphy
     * @param {number} argSize
     * @param {number} argContainerSize
     * @class
     */
    export class DefaultWorldPool implements org.jbox2d.pooling.IWorldPool {
        /*private*/ vecs : org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.common.Vec2>;

        /*private*/ vec3s : org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.common.Vec3>;

        /*private*/ mats : org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.common.Mat22>;

        /*private*/ mat33s : org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.common.Mat33>;

        /*private*/ aabbs : org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.collision.AABB>;

        /*private*/ rots : org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.common.Rot>;

        /*private*/ afloats : any = <any>({});

        /*private*/ aints : any = <any>({});

        /*private*/ avecs : any = <any>({});

        /*private*/ world : org.jbox2d.pooling.IWorldPool = this;

        /*private*/ pcstack : org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> = new DefaultWorldPool.DefaultWorldPool$0(this, org.jbox2d.common.Settings.CONTACT_STACK_INIT_SIZE);

        /*private*/ ccstack : org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> = new DefaultWorldPool.DefaultWorldPool$1(this, org.jbox2d.common.Settings.CONTACT_STACK_INIT_SIZE);

        /*private*/ cpstack : org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> = new DefaultWorldPool.DefaultWorldPool$2(this, org.jbox2d.common.Settings.CONTACT_STACK_INIT_SIZE);

        /*private*/ ecstack : org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> = new DefaultWorldPool.DefaultWorldPool$3(this, org.jbox2d.common.Settings.CONTACT_STACK_INIT_SIZE);

        /*private*/ epstack : org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> = new DefaultWorldPool.DefaultWorldPool$4(this, org.jbox2d.common.Settings.CONTACT_STACK_INIT_SIZE);

        /*private*/ chcstack : org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> = new DefaultWorldPool.DefaultWorldPool$5(this, org.jbox2d.common.Settings.CONTACT_STACK_INIT_SIZE);

        /*private*/ chpstack : org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> = new DefaultWorldPool.DefaultWorldPool$6(this, org.jbox2d.common.Settings.CONTACT_STACK_INIT_SIZE);

        /*private*/ collision : org.jbox2d.collision.Collision;

        /*private*/ toi : org.jbox2d.collision.TimeOfImpact;

        /*private*/ dist : org.jbox2d.collision.Distance;

        public constructor(argSize : number, argContainerSize : number) {
            if(this.vecs===undefined) this.vecs = null;
            if(this.vec3s===undefined) this.vec3s = null;
            if(this.mats===undefined) this.mats = null;
            if(this.mat33s===undefined) this.mat33s = null;
            if(this.aabbs===undefined) this.aabbs = null;
            if(this.rots===undefined) this.rots = null;
            if(this.collision===undefined) this.collision = null;
            if(this.toi===undefined) this.toi = null;
            if(this.dist===undefined) this.dist = null;
            this.vecs = new DefaultWorldPool.DefaultWorldPool$7(this, argSize, argContainerSize);
            this.vec3s = new DefaultWorldPool.DefaultWorldPool$8(this, argSize, argContainerSize);
            this.mats = new DefaultWorldPool.DefaultWorldPool$9(this, argSize, argContainerSize);
            this.aabbs = new DefaultWorldPool.DefaultWorldPool$10(this, argSize, argContainerSize);
            this.rots = new DefaultWorldPool.DefaultWorldPool$11(this, argSize, argContainerSize);
            this.mat33s = new DefaultWorldPool.DefaultWorldPool$12(this, argSize, argContainerSize);
            this.dist = new org.jbox2d.collision.Distance();
            this.collision = new org.jbox2d.collision.Collision(this);
            this.toi = new org.jbox2d.collision.TimeOfImpact(this);
        }

        public getPolyContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact> {
            return this.pcstack;
        }

        public getCircleContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact> {
            return this.ccstack;
        }

        public getPolyCircleContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact> {
            return this.cpstack;
        }

        /**
         * 
         * @return {*}
         */
        public getEdgeCircleContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact> {
            return this.ecstack;
        }

        /**
         * 
         * @return {*}
         */
        public getEdgePolyContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact> {
            return this.epstack;
        }

        /**
         * 
         * @return {*}
         */
        public getChainCircleContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact> {
            return this.chcstack;
        }

        /**
         * 
         * @return {*}
         */
        public getChainPolyContactStack() : org.jbox2d.pooling.IDynamicStack<org.jbox2d.dynamics.contacts.Contact> {
            return this.chpstack;
        }

        public popVec2$() : org.jbox2d.common.Vec2 {
            return this.vecs.pop();
        }

        public popVec2$int(argNum : number) : org.jbox2d.common.Vec2[] {
            return this.vecs.pop$int(argNum);
        }

        public popVec2(argNum? : any) : any {
            if(((typeof argNum === 'number') || argNum === null)) {
                return <any>this.popVec2$int(argNum);
            } else if(argNum === undefined) {
                return <any>this.popVec2$();
            } else throw new Error('invalid overload');
        }

        public pushVec2(argNum : number) {
            this.vecs.push(argNum);
        }

        public popVec3$() : org.jbox2d.common.Vec3 {
            return this.vec3s.pop();
        }

        public popVec3$int(argNum : number) : org.jbox2d.common.Vec3[] {
            return this.vec3s.pop$int(argNum);
        }

        public popVec3(argNum? : any) : any {
            if(((typeof argNum === 'number') || argNum === null)) {
                return <any>this.popVec3$int(argNum);
            } else if(argNum === undefined) {
                return <any>this.popVec3$();
            } else throw new Error('invalid overload');
        }

        public pushVec3(argNum : number) {
            this.vec3s.push(argNum);
        }

        public popMat22$() : org.jbox2d.common.Mat22 {
            return this.mats.pop();
        }

        public popMat22$int(argNum : number) : org.jbox2d.common.Mat22[] {
            return this.mats.pop$int(argNum);
        }

        public popMat22(argNum? : any) : any {
            if(((typeof argNum === 'number') || argNum === null)) {
                return <any>this.popMat22$int(argNum);
            } else if(argNum === undefined) {
                return <any>this.popMat22$();
            } else throw new Error('invalid overload');
        }

        public pushMat22(argNum : number) {
            this.mats.push(argNum);
        }

        public popMat33() : org.jbox2d.common.Mat33 {
            return this.mat33s.pop();
        }

        public pushMat33(argNum : number) {
            this.mat33s.push(argNum);
        }

        public popAABB$() : org.jbox2d.collision.AABB {
            return this.aabbs.pop();
        }

        public popAABB$int(argNum : number) : org.jbox2d.collision.AABB[] {
            return this.aabbs.pop$int(argNum);
        }

        public popAABB(argNum? : any) : any {
            if(((typeof argNum === 'number') || argNum === null)) {
                return <any>this.popAABB$int(argNum);
            } else if(argNum === undefined) {
                return <any>this.popAABB$();
            } else throw new Error('invalid overload');
        }

        public pushAABB(argNum : number) {
            this.aabbs.push(argNum);
        }

        public popRot() : org.jbox2d.common.Rot {
            return this.rots.pop();
        }

        public pushRot(num : number) {
            this.rots.push(num);
        }

        public getCollision() : org.jbox2d.collision.Collision {
            return this.collision;
        }

        public getTimeOfImpact() : org.jbox2d.collision.TimeOfImpact {
            return this.toi;
        }

        public getDistance() : org.jbox2d.collision.Distance {
            return this.dist;
        }

        public getFloatArray(argLength : number) : number[] {
            if(!/* containsKey */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return true; } return false; })(<any>this.afloats, argLength)) {
                /* put */((m,k,v) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { m.entries[i].value=v; return; } m.entries.push({key:k,value:v,getKey: function() { return this.key }, getValue: function() { return this.value }}); })(<any>this.afloats, argLength, (s => { let a=[]; while(s-->0) a.push(0); return a; })(argLength));
            }
            return /* get */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return m.entries[i].value; } return null; })(<any>this.afloats, argLength);
        }

        public getIntArray(argLength : number) : number[] {
            if(!/* containsKey */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return true; } return false; })(<any>this.aints, argLength)) {
                /* put */((m,k,v) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { m.entries[i].value=v; return; } m.entries.push({key:k,value:v,getKey: function() { return this.key }, getValue: function() { return this.value }}); })(<any>this.aints, argLength, (s => { let a=[]; while(s-->0) a.push(0); return a; })(argLength));
            }
            return /* get */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return m.entries[i].value; } return null; })(<any>this.aints, argLength);
        }

        public getVec2Array(argLength : number) : org.jbox2d.common.Vec2[] {
            if(!/* containsKey */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return true; } return false; })(<any>this.avecs, argLength)) {
                let ray : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(argLength);
                for(let i : number = 0; i < argLength; i++) {
                    ray[i] = new org.jbox2d.common.Vec2();
                };
                /* put */((m,k,v) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { m.entries[i].value=v; return; } m.entries.push({key:k,value:v,getKey: function() { return this.key }, getValue: function() { return this.value }}); })(<any>this.avecs, argLength, ray);
            }
            return /* get */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return m.entries[i].value; } return null; })(<any>this.avecs, argLength);
        }
    }
    DefaultWorldPool["__class"] = "org.jbox2d.pooling.normal.DefaultWorldPool";
    DefaultWorldPool["__interfaces"] = ["org.jbox2d.pooling.IWorldPool"];



    export namespace DefaultWorldPool {

        export class DefaultWorldPool$0 extends org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> {
            public __parent: any;
            newInstance() : org.jbox2d.dynamics.contacts.Contact {
                return new org.jbox2d.dynamics.contacts.PolygonContact(this.__parent.world);
            }

            newArray(size : number) : org.jbox2d.dynamics.contacts.Contact[] {
                return (s => { let a=[]; while(s-->0) a.push(null); return a; })(size);
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
            }
        }
        DefaultWorldPool$0["__interfaces"] = ["org.jbox2d.pooling.IDynamicStack"];



        export class DefaultWorldPool$1 extends org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> {
            public __parent: any;
            newInstance() : org.jbox2d.dynamics.contacts.Contact {
                return new org.jbox2d.dynamics.contacts.CircleContact(this.__parent.world);
            }

            newArray(size : number) : org.jbox2d.dynamics.contacts.Contact[] {
                return (s => { let a=[]; while(s-->0) a.push(null); return a; })(size);
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
            }
        }
        DefaultWorldPool$1["__interfaces"] = ["org.jbox2d.pooling.IDynamicStack"];



        export class DefaultWorldPool$2 extends org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> {
            public __parent: any;
            newInstance() : org.jbox2d.dynamics.contacts.Contact {
                return new org.jbox2d.dynamics.contacts.PolygonAndCircleContact(this.__parent.world);
            }

            newArray(size : number) : org.jbox2d.dynamics.contacts.Contact[] {
                return (s => { let a=[]; while(s-->0) a.push(null); return a; })(size);
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
            }
        }
        DefaultWorldPool$2["__interfaces"] = ["org.jbox2d.pooling.IDynamicStack"];



        export class DefaultWorldPool$3 extends org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> {
            public __parent: any;
            newInstance() : org.jbox2d.dynamics.contacts.Contact {
                return new org.jbox2d.dynamics.contacts.EdgeAndCircleContact(this.__parent.world);
            }

            newArray(size : number) : org.jbox2d.dynamics.contacts.Contact[] {
                return (s => { let a=[]; while(s-->0) a.push(null); return a; })(size);
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
            }
        }
        DefaultWorldPool$3["__interfaces"] = ["org.jbox2d.pooling.IDynamicStack"];



        export class DefaultWorldPool$4 extends org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> {
            public __parent: any;
            newInstance() : org.jbox2d.dynamics.contacts.Contact {
                return new org.jbox2d.dynamics.contacts.EdgeAndPolygonContact(this.__parent.world);
            }

            newArray(size : number) : org.jbox2d.dynamics.contacts.Contact[] {
                return (s => { let a=[]; while(s-->0) a.push(null); return a; })(size);
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
            }
        }
        DefaultWorldPool$4["__interfaces"] = ["org.jbox2d.pooling.IDynamicStack"];



        export class DefaultWorldPool$5 extends org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> {
            public __parent: any;
            newInstance() : org.jbox2d.dynamics.contacts.Contact {
                return new org.jbox2d.dynamics.contacts.ChainAndCircleContact(this.__parent.world);
            }

            newArray(size : number) : org.jbox2d.dynamics.contacts.Contact[] {
                return (s => { let a=[]; while(s-->0) a.push(null); return a; })(size);
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
            }
        }
        DefaultWorldPool$5["__interfaces"] = ["org.jbox2d.pooling.IDynamicStack"];



        export class DefaultWorldPool$6 extends org.jbox2d.pooling.normal.MutableStack<org.jbox2d.dynamics.contacts.Contact> {
            public __parent: any;
            newInstance() : org.jbox2d.dynamics.contacts.Contact {
                return new org.jbox2d.dynamics.contacts.ChainAndPolygonContact(this.__parent.world);
            }

            newArray(size : number) : org.jbox2d.dynamics.contacts.Contact[] {
                return (s => { let a=[]; while(s-->0) a.push(null); return a; })(size);
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
            }
        }
        DefaultWorldPool$6["__interfaces"] = ["org.jbox2d.pooling.IDynamicStack"];



        export class DefaultWorldPool$7 extends org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.common.Vec2> {
            public __parent: any;
            newInstance() : org.jbox2d.common.Vec2 {
                return new org.jbox2d.common.Vec2();
            }

            constructor(__parent: any, __arg0: any, __arg1: any) {
                super(__arg0, __arg1);
                this.__parent = __parent;
            }
        }


        export class DefaultWorldPool$8 extends org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.common.Vec3> {
            public __parent: any;
            newInstance() : org.jbox2d.common.Vec3 {
                return new org.jbox2d.common.Vec3();
            }

            constructor(__parent: any, __arg0: any, __arg1: any) {
                super(__arg0, __arg1);
                this.__parent = __parent;
            }
        }


        export class DefaultWorldPool$9 extends org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.common.Mat22> {
            public __parent: any;
            newInstance() : org.jbox2d.common.Mat22 {
                return new org.jbox2d.common.Mat22();
            }

            constructor(__parent: any, __arg0: any, __arg1: any) {
                super(__arg0, __arg1);
                this.__parent = __parent;
            }
        }


        export class DefaultWorldPool$10 extends org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.collision.AABB> {
            public __parent: any;
            newInstance() : org.jbox2d.collision.AABB {
                return new org.jbox2d.collision.AABB();
            }

            constructor(__parent: any, __arg0: any, __arg1: any) {
                super(__arg0, __arg1);
                this.__parent = __parent;
            }
        }


        export class DefaultWorldPool$11 extends org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.common.Rot> {
            public __parent: any;
            newInstance() : org.jbox2d.common.Rot {
                return new org.jbox2d.common.Rot();
            }

            constructor(__parent: any, __arg0: any, __arg1: any) {
                super(__arg0, __arg1);
                this.__parent = __parent;
            }
        }


        export class DefaultWorldPool$12 extends org.jbox2d.pooling.normal.OrderedStack<org.jbox2d.common.Mat33> {
            public __parent: any;
            newInstance() : org.jbox2d.common.Mat33 {
                return new org.jbox2d.common.Mat33();
            }

            constructor(__parent: any, __arg0: any, __arg1: any) {
                super(__arg0, __arg1);
                this.__parent = __parent;
            }
        }

    }

}


org.jbox2d.particle.ParticleSystem.yMask_$LI$();

org.jbox2d.particle.ParticleSystem.xMask_$LI$();

org.jbox2d.particle.ParticleSystem.xOffset_$LI$();

org.jbox2d.particle.ParticleSystem.xScale_$LI$();

org.jbox2d.particle.ParticleSystem.xShift_$LI$();

org.jbox2d.particle.ParticleSystem.yShift_$LI$();

org.jbox2d.particle.ParticleSystem.yOffset_$LI$();

org.jbox2d.particle.ParticleSystem.tagBits_$LI$();

org.jbox2d.particle.ParticleSystem.k_noPressureFlags_$LI$();

org.jbox2d.particle.ParticleSystem.k_triadFlags_$LI$();

org.jbox2d.particle.ParticleSystem.k_pairFlags_$LI$();

org.jbox2d.common.Mat33.IDENTITY_$LI$();

org.jbox2d.common.Transform.pool_$LI$();

org.jbox2d.collision.Collision.d_$LI$();

org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();

org.jbox2d.common.MathUtils.__sinLUT_$LI$();

org.jbox2d.common.MathUtils.RAD2DEG_$LI$();

org.jbox2d.common.MathUtils.DEG2RAD_$LI$();

org.jbox2d.common.MathUtils.THREE_HALVES_PI_$LI$();

org.jbox2d.common.MathUtils.QUARTER_PI_$LI$();

org.jbox2d.common.MathUtils.HALF_PI_$LI$();

org.jbox2d.common.MathUtils.INV_PI_$LI$();

org.jbox2d.common.MathUtils.TWOPI_$LI$();

org.jbox2d.common.MathUtils.PI_$LI$();

org.jbox2d.common.MathUtils.__static_initialize();

org.jbox2d.particle.ParticleType.b2_destructionListener_$LI$();

org.jbox2d.particle.ParticleType.b2_colorMixingParticle_$LI$();

org.jbox2d.particle.ParticleType.b2_tensileParticle_$LI$();

org.jbox2d.particle.ParticleType.b2_powderParticle_$LI$();

org.jbox2d.particle.ParticleType.b2_viscousParticle_$LI$();

org.jbox2d.particle.ParticleType.b2_elasticParticle_$LI$();

org.jbox2d.particle.ParticleType.b2_springParticle_$LI$();

org.jbox2d.particle.ParticleType.b2_wallParticle_$LI$();

org.jbox2d.particle.ParticleType.b2_zombieParticle_$LI$();

org.jbox2d.particle.ParticleGroupType.b2_rigidParticleGroup_$LI$();

org.jbox2d.particle.ParticleGroupType.b2_solidParticleGroup_$LI$();

org.jbox2d.dynamics.World.LIQUID_INT_$LI$();

org.jbox2d.dynamics.Profile.SHORT_FRACTION_$LI$();

org.jbox2d.dynamics.Profile.LONG_FRACTION_$LI$();

org.jbox2d.common.Settings.maxTriadDistanceSquared_$LI$();

org.jbox2d.common.Settings.invalidParticleIndex_$LI$();

org.jbox2d.common.Settings.angularSleepTolerance_$LI$();

org.jbox2d.common.Settings.maxRotationSquared_$LI$();

org.jbox2d.common.Settings.maxRotation_$LI$();

org.jbox2d.common.Settings.maxTranslationSquared_$LI$();

org.jbox2d.common.Settings.maxAngularCorrection_$LI$();

org.jbox2d.common.Settings.polygonRadius_$LI$();

org.jbox2d.common.Settings.angularSlop_$LI$();

org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$();

org.jbox2d.common.Settings.PI_$LI$();

org.jbox2d.common.PlatformMathUtils.INV_SHIFT23_$LI$();

org.jbox2d.common.PlatformMathUtils.SHIFT23_$LI$();

org.jbox2d.common.Color3f.RED_$LI$();

org.jbox2d.common.Color3f.GREEN_$LI$();

org.jbox2d.common.Color3f.BLUE_$LI$();

org.jbox2d.common.Color3f.BLACK_$LI$();

org.jbox2d.common.Color3f.WHITE_$LI$();

org.jbox2d.callbacks.DebugDraw.e_wireframeDrawingBit_$LI$();

org.jbox2d.callbacks.DebugDraw.e_dynamicTreeBit_$LI$();

org.jbox2d.callbacks.DebugDraw.e_centerOfMassBit_$LI$();

org.jbox2d.callbacks.DebugDraw.e_pairBit_$LI$();

org.jbox2d.callbacks.DebugDraw.e_aabbBit_$LI$();

org.jbox2d.callbacks.DebugDraw.e_jointBit_$LI$();

org.jbox2d.callbacks.DebugDraw.e_shapeBit_$LI$();
