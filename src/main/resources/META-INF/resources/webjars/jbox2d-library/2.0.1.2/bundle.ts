/* Generated from Java with JSweet 2.3.0 - http://www.jsweet.org */
namespace org.jbox2d.collision {
    /**
     * Creates an AABB object using the given bounding
     * vertices.
     * @param {org.jbox2d.common.Vec2} lowerVertex the bottom left vertex of the bounding box
     * @param maxVertex the top right vertex of the bounding box
     * @param {org.jbox2d.common.Vec2} upperVertex
     * @class
     */
    export class AABB {
        /**
         * Bottom left vertex of bounding box.
         */
        public lowerBound : org.jbox2d.common.Vec2;

        /**
         * Top right vertex of bounding box.
         */
        public upperBound : org.jbox2d.common.Vec2;

        public constructor(lowerVertex? : any, upperVertex? : any) {
            if(((lowerVertex != null && lowerVertex instanceof <any>org.jbox2d.common.Vec2) || lowerVertex === null) && ((upperVertex != null && upperVertex instanceof <any>org.jbox2d.common.Vec2) || upperVertex === null)) {
                let __args = arguments;
                if(this.lowerBound===undefined) this.lowerBound = null;
                if(this.upperBound===undefined) this.upperBound = null;
                if(this.lowerBound===undefined) this.lowerBound = null;
                if(this.upperBound===undefined) this.upperBound = null;
                (() => {
                    this.lowerBound = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(lowerVertex);
                    this.upperBound = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(upperVertex);
                })();
            } else if(((lowerVertex != null && lowerVertex instanceof <any>org.jbox2d.collision.AABB) || lowerVertex === null) && upperVertex === undefined) {
                let __args = arguments;
                let copy : any = __args[0];
                {
                    let __args = arguments;
                    let lowerVertex : any = copy.lowerBound;
                    let upperVertex : any = copy.upperBound;
                    if(this.lowerBound===undefined) this.lowerBound = null;
                    if(this.upperBound===undefined) this.upperBound = null;
                    if(this.lowerBound===undefined) this.lowerBound = null;
                    if(this.upperBound===undefined) this.upperBound = null;
                    (() => {
                        this.lowerBound = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(lowerVertex);
                        this.upperBound = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(upperVertex);
                    })();
                }
            } else if(lowerVertex === undefined && upperVertex === undefined) {
                let __args = arguments;
                if(this.lowerBound===undefined) this.lowerBound = null;
                if(this.upperBound===undefined) this.upperBound = null;
                if(this.lowerBound===undefined) this.lowerBound = null;
                if(this.upperBound===undefined) this.upperBound = null;
                (() => {
                    this.lowerBound = new org.jbox2d.common.Vec2();
                    this.upperBound = new org.jbox2d.common.Vec2();
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * Sets this object from the given object
         * @param {org.jbox2d.collision.AABB} aabb the object to copy from
         * @return {org.jbox2d.collision.AABB}
         */
        public set(aabb : AABB) : AABB {
            this.lowerBound.set$org_jbox2d_common_Vec2(aabb.lowerBound);
            this.upperBound.set$org_jbox2d_common_Vec2(aabb.upperBound);
            return this;
        }

        /**
         * Verify that the bounds are sorted
         * @return {boolean}
         */
        public isValid() : boolean {
            let dx : number = (<any>Math).fround(this.upperBound.x - this.lowerBound.x);
            let dy : number = (<any>Math).fround(this.upperBound.y - this.lowerBound.y);
            if(!(dx >= 0.0 && dy >= 0)) {
                return false;
            }
            return this.lowerBound.isValid() && this.upperBound.isValid();
        }

        /**
         * Check if AABBs overlap. djm optimized
         * @param {org.jbox2d.collision.AABB} box
         * @return {boolean}
         */
        public testOverlap(box : AABB) : boolean {
            let d1x : number = (<any>Math).fround(box.lowerBound.x - this.upperBound.x);
            let d1y : number = (<any>Math).fround(box.lowerBound.y - this.upperBound.y);
            let d2x : number = (<any>Math).fround(this.lowerBound.x - box.upperBound.x);
            let d2y : number = (<any>Math).fround(this.lowerBound.y - box.upperBound.y);
            if(d1x > 0.0 || d1y > 0.0 || d2x > 0.0 || d2y > 0.0) {
                return false;
            }
            return true;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let s : string = "" + this.lowerBound + " -> " + this.upperBound;
            return s;
        }
    }
    AABB["__class"] = "org.jbox2d.collision.AABB";

}
namespace org.jbox2d.collision {
    /**
     * Used in BroadPhase
     * @param {org.jbox2d.collision.Bound} b
     * @class
     */
    export class Bound {
        public value : number;

        public proxyId : number;

        public stabbingCount : number;

        public constructor(b? : any) {
            if(((b != null && b instanceof <any>org.jbox2d.collision.Bound) || b === null)) {
                let __args = arguments;
                if(this.value===undefined) this.value = 0;
                if(this.proxyId===undefined) this.proxyId = 0;
                if(this.stabbingCount===undefined) this.stabbingCount = 0;
                if(this.value===undefined) this.value = 0;
                if(this.proxyId===undefined) this.proxyId = 0;
                if(this.stabbingCount===undefined) this.stabbingCount = 0;
                (() => {
                    this.value = b.value;
                    this.proxyId = b.proxyId;
                    this.stabbingCount = b.stabbingCount;
                })();
            } else if(b === undefined) {
                let __args = arguments;
                if(this.value===undefined) this.value = 0;
                if(this.proxyId===undefined) this.proxyId = 0;
                if(this.stabbingCount===undefined) this.stabbingCount = 0;
                if(this.value===undefined) this.value = 0;
                if(this.proxyId===undefined) this.proxyId = 0;
                if(this.stabbingCount===undefined) this.stabbingCount = 0;
                (() => {
                    this.value = 0;
                    this.proxyId = 0;
                    this.stabbingCount = 0;
                })();
            } else throw new Error('invalid overload');
        }

        public set(b : Bound) {
            this.setValueInternal(b.value);
            this.proxyId = b.proxyId;
            this.stabbingCount = b.stabbingCount;
        }

        public setValueInternal(val : number) {
            this.value = val;
        }

        public isLower() : boolean {
            return (this.value & 1) === 0;
        }

        public isUpper() : boolean {
            return (this.value & 1) === 1;
        }

        /**
         * swaps the values of this bound with the other bound
         * @param {org.jbox2d.collision.Bound} other bound to swap values with
         */
        public swap(other : Bound) {
            let value : number = this.value;
            let proxyId : number = this.proxyId;
            let stabbingCount : number = this.stabbingCount;
            this.setValueInternal(other.value);
            this.proxyId = other.proxyId;
            this.stabbingCount = other.stabbingCount;
            other.setValueInternal(value);
            other.proxyId = proxyId;
            other.stabbingCount = stabbingCount;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let ret : string = "Bound variable:\n";
            ret += "value: " + this.value + "\n";
            ret += "proxyId: " + this.proxyId + "\n";
            ret += "stabbing count: " + this.stabbingCount + "\n";
            return ret;
        }
    }
    Bound["__class"] = "org.jbox2d.collision.Bound";

}
namespace org.jbox2d.collision {
    export class BoundValues {
        public lowerValues : number[];

        public upperValues : number[];

        public constructor() {
            if(this.lowerValues===undefined) this.lowerValues = null;
            if(this.upperValues===undefined) this.upperValues = null;
            this.lowerValues = [null, null];
            this.upperValues = [null, null];
        }
    }
    BoundValues["__class"] = "org.jbox2d.collision.BoundValues";

}
namespace org.jbox2d.collision {
    /**
     * Used in pair manager.
     * @class
     */
    export class BufferedPair {
        proxyId1 : number;

        proxyId2 : number;

        /*private*/ equals(other : BufferedPair) : boolean {
            return this.proxyId1 === other.proxyId1 && this.proxyId2 === other.proxyId2;
        }

        /*private*/ minor(other : BufferedPair) : boolean {
            if(this.proxyId1 < other.proxyId1) return true;
            if(this.proxyId1 === other.proxyId1) {
                return this.proxyId2 < other.proxyId2;
            }
            return false;
        }

        public compareTo(p : BufferedPair) : number {
            if(this.minor(p)) {
                return -1;
            } else if(this.equals(p)) {
                return 0;
            } else {
                return 1;
            }
        }

        constructor() {
            if(this.proxyId1===undefined) this.proxyId1 = 0;
            if(this.proxyId2===undefined) this.proxyId2 = 0;
        }
    }
    BufferedPair["__class"] = "org.jbox2d.collision.BufferedPair";
    BufferedPair["__interfaces"] = ["java.lang.Comparable"];


}
namespace org.jbox2d.collision {
    /**
     * A few static final variables that don't fit anywhere else (globals in C++ code).
     * @class
     */
    export class Collision {
        public static NULL_FEATURE : number; public static NULL_FEATURE_$LI$() : number { if(Collision.NULL_FEATURE == null) Collision.NULL_FEATURE = 2147483647; return Collision.NULL_FEATURE; };
    }
    Collision["__class"] = "org.jbox2d.collision.Collision";

}
namespace org.jbox2d.collision {
    /**
     * Contact ids to facilitate warm starting.
     * @param {org.jbox2d.collision.ContactID} c
     * @class
     */
    export class ContactID {
        /**
         * Inactive in Java port (used for quick compares in C++ as part of a union)
         */
        public key : number;

        /**
         * The features that intersect to form the contact point
         */
        public features : ContactID.Features;

        public isEqual(cid : ContactID) : boolean {
            return cid.features.isEqual(this.features);
        }

        /**
         * zeros out the data
         */
        public zero() {
            this.key = 0;
            this.features.flip = 0;
            this.features.incidentEdge = 0;
            this.features.incidentVertex = 0;
            this.features.referenceEdge = 0;
        }

        public constructor(c? : any) {
            if(((c != null && c instanceof <any>org.jbox2d.collision.ContactID) || c === null)) {
                let __args = arguments;
                if(this.key===undefined) this.key = 0;
                if(this.features===undefined) this.features = null;
                if(this.key===undefined) this.key = 0;
                if(this.features===undefined) this.features = null;
                (() => {
                    this.key = c.key;
                    this.features = new ContactID.Features(this, c.features);
                })();
            } else if(c === undefined) {
                let __args = arguments;
                if(this.key===undefined) this.key = 0;
                if(this.features===undefined) this.features = null;
                if(this.key===undefined) this.key = 0;
                if(this.features===undefined) this.features = null;
                (() => {
                    this.key = 0;
                    this.features = new ContactID.Features(this);
                })();
            } else throw new Error('invalid overload');
        }

        public set(c : ContactID) {
            this.key = c.key;
            this.features.set(c.features);
        }
    }
    ContactID["__class"] = "org.jbox2d.collision.ContactID";


    export namespace ContactID {

        /**
         * The features that intersect to form the contact point
         * @param {org.jbox2d.collision.ContactID.Features} f
         * @class
         */
        export class Features {
            public __parent: any;
            /**
             * The edge that defines the outward contact normal.
             */
            public referenceEdge : number;

            /**
             * The edge most anti-parallel to the reference edge.
             */
            public incidentEdge : number;

            /**
             * The vertex (0 or 1) on the incident edge that was clipped.
             */
            public incidentVertex : number;

            /**
             * A value of 1 indicates that the reference edge is on shape2.
             */
            public flip : number;

            public constructor(__parent: any, f? : any) {
                if(((f != null && f instanceof <any>org.jbox2d.collision.ContactID.Features) || f === null)) {
                    let __args = Array.prototype.slice.call(arguments, [1]);
                    if(this.referenceEdge===undefined) this.referenceEdge = 0;
                    if(this.incidentEdge===undefined) this.incidentEdge = 0;
                    if(this.incidentVertex===undefined) this.incidentVertex = 0;
                    if(this.flip===undefined) this.flip = 0;
                    this.__parent = __parent;
                    if(this.referenceEdge===undefined) this.referenceEdge = 0;
                    if(this.incidentEdge===undefined) this.incidentEdge = 0;
                    if(this.incidentVertex===undefined) this.incidentVertex = 0;
                    if(this.flip===undefined) this.flip = 0;
                    (() => {
                        this.referenceEdge = f.referenceEdge;
                        this.incidentEdge = f.incidentEdge;
                        this.incidentVertex = f.incidentVertex;
                        this.flip = f.flip;
                    })();
                } else if(f === undefined) {
                    let __args = Array.prototype.slice.call(arguments, [1]);
                    if(this.referenceEdge===undefined) this.referenceEdge = 0;
                    if(this.incidentEdge===undefined) this.incidentEdge = 0;
                    if(this.incidentVertex===undefined) this.incidentVertex = 0;
                    if(this.flip===undefined) this.flip = 0;
                    this.__parent = __parent;
                    if(this.referenceEdge===undefined) this.referenceEdge = 0;
                    if(this.incidentEdge===undefined) this.incidentEdge = 0;
                    if(this.incidentVertex===undefined) this.incidentVertex = 0;
                    if(this.flip===undefined) this.flip = 0;
                    (() => {
                        this.referenceEdge = this.incidentEdge = this.incidentVertex = this.flip = 0;
                    })();
                } else throw new Error('invalid overload');
            }

            public set(f : ContactID.Features) {
                this.referenceEdge = f.referenceEdge;
                this.incidentEdge = f.incidentEdge;
                this.incidentVertex = f.incidentVertex;
                this.flip = f.flip;
            }

            public isEqual(f : ContactID.Features) : boolean {
                return (this.referenceEdge === f.referenceEdge && this.incidentEdge === f.incidentEdge && this.incidentVertex === f.incidentVertex && this.flip === f.flip);
            }

            /**
             * 
             * @return {string}
             */
            public toString() : string {
                let s : string = "Features: (" + this.flip + " ," + this.incidentEdge + " ," + this.incidentVertex + " ," + this.referenceEdge + ")";
                return s;
            }
        }
        Features["__class"] = "org.jbox2d.collision.ContactID.Features";

    }

}
namespace org.jbox2d.collision {
    /**
     * Implements the GJK algorithm for computing distance between shapes.
     * @class
     */
    export class Distance {
        public g_GJK_Iterations : number = 0;

        /*private*/ p1s : org.jbox2d.common.Vec2[] = [null, null, null];

        /*private*/ p2s : org.jbox2d.common.Vec2[] = [null, null, null];

        /*private*/ points : org.jbox2d.common.Vec2[] = [null, null, null];

        /*private*/ v : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ vNeg : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ w : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ w1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ w2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public constructor() {
            for(let i : number = 0; i < 3; ++i) {{
                this.p1s[i] = new org.jbox2d.common.Vec2();
                this.p2s[i] = new org.jbox2d.common.Vec2();
                this.points[i] = new org.jbox2d.common.Vec2();
            };}
        }

        /*private*/ p2r : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ p2d : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        ProcessTwo(x1 : org.jbox2d.common.Vec2, x2 : org.jbox2d.common.Vec2, p1s : org.jbox2d.common.Vec2[], p2s : org.jbox2d.common.Vec2[], points : org.jbox2d.common.Vec2[]) : number {
            this.p2r.x = -points[1].x;
            this.p2r.y = -points[1].y;
            this.p2d.x = (<any>Math).fround(points[0].x - points[1].x);
            this.p2d.y = (<any>Math).fround(points[0].y - points[1].y);
            let length : number = this.p2d.normalize();
            let lambda : number = org.jbox2d.common.Vec2.dot(this.p2r, this.p2d);
            if(lambda <= 0.0 || length < org.jbox2d.common.Settings.EPSILON) {
                x1.set$org_jbox2d_common_Vec2(p1s[1]);
                x2.set$org_jbox2d_common_Vec2(p2s[1]);
                p1s[0].set$org_jbox2d_common_Vec2(p1s[1]);
                p2s[0].set$org_jbox2d_common_Vec2(p2s[1]);
                points[0].set$org_jbox2d_common_Vec2(points[1]);
                return 1;
            }
            lambda /= length;
            x1.set$float$float((<any>Math).fround(p1s[1].x + (<any>Math).fround(lambda * ((<any>Math).fround(p1s[0].x - p1s[1].x)))), (<any>Math).fround(p1s[1].y + (<any>Math).fround(lambda * ((<any>Math).fround(p1s[0].y - p1s[1].y)))));
            x2.set$float$float((<any>Math).fround(p2s[1].x + (<any>Math).fround(lambda * ((<any>Math).fround(p2s[0].x - p2s[1].x)))), (<any>Math).fround(p2s[1].y + (<any>Math).fround(lambda * ((<any>Math).fround(p2s[0].y - p2s[1].y)))));
            return 2;
        }

        ProcessThree(x1 : org.jbox2d.common.Vec2, x2 : org.jbox2d.common.Vec2, p1s : org.jbox2d.common.Vec2[], p2s : org.jbox2d.common.Vec2[], points : org.jbox2d.common.Vec2[]) : number {
            let a : org.jbox2d.common.Vec2 = points[0];
            let b : org.jbox2d.common.Vec2 = points[1];
            let c : org.jbox2d.common.Vec2 = points[2];
            let abx : number = (<any>Math).fround(b.x - a.x);
            let aby : number = (<any>Math).fround(b.y - a.y);
            let acx : number = (<any>Math).fround(c.x - a.x);
            let acy : number = (<any>Math).fround(c.y - a.y);
            let bcx : number = (<any>Math).fround(c.x - b.x);
            let bcy : number = (<any>Math).fround(c.y - b.y);
            let sn : number = -((<any>Math).fround((<any>Math).fround(a.x * abx) + (<any>Math).fround(a.y * aby)));
            let sd : number = (<any>Math).fround((<any>Math).fround(b.x * abx) + (<any>Math).fround(b.y * aby));
            let tn : number = -((<any>Math).fround((<any>Math).fround(a.x * acx) + (<any>Math).fround(a.y * acy)));
            let td : number = (<any>Math).fround((<any>Math).fround(c.x * acx) + (<any>Math).fround(c.y * acy));
            let un : number = -((<any>Math).fround((<any>Math).fround(b.x * bcx) + (<any>Math).fround(b.y * bcy)));
            let ud : number = (<any>Math).fround((<any>Math).fround(c.x * bcx) + (<any>Math).fround(c.y * bcy));
            if(td <= 0.0 && ud <= 0.0) {
                x1.set$org_jbox2d_common_Vec2(p1s[2]);
                x2.set$org_jbox2d_common_Vec2(p2s[2]);
                p1s[0].set$org_jbox2d_common_Vec2(p1s[2]);
                p2s[0].set$org_jbox2d_common_Vec2(p2s[2]);
                points[0].set$org_jbox2d_common_Vec2(points[2]);
                return 1;
            }
            if(!(sn > 0.0 || tn > 0.0)) throw new Error("Assertion error line 82: assert sn > 0.0F || tn > 0.0F;");;
            if(!(sd > 0.0 || un > 0.0)) throw new Error("Assertion error line 83: assert sd > 0.0F || un > 0.0F;");;
            let n : number = (<any>Math).fround((<any>Math).fround(abx * acy) - (<any>Math).fround(aby * acx));
            let vc : number = (<any>Math).fround(n * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, b));
            if(!(vc > 0.0 || sn > 0.0 || sd > 0.0)) throw new Error("Assertion error line 86: assert vc > 0.0F || sn > 0.0F || sd > 0.0F;");;
            let va : number = (<any>Math).fround(n * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b, c));
            if(va <= 0.0 && un >= 0.0 && ud >= 0.0 && (<any>Math).fround(un + ud) > 0.0) {
                if(!((<any>Math).fround(un + ud) > 0.0)) throw new Error("Assertion error line 89: assert un + ud > 0.0F;");;
                let lambda : number = (<any>Math).fround(un / ((<any>Math).fround(un + ud)));
                x1.set$float$float((<any>Math).fround(p1s[1].x + (<any>Math).fround(lambda * ((<any>Math).fround(p1s[2].x - p1s[1].x)))), (<any>Math).fround(p1s[1].y + (<any>Math).fround(lambda * ((<any>Math).fround(p1s[2].y - p1s[1].y)))));
                x2.set$float$float((<any>Math).fround(p2s[1].x + (<any>Math).fround(lambda * ((<any>Math).fround(p2s[2].x - p2s[1].x)))), (<any>Math).fround(p2s[1].y + (<any>Math).fround(lambda * ((<any>Math).fround(p2s[2].y - p2s[1].y)))));
                p1s[0].set$org_jbox2d_common_Vec2(p1s[2]);
                p2s[0].set$org_jbox2d_common_Vec2(p2s[2]);
                points[0].set$org_jbox2d_common_Vec2(points[2]);
                return 2;
            }
            let vb : number = (<any>Math).fround(n * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(c, a));
            if(vb <= 0.0 && tn >= 0.0 && td >= 0.0 && (<any>Math).fround(tn + td) > 0.0) {
                if(!((<any>Math).fround(tn + td) > 0.0)) throw new Error("Assertion error line 100: assert tn + td > 0.0F;");;
                let lambda : number = (<any>Math).fround(tn / ((<any>Math).fround(tn + td)));
                x1.set$float$float((<any>Math).fround(p1s[0].x + (<any>Math).fround(lambda * ((<any>Math).fround(p1s[2].x - p1s[0].x)))), (<any>Math).fround(p1s[0].y + (<any>Math).fround(lambda * ((<any>Math).fround(p1s[2].y - p1s[0].y)))));
                x2.set$float$float((<any>Math).fround(p2s[0].x + (<any>Math).fround(lambda * ((<any>Math).fround(p2s[2].x - p2s[0].x)))), (<any>Math).fround(p2s[0].y + (<any>Math).fround(lambda * ((<any>Math).fround(p2s[2].y - p2s[0].y)))));
                p1s[1].set$org_jbox2d_common_Vec2(p1s[2]);
                p2s[1].set$org_jbox2d_common_Vec2(p2s[2]);
                points[1].set$org_jbox2d_common_Vec2(points[2]);
                return 2;
            }
            let denom : number = (<any>Math).fround((<any>Math).fround(va + vb) + vc);
            if(!(denom > 0.0)) throw new Error("Assertion error line 110: assert denom > 0.0F;");;
            denom = (<any>Math).fround(1.0 / denom);
            let u : number = (<any>Math).fround(va * denom);
            let v : number = (<any>Math).fround(vb * denom);
            let w : number = (<any>Math).fround((<any>Math).fround(1.0 - u) - v);
            x1.set$float$float((<any>Math).fround((<any>Math).fround((<any>Math).fround(u * p1s[0].x) + (<any>Math).fround(v * p1s[1].x)) + (<any>Math).fround(w * p1s[2].x)), (<any>Math).fround((<any>Math).fround((<any>Math).fround(u * p1s[0].y) + (<any>Math).fround(v * p1s[1].y)) + (<any>Math).fround(w * p1s[2].y)));
            x2.set$float$float((<any>Math).fround((<any>Math).fround((<any>Math).fround(u * p2s[0].x) + (<any>Math).fround(v * p2s[1].x)) + (<any>Math).fround(w * p2s[2].x)), (<any>Math).fround((<any>Math).fround((<any>Math).fround(u * p2s[0].y) + (<any>Math).fround(v * p2s[1].y)) + (<any>Math).fround(w * p2s[2].y)));
            return 3;
        }

        public InPoints(w : org.jbox2d.common.Vec2, points : org.jbox2d.common.Vec2[], pointCount : number) : boolean {
            let k_tolerance : number = (<any>Math).fround(100.0 * org.jbox2d.common.Settings.EPSILON);
            for(let i : number = 0; i < pointCount; ++i) {{
                let v : org.jbox2d.common.Vec2 = points[i];
                let dx : number = org.jbox2d.common.MathUtils.abs((<any>Math).fround(w.x - v.x));
                let dy : number = org.jbox2d.common.MathUtils.abs((<any>Math).fround(w.y - v.y));
                let mx : number = org.jbox2d.common.MathUtils.max$float$float(org.jbox2d.common.MathUtils.abs(w.x), org.jbox2d.common.MathUtils.abs(points[i].x));
                let my : number = org.jbox2d.common.MathUtils.max$float$float(org.jbox2d.common.MathUtils.abs(w.y), org.jbox2d.common.MathUtils.abs(points[i].y));
                if(dx < (<any>Math).fround(k_tolerance * ((<any>Math).fround(mx + 1.0))) && dy < (<any>Math).fround(k_tolerance * ((<any>Math).fround(my + 1.0)))) {
                    return true;
                }
            };}
            return false;
        }

        /**
         * Distance between any two objects that implement SupportsGeneric Note that
         * x1 and x2 are passed so that they may store results - they must be
         * instantiated before being passed, and the contents will be lost.
         * 
         * @param {org.jbox2d.common.Vec2} x1
         * Set to closest point on shape1 (result parameter)
         * @param {org.jbox2d.common.Vec2} x2
         * Set to closest point on shape2 (result parameter)
         * @param {*} shape1
         * Shape to test
         * @param {org.jbox2d.common.XForm} xf1
         * Transform of shape1
         * @param {*} shape2
         * Shape to test
         * @param {org.jbox2d.common.XForm} xf2
         * Transform of shape2
         * @return {number} the distance
         */
        public DistanceGeneric(x1 : org.jbox2d.common.Vec2, x2 : org.jbox2d.common.Vec2, shape1 : org.jbox2d.collision.SupportsGenericDistance, xf1 : org.jbox2d.common.XForm, shape2 : org.jbox2d.collision.SupportsGenericDistance, xf2 : org.jbox2d.common.XForm) : number {
            let pointCount : number = 0;
            shape1.getFirstVertexToOut(xf1, x1);
            shape2.getFirstVertexToOut(xf2, x2);
            let vSqr : number = 0.0;
            let maxIterations : number = 20;
            for(let iter : number = 0; iter < maxIterations; ++iter) {{
                this.v.set$float$float((<any>Math).fround(x2.x - x1.x), (<any>Math).fround(x2.y - x1.y));
                shape1.support(this.w1, xf1, this.v);
                this.vNeg.set$float$float(-this.v.x, -this.v.y);
                shape2.support(this.w2, xf2, this.vNeg);
                vSqr = org.jbox2d.common.Vec2.dot(this.v, this.v);
                this.w.set$float$float((<any>Math).fround(this.w2.x - this.w1.x), (<any>Math).fround(this.w2.y - this.w1.y));
                let vw : number = org.jbox2d.common.Vec2.dot(this.v, this.w);
                if((<any>Math).fround(vSqr - vw) <= (<any>Math).fround(0.01 * vSqr) || this.InPoints(this.w, this.points, pointCount)) {
                    if(pointCount === 0) {
                        x1.set$org_jbox2d_common_Vec2(this.w1);
                        x2.set$org_jbox2d_common_Vec2(this.w2);
                    }
                    this.g_GJK_Iterations = iter;
                    return org.jbox2d.common.MathUtils.sqrt(vSqr);
                }
                switch((pointCount)) {
                case 0:
                    this.p1s[0].set$org_jbox2d_common_Vec2(this.w1);
                    this.p2s[0].set$org_jbox2d_common_Vec2(this.w2);
                    this.points[0].set$org_jbox2d_common_Vec2(this.w);
                    x1.set$org_jbox2d_common_Vec2(this.p1s[0]);
                    x2.set$org_jbox2d_common_Vec2(this.p2s[0]);
                    ++pointCount;
                    break;
                case 1:
                    this.p1s[1].set$org_jbox2d_common_Vec2(this.w1);
                    this.p2s[1].set$org_jbox2d_common_Vec2(this.w2);
                    this.points[1].set$org_jbox2d_common_Vec2(this.w);
                    pointCount = this.ProcessTwo(x1, x2, this.p1s, this.p2s, this.points);
                    break;
                case 2:
                    this.p1s[2].set$org_jbox2d_common_Vec2(this.w1);
                    this.p2s[2].set$org_jbox2d_common_Vec2(this.w2);
                    this.points[2].set$org_jbox2d_common_Vec2(this.w);
                    pointCount = this.ProcessThree(x1, x2, this.p1s, this.p2s, this.points);
                    break;
                }
                if(pointCount === 3) {
                    this.g_GJK_Iterations = iter;
                    return 0.0;
                }
                let maxSqr : number = -3.4028235E38;
                for(let i : number = 0; i < pointCount; ++i) {{
                    maxSqr = org.jbox2d.common.MathUtils.max$float$float(maxSqr, org.jbox2d.common.Vec2.dot(this.points[i], this.points[i]));
                };}
                if(pointCount === 3 || vSqr <= (<any>Math).fround((<any>Math).fround(100.0 * org.jbox2d.common.Settings.EPSILON) * maxSqr)) {
                    this.g_GJK_Iterations = iter;
                    let vx : number = (<any>Math).fround(x2.x - x1.x);
                    let vy : number = (<any>Math).fround(x2.y - x1.y);
                    vSqr = (<any>Math).fround((<any>Math).fround(vx * vx) + (<any>Math).fround(vy * vy));
                    return org.jbox2d.common.MathUtils.sqrt(vSqr);
                }
            };}
            this.g_GJK_Iterations = maxIterations;
            return org.jbox2d.common.MathUtils.sqrt(vSqr);
        }

        /*private*/ distCCp1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ distCCp2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ distCCd : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * distance between two circle shapes
         * 
         * @param {org.jbox2d.common.Vec2} x1
         * Closest point on shape1 is put here (result parameter)
         * @param {org.jbox2d.common.Vec2} x2
         * Closest point on shape2 is put here (result parameter)
         * @param {org.jbox2d.collision.shapes.CircleShape} circle1
         * @param {org.jbox2d.common.XForm} xf1
         * Transform of first shape
         * @param {org.jbox2d.collision.shapes.CircleShape} circle2
         * @param {org.jbox2d.common.XForm} xf2
         * Transform of second shape
         * @return {number} the distance
         */
        public DistanceCC(x1 : org.jbox2d.common.Vec2, x2 : org.jbox2d.common.Vec2, circle1 : org.jbox2d.collision.shapes.CircleShape, xf1 : org.jbox2d.common.XForm, circle2 : org.jbox2d.collision.shapes.CircleShape, xf2 : org.jbox2d.common.XForm) : number {
            org.jbox2d.common.XForm.mulToOut(xf1, circle1.getMemberLocalPosition(), this.distCCp1);
            org.jbox2d.common.XForm.mulToOut(xf2, circle2.getMemberLocalPosition(), this.distCCp2);
            this.distCCd.x = (<any>Math).fround(this.distCCp2.x - this.distCCp1.x);
            this.distCCd.y = (<any>Math).fround(this.distCCp2.y - this.distCCp1.y);
            let dSqr : number = org.jbox2d.common.Vec2.dot(this.distCCd, this.distCCd);
            let r1 : number = (<any>Math).fround(circle1.getRadius() - org.jbox2d.common.Settings.toiSlop_$LI$());
            let r2 : number = (<any>Math).fround(circle2.getRadius() - org.jbox2d.common.Settings.toiSlop_$LI$());
            let r : number = (<any>Math).fround(r1 + r2);
            if(dSqr > (<any>Math).fround(r * r)) {
                let dLen : number = this.distCCd.normalize();
                let distance : number = (<any>Math).fround(dLen - r);
                x1.set$float$float((<any>Math).fround(this.distCCp1.x + (<any>Math).fround(r1 * this.distCCd.x)), (<any>Math).fround(this.distCCp1.y + (<any>Math).fround(r1 * this.distCCd.y)));
                x2.set$float$float((<any>Math).fround(this.distCCp2.x - (<any>Math).fround(r2 * this.distCCd.x)), (<any>Math).fround(this.distCCp2.y - (<any>Math).fround(r2 * this.distCCd.y)));
                return distance;
            } else if(dSqr > (<any>Math).fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON)) {
                this.distCCd.normalize();
                x1.set$float$float((<any>Math).fround(this.distCCp1.x + (<any>Math).fround(r1 * this.distCCd.x)), (<any>Math).fround(this.distCCp1.y + (<any>Math).fround(r1 * this.distCCd.y)));
                x2.set$org_jbox2d_common_Vec2(x1);
                return 0.0;
            }
            x1.set$org_jbox2d_common_Vec2(this.distCCp1);
            x2.set$org_jbox2d_common_Vec2(x1);
            return 0.0;
        }

        /*private*/ cWorld : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ ECcLocal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ ECvWorld : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ ECd : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ ECtemp : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * Distance bewteen an edge and a circle
         * 
         * @param {org.jbox2d.common.Vec2} x1
         * Closest point on shape1 is put here (result parameter)
         * @param {org.jbox2d.common.Vec2} x2
         * Closest point on shape2 is put here (result parameter)
         * @param {org.jbox2d.collision.shapes.EdgeShape} edge
         * @param {org.jbox2d.common.XForm} xf1
         * xform of edge
         * @param {org.jbox2d.collision.shapes.CircleShape} circle
         * @param {org.jbox2d.common.XForm} xf2
         * xform of circle
         * @return {number} the distance
         */
        public DistanceEdgeCircle(x1 : org.jbox2d.common.Vec2, x2 : org.jbox2d.common.Vec2, edge : org.jbox2d.collision.shapes.EdgeShape, xf1 : org.jbox2d.common.XForm, circle : org.jbox2d.collision.shapes.CircleShape, xf2 : org.jbox2d.common.XForm) : number {
            let dSqr : number;
            let dLen : number;
            let r : number = (<any>Math).fround(circle.getRadius() - org.jbox2d.common.Settings.toiSlop_$LI$());
            org.jbox2d.common.XForm.mulToOut(xf2, circle.getMemberLocalPosition(), this.cWorld);
            org.jbox2d.common.XForm.mulTransToOut(xf1, this.cWorld, this.ECcLocal);
            let dirDist : number = org.jbox2d.common.Vec2.dot(this.ECcLocal.sub(edge.getCoreVertex1()), edge.getDirectionVector());
            if(dirDist <= 0.0) {
                org.jbox2d.common.XForm.mulToOut(xf1, edge.getCoreVertex1(), this.ECvWorld);
            } else if(dirDist >= edge.getLength()) {
                org.jbox2d.common.XForm.mulToOut(xf1, edge.getCoreVertex2(), this.ECvWorld);
            } else {
                x1.set$org_jbox2d_common_Vec2(edge.getDirectionVector());
                x1.mulLocal(dirDist).addLocal$org_jbox2d_common_Vec2(edge.getCoreVertex1());
                org.jbox2d.common.XForm.mulToOut(xf1, x1, x1);
                this.ECtemp.set$org_jbox2d_common_Vec2(this.ECcLocal);
                this.ECtemp.subLocal(edge.getCoreVertex1());
                dLen = org.jbox2d.common.Vec2.dot(this.ECtemp, edge.getNormalVector());
                if(dLen < 0.0) {
                    if(dLen < -r) {
                        x2.set$org_jbox2d_common_Vec2(edge.getNormalVector());
                        x2.mulLocal(r).addLocal$org_jbox2d_common_Vec2(this.ECcLocal);
                        org.jbox2d.common.XForm.mulToOut(xf1, x2, x2);
                        return (<any>Math).fround(-dLen - r);
                    } else {
                        x2.set$org_jbox2d_common_Vec2(x1);
                        return 0.0;
                    }
                } else {
                    if(dLen > r) {
                        x2.set$org_jbox2d_common_Vec2(edge.getNormalVector());
                        x2.mulLocal(r).subLocal(this.ECcLocal).negateLocal();
                        org.jbox2d.common.XForm.mulToOut(xf1, x2, x2);
                        return (<any>Math).fround(dLen - r);
                    } else {
                        x2.set$org_jbox2d_common_Vec2(x1);
                        return 0.0;
                    }
                }
            }
            x1.set$org_jbox2d_common_Vec2(this.ECvWorld);
            this.ECd.set$org_jbox2d_common_Vec2(this.cWorld);
            this.ECd.subLocal(this.ECvWorld);
            dSqr = org.jbox2d.common.Vec2.dot(this.ECd, this.ECd);
            if(dSqr > (<any>Math).fround(r * r)) {
                dLen = this.ECd.normalize();
                x2.set$org_jbox2d_common_Vec2(this.ECd);
                x2.mulLocal(r).subLocal(this.cWorld).negateLocal();
                return (<any>Math).fround(dLen - r);
            } else {
                x2.set$org_jbox2d_common_Vec2(this.ECvWorld);
                return 0.0;
            }
        }

        /*private*/ point : org.jbox2d.collision.Point = new org.jbox2d.collision.Point();

        /**
         * Distance between a polygon and a circle
         * 
         * @param {org.jbox2d.common.Vec2} x1
         * Closest point on shape1 is put here (result parameter)
         * @param {org.jbox2d.common.Vec2} x2
         * Closest point on shape2 is put here (result parameter)
         * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
         * @param {org.jbox2d.common.XForm} xf1
         * xform of polygon
         * @param {org.jbox2d.collision.shapes.CircleShape} circle
         * @param {org.jbox2d.common.XForm} xf2
         * xform of circle
         * @return {number} the distance
         */
        public DistancePC(x1 : org.jbox2d.common.Vec2, x2 : org.jbox2d.common.Vec2, polygon : org.jbox2d.collision.shapes.PolygonShape, xf1 : org.jbox2d.common.XForm, circle : org.jbox2d.collision.shapes.CircleShape, xf2 : org.jbox2d.common.XForm) : number {
            this.point.p.set$float$float((<any>Math).fround((<any>Math).fround(xf2.position.x + (<any>Math).fround(xf2.R.col1.x * circle.m_localPosition.x)) + (<any>Math).fround(xf2.R.col2.x * circle.m_localPosition.y)), (<any>Math).fround((<any>Math).fround(xf2.position.y + (<any>Math).fround(xf2.R.col1.y * circle.m_localPosition.x)) + (<any>Math).fround(xf2.R.col2.y * circle.m_localPosition.y)));
            let distance : number = this.DistanceGeneric(x1, x2, polygon, xf1, this.point, org.jbox2d.common.XForm.identity_$LI$());
            let r : number = (<any>Math).fround(circle.getRadius() - org.jbox2d.common.Settings.toiSlop_$LI$());
            if(distance > r) {
                distance -= r;
                let dx : number = (<any>Math).fround(x2.x - x1.x);
                let dy : number = (<any>Math).fround(x2.y - x1.y);
                let length : number = org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy)));
                if(length >= org.jbox2d.common.Settings.EPSILON) {
                    let invLength : number = (<any>Math).fround(1.0 / length);
                    dx *= invLength;
                    dy *= invLength;
                }
                x2.x -= (<any>Math).fround(r * dx);
                x2.y -= (<any>Math).fround(r * dy);
            } else {
                distance = 0.0;
                x2.set$org_jbox2d_common_Vec2(x1);
            }
            return distance;
        }

        /**
         * Distance between a polygon and a point
         * 
         * @param {org.jbox2d.common.Vec2} x1
         * Closest point on shape1 is put here (result parameter)
         * @param {org.jbox2d.common.Vec2} x2
         * Closest point on shape2 is put here (result parameter)
         * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
         * @param {org.jbox2d.common.XForm} xf1
         * xform of polygon
         * @param {org.jbox2d.collision.shapes.PointShape} pt
         * @param {org.jbox2d.common.XForm} xf2
         * xform of point
         * @return {number} the distance
         */
        public DistancePolygonPoint(x1 : org.jbox2d.common.Vec2, x2 : org.jbox2d.common.Vec2, polygon : org.jbox2d.collision.shapes.PolygonShape, xf1 : org.jbox2d.common.XForm, pt : org.jbox2d.collision.shapes.PointShape, xf2 : org.jbox2d.common.XForm) : number {
            this.point.p.set$float$float((<any>Math).fround((<any>Math).fround(xf2.position.x + (<any>Math).fround(xf2.R.col1.x * pt.m_localPosition.x)) + (<any>Math).fround(xf2.R.col2.x * pt.m_localPosition.y)), (<any>Math).fround((<any>Math).fround(xf2.position.y + (<any>Math).fround(xf2.R.col1.y * pt.m_localPosition.x)) + (<any>Math).fround(xf2.R.col2.y * pt.m_localPosition.y)));
            let distance : number = this.DistanceGeneric(x1, x2, polygon, xf1, this.point, org.jbox2d.common.XForm.identity_$LI$());
            let r : number = -org.jbox2d.common.Settings.toiSlop_$LI$();
            if(distance > r) {
                distance -= r;
                let dx : number = (<any>Math).fround(x2.x - x1.x);
                let dy : number = (<any>Math).fround(x2.y - x1.y);
                let length : number = org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy)));
                if(length >= org.jbox2d.common.Settings.EPSILON) {
                    let invLength : number = (<any>Math).fround(1.0 / length);
                    dx *= invLength;
                    dy *= invLength;
                }
                x2.x -= (<any>Math).fround(r * dx);
                x2.y -= (<any>Math).fround(r * dy);
            } else {
                distance = 0.0;
                x2.set$org_jbox2d_common_Vec2(x1);
            }
            return distance;
        }

        /*private*/ CPp1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ CPp2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ CPd : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * Distance between a circle and a point
         * 
         * @param {org.jbox2d.common.Vec2} x1
         * Closest point on shape1 is put here (result parameter)
         * @param {org.jbox2d.common.Vec2} x2
         * Closest point on shape2 is put here (result parameter)
         * @param {org.jbox2d.collision.shapes.CircleShape} circle1
         * @param {org.jbox2d.common.XForm} xf1
         * xform of circle
         * @param {org.jbox2d.collision.shapes.PointShape} pt2
         * @param {org.jbox2d.common.XForm} xf2
         * xform of point
         * @return {number} the distance
         */
        public DistanceCirclePoint(x1 : org.jbox2d.common.Vec2, x2 : org.jbox2d.common.Vec2, circle1 : org.jbox2d.collision.shapes.CircleShape, xf1 : org.jbox2d.common.XForm, pt2 : org.jbox2d.collision.shapes.PointShape, xf2 : org.jbox2d.common.XForm) : number {
            org.jbox2d.common.XForm.mulToOut(xf1, circle1.getMemberLocalPosition(), this.CPp1);
            org.jbox2d.common.XForm.mulToOut(xf2, pt2.getMemberLocalPosition(), this.CPp2);
            this.CPd.x = (<any>Math).fround(this.CPp2.x - this.CPp1.x);
            this.CPd.y = (<any>Math).fround(this.CPp2.y - this.CPp1.y);
            let dSqr : number = org.jbox2d.common.Vec2.dot(this.CPd, this.CPd);
            let r1 : number = (<any>Math).fround(circle1.getRadius() - org.jbox2d.common.Settings.toiSlop_$LI$());
            let r2 : number = -org.jbox2d.common.Settings.toiSlop_$LI$();
            let r : number = (<any>Math).fround(r1 + r2);
            if(dSqr > (<any>Math).fround(r * r)) {
                let dLen : number = this.CPd.normalize();
                let distance : number = (<any>Math).fround(dLen - r);
                x1.set$float$float((<any>Math).fround(this.CPp1.x + (<any>Math).fround(r1 * this.CPd.x)), (<any>Math).fround(this.CPp1.y + (<any>Math).fround(r1 * this.CPd.y)));
                x2.set$float$float((<any>Math).fround(this.CPp2.x - (<any>Math).fround(r2 * this.CPd.x)), (<any>Math).fround(this.CPp2.y - (<any>Math).fround(r2 * this.CPd.y)));
                return distance;
            } else if(dSqr > (<any>Math).fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON)) {
                this.CPd.normalize();
                x1.set$float$float((<any>Math).fround(this.CPp1.x + (<any>Math).fround(r1 * this.CPd.x)), (<any>Math).fround(this.CPp1.y + (<any>Math).fround(r1 * this.CPd.y)));
                x2.set$org_jbox2d_common_Vec2(x1);
                return 0.0;
            }
            x1.set$org_jbox2d_common_Vec2(this.CPp1);
            x2.set$org_jbox2d_common_Vec2(x1);
            return 0.0;
        }

        /**
         * Find the closest distance between shapes shape1 and shape2, and load the
         * closest points into x1 and x2. Note that x1 and x2 are passed so that
         * they may store results - they must be instantiated before being passed,
         * and the contents will be lost.
         * 
         * @param {org.jbox2d.common.Vec2} x1
         * Closest point on shape1 is put here (result parameter)
         * @param {org.jbox2d.common.Vec2} x2
         * Closest point on shape2 is put here (result parameter)
         * @param {org.jbox2d.collision.shapes.Shape} shape1
         * First shape to test
         * @param {org.jbox2d.common.XForm} xf1
         * Transform of first shape
         * @param {org.jbox2d.collision.shapes.Shape} shape2
         * Second shape to test
         * @param {org.jbox2d.common.XForm} xf2
         * Transform of second shape
         * @return {number} the distance
         */
        public distance(x1 : org.jbox2d.common.Vec2, x2 : org.jbox2d.common.Vec2, shape1 : org.jbox2d.collision.shapes.Shape, xf1 : org.jbox2d.common.XForm, shape2 : org.jbox2d.collision.shapes.Shape, xf2 : org.jbox2d.common.XForm) : number {
            let type1 : org.jbox2d.collision.shapes.ShapeType = shape1.getType();
            let type2 : org.jbox2d.collision.shapes.ShapeType = shape2.getType();
            if(type1 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                return this.DistanceCC(x1, x2, <org.jbox2d.collision.shapes.CircleShape>shape1, xf1, <org.jbox2d.collision.shapes.CircleShape>shape2, xf2);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                return this.DistancePC(x1, x2, <org.jbox2d.collision.shapes.PolygonShape>shape1, xf1, <org.jbox2d.collision.shapes.CircleShape>shape2, xf2);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                return this.DistancePC(x2, x1, <org.jbox2d.collision.shapes.PolygonShape>shape2, xf2, <org.jbox2d.collision.shapes.CircleShape>shape1, xf1);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                return this.DistanceGeneric(x1, x2, <org.jbox2d.collision.shapes.PolygonShape>shape1, xf1, <org.jbox2d.collision.shapes.PolygonShape>shape2, xf2);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                return this.DistanceEdgeCircle(x1, x2, <org.jbox2d.collision.shapes.EdgeShape>shape1, xf1, <org.jbox2d.collision.shapes.CircleShape>shape2, xf2);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE) {
                return this.DistanceEdgeCircle(x2, x1, <org.jbox2d.collision.shapes.EdgeShape>shape2, xf2, <org.jbox2d.collision.shapes.CircleShape>shape1, xf1);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE) {
                return this.DistanceGeneric(x2, x1, <org.jbox2d.collision.shapes.EdgeShape>shape2, xf2, <org.jbox2d.collision.shapes.PolygonShape>shape1, xf1);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                return this.DistanceGeneric(x1, x2, <org.jbox2d.collision.shapes.EdgeShape>shape1, xf1, <org.jbox2d.collision.shapes.PolygonShape>shape2, xf2);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE) {
                return 3.4028235E38;
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                return this.DistanceCirclePoint(x2, x1, <org.jbox2d.collision.shapes.CircleShape>shape2, xf2, <org.jbox2d.collision.shapes.PointShape>shape1, xf1);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE) {
                return this.DistanceCirclePoint(x1, x2, <org.jbox2d.collision.shapes.CircleShape>shape1, xf1, <org.jbox2d.collision.shapes.PointShape>shape2, xf2);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                return this.DistancePolygonPoint(x2, x1, <org.jbox2d.collision.shapes.PolygonShape>shape2, xf2, <org.jbox2d.collision.shapes.PointShape>shape1, xf1);
            } else if(type1 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE) {
                return this.DistancePolygonPoint(x1, x2, <org.jbox2d.collision.shapes.PolygonShape>shape1, xf1, <org.jbox2d.collision.shapes.PointShape>shape2, xf2);
            }
            return 0.0;
        }
    }
    Distance["__class"] = "org.jbox2d.collision.Distance";


    export class Point implements org.jbox2d.collision.SupportsGenericDistance {
        public p : org.jbox2d.common.Vec2;

        public constructor(_p? : any) {
            if(((_p != null && _p instanceof <any>org.jbox2d.common.Vec2) || _p === null)) {
                let __args = arguments;
                if(this.p===undefined) this.p = null;
                if(this.p===undefined) this.p = null;
                (() => {
                    this.p = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_p);
                })();
            } else if(_p === undefined) {
                let __args = arguments;
                if(this.p===undefined) this.p = null;
                if(this.p===undefined) this.p = null;
                (() => {
                    this.p = new org.jbox2d.common.Vec2();
                })();
            } else throw new Error('invalid overload');
        }

        public support(dest : org.jbox2d.common.Vec2, xf : org.jbox2d.common.XForm, v : org.jbox2d.common.Vec2) {
            dest.set$org_jbox2d_common_Vec2(this.p);
        }

        public getFirstVertexToOut(xf : org.jbox2d.common.XForm, out : org.jbox2d.common.Vec2) {
            out.set$org_jbox2d_common_Vec2(this.p);
        }
    }
    Point["__class"] = "org.jbox2d.collision.Point";
    Point["__interfaces"] = ["org.jbox2d.collision.SupportsGenericDistance"];


}
namespace org.jbox2d.collision {
    /**
     * This holds contact filtering data.
     * @class
     */
    export class FilterData {
        /**
         * The collision category bits. Normally you would just set one bit.
         */
        public categoryBits : number;

        /**
         * The collision mask bits. This states the categories that this
         * shape would accept for collision.
         */
        public maskBits : number;

        /**
         * Collision groups allow a certain group of objects to never collide (negative)
         * or always collide (positive). Zero means no collision group. Non-zero group
         * filtering always wins against the mask bits.
         */
        public groupIndex : number;

        public set(fd : FilterData) {
            this.categoryBits = fd.categoryBits;
            this.maskBits = fd.maskBits;
            this.groupIndex = fd.groupIndex;
        }

        constructor() {
            if(this.categoryBits===undefined) this.categoryBits = 0;
            if(this.maskBits===undefined) this.maskBits = 0;
            if(this.groupIndex===undefined) this.groupIndex = 0;
        }
    }
    FilterData["__class"] = "org.jbox2d.collision.FilterData";

}
namespace org.jbox2d.collision {
    /**
     * Creates this manifold as a copy of the other
     * @param {org.jbox2d.collision.Manifold} other
     * @class
     */
    export class Manifold {
        /**
         * The points of contact.
         */
        public points : org.jbox2d.collision.ManifoldPoint[];

        /**
         * The shared unit normal vector.
         */
        public normal : org.jbox2d.common.Vec2;

        /**
         * The number of manifold points.
         */
        public pointCount : number;

        public constructor(other? : any) {
            if(((other != null && other instanceof <any>org.jbox2d.collision.Manifold) || other === null)) {
                let __args = arguments;
                if(this.points===undefined) this.points = null;
                if(this.normal===undefined) this.normal = null;
                if(this.pointCount===undefined) this.pointCount = 0;
                if(this.points===undefined) this.points = null;
                if(this.normal===undefined) this.normal = null;
                if(this.pointCount===undefined) this.pointCount = 0;
                (() => {
                    this.points = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);
                    this.normal = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(other.normal);
                    this.pointCount = other.pointCount;
                    for(let i : number = 0; i < other.points.length; i++) {{
                        this.points[i] = new org.jbox2d.collision.ManifoldPoint(other.points[i]);
                    };}
                })();
            } else if(other === undefined) {
                let __args = arguments;
                if(this.points===undefined) this.points = null;
                if(this.normal===undefined) this.normal = null;
                if(this.pointCount===undefined) this.pointCount = 0;
                if(this.points===undefined) this.points = null;
                if(this.normal===undefined) this.normal = null;
                if(this.pointCount===undefined) this.pointCount = 0;
                (() => {
                    this.points = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);
                    for(let i : number = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; i++) {{
                        this.points[i] = new org.jbox2d.collision.ManifoldPoint();
                    };}
                    this.normal = new org.jbox2d.common.Vec2();
                    this.pointCount = 0;
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * copies this manifold from the given one
         * @param {org.jbox2d.collision.Manifold} cp manifold to copy from
         * @return {org.jbox2d.collision.Manifold}
         */
        public set(cp : Manifold) : Manifold {
            for(let i : number = 0; i < cp.pointCount; i++) {{
                this.points[i].set(cp.points[i]);
            };}
            this.normal.set$org_jbox2d_common_Vec2(cp.normal);
            this.pointCount = cp.pointCount;
            return this;
        }
    }
    Manifold["__class"] = "org.jbox2d.collision.Manifold";

}
namespace org.jbox2d.collision {
    /**
     * Creates a manifold point as a copy of the given point
     * @param {org.jbox2d.collision.ManifoldPoint} cp point to copy from
     * @class
     */
    export class ManifoldPoint {
        /**
         * Local position of the contact point in body1
         */
        public localPoint1 : org.jbox2d.common.Vec2;

        /**
         * Local position of the contact point in body2
         */
        public localPoint2 : org.jbox2d.common.Vec2;

        /**
         * The separation of the shapes along the normal vector
         */
        public separation : number;

        /**
         * The non-penetration force
         */
        public normalImpulse : number;

        /**
         * The friction force
         */
        public tangentImpulse : number;

        /**
         * Uniquely identifies a contact point between two shapes
         */
        public id : org.jbox2d.collision.ContactID;

        public constructor(cp? : any) {
            if(((cp != null && cp instanceof <any>org.jbox2d.collision.ManifoldPoint) || cp === null)) {
                let __args = arguments;
                if(this.localPoint1===undefined) this.localPoint1 = null;
                if(this.localPoint2===undefined) this.localPoint2 = null;
                if(this.separation===undefined) this.separation = 0;
                if(this.normalImpulse===undefined) this.normalImpulse = 0;
                if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
                if(this.id===undefined) this.id = null;
                if(this.localPoint1===undefined) this.localPoint1 = null;
                if(this.localPoint2===undefined) this.localPoint2 = null;
                if(this.separation===undefined) this.separation = 0;
                if(this.normalImpulse===undefined) this.normalImpulse = 0;
                if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
                if(this.id===undefined) this.id = null;
                (() => {
                    this.localPoint1 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(cp.localPoint1);
                    this.localPoint2 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(cp.localPoint2);
                    this.separation = cp.separation;
                    this.normalImpulse = cp.normalImpulse;
                    this.tangentImpulse = cp.tangentImpulse;
                    this.id = new org.jbox2d.collision.ContactID(cp.id);
                })();
            } else if(cp === undefined) {
                let __args = arguments;
                if(this.localPoint1===undefined) this.localPoint1 = null;
                if(this.localPoint2===undefined) this.localPoint2 = null;
                if(this.separation===undefined) this.separation = 0;
                if(this.normalImpulse===undefined) this.normalImpulse = 0;
                if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
                if(this.id===undefined) this.id = null;
                if(this.localPoint1===undefined) this.localPoint1 = null;
                if(this.localPoint2===undefined) this.localPoint2 = null;
                if(this.separation===undefined) this.separation = 0;
                if(this.normalImpulse===undefined) this.normalImpulse = 0;
                if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
                if(this.id===undefined) this.id = null;
                (() => {
                    this.localPoint1 = new org.jbox2d.common.Vec2();
                    this.localPoint2 = new org.jbox2d.common.Vec2();
                    this.separation = this.normalImpulse = this.tangentImpulse = 0.0;
                    this.id = new org.jbox2d.collision.ContactID();
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * Sets this manifold point form the given one
         * @param {org.jbox2d.collision.ManifoldPoint} cp the point to copy from
         */
        public set(cp : ManifoldPoint) {
            this.localPoint1.set$org_jbox2d_common_Vec2(cp.localPoint1);
            this.localPoint2.set$org_jbox2d_common_Vec2(cp.localPoint2);
            this.separation = cp.separation;
            this.normalImpulse = cp.normalImpulse;
            this.tangentImpulse = cp.tangentImpulse;
            this.id.set(cp.id);
        }
    }
    ManifoldPoint["__class"] = "org.jbox2d.collision.ManifoldPoint";

}
namespace org.jbox2d.collision {
    /**
     * Copies from the given mass data
     * @param {org.jbox2d.collision.MassData} md mass data to copy from
     * @class
     */
    export class MassData {
        /**
         * The mass of the shape, usually in kilograms.
         */
        public mass : number;

        /**
         * The position of the shape's centroid relative to the shape's origin.
         */
        public center : org.jbox2d.common.Vec2;

        /**
         * The rotational inertia of the shape.
         */
        public I : number;

        public set(argOther : MassData) : MassData {
            this.mass = argOther.mass;
            this.center.set$org_jbox2d_common_Vec2(argOther.center);
            this.I = argOther.I;
            return this;
        }

        public constructor(md? : any) {
            if(((md != null && md instanceof <any>org.jbox2d.collision.MassData) || md === null)) {
                let __args = arguments;
                if(this.mass===undefined) this.mass = 0;
                if(this.center===undefined) this.center = null;
                if(this.I===undefined) this.I = 0;
                if(this.mass===undefined) this.mass = 0;
                if(this.center===undefined) this.center = null;
                if(this.I===undefined) this.I = 0;
                (() => {
                    this.mass = md.mass;
                    this.I = md.I;
                    this.center = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(md.center);
                })();
            } else if(md === undefined) {
                let __args = arguments;
                if(this.mass===undefined) this.mass = 0;
                if(this.center===undefined) this.center = null;
                if(this.I===undefined) this.I = 0;
                if(this.mass===undefined) this.mass = 0;
                if(this.center===undefined) this.center = null;
                if(this.I===undefined) this.I = 0;
                (() => {
                    this.mass = this.I = 0.0;
                    this.center = new org.jbox2d.common.Vec2();
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * Return a copy of this object.
         * @return {org.jbox2d.collision.MassData}
         */
        public clone() : MassData {
            return new MassData(this);
        }
    }
    MassData["__class"] = "org.jbox2d.collision.MassData";

}
namespace org.jbox2d.collision {
    /**
     * creates OBB with the given data.  The arguments are cloned
     * before being placed in the object
     * @param {org.jbox2d.common.Mat22} _R
     * @param {org.jbox2d.common.Vec2} _center
     * @param {org.jbox2d.common.Vec2} _extents
     * @class
     */
    export class OBB {
        /**
         * The rotation matrix.
         */
        public R : org.jbox2d.common.Mat22;

        /**
         * The local centroid.
         */
        public center : org.jbox2d.common.Vec2;

        /**
         * The half-widths.
         */
        public extents : org.jbox2d.common.Vec2;

        public constructor(_R? : any, _center? : any, _extents? : any) {
            if(((_R != null && _R instanceof <any>org.jbox2d.common.Mat22) || _R === null) && ((_center != null && _center instanceof <any>org.jbox2d.common.Vec2) || _center === null) && ((_extents != null && _extents instanceof <any>org.jbox2d.common.Vec2) || _extents === null)) {
                let __args = arguments;
                if(this.R===undefined) this.R = null;
                if(this.center===undefined) this.center = null;
                if(this.extents===undefined) this.extents = null;
                if(this.R===undefined) this.R = null;
                if(this.center===undefined) this.center = null;
                if(this.extents===undefined) this.extents = null;
                (() => {
                    this.R = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_R);
                    this.center = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_center);
                    this.extents = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_extents);
                })();
            } else if(((_R != null && _R instanceof <any>org.jbox2d.collision.OBB) || _R === null) && _center === undefined && _extents === undefined) {
                let __args = arguments;
                let copy : any = __args[0];
                {
                    let __args = arguments;
                    let _R : any = copy.R;
                    let _center : any = copy.center;
                    let _extents : any = copy.extents;
                    if(this.R===undefined) this.R = null;
                    if(this.center===undefined) this.center = null;
                    if(this.extents===undefined) this.extents = null;
                    if(this.R===undefined) this.R = null;
                    if(this.center===undefined) this.center = null;
                    if(this.extents===undefined) this.extents = null;
                    (() => {
                        this.R = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_R);
                        this.center = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_center);
                        this.extents = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_extents);
                    })();
                }
            } else if(_R === undefined && _center === undefined && _extents === undefined) {
                let __args = arguments;
                if(this.R===undefined) this.R = null;
                if(this.center===undefined) this.center = null;
                if(this.extents===undefined) this.extents = null;
                if(this.R===undefined) this.R = null;
                if(this.center===undefined) this.center = null;
                if(this.extents===undefined) this.extents = null;
                (() => {
                    this.R = new org.jbox2d.common.Mat22();
                    this.center = new org.jbox2d.common.Vec2();
                    this.extents = new org.jbox2d.common.Vec2();
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * @return {org.jbox2d.collision.OBB} a copy
         */
        public clone() : OBB {
            return new OBB(this);
        }
    }
    OBB["__class"] = "org.jbox2d.collision.OBB";

}
namespace org.jbox2d.collision {
    /**
     * Copy constructor
     * @param {org.jbox2d.collision.Pair} other
     * @class
     */
    export class Pair {
        static PAIR_BUFFERED : number = 1;

        static PAIR_REMOVED : number = 2;

        static PAIR_FINAL : number = 4;

        public userData : any;

        public proxyId1 : number;

        public proxyId2 : number;

        public status : number;

        public next : number;

        public constructor(other? : any) {
            if(((other != null && other instanceof <any>org.jbox2d.collision.Pair) || other === null)) {
                let __args = arguments;
                if(this.userData===undefined) this.userData = null;
                if(this.proxyId1===undefined) this.proxyId1 = 0;
                if(this.proxyId2===undefined) this.proxyId2 = 0;
                if(this.status===undefined) this.status = 0;
                if(this.next===undefined) this.next = 0;
                if(this.userData===undefined) this.userData = null;
                if(this.proxyId1===undefined) this.proxyId1 = 0;
                if(this.proxyId2===undefined) this.proxyId2 = 0;
                if(this.status===undefined) this.status = 0;
                if(this.next===undefined) this.next = 0;
                (() => {
                    this.userData = other.userData;
                    this.proxyId1 = other.proxyId1;
                    this.proxyId2 = other.proxyId2;
                    this.status = other.status;
                })();
            } else if(other === undefined) {
                let __args = arguments;
                if(this.userData===undefined) this.userData = null;
                if(this.proxyId1===undefined) this.proxyId1 = 0;
                if(this.proxyId2===undefined) this.proxyId2 = 0;
                if(this.status===undefined) this.status = 0;
                if(this.next===undefined) this.next = 0;
                if(this.userData===undefined) this.userData = null;
                if(this.proxyId1===undefined) this.proxyId1 = 0;
                if(this.proxyId2===undefined) this.proxyId2 = 0;
                if(this.status===undefined) this.status = 0;
                if(this.next===undefined) this.next = 0;
            } else throw new Error('invalid overload');
        }

        public setBuffered() {
            this.status |= Pair.PAIR_BUFFERED;
        }

        public clearBuffered() {
            this.status &= ~Pair.PAIR_BUFFERED;
        }

        public isBuffered() : boolean {
            return (this.status & Pair.PAIR_BUFFERED) === Pair.PAIR_BUFFERED;
        }

        public clearRemoved() {
            this.status &= ~Pair.PAIR_REMOVED;
        }

        public setRemoved() {
            this.status |= Pair.PAIR_REMOVED;
        }

        public isRemoved() : boolean {
            return (this.status & Pair.PAIR_REMOVED) === Pair.PAIR_REMOVED;
        }

        public setFinal() {
            this.status |= Pair.PAIR_FINAL;
        }

        public isFinal() : boolean {
            return (this.status & Pair.PAIR_FINAL) === Pair.PAIR_FINAL;
        }

        public compareTo(p : Pair) : number {
            return this.proxyId1 - p.proxyId1;
        }
    }
    Pair["__class"] = "org.jbox2d.collision.Pair";
    Pair["__interfaces"] = ["java.lang.Comparable"];


}
namespace org.jbox2d.collision {
    export interface PairCallback {
        /**
         * This should return the new pair user data. It is okay if the
         * user data is null.
         * @param {*} proxyUserData1
         * @param {*} proxyUserData2
         * @return {*}
         */
        pairAdded(proxyUserData1 : any, proxyUserData2 : any) : any;

        /**
         * This should free the pair's user data. In extreme circumstances, it is
         * possible this will be called with null pairUserData because the pair never
         * existed.
         * @param {*} proxyUserData1
         * @param {*} proxyUserData2
         * @param {*} pairUserData
         */
        pairRemoved(proxyUserData1 : any, proxyUserData2 : any, pairUserData : any);
    }
}
namespace org.jbox2d.collision {
    export class Proxy {
        public lowerBounds : number[];

        public upperBounds : number[];

        overlapCount : number;

        timeStamp : number;

        categoryBits : number;

        maskBits : number;

        groupIndex : number;

        userData : any;

        public constructor() {
            if(this.lowerBounds===undefined) this.lowerBounds = null;
            if(this.upperBounds===undefined) this.upperBounds = null;
            if(this.overlapCount===undefined) this.overlapCount = 0;
            if(this.timeStamp===undefined) this.timeStamp = 0;
            if(this.categoryBits===undefined) this.categoryBits = 0;
            if(this.maskBits===undefined) this.maskBits = 0;
            if(this.groupIndex===undefined) this.groupIndex = 0;
            if(this.userData===undefined) this.userData = null;
            this.lowerBounds = [0, 0];
            this.upperBounds = [0, 0];
            this.lowerBounds[0] = this.lowerBounds[1] = 0;
            this.upperBounds[0] = this.upperBounds[1] = 0;
            this.overlapCount = org.jbox2d.collision.BroadPhase.INVALID_$LI$();
            this.timeStamp = 0;
        }

        getNext() : number {
            return this.lowerBounds[0];
        }

        setNext(next : number) {
            this.lowerBounds[0] = next;
        }

        public isValid() : boolean {
            return this.overlapCount !== org.jbox2d.collision.BroadPhase.INVALID_$LI$();
        }
    }
    Proxy["__class"] = "org.jbox2d.collision.Proxy";

}
namespace org.jbox2d.collision {
    export enum SegmentCollide {
        STARTS_INSIDE_COLLIDE, MISS_COLLIDE, HIT_COLLIDE
    }
}
namespace org.jbox2d.collision.shapes {
    /**
     * Circle/circle and circle/polygon overlap solver -
     * for internal use only.
     * @class
     */
    export class CollideCircle {
        /*private*/ colCCP1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colCCP2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colCCD : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colCCP : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * puts collision information of the two circles in the manifold
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.collision.shapes.CircleShape} circle1
         * @param {org.jbox2d.common.XForm} xf1
         * @param {org.jbox2d.collision.shapes.CircleShape} circle2
         * @param {org.jbox2d.common.XForm} xf2
         */
        public collideCircles(manifold : org.jbox2d.collision.Manifold, circle1 : org.jbox2d.collision.shapes.CircleShape, xf1 : org.jbox2d.common.XForm, circle2 : org.jbox2d.collision.shapes.CircleShape, xf2 : org.jbox2d.common.XForm) {
            manifold.pointCount = 0;
            org.jbox2d.common.XForm.mulToOut(xf1, circle1.getMemberLocalPosition(), this.colCCP1);
            org.jbox2d.common.XForm.mulToOut(xf2, circle2.getMemberLocalPosition(), this.colCCP2);
            this.colCCD.x = (<any>Math).fround(this.colCCP2.x - this.colCCP1.x);
            this.colCCD.y = (<any>Math).fround(this.colCCP2.y - this.colCCP1.y);
            let distSqr : number = org.jbox2d.common.Vec2.dot(this.colCCD, this.colCCD);
            let r1 : number = circle1.getRadius();
            let r2 : number = circle2.getRadius();
            let radiusSum : number = (<any>Math).fround(r1 + r2);
            if(distSqr > (<any>Math).fround(radiusSum * radiusSum)) {
                return;
            }
            let separation : number;
            if(distSqr < org.jbox2d.common.Settings.EPSILON) {
                separation = -radiusSum;
                manifold.normal.set$float$float(0.0, 1.0);
            } else {
                let dist : number = org.jbox2d.common.MathUtils.sqrt(distSqr);
                separation = (<any>Math).fround(dist - radiusSum);
                let a : number = (<any>Math).fround(1.0 / dist);
                manifold.normal.x = (<any>Math).fround(a * this.colCCD.x);
                manifold.normal.y = (<any>Math).fround(a * this.colCCD.y);
            }
            manifold.pointCount = 1;
            manifold.points[0].id.zero();
            manifold.points[0].separation = separation;
            this.colCCP1.addLocal$org_jbox2d_common_Vec2(manifold.normal.mul(r1));
            this.colCCP2.subLocal(manifold.normal.mul(r2));
            this.colCCP.x = (<any>Math).fround(0.5 * ((<any>Math).fround(this.colCCP1.x + this.colCCP2.x)));
            this.colCCP.y = (<any>Math).fround(0.5 * ((<any>Math).fround(this.colCCP1.y + this.colCCP2.y)));
            org.jbox2d.common.XForm.mulTransToOut(xf1, this.colCCP, manifold.points[0].localPoint1);
            org.jbox2d.common.XForm.mulTransToOut(xf2, this.colCCP, manifold.points[0].localPoint2);
        }

        /*private*/ colPCP1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colPCP2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colPCD : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colPCP : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * Puts collision information in the manifold about a collision between a point and a circle
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.collision.shapes.PointShape} point1
         * @param {org.jbox2d.common.XForm} xf1
         * @param {org.jbox2d.collision.shapes.CircleShape} circle2
         * @param {org.jbox2d.common.XForm} xf2
         */
        public collidePointAndCircle(manifold : org.jbox2d.collision.Manifold, point1 : org.jbox2d.collision.shapes.PointShape, xf1 : org.jbox2d.common.XForm, circle2 : org.jbox2d.collision.shapes.CircleShape, xf2 : org.jbox2d.common.XForm) {
            manifold.pointCount = 0;
            org.jbox2d.common.XForm.mulToOut(xf1, point1.getMemberLocalPosition(), this.colPCP1);
            org.jbox2d.common.XForm.mulToOut(xf2, circle2.getMemberLocalPosition(), this.colPCP2);
            this.colPCD.x = (<any>Math).fround(this.colPCP2.x - this.colPCP1.x);
            this.colPCD.y = (<any>Math).fround(this.colPCP2.y - this.colPCP1.y);
            let distSqr : number = org.jbox2d.common.Vec2.dot(this.colPCD, this.colPCD);
            let r2 : number = circle2.getRadius();
            if(distSqr > (<any>Math).fround(r2 * r2)) {
                return;
            }
            let separation : number;
            if(distSqr < org.jbox2d.common.Settings.EPSILON) {
                separation = -r2;
                manifold.normal.set$float$float(0.0, 1.0);
            } else {
                let dist : number = org.jbox2d.common.MathUtils.sqrt(distSqr);
                separation = (<any>Math).fround(dist - r2);
                let a : number = (<any>Math).fround(1.0 / dist);
                manifold.normal.x = (<any>Math).fround(a * this.colPCD.x);
                manifold.normal.y = (<any>Math).fround(a * this.colPCD.y);
            }
            manifold.pointCount = 1;
            manifold.points[0].id.zero();
            manifold.points[0].separation = separation;
            this.colPCP2.subLocal(manifold.normal.mul(r2));
            this.colPCP.x = (<any>Math).fround(0.5 * ((<any>Math).fround(this.colPCP1.x + this.colPCP2.x)));
            this.colPCP.y = (<any>Math).fround(0.5 * ((<any>Math).fround(this.colPCP1.y + this.colPCP2.y)));
            org.jbox2d.common.XForm.mulTransToOut(xf1, this.colPCP, manifold.points[0].localPoint1);
            org.jbox2d.common.XForm.mulTransToOut(xf2, this.colPCP, manifold.points[0].localPoint2);
        }

        /**
         * puts collision information about the collision of a polygon and a circle
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
         * @param {org.jbox2d.common.XForm} xf1
         * @param {org.jbox2d.collision.shapes.CircleShape} circle
         * @param {org.jbox2d.common.XForm} xf2
         */
        public collidePolygonAndCircle(manifold : org.jbox2d.collision.Manifold, polygon : org.jbox2d.collision.shapes.PolygonShape, xf1 : org.jbox2d.common.XForm, circle : org.jbox2d.collision.shapes.CircleShape, xf2 : org.jbox2d.common.XForm) {
            manifold.pointCount = 0;
            let cx : number = (<any>Math).fround((<any>Math).fround(xf2.position.x + (<any>Math).fround(xf2.R.col1.x * circle.m_localPosition.x)) + (<any>Math).fround(xf2.R.col2.x * circle.m_localPosition.y));
            let cy : number = (<any>Math).fround((<any>Math).fround(xf2.position.y + (<any>Math).fround(xf2.R.col1.y * circle.m_localPosition.x)) + (<any>Math).fround(xf2.R.col2.y * circle.m_localPosition.y));
            let v1x : number = (<any>Math).fround(cx - xf1.position.x);
            let v1y : number = (<any>Math).fround(cy - xf1.position.y);
            let cLocalx : number = (<any>Math).fround((<any>Math).fround(v1x * xf1.R.col1.x) + (<any>Math).fround(v1y * xf1.R.col1.y));
            let cLocaly : number = (<any>Math).fround((<any>Math).fround(v1x * xf1.R.col2.x) + (<any>Math).fround(v1y * xf1.R.col2.y));
            let normalIndex : number = 0;
            let separation : number = -3.4028235E38;
            let radius : number = circle.getRadius();
            let vertexCount : number = polygon.getVertexCount();
            let vertices : org.jbox2d.common.Vec2[] = polygon.getVertices();
            let normals : org.jbox2d.common.Vec2[] = polygon.getNormals();
            for(let i : number = 0; i < vertexCount; ++i) {{
                let s : number = (<any>Math).fround((<any>Math).fround(normals[i].x * ((<any>Math).fround(cLocalx - vertices[i].x))) + (<any>Math).fround(normals[i].y * ((<any>Math).fround(cLocaly - vertices[i].y))));
                if(s > circle.m_radius) {
                    return;
                }
                if(s > separation) {
                    normalIndex = i;
                    separation = s;
                }
            };}
            if(separation < org.jbox2d.common.Settings.EPSILON) {
                manifold.pointCount = 1;
                manifold.normal.x = (<any>Math).fround((<any>Math).fround(xf1.R.col1.x * normals[normalIndex].x) + (<any>Math).fround(xf1.R.col2.x * normals[normalIndex].y));
                manifold.normal.y = (<any>Math).fround((<any>Math).fround(xf1.R.col1.y * normals[normalIndex].x) + (<any>Math).fround(xf1.R.col2.y * normals[normalIndex].y));
                manifold.points[0].id.features.incidentEdge = normalIndex;
                manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                manifold.points[0].id.features.referenceEdge = 0;
                manifold.points[0].id.features.flip = 0;
                let positionx : number = (<any>Math).fround(cx - (<any>Math).fround(manifold.normal.x * radius));
                let positiony : number = (<any>Math).fround(cy - (<any>Math).fround(manifold.normal.y * radius));
                let v1x1 : number = (<any>Math).fround(positionx - xf1.position.x);
                let v1y1 : number = (<any>Math).fround(positiony - xf1.position.y);
                manifold.points[0].localPoint1.x = ((<any>Math).fround((<any>Math).fround(v1x1 * xf1.R.col1.x) + (<any>Math).fround(v1y1 * xf1.R.col1.y)));
                manifold.points[0].localPoint1.y = ((<any>Math).fround((<any>Math).fround(v1x1 * xf1.R.col2.x) + (<any>Math).fround(v1y1 * xf1.R.col2.y)));
                let v1x2 : number = (<any>Math).fround(positionx - xf2.position.x);
                let v1y2 : number = (<any>Math).fround(positiony - xf2.position.y);
                manifold.points[0].localPoint2.x = ((<any>Math).fround((<any>Math).fround(v1x2 * xf2.R.col1.x) + (<any>Math).fround(v1y2 * xf2.R.col1.y)));
                manifold.points[0].localPoint2.y = ((<any>Math).fround((<any>Math).fround(v1x2 * xf2.R.col2.x) + (<any>Math).fround(v1y2 * xf2.R.col2.y)));
                manifold.points[0].separation = (<any>Math).fround(separation - radius);
                return;
            }
            let vertIndex1 : number = normalIndex;
            let vertIndex2 : number = vertIndex1 + 1 < vertexCount?vertIndex1 + 1:0;
            let ex : number = (<any>Math).fround(vertices[vertIndex2].x - vertices[vertIndex1].x);
            let ey : number = (<any>Math).fround(vertices[vertIndex2].y - vertices[vertIndex1].y);
            let length : number = org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(ex * ex) + (<any>Math).fround(ey * ey)));
            if(!((length > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 165: assert (length > Settings.EPSILON);");;
            let invLength : number = (<any>Math).fround(1.0 / length);
            ex *= invLength;
            ey *= invLength;
            let u : number = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(cLocalx - vertices[vertIndex1].x)) * ex) + (<any>Math).fround(((<any>Math).fround(cLocaly - vertices[vertIndex1].y)) * ey));
            let px : number;
            let py : number;
            if(u <= 0.0) {
                px = vertices[vertIndex1].x;
                py = vertices[vertIndex1].y;
                manifold.points[0].id.features.incidentEdge = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                manifold.points[0].id.features.incidentVertex = vertIndex1;
            } else if(u >= length) {
                px = vertices[vertIndex2].x;
                py = vertices[vertIndex2].y;
                manifold.points[0].id.features.incidentEdge = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                manifold.points[0].id.features.incidentVertex = vertIndex2;
            } else {
                px = vertices[vertIndex1].x;
                py = vertices[vertIndex1].y;
                px += (<any>Math).fround(u * ex);
                py += (<any>Math).fround(u * ey);
                manifold.points[0].id.features.incidentEdge = normalIndex;
                manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
            }
            let dx : number = (<any>Math).fround(cLocalx - px);
            let dy : number = (<any>Math).fround(cLocaly - py);
            let dist : number = org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy)));
            if(dist > radius) {
                return;
            }
            if(dist >= org.jbox2d.common.Settings.EPSILON) {
                let invDist : number = (<any>Math).fround(1.0 / dist);
                dx *= invDist;
                dy *= invDist;
            }
            manifold.pointCount = 1;
            manifold.normal.x = (<any>Math).fround((<any>Math).fround(xf1.R.col1.x * dx) + (<any>Math).fround(xf1.R.col2.x * dy));
            manifold.normal.y = (<any>Math).fround((<any>Math).fround(xf1.R.col1.y * dx) + (<any>Math).fround(xf1.R.col2.y * dy));
            let positionx : number = (<any>Math).fround(cx - (<any>Math).fround(manifold.normal.x * radius));
            let positiony : number = (<any>Math).fround(cy - (<any>Math).fround(manifold.normal.y * radius));
            let v1x1 : number = (<any>Math).fround(positionx - xf1.position.x);
            let v1y1 : number = (<any>Math).fround(positiony - xf1.position.y);
            manifold.points[0].localPoint1.x = ((<any>Math).fround((<any>Math).fround(v1x1 * xf1.R.col1.x) + (<any>Math).fround(v1y1 * xf1.R.col1.y)));
            manifold.points[0].localPoint1.y = ((<any>Math).fround((<any>Math).fround(v1x1 * xf1.R.col2.x) + (<any>Math).fround(v1y1 * xf1.R.col2.y)));
            let v1x2 : number = (<any>Math).fround(positionx - xf2.position.x);
            let v1y2 : number = (<any>Math).fround(positiony - xf2.position.y);
            manifold.points[0].localPoint2.x = ((<any>Math).fround((<any>Math).fround(v1x2 * xf2.R.col1.x) + (<any>Math).fround(v1y2 * xf2.R.col1.y)));
            manifold.points[0].localPoint2.y = ((<any>Math).fround((<any>Math).fround(v1x2 * xf2.R.col2.x) + (<any>Math).fround(v1y2 * xf2.R.col2.y)));
            manifold.points[0].separation = (<any>Math).fround(dist - radius);
            manifold.points[0].id.features.referenceEdge = 0;
            manifold.points[0].id.features.flip = 0;
        }

        /*private*/ ECd : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ ECc : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ ECcLocal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * puts collision information into the manifold from a circle and edge collision
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.collision.shapes.EdgeShape} edge
         * @param {org.jbox2d.common.XForm} xf1
         * @param {org.jbox2d.collision.shapes.CircleShape} circle
         * @param {org.jbox2d.common.XForm} xf2
         */
        public collideEdgeAndCircle(manifold : org.jbox2d.collision.Manifold, edge : org.jbox2d.collision.shapes.EdgeShape, xf1 : org.jbox2d.common.XForm, circle : org.jbox2d.collision.shapes.CircleShape, xf2 : org.jbox2d.common.XForm) {
            manifold.pointCount = 0;
            org.jbox2d.common.XForm.mulToOut(xf2, circle.getMemberLocalPosition(), this.ECc);
            org.jbox2d.common.XForm.mulTransToOut(xf1, this.ECc, this.ECcLocal);
            let n : org.jbox2d.common.Vec2 = edge.getNormalVector();
            let v1 : org.jbox2d.common.Vec2 = edge.getVertex1();
            let v2 : org.jbox2d.common.Vec2 = edge.getVertex2();
            let radius : number = circle.getRadius();
            let separation : number;
            this.ECd.set$org_jbox2d_common_Vec2(this.ECcLocal);
            this.ECd.subLocal(v1);
            let dirDist : number = org.jbox2d.common.Vec2.dot(this.ECd, edge.getDirectionVector());
            if(dirDist <= 0) {
                if(org.jbox2d.common.Vec2.dot(this.ECd, edge.getCorner1Vector()) < 0) {
                    return;
                }
                org.jbox2d.common.XForm.mulToOut(xf1, v1, this.ECd);
                this.ECd.subLocal(this.ECc);
                this.ECd.negateLocal();
            } else if(dirDist >= edge.getLength()) {
                this.ECd.set$org_jbox2d_common_Vec2(this.ECcLocal);
                this.ECd.subLocal(v2);
                if(org.jbox2d.common.Vec2.dot(this.ECd, edge.getCorner2Vector()) > 0) {
                    return;
                }
                org.jbox2d.common.XForm.mulToOut(xf1, v2, this.ECd);
                this.ECd.subLocal(this.ECc);
                this.ECd.negateLocal();
            } else {
                separation = org.jbox2d.common.Vec2.dot(this.ECd, n);
                if(separation > radius || separation < -radius) {
                    return;
                }
                separation -= radius;
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, n, manifold.normal);
                manifold.pointCount = 1;
                manifold.points[0].id.zero();
                manifold.points[0].separation = separation;
                this.ECd.set$org_jbox2d_common_Vec2(manifold.normal);
                this.ECd.mulLocal(radius);
                this.ECc.subLocal(this.ECd);
                org.jbox2d.common.XForm.mulTransToOut(xf1, this.ECc, manifold.points[0].localPoint1);
                org.jbox2d.common.XForm.mulTransToOut(xf2, this.ECc, manifold.points[0].localPoint2);
                return;
            }
            let distSqr : number = org.jbox2d.common.Vec2.dot(this.ECd, this.ECd);
            if(distSqr > (<any>Math).fround(radius * radius)) {
                return;
            }
            if(distSqr < org.jbox2d.common.Settings.EPSILON) {
                separation = -radius;
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, n, manifold.normal);
            } else {
                separation = (<any>Math).fround(this.ECd.normalize() - radius);
                manifold.normal.set$org_jbox2d_common_Vec2(this.ECd);
            }
            manifold.pointCount = 1;
            manifold.points[0].id.zero();
            manifold.points[0].separation = separation;
            this.ECd.set$org_jbox2d_common_Vec2(manifold.normal);
            this.ECd.mulLocal(radius);
            this.ECc.subLocal(this.ECd);
            org.jbox2d.common.XForm.mulTransToOut(xf1, this.ECc, manifold.points[0].localPoint1);
            org.jbox2d.common.XForm.mulTransToOut(xf2, this.ECc, manifold.points[0].localPoint2);
        }
    }
    CollideCircle["__class"] = "org.jbox2d.collision.shapes.CollideCircle";

}
namespace org.jbox2d.collision.shapes {
    /**
     * Polygon overlap solver - for internal use.
     * @class
     */
    export class CollidePoly {
        public clipSegmentToLine(vOut : CollidePoly.ClipVertex[], vIn : CollidePoly.ClipVertex[], normal : org.jbox2d.common.Vec2, offset : number) : number {
            let numOut : number = 0;
            let distance0 : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(normal, vIn[0].v) - offset);
            let distance1 : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(normal, vIn[1].v) - offset);
            if(distance0 <= 0.0) {
                vOut[numOut] = new CollidePoly.ClipVertex();
                vOut[numOut].id.set(vIn[0].id);
                vOut[numOut++].v.set$org_jbox2d_common_Vec2(vIn[0].v);
            }
            if(distance1 <= 0.0) {
                vOut[numOut] = new CollidePoly.ClipVertex();
                vOut[numOut].id.set(vIn[1].id);
                vOut[numOut++].v.set$org_jbox2d_common_Vec2(vIn[1].v);
            }
            if((<any>Math).fround(distance0 * distance1) < 0.0) {
                let interp : number = (<any>Math).fround(distance0 / ((<any>Math).fround(distance0 - distance1)));
                vOut[numOut] = new CollidePoly.ClipVertex();
                vOut[numOut].v.x = (<any>Math).fround(vIn[0].v.x + (<any>Math).fround(interp * ((<any>Math).fround(vIn[1].v.x - vIn[0].v.x))));
                vOut[numOut].v.y = (<any>Math).fround(vIn[0].v.y + (<any>Math).fround(interp * ((<any>Math).fround(vIn[1].v.y - vIn[0].v.y))));
                if(distance0 > 0.0) {
                    vOut[numOut].id.set(vIn[0].id);
                } else {
                    vOut[numOut].id.set(vIn[1].id);
                }
                ++numOut;
            }
            return numOut;
        }

        /*private*/ normal1World : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public edgeSeparation(poly1 : org.jbox2d.collision.shapes.PolygonShape, xf1 : org.jbox2d.common.XForm, edge1 : number, poly2 : org.jbox2d.collision.shapes.PolygonShape, xf2 : org.jbox2d.common.XForm) : number {
            let count1 : number = poly1.getVertexCount();
            let vertices1 : org.jbox2d.common.Vec2[] = poly1.getVertices();
            let normals1 : org.jbox2d.common.Vec2[] = poly1.getNormals();
            let count2 : number = poly2.getVertexCount();
            let vertices2 : org.jbox2d.common.Vec2[] = poly2.getVertices();
            if(!((0 <= edge1 && edge1 < count1))) throw new Error("Assertion error line 44: assert (0 <= edge1 && edge1 < count1);");;
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, normals1[edge1], this.normal1World);
            let normal1x : number = org.jbox2d.common.Vec2.dot(this.normal1World, xf2.R.col1);
            let normal1y : number = org.jbox2d.common.Vec2.dot(this.normal1World, xf2.R.col2);
            let index : number = 0;
            let minDot : number = 3.4028235E38;
            for(let i : number = 0; i < count2; ++i) {{
                let dot : number = (<any>Math).fround((<any>Math).fround(vertices2[i].x * normal1x) + (<any>Math).fround(vertices2[i].y * normal1y));
                if(dot < minDot) {
                    minDot = dot;
                    index = i;
                }
            };}
            let v : org.jbox2d.common.Vec2 = vertices1[edge1];
            let v1x : number = (<any>Math).fround((<any>Math).fround(xf1.position.x + (<any>Math).fround(xf1.R.col1.x * v.x)) + (<any>Math).fround(xf1.R.col2.x * v.y));
            let v1y : number = (<any>Math).fround((<any>Math).fround(xf1.position.y + (<any>Math).fround(xf1.R.col1.y * v.x)) + (<any>Math).fround(xf1.R.col2.y * v.y));
            let v3 : org.jbox2d.common.Vec2 = vertices2[index];
            let v2x : number = (<any>Math).fround((<any>Math).fround(xf2.position.x + (<any>Math).fround(xf2.R.col1.x * v3.x)) + (<any>Math).fround(xf2.R.col2.x * v3.y));
            let v2y : number = (<any>Math).fround((<any>Math).fround(xf2.position.y + (<any>Math).fround(xf2.R.col1.y * v3.x)) + (<any>Math).fround(xf2.R.col2.y * v3.y));
            let separation : number = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(v2x - v1x)) * this.normal1World.x) + (<any>Math).fround(((<any>Math).fround(v2y - v1y)) * this.normal1World.y));
            return separation;
        }

        /*private*/ dLocal1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * Find the max separation between poly1 and poly2 using face normals
         * from poly1.
         * @param {org.jbox2d.collision.shapes.PolygonShape} poly1
         * @param {org.jbox2d.common.XForm} xf1
         * @param {org.jbox2d.collision.shapes.PolygonShape} poly2
         * @param {org.jbox2d.common.XForm} xf2
         * @return
         * @return {org.jbox2d.collision.shapes.MaxSeparation}
         */
        public findMaxSeparation(poly1 : org.jbox2d.collision.shapes.PolygonShape, xf1 : org.jbox2d.common.XForm, poly2 : org.jbox2d.collision.shapes.PolygonShape, xf2 : org.jbox2d.common.XForm) : org.jbox2d.collision.shapes.MaxSeparation {
            let separation : org.jbox2d.collision.shapes.MaxSeparation = new org.jbox2d.collision.shapes.MaxSeparation();
            let count1 : number = poly1.getVertexCount();
            let normals1 : org.jbox2d.common.Vec2[] = poly1.getNormals();
            let v : org.jbox2d.common.Vec2 = poly1.getCentroid();
            let v1 : org.jbox2d.common.Vec2 = poly2.getCentroid();
            let dx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(xf2.position.x + (<any>Math).fround(xf2.R.col1.x * v1.x)) + (<any>Math).fround(xf2.R.col2.x * v1.y)) - ((<any>Math).fround((<any>Math).fround(xf1.position.x + (<any>Math).fround(xf1.R.col1.x * v.x)) + (<any>Math).fround(xf1.R.col2.x * v.y))));
            let dy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(xf2.position.y + (<any>Math).fround(xf2.R.col1.y * v1.x)) + (<any>Math).fround(xf2.R.col2.y * v1.y)) - ((<any>Math).fround((<any>Math).fround(xf1.position.y + (<any>Math).fround(xf1.R.col1.y * v.x)) + (<any>Math).fround(xf1.R.col2.y * v.y))));
            let b : org.jbox2d.common.Vec2 = xf1.R.col1;
            let b1 : org.jbox2d.common.Vec2 = xf1.R.col2;
            this.dLocal1.x = ((<any>Math).fround((<any>Math).fround(dx * b.x) + (<any>Math).fround(dy * b.y)));
            this.dLocal1.y = ((<any>Math).fround((<any>Math).fround(dx * b1.x) + (<any>Math).fround(dy * b1.y)));
            let edge : number = 0;
            let maxDot : number = -3.4028235E38;
            for(let i : number = 0; i < count1; ++i) {{
                let dot : number = org.jbox2d.common.Vec2.dot(normals1[i], this.dLocal1);
                if(dot > maxDot) {
                    maxDot = dot;
                    edge = i;
                }
            };}
            let s : number = this.edgeSeparation(poly1, xf1, edge, poly2, xf2);
            if(s > 0.0) {
                separation.bestSeparation = s;
                return separation;
            }
            let prevEdge : number = edge - 1 >= 0?edge - 1:count1 - 1;
            let sPrev : number = this.edgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
            if(sPrev > 0.0) {
                separation.bestSeparation = sPrev;
                return separation;
            }
            let nextEdge : number = edge + 1 < count1?edge + 1:0;
            let sNext : number = this.edgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
            if(sNext > 0.0) {
                separation.bestSeparation = sNext;
                return separation;
            }
            let bestEdge : number;
            let bestSeparation : number;
            let increment : number;
            if(sPrev > s && sPrev > sNext) {
                increment = -1;
                bestEdge = prevEdge;
                bestSeparation = sPrev;
            } else if(sNext > s) {
                increment = 1;
                bestEdge = nextEdge;
                bestSeparation = sNext;
            } else {
                separation.bestFaceIndex = edge;
                separation.bestSeparation = s;
                return separation;
            }
            while((true)) {{
                if(increment === -1) {
                    edge = bestEdge - 1 >= 0?bestEdge - 1:count1 - 1;
                } else {
                    edge = bestEdge + 1 < count1?bestEdge + 1:0;
                }
                s = this.edgeSeparation(poly1, xf1, edge, poly2, xf2);
                if(s > 0.0) {
                    separation.bestSeparation = s;
                    return separation;
                }
                if(s > bestSeparation) {
                    bestEdge = edge;
                    bestSeparation = s;
                } else {
                    break;
                }
            }};
            separation.bestFaceIndex = bestEdge;
            separation.bestSeparation = bestSeparation;
            return separation;
        }

        /*private*/ mulTemp : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ normal1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public findIncidentEdge(c : CollidePoly.ClipVertex[], poly1 : org.jbox2d.collision.shapes.PolygonShape, xf1 : org.jbox2d.common.XForm, edge1 : number, poly2 : org.jbox2d.collision.shapes.PolygonShape, xf2 : org.jbox2d.common.XForm) {
            let count1 : number = poly1.getVertexCount();
            let normals1 : org.jbox2d.common.Vec2[] = poly1.getNormals();
            let count2 : number = poly2.getVertexCount();
            let vertices2 : org.jbox2d.common.Vec2[] = poly2.getVertices();
            let normals2 : org.jbox2d.common.Vec2[] = poly2.getNormals();
            if(!((0 <= edge1 && edge1 < count1))) throw new Error("Assertion error line 166: assert (0 <= edge1 && edge1 < count1);");;
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, normals1[edge1], this.mulTemp);
            org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf2.R, this.mulTemp, this.normal1);
            let index : number = 0;
            let minDot : number = 3.4028235E38;
            for(let i : number = 0; i < count2; ++i) {{
                let dot : number = org.jbox2d.common.Vec2.dot(this.normal1, normals2[i]);
                if(dot < minDot) {
                    minDot = dot;
                    index = i;
                }
            };}
            let i1 : number = index;
            let i2 : number = i1 + 1 < count2?i1 + 1:0;
            c[0] = new CollidePoly.ClipVertex();
            c[1] = new CollidePoly.ClipVertex();
            org.jbox2d.common.XForm.mulToOut(xf2, vertices2[i1], c[0].v);
            c[0].id.features.referenceEdge = edge1;
            c[0].id.features.incidentEdge = i1;
            c[0].id.features.incidentVertex = 0;
            org.jbox2d.common.XForm.mulToOut(xf2, vertices2[i2], c[1].v);
            c[1].id.features.referenceEdge = edge1;
            c[1].id.features.incidentEdge = i2;
            c[1].id.features.incidentVertex = 1;
        }

        public collidePolygons(manif : org.jbox2d.collision.Manifold, polyA : org.jbox2d.collision.shapes.PolygonShape, xfA : org.jbox2d.common.XForm, polyB : org.jbox2d.collision.shapes.PolygonShape, xfB : org.jbox2d.common.XForm) {
            manif.pointCount = 0;
            let sepA : org.jbox2d.collision.shapes.MaxSeparation = this.findMaxSeparation(polyA, xfA, polyB, xfB);
            if(sepA.bestSeparation > 0.0) {
                return;
            }
            let sepB : org.jbox2d.collision.shapes.MaxSeparation = this.findMaxSeparation(polyB, xfB, polyA, xfA);
            if(sepB.bestSeparation > 0.0) {
                return;
            }
            let poly1 : org.jbox2d.collision.shapes.PolygonShape;
            let poly2 : org.jbox2d.collision.shapes.PolygonShape;
            let xf1 : org.jbox2d.common.XForm = this.p_xf1;
            let xf2 : org.jbox2d.common.XForm = this.p_xf2;
            let edge1 : number;
            let flip : number;
            let k_relativeTol : number = 0.98;
            let k_absoluteTol : number = 0.001;
            if(sepB.bestSeparation > (<any>Math).fround((<any>Math).fround(k_relativeTol * sepA.bestSeparation) + k_absoluteTol)) {
                poly1 = polyB;
                poly2 = polyA;
                xf1.set(xfB);
                xf2.set(xfA);
                edge1 = sepB.bestFaceIndex;
                flip = 1;
            } else {
                poly1 = polyA;
                poly2 = polyB;
                xf1.set(xfA);
                xf2.set(xfB);
                edge1 = sepA.bestFaceIndex;
                flip = 0;
            }
            let incidentEdge : CollidePoly.ClipVertex[] = [null, null];
            this.findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
            let count1 : number = poly1.getVertexCount();
            let vertices1 : org.jbox2d.common.Vec2[] = poly1.getVertices();
            let v11 : org.jbox2d.common.Vec2 = vertices1[edge1];
            let v12 : org.jbox2d.common.Vec2 = edge1 + 1 < count1?vertices1[edge1 + 1]:vertices1[0];
            let v1x : number = (<any>Math).fround(v12.x - v11.x);
            let v1y : number = (<any>Math).fround(v12.y - v11.y);
            this.sideNormal.set$float$float((<any>Math).fround((<any>Math).fround(xf1.R.col1.x * v1x) + (<any>Math).fround(xf1.R.col2.x * v1y)), (<any>Math).fround((<any>Math).fround(xf1.R.col1.y * v1x) + (<any>Math).fround(xf1.R.col2.y * v1y)));
            this.sideNormal.normalize();
            this.frontNormal.set$float$float(this.sideNormal.y, -this.sideNormal.x);
            let v11x : number = (<any>Math).fround((<any>Math).fround(xf1.position.x + (<any>Math).fround(xf1.R.col1.x * v11.x)) + (<any>Math).fround(xf1.R.col2.x * v11.y));
            let v11y : number = (<any>Math).fround((<any>Math).fround(xf1.position.y + (<any>Math).fround(xf1.R.col1.y * v11.x)) + (<any>Math).fround(xf1.R.col2.y * v11.y));
            let v12x : number = (<any>Math).fround((<any>Math).fround(xf1.position.x + (<any>Math).fround(xf1.R.col1.x * v12.x)) + (<any>Math).fround(xf1.R.col2.x * v12.y));
            let v12y : number = (<any>Math).fround((<any>Math).fround(xf1.position.y + (<any>Math).fround(xf1.R.col1.y * v12.x)) + (<any>Math).fround(xf1.R.col2.y * v12.y));
            let frontOffset : number = (<any>Math).fround((<any>Math).fround(this.frontNormal.x * v11x) + (<any>Math).fround(this.frontNormal.y * v11y));
            let sideOffset1 : number = -((<any>Math).fround((<any>Math).fround(this.sideNormal.x * v11x) + (<any>Math).fround(this.sideNormal.y * v11y)));
            let sideOffset2 : number = (<any>Math).fround((<any>Math).fround(this.sideNormal.x * v12x) + (<any>Math).fround(this.sideNormal.y * v12y));
            let clipPoints1 : CollidePoly.ClipVertex[] = [null, null];
            let clipPoints2 : CollidePoly.ClipVertex[] = [null, null];
            let np : number;
            np = this.clipSegmentToLine(clipPoints1, incidentEdge, this.sideNormal.negate(), sideOffset1);
            if(np < 2) {
                return;
            }
            np = this.clipSegmentToLine(clipPoints2, clipPoints1, this.sideNormal, sideOffset2);
            if(np < 2) {
                return;
            }
            manif.normal.set$org_jbox2d_common_Vec2(this.frontNormal);
            if(flip !== 0) {
                manif.normal.negateLocal();
            }
            let pointCount : number = 0;
            for(let i : number = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; ++i) {{
                let separation : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(this.frontNormal, clipPoints2[i].v) - frontOffset);
                if(separation <= 0.0) {
                    let cp : org.jbox2d.collision.ManifoldPoint = manif.points[pointCount];
                    cp.separation = separation;
                    let vec : org.jbox2d.common.Vec2 = clipPoints2[i].v;
                    let u1x : number = (<any>Math).fround(vec.x - xfA.position.x);
                    let u1y : number = (<any>Math).fround(vec.y - xfA.position.y);
                    cp.localPoint1.x = ((<any>Math).fround((<any>Math).fround(u1x * xfA.R.col1.x) + (<any>Math).fround(u1y * xfA.R.col1.y)));
                    cp.localPoint1.y = ((<any>Math).fround((<any>Math).fround(u1x * xfA.R.col2.x) + (<any>Math).fround(u1y * xfA.R.col2.y)));
                    u1x = (<any>Math).fround(vec.x - xfB.position.x);
                    u1y = (<any>Math).fround(vec.y - xfB.position.y);
                    cp.localPoint2.x = ((<any>Math).fround((<any>Math).fround(u1x * xfB.R.col1.x) + (<any>Math).fround(u1y * xfB.R.col1.y)));
                    cp.localPoint2.y = ((<any>Math).fround((<any>Math).fround(u1x * xfB.R.col2.x) + (<any>Math).fround(u1y * xfB.R.col2.y)));
                    cp.id.set(clipPoints2[i].id);
                    cp.id.features.flip = flip;
                    ++pointCount;
                }
            };}
            manif.pointCount = pointCount;
            return;
        }

        /*private*/ colPPc : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colPPcLocal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colPPsub : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colPPe : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colPPp : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ colPPd : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * puts collision information into the manifold about the collision between a polygon and a point
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
         * @param {org.jbox2d.common.XForm} xf1
         * @param {org.jbox2d.collision.shapes.PointShape} point
         * @param {org.jbox2d.common.XForm} xf2
         */
        public collidePolygonAndPoint(manifold : org.jbox2d.collision.Manifold, polygon : org.jbox2d.collision.shapes.PolygonShape, xf1 : org.jbox2d.common.XForm, point : org.jbox2d.collision.shapes.PointShape, xf2 : org.jbox2d.common.XForm) {
            manifold.pointCount = 0;
            org.jbox2d.common.XForm.mulToOut(xf2, point.getMemberLocalPosition(), this.colPPc);
            org.jbox2d.common.XForm.mulTransToOut(xf1, this.colPPc, this.colPPcLocal);
            let normalIndex : number = 0;
            let separation : number = -3.4028235E38;
            let vertexCount : number = polygon.getVertexCount();
            let vertices : org.jbox2d.common.Vec2[] = polygon.getVertices();
            let normals : org.jbox2d.common.Vec2[] = polygon.getNormals();
            for(let i : number = 0; i < vertexCount; ++i) {{
                this.colPPsub.set$org_jbox2d_common_Vec2(this.colPPcLocal);
                this.colPPsub.subLocal(vertices[i]);
                let s : number = org.jbox2d.common.Vec2.dot(normals[i], this.colPPsub);
                if(s > 0) {
                    return;
                }
                if(s > separation) {
                    normalIndex = i;
                    separation = s;
                }
            };}
            if(separation < org.jbox2d.common.Settings.EPSILON) {
                manifold.pointCount = 1;
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, normals[normalIndex], manifold.normal);
                manifold.points[0].id.features.incidentEdge = normalIndex;
                manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                manifold.points[0].id.features.referenceEdge = 0;
                manifold.points[0].id.features.flip = 0;
                let position : org.jbox2d.common.Vec2 = this.colPPc;
                org.jbox2d.common.XForm.mulTransToOut(xf1, position, manifold.points[0].localPoint1);
                org.jbox2d.common.XForm.mulTransToOut(xf2, position, manifold.points[0].localPoint2);
                manifold.points[0].separation = separation;
                return;
            }
            let vertIndex1 : number = normalIndex;
            let vertIndex2 : number = vertIndex1 + 1 < vertexCount?vertIndex1 + 1:0;
            this.colPPe.set$org_jbox2d_common_Vec2(vertices[vertIndex2]);
            this.colPPe.subLocal(vertices[vertIndex1]);
            let length : number = this.colPPe.normalize();
            if(!((length > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 341: assert (length > Settings.EPSILON);");;
            this.colPPsub.set$org_jbox2d_common_Vec2(this.colPPcLocal);
            this.colPPsub.subLocal(vertices[vertIndex1]);
            let u : number = org.jbox2d.common.Vec2.dot(this.colPPsub, this.colPPe);
            this.colPPp.setZero();
            if(u <= 0.0) {
                this.colPPp.set$org_jbox2d_common_Vec2(vertices[vertIndex1]);
                manifold.points[0].id.features.incidentEdge = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                manifold.points[0].id.features.incidentVertex = vertIndex1;
            } else if(u >= length) {
                this.colPPp.set$org_jbox2d_common_Vec2(vertices[vertIndex2]);
                manifold.points[0].id.features.incidentEdge = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                manifold.points[0].id.features.incidentVertex = vertIndex2;
            } else {
                this.colPPp.set$org_jbox2d_common_Vec2(vertices[vertIndex1]);
                this.colPPp.x += (<any>Math).fround(u * this.colPPe.x);
                this.colPPp.y += (<any>Math).fround(u * this.colPPe.y);
                manifold.points[0].id.features.incidentEdge = normalIndex;
                manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
            }
            this.colPPd.set$org_jbox2d_common_Vec2(this.colPPcLocal);
            this.colPPd.subLocal(this.colPPp);
            let dist : number = this.colPPd.normalize();
            if(dist > 0) {
                return;
            }
            manifold.pointCount = 1;
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, this.colPPd, manifold.normal);
            let position : org.jbox2d.common.Vec2 = this.colPPc;
            org.jbox2d.common.XForm.mulTransToOut(xf1, position, manifold.points[0].localPoint1);
            org.jbox2d.common.XForm.mulTransToOut(xf2, position, manifold.points[0].localPoint2);
            manifold.points[0].separation = dist;
            manifold.points[0].id.features.referenceEdge = 0;
            manifold.points[0].id.features.flip = 0;
        }

        /*private*/ PEv1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ PEv2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ PEn : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ PEv1Local : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ PEv2Local : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ PEnLocal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ temp : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ temp2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * puts collision information into the manifold about a collision between
         * a polygon and an edge
         * @param {org.jbox2d.collision.Manifold} manifold
         * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
         * @param {org.jbox2d.common.XForm} xf1
         * @param {org.jbox2d.collision.shapes.EdgeShape} edge
         * @param {org.jbox2d.common.XForm} xf2
         */
        public collidePolyAndEdge(manifold : org.jbox2d.collision.Manifold, polygon : org.jbox2d.collision.shapes.PolygonShape, xf1 : org.jbox2d.common.XForm, edge : org.jbox2d.collision.shapes.EdgeShape, xf2 : org.jbox2d.common.XForm) {
            manifold.pointCount = 0;
            org.jbox2d.common.XForm.mulToOut(xf2, edge.getVertex1(), this.PEv1);
            org.jbox2d.common.XForm.mulToOut(xf2, edge.getVertex2(), this.PEv2);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf2.R, edge.getNormalVector(), this.PEn);
            org.jbox2d.common.XForm.mulTransToOut(xf1, this.PEv1, this.PEv1Local);
            org.jbox2d.common.XForm.mulTransToOut(xf1, this.PEv2, this.PEv2Local);
            org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, this.PEn, this.PEnLocal);
            let separation1 : number;
            let separationIndex1 : number = -1;
            let separationMax1 : number = -3.4028235E38;
            let separation2 : number;
            let separationIndex2 : number = -1;
            let separationMax2 : number = -3.4028235E38;
            let separationMax : number = -3.4028235E38;
            let separationV1 : boolean = false;
            let separationIndex : number = -1;
            let vertexCount : number = polygon.getVertexCount();
            let vertices : org.jbox2d.common.Vec2[] = polygon.getVertices();
            let normals : org.jbox2d.common.Vec2[] = polygon.getNormals();
            let enterStartIndex : number = -1;
            let enterEndIndex : number = -1;
            let exitStartIndex : number = -1;
            let exitEndIndex : number = -1;
            let prevSepN : number = 0.0;
            let nextSepN : number = 0.0;
            let enterSepN : number = 0.0;
            let exitSepN : number = 0.0;
            let deepestSepN : number = 3.4028235E38;
            this.temp.set$org_jbox2d_common_Vec2(vertices[vertexCount - 1]);
            this.temp.subLocal(this.PEv1Local);
            prevSepN = org.jbox2d.common.Vec2.dot(this.temp, this.PEnLocal);
            for(let i : number = 0; i < vertexCount; i++) {{
                this.temp.set$org_jbox2d_common_Vec2(this.PEv1Local);
                this.temp.subLocal(vertices[i]);
                separation1 = org.jbox2d.common.Vec2.dot(this.temp, normals[i]);
                this.temp.set$org_jbox2d_common_Vec2(this.PEv2Local);
                this.temp.subLocal(vertices[i]);
                separation2 = org.jbox2d.common.Vec2.dot(this.temp, normals[i]);
                if(separation2 < separation1) {
                    if(separation2 > separationMax) {
                        separationMax = separation2;
                        separationV1 = false;
                        separationIndex = i;
                    }
                } else {
                    if(separation1 > separationMax) {
                        separationMax = separation1;
                        separationV1 = true;
                        separationIndex = i;
                    }
                }
                if(separation1 > separationMax1) {
                    separationMax1 = separation1;
                    separationIndex1 = i;
                }
                if(separation2 > separationMax2) {
                    separationMax2 = separation2;
                    separationIndex2 = i;
                }
                this.temp.set$org_jbox2d_common_Vec2(vertices[i]);
                this.temp.subLocal(this.PEv1Local);
                nextSepN = org.jbox2d.common.Vec2.dot(this.temp, this.PEnLocal);
                if(nextSepN >= 0.0 && prevSepN < 0.0) {
                    exitStartIndex = (i === 0)?vertexCount - 1:i - 1;
                    exitEndIndex = i;
                    exitSepN = prevSepN;
                } else if(nextSepN < 0.0 && prevSepN >= 0.0) {
                    enterStartIndex = (i === 0)?vertexCount - 1:i - 1;
                    enterEndIndex = i;
                    enterSepN = nextSepN;
                }
                if(nextSepN < deepestSepN) {
                    deepestSepN = nextSepN;
                }
                prevSepN = nextSepN;
            };}
            if(enterStartIndex === -1) {
                return;
            }
            if(separationMax > 0.0) {
                return;
            }
            if((separationV1 && edge.corner1IsConvex()) || (!separationV1 && edge.corner2IsConvex())) {
                if(separationMax > (<any>Math).fround(deepestSepN + org.jbox2d.common.Settings.linearSlop_$LI$())) {
                    if(separationV1) {
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf2.R, edge.getCorner1Vector(), this.temp);
                        org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, this.temp, this.temp);
                        if(org.jbox2d.common.Vec2.dot(normals[separationIndex1], this.temp) >= 0.0) {
                            return;
                        }
                    } else {
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf2.R, edge.getCorner2Vector(), this.temp);
                        org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, this.temp, this.temp);
                        if(org.jbox2d.common.Vec2.dot(normals[separationIndex2], this.temp) <= 0.0) {
                            return;
                        }
                    }
                    manifold.pointCount = 1;
                    org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, normals[separationIndex], manifold.normal);
                    manifold.points[0].separation = separationMax;
                    manifold.points[0].id.features.incidentEdge = separationIndex;
                    manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                    manifold.points[0].id.features.referenceEdge = 0;
                    manifold.points[0].id.features.flip = 0;
                    if(separationV1) {
                        manifold.points[0].localPoint1.set$org_jbox2d_common_Vec2(this.PEv1Local);
                        manifold.points[0].localPoint2.set$org_jbox2d_common_Vec2(edge.getVertex1());
                    } else {
                        manifold.points[0].localPoint1.set$org_jbox2d_common_Vec2(this.PEv2Local);
                        manifold.points[0].localPoint2.set$org_jbox2d_common_Vec2(edge.getVertex2());
                    }
                    return;
                }
            }
            this.temp.set$org_jbox2d_common_Vec2(this.PEn);
            this.temp.mulLocal(-1.0);
            manifold.normal.set$org_jbox2d_common_Vec2(this.temp);
            if(enterEndIndex === exitStartIndex) {
                manifold.pointCount = 1;
                manifold.points[0].id.features.incidentEdge = enterEndIndex;
                manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                manifold.points[0].id.features.referenceEdge = 0;
                manifold.points[0].id.features.flip = 0;
                manifold.points[0].localPoint1.set$org_jbox2d_common_Vec2(vertices[enterEndIndex]);
                org.jbox2d.common.XForm.mulTransToOut(xf2, org.jbox2d.common.XForm.mul(xf1, vertices[enterEndIndex]), manifold.points[0].localPoint2);
                manifold.points[0].separation = enterSepN;
                return;
            }
            manifold.pointCount = 2;
            org.jbox2d.common.Vec2.crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(this.PEnLocal, -1.0, this.temp);
            this.temp2.set$org_jbox2d_common_Vec2(vertices[enterEndIndex]);
            this.temp2.subLocal(this.PEv1Local);
            let dirProj1 : number = org.jbox2d.common.Vec2.dot(this.temp, this.temp2);
            let dirProj2 : number = 0.0;
            this.temp2.set$org_jbox2d_common_Vec2(vertices[exitStartIndex]);
            this.temp2.subLocal(this.PEv1Local);
            exitEndIndex = (enterEndIndex === vertexCount - 1)?0:enterEndIndex + 1;
            if(exitEndIndex !== exitStartIndex) {
                exitStartIndex = exitEndIndex;
                exitSepN = org.jbox2d.common.Vec2.dot(this.PEnLocal, this.temp2);
            }
            dirProj2 = org.jbox2d.common.Vec2.dot(this.temp, this.temp2);
            manifold.points[0].id.features.incidentEdge = enterEndIndex;
            manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
            manifold.points[0].id.features.referenceEdge = 0;
            manifold.points[0].id.features.flip = 0;
            if(dirProj1 > edge.getLength()) {
                manifold.points[0].localPoint1.set$org_jbox2d_common_Vec2(this.PEv2Local);
                manifold.points[0].localPoint2.set$org_jbox2d_common_Vec2(edge.getVertex2());
                let ratio : number = (<any>Math).fround(((<any>Math).fround(edge.getLength() - dirProj2)) / ((<any>Math).fround(dirProj1 - dirProj2)));
                if(ratio > (<any>Math).fround(100.0 * org.jbox2d.common.Settings.EPSILON) && ratio < 1.0) {
                    manifold.points[0].separation = (<any>Math).fround((<any>Math).fround(exitSepN * ((<any>Math).fround(1.0 - ratio))) + (<any>Math).fround(enterSepN * ratio));
                } else {
                    manifold.points[0].separation = enterSepN;
                }
            } else {
                manifold.points[0].localPoint1.set$org_jbox2d_common_Vec2(vertices[enterEndIndex]);
                org.jbox2d.common.XForm.mulTransToOut(xf2, org.jbox2d.common.XForm.mul(xf1, vertices[enterEndIndex]), manifold.points[0].localPoint2);
                manifold.points[0].separation = enterSepN;
            }
            manifold.points[1].id.features.incidentEdge = exitStartIndex;
            manifold.points[1].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
            manifold.points[1].id.features.referenceEdge = 0;
            manifold.points[1].id.features.flip = 0;
            if(dirProj2 < 0.0) {
                manifold.points[1].localPoint1.set$org_jbox2d_common_Vec2(this.PEv1Local);
                manifold.points[1].localPoint2.set$org_jbox2d_common_Vec2(edge.getVertex1());
                let ratio : number = (<any>Math).fround((-dirProj1) / ((<any>Math).fround(dirProj2 - dirProj1)));
                if(ratio > (<any>Math).fround(100.0 * org.jbox2d.common.Settings.EPSILON) && ratio < 1.0) {
                    manifold.points[1].separation = (<any>Math).fround((<any>Math).fround(enterSepN * ((<any>Math).fround(1.0 - ratio))) + (<any>Math).fround(exitSepN * ratio));
                } else {
                    manifold.points[1].separation = exitSepN;
                }
            } else {
                manifold.points[1].localPoint1.set$org_jbox2d_common_Vec2(vertices[exitStartIndex]);
                org.jbox2d.common.XForm.mulTransToOut(xf2, org.jbox2d.common.XForm.mul(xf1, vertices[exitStartIndex]), manifold.points[1].localPoint2);
                manifold.points[1].separation = exitSepN;
            }
        }

        /*private*/ sideNormal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ frontNormal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ p_xf1 : org.jbox2d.common.XForm = new org.jbox2d.common.XForm();

        /*private*/ p_xf2 : org.jbox2d.common.XForm = new org.jbox2d.common.XForm();
    }
    CollidePoly["__class"] = "org.jbox2d.collision.shapes.CollidePoly";


    export namespace CollidePoly {

        export class ClipVertex {
            public v : org.jbox2d.common.Vec2;

            public id : org.jbox2d.collision.ContactID;

            public constructor() {
                if(this.v===undefined) this.v = null;
                if(this.id===undefined) this.id = null;
                this.v = new org.jbox2d.common.Vec2();
                this.id = new org.jbox2d.collision.ContactID();
            }
        }
        ClipVertex["__class"] = "org.jbox2d.collision.shapes.CollidePoly.ClipVertex";

    }


    /**
     * Holder class used internally in CollidePoly
     * @class
     */
    export class MaxSeparation {
        public bestFaceIndex : number;

        public bestSeparation : number;

        constructor() {
            if(this.bestFaceIndex===undefined) this.bestFaceIndex = 0;
            if(this.bestSeparation===undefined) this.bestSeparation = 0;
        }
    }
    MaxSeparation["__class"] = "org.jbox2d.collision.shapes.MaxSeparation";

}
namespace org.jbox2d.collision.shapes {
    /**
     * Superclass for shape definitions.
     * You should usually use CircleDef or
     * PolygonDef to define concrete shapes.
     * @class
     */
    export class ShapeDef {
        /**
         * Holds the shape type for down-casting.
         */
        public type : org.jbox2d.collision.shapes.ShapeType;

        /**
         * Use this to store application specify shape data.
         */
        public userData : any;

        /**
         * The shape's friction coefficient, usually in the range [0,1].
         */
        public friction : number;

        /**
         * The shape's restitution (elasticity) usually in the range [0,1].
         */
        public restitution : number;

        /**
         * The shape's density, usually in kg/m^2.
         */
        public density : number;

        /**
         * Contact filtering data.
         */
        public filter : org.jbox2d.collision.FilterData;

        /**
         * A sensor shape collects contact information but never generates a collision
         * response.
         */
        public isSensor : boolean;

        public constructor() {
            if(this.type===undefined) this.type = null;
            if(this.userData===undefined) this.userData = null;
            if(this.friction===undefined) this.friction = 0;
            if(this.restitution===undefined) this.restitution = 0;
            if(this.density===undefined) this.density = 0;
            if(this.filter===undefined) this.filter = null;
            if(this.isSensor===undefined) this.isSensor = false;
            this.type = org.jbox2d.collision.shapes.ShapeType.UNKNOWN_SHAPE;
            this.userData = null;
            this.friction = 0.2;
            this.restitution = 0.0;
            this.density = 0.0;
            this.filter = new org.jbox2d.collision.FilterData();
            this.filter.categoryBits = 1;
            this.filter.maskBits = 65535;
            this.filter.groupIndex = 0;
            this.isSensor = false;
        }
    }
    ShapeDef["__class"] = "org.jbox2d.collision.shapes.ShapeDef";

}
namespace org.jbox2d.collision.shapes {
    export enum ShapeType {
        UNKNOWN_SHAPE, CIRCLE_SHAPE, POLYGON_SHAPE, POINT_SHAPE, EDGE_SHAPE, SHAPE_TYPE_COUNT
    }
}
namespace org.jbox2d.collision {
    /**
     * @author eric
     * @class
     */
    export interface SortKeyFunc {
        apply(shape : any) : number;
    }
}
namespace org.jbox2d.collision {
    /**
     * A shape that implements this interface can be used in distance calculations
     * for continuous collision detection.  This does not remove the necessity of
     * specialized penetration calculations when CCD is not in effect, however.
     * @class
     */
    export interface SupportsGenericDistance {
        support(dest : org.jbox2d.common.Vec2, xf : org.jbox2d.common.XForm, v : org.jbox2d.common.Vec2);

        getFirstVertexToOut(xf : org.jbox2d.common.XForm, out : org.jbox2d.common.Vec2);
    }
}
namespace org.jbox2d.common {
    /**
     * Similar to javax.vecmath.Color3f holder
     * @author ewjordan
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @class
     */
    export class Color3f {
        public static WHITE : Color3f; public static WHITE_$LI$() : Color3f { if(Color3f.WHITE == null) Color3f.WHITE = new Color3f(255, 255, 255); return Color3f.WHITE; };

        public static BLACK : Color3f; public static BLACK_$LI$() : Color3f { if(Color3f.BLACK == null) Color3f.BLACK = new Color3f(0, 0, 0); return Color3f.BLACK; };

        public static BLUE : Color3f; public static BLUE_$LI$() : Color3f { if(Color3f.BLUE == null) Color3f.BLUE = new Color3f(0, 0, 255); return Color3f.BLUE; };

        public static GREEN : Color3f; public static GREEN_$LI$() : Color3f { if(Color3f.GREEN == null) Color3f.GREEN = new Color3f(0, 255, 0); return Color3f.GREEN; };

        public static RED : Color3f; public static RED_$LI$() : Color3f { if(Color3f.RED == null) Color3f.RED = new Color3f(255, 0, 0); return Color3f.RED; };

        public x : number;

        public y : number;

        public z : number;

        public constructor(r : number, g : number, b : number) {
            if(this.x===undefined) this.x = 0;
            if(this.y===undefined) this.y = 0;
            if(this.z===undefined) this.z = 0;
            this.x = r;
            this.y = g;
            this.z = b;
        }
    }
    Color3f["__class"] = "org.jbox2d.common.Color3f";

}
namespace org.jbox2d.common {
    /**
     * This is the viewport transform used from drawing.
     * Use yFlip if you are drawing from the top-left corner.
     * @author daniel
     * @class
     */
    export interface IViewportTransform {
        /**
         * @return {boolean} if the transform flips the y axis
         */
        isYFlip() : boolean;

        /**
         * @param {boolean} yFlip if we flip the y axis when transforming
         */
        setYFlip(yFlip : boolean);

        /**
         * This is the half-width and half-height.
         * This should be the actual half-width and
         * half-height, not anything transformed or scaled.
         * Not a copy.
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        getExtents() : org.jbox2d.common.Vec2;

        /**
         * This sets the half-width and half-height of the
         * viewport. This should be the actual half-width and
         * half-height, not anything transformed or scaled.
         * @param {number} argHalfWidth
         * @param {number} argHalfHeight
         */
        setExtents(argHalfWidth? : any, argHalfHeight? : any) : any;

        /**
         * center of the viewport.  Not a copy.
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        getCenter() : org.jbox2d.common.Vec2;

        /**
         * sets the center of the viewport.
         * @param {number} x
         * @param {number} y
         */
        setCenter(x? : any, y? : any) : any;

        /**
         * Sets the transform's center to the given x and y coordinates,
         * and using the given scale.
         * @param {number} x
         * @param {number} y
         * @param {number} scale
         */
        setCamera(x : number, y : number, scale : number);

        /**
         * Transforms the given directional vector by the
         * viewport transform (not positional)
         * @param argVec
         * @param argOut
         * @param {org.jbox2d.common.Vec2} argWorld
         * @param {org.jbox2d.common.Vec2} argScreen
         */
        vectorTransform(argWorld : org.jbox2d.common.Vec2, argScreen : org.jbox2d.common.Vec2);

        /**
         * Transforms the given directional screen vector back to
         * the world direction.
         * @param argVec
         * @param argOut
         * @param {org.jbox2d.common.Vec2} argScreen
         * @param {org.jbox2d.common.Vec2} argWorld
         */
        vectorInverseTransform(argScreen : org.jbox2d.common.Vec2, argWorld : org.jbox2d.common.Vec2);

        /**
         * takes the world coordinate (argWorld) puts the corresponding
         * screen coordinate in argScreen.  It should be safe to give the
         * same object as both parameters.
         * @param {org.jbox2d.common.Vec2} argWorld
         * @param {org.jbox2d.common.Vec2} argScreen
         */
        getWorldToScreen(argWorld : org.jbox2d.common.Vec2, argScreen : org.jbox2d.common.Vec2);

        /**
         * takes the screen coordinates (argScreen) and puts the
         * corresponding world coordinates in argWorld. It should be safe
         * to give the same object as both parameters.
         * @param {org.jbox2d.common.Vec2} argScreen
         * @param {org.jbox2d.common.Vec2} argWorld
         */
        getScreenToWorld(argScreen : org.jbox2d.common.Vec2, argWorld : org.jbox2d.common.Vec2);
    }
}
namespace org.jbox2d.common {
    /**
     * Create a matrix from four floats.
     * @param {number} col1x
     * @param {number} col2x
     * @param {number} col1y
     * @param {number} col2y
     * @class
     * @author ewjordan
     */
    export class Mat22 {
        public col1 : org.jbox2d.common.Vec2;

        public col2 : org.jbox2d.common.Vec2;

        /**
         * Convert the matrix to printable format.
         * @return {string}
         */
        public toString() : string {
            let s : string = "";
            s += "[" + this.col1.x + "," + this.col2.x + "]\n";
            s += "[" + this.col1.y + "," + this.col2.y + "]";
            return s;
        }

        public constructor(col1x? : any, col2x? : any, col1y? : any, col2y? : any) {
            if(((typeof col1x === 'number') || col1x === null) && ((typeof col2x === 'number') || col2x === null) && ((typeof col1y === 'number') || col1y === null) && ((typeof col2y === 'number') || col2y === null)) {
                let __args = arguments;
                if(this.col1===undefined) this.col1 = null;
                if(this.col2===undefined) this.col2 = null;
                if(this.col1===undefined) this.col1 = null;
                if(this.col2===undefined) this.col2 = null;
                (() => {
                    this.col1 = new org.jbox2d.common.Vec2(col1x, col1y);
                    this.col2 = new org.jbox2d.common.Vec2(col2x, col2y);
                })();
            } else if(((col1x != null && col1x instanceof <any>org.jbox2d.common.Vec2) || col1x === null) && ((col2x != null && col2x instanceof <any>org.jbox2d.common.Vec2) || col2x === null) && col1y === undefined && col2y === undefined) {
                let __args = arguments;
                let c1 : any = __args[0];
                let c2 : any = __args[1];
                if(this.col1===undefined) this.col1 = null;
                if(this.col2===undefined) this.col2 = null;
                if(this.col1===undefined) this.col1 = null;
                if(this.col2===undefined) this.col2 = null;
                (() => {
                    this.col1 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(c1);
                    this.col2 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(c2);
                })();
            } else if(col1x === undefined && col2x === undefined && col1y === undefined && col2y === undefined) {
                let __args = arguments;
                if(this.col1===undefined) this.col1 = null;
                if(this.col2===undefined) this.col2 = null;
                if(this.col1===undefined) this.col1 = null;
                if(this.col2===undefined) this.col2 = null;
                (() => {
                    this.col1 = new org.jbox2d.common.Vec2();
                    this.col2 = new org.jbox2d.common.Vec2();
                })();
            } else throw new Error('invalid overload');
        }

        public set$org_jbox2d_common_Mat22(m : Mat22) : Mat22 {
            this.col1.x = m.col1.x;
            this.col1.y = m.col1.y;
            this.col2.x = m.col2.x;
            this.col2.y = m.col2.y;
            return this;
        }

        public set$float$float$float$float(col1x : number, col2x : number, col1y : number, col2y : number) : Mat22 {
            this.col1.x = col1x;
            this.col1.y = col1y;
            this.col2.x = col2x;
            this.col2.y = col2y;
            return this;
        }

        public set(col1x? : any, col2x? : any, col1y? : any, col2y? : any) : any {
            if(((typeof col1x === 'number') || col1x === null) && ((typeof col2x === 'number') || col2x === null) && ((typeof col1y === 'number') || col1y === null) && ((typeof col2y === 'number') || col2y === null)) {
                return <any>this.set$float$float$float$float(col1x, col2x, col1y, col2y);
            } else if(((col1x != null && col1x instanceof <any>org.jbox2d.common.Vec2) || col1x === null) && ((col2x != null && col2x instanceof <any>org.jbox2d.common.Vec2) || col2x === null) && col1y === undefined && col2y === undefined) {
                return <any>this.set$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(col1x, col2x);
            } else if(((col1x != null && col1x instanceof <any>org.jbox2d.common.Mat22) || col1x === null) && col2x === undefined && col1y === undefined && col2y === undefined) {
                return <any>this.set$org_jbox2d_common_Mat22(col1x);
            } else if(((typeof col1x === 'number') || col1x === null) && col2x === undefined && col1y === undefined && col2y === undefined) {
                return <any>this.set$float(col1x);
            } else throw new Error('invalid overload');
        }

        /**
         * Return a clone of this matrix.
         * djm fixed double allocation
         * @return {org.jbox2d.common.Mat22}
         */
        public clone() : Mat22 {
            return new Mat22(this.col1, this.col2);
        }

        public set$float(angle : number) {
            let c : number = org.jbox2d.common.MathUtils.cos(angle);
            let s : number = org.jbox2d.common.MathUtils.sin(angle);
            this.col1.x = c;
            this.col2.x = -s;
            this.col1.y = s;
            this.col2.y = c;
        }

        /**
         * Set as the identity matrix.
         */
        public setIdentity() {
            this.col1.x = 1.0;
            this.col2.x = 0.0;
            this.col1.y = 0.0;
            this.col2.y = 1.0;
        }

        /**
         * Set as the zero matrix.
         */
        public setZero() {
            this.col1.x = 0.0;
            this.col2.x = 0.0;
            this.col1.y = 0.0;
            this.col2.y = 0.0;
        }

        public set$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(c1 : org.jbox2d.common.Vec2, c2 : org.jbox2d.common.Vec2) {
            this.col1.x = c1.x;
            this.col2.x = c2.x;
            this.col1.y = c1.y;
            this.col2.y = c2.y;
        }

        /**
         * Returns the inverted Mat22 - does NOT invert the matrix locally!
         * @return {org.jbox2d.common.Mat22}
         */
        public invert() : Mat22 {
            let a : number = this.col1.x;
            let b : number = this.col2.x;
            let c : number = this.col1.y;
            let d : number = this.col2.y;
            let B : Mat22 = new Mat22();
            let det : number = (<any>Math).fround((<any>Math).fround(a * d) - (<any>Math).fround(b * c));
            det = (<any>Math).fround(1.0 / det);
            B.col1.x = (<any>Math).fround(det * d);
            B.col2.x = (<any>Math).fround(-det * b);
            B.col1.y = (<any>Math).fround(-det * c);
            B.col2.y = (<any>Math).fround(det * a);
            return B;
        }

        public invertLocal() : Mat22 {
            let a : number = this.col1.x;
            let b : number = this.col2.x;
            let c : number = this.col1.y;
            let d : number = this.col2.y;
            let det : number = (<any>Math).fround((<any>Math).fround(a * d) - (<any>Math).fround(b * c));
            det = (<any>Math).fround(1.0 / det);
            this.col1.x = (<any>Math).fround(det * d);
            this.col2.x = (<any>Math).fround(-det * b);
            this.col1.y = (<any>Math).fround(-det * c);
            this.col2.y = (<any>Math).fround(det * a);
            return this;
        }

        public invertToOut(out : Mat22) {
            let a : number = this.col1.x;
            let b : number = this.col2.x;
            let c : number = this.col1.y;
            let d : number = this.col2.y;
            let det : number = (<any>Math).fround((<any>Math).fround(a * d) - (<any>Math).fround(b * c));
            det = (<any>Math).fround(1.0 / det);
            out.col1.x = (<any>Math).fround(det * d);
            out.col2.x = (<any>Math).fround(-det * b);
            out.col1.y = (<any>Math).fround(-det * c);
            out.col2.y = (<any>Math).fround(det * a);
        }

        /**
         * Return the matrix composed of the absolute values of all elements.
         * djm: fixed double allocation
         * @return {org.jbox2d.common.Mat22} Absolute value matrix
         */
        public abs() : Mat22 {
            return new Mat22(org.jbox2d.common.MathUtils.abs(this.col1.x), org.jbox2d.common.MathUtils.abs(this.col2.x), org.jbox2d.common.MathUtils.abs(this.col1.y), org.jbox2d.common.MathUtils.abs(this.col2.y));
        }

        public absLocal() {
            this.col1.absLocal();
            this.col2.absLocal();
        }

        /**
         * Return the matrix composed of the absolute values of all elements.
         * @return {org.jbox2d.common.Mat22} Absolute value matrix
         * @param {org.jbox2d.common.Mat22} R
         */
        public static abs(R : Mat22) : Mat22 {
            return R.abs();
        }

        public static absToOut(R : Mat22, out : Mat22) {
            out.col1.x = org.jbox2d.common.MathUtils.abs(R.col1.x);
            out.col1.y = org.jbox2d.common.MathUtils.abs(R.col1.y);
            out.col2.x = org.jbox2d.common.MathUtils.abs(R.col2.x);
            out.col2.y = org.jbox2d.common.MathUtils.abs(R.col2.y);
        }

        public mul$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2((<any>Math).fround((<any>Math).fround(this.col1.x * v.x) + (<any>Math).fround(this.col2.x * v.y)), (<any>Math).fround((<any>Math).fround(this.col1.y * v.x) + (<any>Math).fround(this.col2.y * v.y)));
        }

        /**
         * Multiply a vector by this matrix.
         * @param {org.jbox2d.common.Vec2} v Vector to multiply by matrix.
         * @return {org.jbox2d.common.Vec2} Resulting vector
         */
        public mul(v? : any) : any {
            if(((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null)) {
                return <any>this.mul$org_jbox2d_common_Vec2(v);
            } else if(((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null)) {
                return <any>this.mul$org_jbox2d_common_Mat22(v);
            } else throw new Error('invalid overload');
        }

        public mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempy : number = (<any>Math).fround((<any>Math).fround(this.col1.y * v.x) + (<any>Math).fround(this.col2.y * v.y));
            out.x = (<any>Math).fround((<any>Math).fround(this.col1.x * v.x) + (<any>Math).fround(this.col2.x * v.y));
            out.y = tempy;
        }

        public mulToOut(v? : any, out? : any) : any {
            if(((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>this.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v, out);
            } else if(((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>this.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(v, out);
            } else throw new Error('invalid overload');
        }

        public mul$org_jbox2d_common_Mat22(R : Mat22) : Mat22 {
            let C : Mat22 = new Mat22();
            C.col1.x = (<any>Math).fround((<any>Math).fround(this.col1.x * R.col1.x) + (<any>Math).fround(this.col2.x * R.col1.y));
            C.col1.y = (<any>Math).fround((<any>Math).fround(this.col1.y * R.col1.x) + (<any>Math).fround(this.col2.y * R.col1.y));
            C.col2.x = (<any>Math).fround((<any>Math).fround(this.col1.x * R.col2.x) + (<any>Math).fround(this.col2.x * R.col2.y));
            C.col2.y = (<any>Math).fround((<any>Math).fround(this.col1.y * R.col2.x) + (<any>Math).fround(this.col2.y * R.col2.y));
            return C;
        }

        public mulLocal(R : Mat22) : Mat22 {
            this.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, this);
            return this;
        }

        public mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R : Mat22, out : Mat22) {
            let tempy1 : number = (<any>Math).fround((<any>Math).fround(this.col1.y * R.col1.x) + (<any>Math).fround(this.col2.y * R.col1.y));
            let tempx1 : number = (<any>Math).fround((<any>Math).fround(this.col1.x * R.col1.x) + (<any>Math).fround(this.col2.x * R.col1.y));
            out.col1.x = tempx1;
            out.col1.y = tempy1;
            let tempy2 : number = (<any>Math).fround((<any>Math).fround(this.col1.y * R.col2.x) + (<any>Math).fround(this.col2.y * R.col2.y));
            let tempx2 : number = (<any>Math).fround((<any>Math).fround(this.col1.x * R.col2.x) + (<any>Math).fround(this.col2.x * R.col2.y));
            out.col2.x = tempx2;
            out.col2.y = tempy2;
        }

        public mulTrans$org_jbox2d_common_Mat22(B : Mat22) : Mat22 {
            let C : Mat22 = new Mat22();
            C.col1.x = org.jbox2d.common.Vec2.dot(this.col1, B.col1);
            C.col1.y = org.jbox2d.common.Vec2.dot(this.col2, B.col1);
            C.col2.x = org.jbox2d.common.Vec2.dot(this.col1, B.col2);
            C.col2.y = org.jbox2d.common.Vec2.dot(this.col2, B.col2);
            return C;
        }

        /**
         * Multiply another matrix by the transpose of this one (transpose of this one on left).
         * djm: optimized
         * @param {org.jbox2d.common.Mat22} B
         * @return
         * @return {org.jbox2d.common.Mat22}
         */
        public mulTrans(B? : any) : any {
            if(((B != null && B instanceof <any>org.jbox2d.common.Mat22) || B === null)) {
                return <any>this.mulTrans$org_jbox2d_common_Mat22(B);
            } else if(((B != null && B instanceof <any>org.jbox2d.common.Vec2) || B === null)) {
                return <any>this.mulTrans$org_jbox2d_common_Vec2(B);
            } else throw new Error('invalid overload');
        }

        public mulTransLocal(B : Mat22) : Mat22 {
            this.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(B, this);
            return this;
        }

        public mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(B : Mat22, out : Mat22) {
            let x1 : number = (<any>Math).fround((<any>Math).fround(this.col1.x * B.col1.x) + (<any>Math).fround(this.col1.y * B.col1.y));
            let y1 : number = (<any>Math).fround((<any>Math).fround(this.col2.x * B.col1.x) + (<any>Math).fround(this.col2.y * B.col1.y));
            let x2 : number = (<any>Math).fround((<any>Math).fround(this.col1.x * B.col2.x) + (<any>Math).fround(this.col1.y * B.col2.y));
            let y2 : number = (<any>Math).fround((<any>Math).fround(this.col2.x * B.col2.x) + (<any>Math).fround(this.col2.y * B.col2.y));
            out.col1.x = x1;
            out.col2.x = x2;
            out.col1.y = y1;
            out.col2.y = y2;
        }

        public mulTransToOut(B? : any, out? : any) : any {
            if(((B != null && B instanceof <any>org.jbox2d.common.Mat22) || B === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>this.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(B, out);
            } else if(((B != null && B instanceof <any>org.jbox2d.common.Vec2) || B === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>this.mulTransToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(B, out);
            } else throw new Error('invalid overload');
        }

        public mulTrans$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2(((<any>Math).fround((<any>Math).fround(v.x * this.col1.x) + (<any>Math).fround(v.y * this.col1.y))), ((<any>Math).fround((<any>Math).fround(v.x * this.col2.x) + (<any>Math).fround(v.y * this.col2.y))));
        }

        public mulTransToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            out.x = (<any>Math).fround((<any>Math).fround(v.x * this.col1.x) + (<any>Math).fround(v.y * this.col1.y));
            out.y = org.jbox2d.common.Vec2.dot(v, this.col2);
        }

        /**
         * Add this matrix to B, return the result.
         * @param {org.jbox2d.common.Mat22} B
         * @return
         * @return {org.jbox2d.common.Mat22}
         */
        public add(B : Mat22) : Mat22 {
            let m : Mat22 = new Mat22();
            m.col1.x = (<any>Math).fround(this.col1.x + B.col1.x);
            m.col1.y = (<any>Math).fround(this.col1.y + B.col1.y);
            m.col2.x = (<any>Math).fround(this.col2.x + B.col2.x);
            m.col2.y = (<any>Math).fround(this.col2.y + B.col2.y);
            return m;
        }

        /**
         * Add B to this matrix locally.
         * @param {org.jbox2d.common.Mat22} B
         * @return
         * @return {org.jbox2d.common.Mat22}
         */
        public addLocal(B : Mat22) : Mat22 {
            this.col1.x += B.col1.x;
            this.col1.y += B.col1.y;
            this.col2.x += B.col2.x;
            this.col2.y += B.col2.y;
            return this;
        }

        /**
         * Solve A * x = b where A = this matrix.
         * @return {org.jbox2d.common.Vec2} The vector x that solves the above equation.
         * @param {org.jbox2d.common.Vec2} b
         */
        public solve(b : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let a11 : number = this.col1.x;
            let a12 : number = this.col2.x;
            let a21 : number = this.col1.y;
            let a22 : number = this.col2.y;
            let det : number = (<any>Math).fround((<any>Math).fround(a11 * a22) - (<any>Math).fround(a12 * a21));
            if(!((det !== 0.0))) throw new Error("Assertion error line 365: assert (det != 0.0F);");;
            det = (<any>Math).fround(1.0 / det);
            let x : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a22 * b.x) - (<any>Math).fround(a12 * b.y)))), (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a11 * b.y) - (<any>Math).fround(a21 * b.x)))));
            return x;
        }

        public solveToOut(b : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let a11 : number = this.col1.x;
            let a12 : number = this.col2.x;
            let a21 : number = this.col1.y;
            let a22 : number = this.col2.y;
            let det : number = (<any>Math).fround((<any>Math).fround(a11 * a22) - (<any>Math).fround(a12 * a21));
            if(!((det !== 0.0))) throw new Error("Assertion error line 377: assert (det != 0.0F);");;
            det = (<any>Math).fround(1.0 / det);
            let tempy : number = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a11 * b.y) - (<any>Math).fround(a21 * b.x))));
            out.x = (<any>Math).fround(det * ((<any>Math).fround((<any>Math).fround(a22 * b.x) - (<any>Math).fround(a12 * b.y))));
            out.y = tempy;
        }

        public static mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R : Mat22, v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2((<any>Math).fround((<any>Math).fround(R.col1.x * v.x) + (<any>Math).fround(R.col2.x * v.y)), (<any>Math).fround((<any>Math).fround(R.col1.y * v.x) + (<any>Math).fround(R.col2.y * v.y)));
        }

        public static mul(R? : any, v? : any) : any {
            if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null)) {
                return <any>org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R, v);
            } else if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null)) {
                return <any>org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v);
            } else throw new Error('invalid overload');
        }

        public static mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R : Mat22, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempy : number = (<any>Math).fround((<any>Math).fround(R.col1.y * v.x) + (<any>Math).fround(R.col2.y * v.y));
            out.x = (<any>Math).fround((<any>Math).fround(R.col1.x * v.x) + (<any>Math).fround(R.col2.x * v.y));
            out.y = tempy;
        }

        public static mulToOut(R? : any, v? : any, out? : any) : any {
            if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R, v, out);
            } else if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v, out);
            } else throw new Error('invalid overload');
        }

        public static mul$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A : Mat22, B : Mat22) : Mat22 {
            let C : Mat22 = new Mat22();
            C.col1.x = (<any>Math).fround((<any>Math).fround(A.col1.x * B.col1.x) + (<any>Math).fround(A.col2.x * B.col1.y));
            C.col1.y = (<any>Math).fround((<any>Math).fround(A.col1.y * B.col1.x) + (<any>Math).fround(A.col2.y * B.col1.y));
            C.col2.x = (<any>Math).fround((<any>Math).fround(A.col1.x * B.col2.x) + (<any>Math).fround(A.col2.x * B.col2.y));
            C.col2.y = (<any>Math).fround((<any>Math).fround(A.col1.y * B.col2.x) + (<any>Math).fround(A.col2.y * B.col2.y));
            return C;
        }

        public static mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A : Mat22, B : Mat22, out : Mat22) {
            let tempy1 : number = (<any>Math).fround((<any>Math).fround(A.col1.y * B.col1.x) + (<any>Math).fround(A.col2.y * B.col1.y));
            let tempx1 : number = (<any>Math).fround((<any>Math).fround(A.col1.x * B.col1.x) + (<any>Math).fround(A.col2.x * B.col1.y));
            let tempy2 : number = (<any>Math).fround((<any>Math).fround(A.col1.y * B.col2.x) + (<any>Math).fround(A.col2.y * B.col2.y));
            let tempx2 : number = (<any>Math).fround((<any>Math).fround(A.col1.x * B.col2.x) + (<any>Math).fround(A.col2.x * B.col2.y));
            out.col1.x = tempx1;
            out.col1.y = tempy1;
            out.col2.x = tempx2;
            out.col2.y = tempy2;
        }

        public static mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R : Mat22, v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2(((<any>Math).fround((<any>Math).fround(v.x * R.col1.x) + (<any>Math).fround(v.y * R.col1.y))), ((<any>Math).fround((<any>Math).fround(v.x * R.col2.x) + (<any>Math).fround(v.y * R.col2.y))));
        }

        public static mulTrans(R? : any, v? : any) : any {
            if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null)) {
                return <any>org.jbox2d.common.Mat22.mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R, v);
            } else if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null)) {
                return <any>org.jbox2d.common.Mat22.mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v);
            } else throw new Error('invalid overload');
        }

        public static mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R : Mat22, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let outx : number = (<any>Math).fround((<any>Math).fround(v.x * R.col1.x) + (<any>Math).fround(v.y * R.col1.y));
            out.y = (<any>Math).fround((<any>Math).fround(v.x * R.col2.x) + (<any>Math).fround(v.y * R.col2.y));
            out.x = outx;
        }

        public static mulTransToOut(R? : any, v? : any, out? : any) : any {
            if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R, v, out);
            } else if(((R != null && R instanceof <any>org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof <any>org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v, out);
            } else throw new Error('invalid overload');
        }

        public static mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A : Mat22, B : Mat22) : Mat22 {
            let C : Mat22 = new Mat22();
            C.col1.x = (<any>Math).fround((<any>Math).fround(A.col1.x * B.col1.x) + (<any>Math).fround(A.col1.y * B.col1.y));
            C.col1.y = (<any>Math).fround((<any>Math).fround(A.col2.x * B.col1.x) + (<any>Math).fround(A.col2.y * B.col1.y));
            C.col2.x = (<any>Math).fround((<any>Math).fround(A.col1.x * B.col2.x) + (<any>Math).fround(A.col1.y * B.col2.y));
            C.col2.y = (<any>Math).fround((<any>Math).fround(A.col2.x * B.col2.x) + (<any>Math).fround(A.col2.y * B.col2.y));
            return C;
        }

        public static mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A : Mat22, B : Mat22, out : Mat22) {
            let x1 : number = (<any>Math).fround((<any>Math).fround(A.col1.x * B.col1.x) + (<any>Math).fround(A.col1.y * B.col1.y));
            let y1 : number = (<any>Math).fround((<any>Math).fround(A.col2.x * B.col1.x) + (<any>Math).fround(A.col2.y * B.col1.y));
            let x2 : number = (<any>Math).fround((<any>Math).fround(A.col1.x * B.col2.x) + (<any>Math).fround(A.col1.y * B.col2.y));
            let y2 : number = (<any>Math).fround((<any>Math).fround(A.col2.x * B.col2.x) + (<any>Math).fround(A.col2.y * B.col2.y));
            out.col1.x = x1;
            out.col1.y = y1;
            out.col2.x = x2;
            out.col2.y = y2;
        }

        public static createRotationalTransform$float(angle : number) : Mat22 {
            let mat : Mat22 = new Mat22();
            let c : number = org.jbox2d.common.MathUtils.cos(angle);
            let s : number = org.jbox2d.common.MathUtils.sin(angle);
            mat.col1.x = c;
            mat.col2.x = -s;
            mat.col1.y = s;
            mat.col2.y = c;
            return mat;
        }

        public static createRotationalTransform$float$org_jbox2d_common_Mat22(angle : number, out : Mat22) {
            let c : number = org.jbox2d.common.MathUtils.cos(angle);
            let s : number = org.jbox2d.common.MathUtils.sin(angle);
            out.col1.x = c;
            out.col2.x = -s;
            out.col1.y = s;
            out.col2.y = c;
        }

        public static createRotationalTransform(angle? : any, out? : any) : any {
            if(((typeof angle === 'number') || angle === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>org.jbox2d.common.Mat22.createRotationalTransform$float$org_jbox2d_common_Mat22(angle, out);
            } else if(((typeof angle === 'number') || angle === null) && out === undefined) {
                return <any>org.jbox2d.common.Mat22.createRotationalTransform$float(angle);
            } else throw new Error('invalid overload');
        }

        public static createScaleTransform$float(scale : number) : Mat22 {
            let mat : Mat22 = new Mat22();
            mat.col1.x = scale;
            mat.col2.y = scale;
            return mat;
        }

        public static createScaleTransform$float$float(scaleX : number, scaleY : number) : Mat22 {
            let mat : Mat22 = new Mat22();
            mat.col1.x = scaleX;
            mat.col2.y = scaleY;
            return mat;
        }

        public static createScaleTransform$float$org_jbox2d_common_Mat22(scale : number, out : Mat22) {
            out.col1.x = scale;
            out.col1.y = 0;
            out.col2.x = 0;
            out.col2.y = scale;
        }

        public static createScaleTransform$float$float$org_jbox2d_common_Mat22(scaleX : number, scaleY : number, out : Mat22) {
            out.col1.x = scaleX;
            out.col1.y = 0;
            out.col2.x = 0;
            out.col2.y = scaleY;
        }

        public static createScaleTransform(scaleX? : any, scaleY? : any, out? : any) : any {
            if(((typeof scaleX === 'number') || scaleX === null) && ((typeof scaleY === 'number') || scaleY === null) && ((out != null && out instanceof <any>org.jbox2d.common.Mat22) || out === null)) {
                return <any>org.jbox2d.common.Mat22.createScaleTransform$float$float$org_jbox2d_common_Mat22(scaleX, scaleY, out);
            } else if(((typeof scaleX === 'number') || scaleX === null) && ((scaleY != null && scaleY instanceof <any>org.jbox2d.common.Mat22) || scaleY === null) && out === undefined) {
                return <any>org.jbox2d.common.Mat22.createScaleTransform$float$org_jbox2d_common_Mat22(scaleX, scaleY);
            } else if(((typeof scaleX === 'number') || scaleX === null) && ((typeof scaleY === 'number') || scaleY === null) && out === undefined) {
                return <any>org.jbox2d.common.Mat22.createScaleTransform$float$float(scaleX, scaleY);
            } else if(((typeof scaleX === 'number') || scaleX === null) && scaleY === undefined && out === undefined) {
                return <any>org.jbox2d.common.Mat22.createScaleTransform$float(scaleX);
            } else throw new Error('invalid overload');
        }
    }
    Mat22["__class"] = "org.jbox2d.common.Mat22";

}
namespace org.jbox2d.common {
    export class Mat33 {
        public col1 : org.jbox2d.common.Vec3;

        public col2 : org.jbox2d.common.Vec3;

        public col3 : org.jbox2d.common.Vec3;

        public constructor(argCol1? : any, argCol2? : any, argCol3? : any) {
            if(((argCol1 != null && argCol1 instanceof <any>org.jbox2d.common.Vec3) || argCol1 === null) && ((argCol2 != null && argCol2 instanceof <any>org.jbox2d.common.Vec3) || argCol2 === null) && ((argCol3 != null && argCol3 instanceof <any>org.jbox2d.common.Vec3) || argCol3 === null)) {
                let __args = arguments;
                if(this.col1===undefined) this.col1 = null;
                if(this.col2===undefined) this.col2 = null;
                if(this.col3===undefined) this.col3 = null;
                this.temp = new org.jbox2d.common.Vec3();
                if(this.col1===undefined) this.col1 = null;
                if(this.col2===undefined) this.col2 = null;
                if(this.col3===undefined) this.col3 = null;
                (() => {
                    this.col1 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(argCol1);
                    this.col2 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(argCol2);
                    this.col3 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(argCol3);
                })();
            } else if(argCol1 === undefined && argCol2 === undefined && argCol3 === undefined) {
                let __args = arguments;
                if(this.col1===undefined) this.col1 = null;
                if(this.col2===undefined) this.col2 = null;
                if(this.col3===undefined) this.col3 = null;
                this.temp = new org.jbox2d.common.Vec3();
                if(this.col1===undefined) this.col1 = null;
                if(this.col2===undefined) this.col2 = null;
                if(this.col3===undefined) this.col3 = null;
                (() => {
                    this.col1 = new org.jbox2d.common.Vec3();
                    this.col2 = new org.jbox2d.common.Vec3();
                    this.col3 = new org.jbox2d.common.Vec3();
                })();
            } else throw new Error('invalid overload');
        }

        public setZero() {
            this.col1.setZero();
            this.col2.setZero();
            this.col3.setZero();
        }

        public static mul(A : Mat33, v : org.jbox2d.common.Vec3) : org.jbox2d.common.Vec3 {
            return new org.jbox2d.common.Vec3((<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.col1.x) + (<any>Math).fround(v.y * A.col2.x)) + v.z) + A.col3.x), (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.col1.y) + (<any>Math).fround(v.y * A.col2.y)) + (<any>Math).fround(v.z * A.col3.y)), (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.col1.z) + (<any>Math).fround(v.y * A.col2.z)) + (<any>Math).fround(v.z * A.col3.z)));
        }

        public static mulToOut(A : Mat33, v : org.jbox2d.common.Vec3, out : org.jbox2d.common.Vec3) {
            let tempy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.col1.y) + (<any>Math).fround(v.y * A.col2.y)) + (<any>Math).fround(v.z * A.col3.y));
            let tempz : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.col1.z) + (<any>Math).fround(v.y * A.col2.z)) + (<any>Math).fround(v.z * A.col3.z));
            out.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(v.x * A.col1.x) + (<any>Math).fround(v.y * A.col2.x)) + v.z) + A.col3.x);
            out.y = tempy;
            out.z = tempz;
        }

        /*private*/ temp : org.jbox2d.common.Vec3 = new org.jbox2d.common.Vec3();

        public solve(b : org.jbox2d.common.Vec3) : org.jbox2d.common.Vec3 {
            org.jbox2d.common.Vec3.crossToOut(this.col1, this.col2, this.temp);
            let det : number = org.jbox2d.common.Vec3.dot(this.col1, this.temp);
            if(!((det !== 0.0))) throw new Error("Assertion error line 64: assert (det != 0.0F);");;
            det = (<any>Math).fround(1.0 / det);
            let x : org.jbox2d.common.Vec3 = new org.jbox2d.common.Vec3();
            org.jbox2d.common.Vec3.crossToOut(this.col2, this.col3, this.temp);
            x.x = (<any>Math).fround(det * org.jbox2d.common.Vec3.dot(b, this.temp));
            org.jbox2d.common.Vec3.crossToOut(b, this.col3, this.temp);
            x.y = (<any>Math).fround(det * org.jbox2d.common.Vec3.dot(this.col1, this.temp));
            org.jbox2d.common.Vec3.crossToOut(this.col2, b, this.temp);
            x.z = (<any>Math).fround(det * org.jbox2d.common.Vec3.dot(this.col1, this.temp));
            return x;
        }

        public solveToOut(b : org.jbox2d.common.Vec3, out : org.jbox2d.common.Vec3) {
            org.jbox2d.common.Vec3.crossToOut(this.col1, this.col2, out);
            let det : number = org.jbox2d.common.Vec3.dot(this.col1, out);
            if(!((det !== 0.0))) throw new Error("Assertion error line 79: assert (det != 0.0F);");;
            det = (<any>Math).fround(1.0 / det);
            org.jbox2d.common.Vec3.crossToOut(this.col2, this.col3, out);
            let tempx : number = (<any>Math).fround(det * org.jbox2d.common.Vec3.dot(b, out));
            org.jbox2d.common.Vec3.crossToOut(b, this.col3, out);
            let tempy : number = (<any>Math).fround(det * org.jbox2d.common.Vec3.dot(this.col1, out));
            org.jbox2d.common.Vec3.crossToOut(this.col2, b, out);
            let tempz : number = (<any>Math).fround(det * org.jbox2d.common.Vec3.dot(this.col1, out));
            out.x = tempx;
            out.y = tempy;
            out.z = tempz;
        }
    }
    Mat33["__class"] = "org.jbox2d.common.Mat33";

}
namespace org.jbox2d.common {
    export class RaycastResult {
        public lambda : number = 0.0;

        public normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public set(argOther : RaycastResult) : RaycastResult {
            this.lambda = argOther.lambda;
            this.normal.set$org_jbox2d_common_Vec2(argOther.normal);
            return this;
        }
    }
    RaycastResult["__class"] = "org.jbox2d.common.RaycastResult";

}
namespace org.jbox2d.common {
    /**
     * Global tuning constants based on MKS units and various integer maximums (vertices per shape, pairs, etc.).
     * @class
     */
    export class Settings {
        /**
         * A "close to zero" float epsilon value for use
         */
        public static EPSILON : number = 1.1920929E-7;

        /**
         * Pi.
         */
        public static pi : number; public static pi_$LI$() : number { if(Settings.pi == null) Settings.pi = (<any>Math).fround(Math.PI); return Settings.pi; };

        /**
         * needs to be final, or will slow down math methods
         */
        public static FAST_MATH : boolean = true;

        public static SINCOS_LUT_ENABLED : boolean = true;

        /**
         * smaller the precision, the larger the table.  If
         * a small table is used (eg, precision is .006 or greater),
         * make sure you set the table to lerp it's results.  Accuracy chart
         * is in the MathUtils source.  Or, run the tests
         * yourself in {@link org.jbox2d.testbed.mathtests.SinCosTest}.</br>
         * </br>
         * Good lerp precision values:
         * <ul><li>.0092</li>
         * <li>.008201</li>
         * <li>.005904</li>
         * <li>.005204</li>
         * <li>.004305</li>
         * <li>.002807</li>
         * <li>.001508</li>
         * <li>9.32500E-4</li>
         * <li>7.48000E-4</li>
         * <li>8.47000E-4</li>
         * <li>.0005095</li>
         * <li>.0001098</li>
         * <li>9.50499E-5</li>
         * <li>6.08500E-5</li>
         * <li>3.07000E-5</li>
         * <li>1.53999E-5</li></ul>
         * 
         */
        public static SINCOS_LUT_PRECISION : number = 0.00131;

        public static SINCOS_LUT_LENGTH : number; public static SINCOS_LUT_LENGTH_$LI$() : number { if(Settings.SINCOS_LUT_LENGTH == null) Settings.SINCOS_LUT_LENGTH = (<number>Math.ceil(Math.PI * 2 / Settings.SINCOS_LUT_PRECISION)|0); return Settings.SINCOS_LUT_LENGTH; };

        /**
         * Use if the table's precision is large (eg .006 or greater).
         * Although it is more expensive, it greatly increases
         * accuracy.  Look in the MathUtils source for some test results
         * on the accuracy and speed of lerp vs non lerp.  Or, run the tests
         * yourself in {@link org.jbox2d.testbed.mathtests.SinCosTest}.
         */
        public static SINCOS_LUT_LERP : boolean = false;

        public static lengthUnitsPerMeter : number = 1.0;

        public static massUnitsPerKilogram : number = 1.0;

        public static timeUnitsPerSecond : number = 1.0;

        public static maxManifoldPoints : number = 2;

        public static maxShapesPerBody : number = 64;

        public static maxPolygonVertices : number = 8;

        /**
         * Must be a power of two.
         */
        public static maxProxies : number = 64;

        /**
         * Must be a power of two.
         */
        public static maxPairs : number; public static maxPairs_$LI$() : number { if(Settings.maxPairs == null) Settings.maxPairs = 64 * Settings.maxProxies; return Settings.maxPairs; };

        /**
         * A small length used as a collision and constraint tolerance. Usually it is
         * chosen to be numerically significant, but visually insignificant.
         */
        public static linearSlop : number; public static linearSlop_$LI$() : number { if(Settings.linearSlop == null) Settings.linearSlop = (<any>Math).fround(0.005 * Settings.lengthUnitsPerMeter); return Settings.linearSlop; };

        /**
         * A small angle used as a collision and constraint tolerance. Usually it is
         * chosen to be numerically significant, but visually insignificant.
         */
        public static angularSlop : number; public static angularSlop_$LI$() : number { if(Settings.angularSlop == null) Settings.angularSlop = (<any>Math).fround((<any>Math).fround(2.0 / 180.0) * Settings.pi_$LI$()); return Settings.angularSlop; };

        /**
         * A velocity threshold for elastic collisions. Any collision with a relative linear
         * velocity below this threshold will be treated as inelastic.
         */
        public static velocityThreshold : number; public static velocityThreshold_$LI$() : number { if(Settings.velocityThreshold == null) Settings.velocityThreshold = (<any>Math).fround((<any>Math).fround(1.0 * Settings.lengthUnitsPerMeter) / Settings.timeUnitsPerSecond); return Settings.velocityThreshold; };

        /**
         * The maximum linear position correction used when solving constraints. This helps to
         * prevent overshoot.
         */
        public static maxLinearCorrection : number; public static maxLinearCorrection_$LI$() : number { if(Settings.maxLinearCorrection == null) Settings.maxLinearCorrection = (<any>Math).fround(0.2 * Settings.lengthUnitsPerMeter); return Settings.maxLinearCorrection; };

        /**
         * The maximum angular position correction used when solving constraints. This helps to
         * prevent overshoot.
         */
        public static maxAngularCorrection : number; public static maxAngularCorrection_$LI$() : number { if(Settings.maxAngularCorrection == null) Settings.maxAngularCorrection = (<any>Math).fround((<any>Math).fround(8.0 / 180.0) * Settings.pi_$LI$()); return Settings.maxAngularCorrection; };

        /**
         * This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
         * that overlap is removed in one time step. However using values close to 1 often lead
         * to overshoot.
         */
        public static contactBaumgarte : number = 0.2;

        /**
         * The time that a body must be still before it will go to sleep.
         */
        public static timeToSleep : number; public static timeToSleep_$LI$() : number { if(Settings.timeToSleep == null) Settings.timeToSleep = (<any>Math).fround(0.5 * Settings.timeUnitsPerSecond); return Settings.timeToSleep; };

        /**
         * A body cannot sleep if its linear velocity is above this tolerance.
         */
        public static linearSleepTolerance : number; public static linearSleepTolerance_$LI$() : number { if(Settings.linearSleepTolerance == null) Settings.linearSleepTolerance = (<any>Math).fround((<any>Math).fround(0.01 * Settings.lengthUnitsPerMeter) / Settings.timeUnitsPerSecond); return Settings.linearSleepTolerance; };

        /**
         * A body cannot sleep if its angular velocity is above this tolerance.
         */
        public static angularSleepTolerance : number; public static angularSleepTolerance_$LI$() : number { if(Settings.angularSleepTolerance == null) Settings.angularSleepTolerance = (<any>Math).fround((<any>Math).fround(2.0 / 180.0) / Settings.timeUnitsPerSecond); return Settings.angularSleepTolerance; };

        /**
         * Continuous collision detection (CCD) works with core, shrunken shapes. This is the
         * amount by which shapes are automatically shrunk to work with CCD. This must be
         * larger than b2_linearSlop.
         */
        public static toiSlop : number; public static toiSlop_$LI$() : number { if(Settings.toiSlop == null) Settings.toiSlop = (<any>Math).fround(8.0 * Settings.linearSlop_$LI$()); return Settings.toiSlop; };

        /**
         * The maximum linear velocity of a body. This limit is very large and is used
         * to prevent numerical problems. You shouldn't need to adjust this.
         */
        public static maxLinearVelocity : number = 200.0;

        public static maxLinearVelocitySquared : number; public static maxLinearVelocitySquared_$LI$() : number { if(Settings.maxLinearVelocitySquared == null) Settings.maxLinearVelocitySquared = (<any>Math).fround(Settings.maxLinearVelocity * Settings.maxLinearVelocity); return Settings.maxLinearVelocitySquared; };

        /**
         * The maximum angular velocity of a body. This limit is very large and is used
         * to prevent numerical problems. You shouldn't need to adjust this.
         */
        public static maxAngularVelocity : number = 250.0;

        public static maxAngularVelocitySquared : number; public static maxAngularVelocitySquared_$LI$() : number { if(Settings.maxAngularVelocitySquared == null) Settings.maxAngularVelocitySquared = (<any>Math).fround(Settings.maxAngularVelocity * Settings.maxAngularVelocity); return Settings.maxAngularVelocitySquared; };

        /**
         * Maximum number of contacts to be handled to solve a TOI island.
         */
        public static maxTOIContactsPerIsland : number = 32;

        /**
         * Maximum number of joints to be handled to solve a TOI island.
         */
        public static maxTOIJointsPerIsland : number = 0;
    }
    Settings["__class"] = "org.jbox2d.common.Settings";

}
namespace org.jbox2d.common {
    /**
     * Primarily for internal use.
     * <BR><BR>
     * Describes the motion of a body/shape for TOI computation.
     * Shapes are defined with respect to the body origin, which may
     * not coincide with the center of mass. However, to support dynamics
     * we must interpolate the center of mass position.
     * 
     * @class
     */
    export class Sweep {
        /**
         * Local center of mass position
         */
        public localCenter : org.jbox2d.common.Vec2;

        /**
         * Center world positions
         */
        public c0 : org.jbox2d.common.Vec2;

        /**
         * Center world positions
         */
        public c : org.jbox2d.common.Vec2;

        /**
         * World angles
         */
        public a0 : number;

        /**
         * World angles
         */
        public a : number;

        /**
         * Time interval = [t0,1], where t0 is in [0,1]
         */
        public t0 : number;

        public toString() : string {
            let s : string = "Sweep:\nlocalCenter: " + this.localCenter + "\n";
            s += "c0: " + this.c0 + ", c: " + this.c + "\n";
            s += "a0: " + this.a0 + ", a: " + this.a + "\n";
            s += "t0: " + this.t0 + "\n";
            return s;
        }

        public constructor() {
            if(this.localCenter===undefined) this.localCenter = null;
            if(this.c0===undefined) this.c0 = null;
            if(this.c===undefined) this.c = null;
            if(this.a0===undefined) this.a0 = 0;
            if(this.a===undefined) this.a = 0;
            if(this.t0===undefined) this.t0 = 0;
            this.localCenter = new org.jbox2d.common.Vec2();
            this.c0 = new org.jbox2d.common.Vec2();
            this.c = new org.jbox2d.common.Vec2();
        }

        public set(argCloneFrom : Sweep) : Sweep {
            this.localCenter.set$org_jbox2d_common_Vec2(argCloneFrom.localCenter);
            this.c0.set$org_jbox2d_common_Vec2(argCloneFrom.c0);
            this.c.set$org_jbox2d_common_Vec2(argCloneFrom.c);
            this.a0 = argCloneFrom.a0;
            this.a = argCloneFrom.a;
            this.t0 = argCloneFrom.t0;
            return this;
        }

        /**
         * Get the interpolated transform at a specific time.
         * @param {org.jbox2d.common.XForm} xf the result is placed here - must not be null
         * @param {number} t the normalized time in [0,1].
         */
        public getXForm(xf : org.jbox2d.common.XForm, t : number) {
            if(!((xf != null))) throw new Error("Assertion error line 79: assert (xf != null);");;
            if((<any>Math).fround(1.0 - this.t0) > org.jbox2d.common.Settings.EPSILON) {
                let alpha : number = (<any>Math).fround(((<any>Math).fround(t - this.t0)) / ((<any>Math).fround(1.0 - this.t0)));
                xf.position.x = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - alpha)) * this.c0.x) + (<any>Math).fround(alpha * this.c.x));
                xf.position.y = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - alpha)) * this.c0.y) + (<any>Math).fround(alpha * this.c.y));
                let angle : number = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - alpha)) * this.a0) + (<any>Math).fround(alpha * this.a));
                xf.R.set$float(angle);
            } else {
                xf.position.set$org_jbox2d_common_Vec2(this.c);
                xf.R.set$float(this.a);
            }
            xf.position.x -= (<any>Math).fround((<any>Math).fround(xf.R.col1.x * this.localCenter.x) + (<any>Math).fround(xf.R.col2.x * this.localCenter.y));
            xf.position.y -= (<any>Math).fround((<any>Math).fround(xf.R.col1.y * this.localCenter.x) + (<any>Math).fround(xf.R.col2.y * this.localCenter.y));
        }

        /**
         * 
         * Advance the sweep forward, yielding a new initial state.
         * @param {number} t the new initial time.
         */
        public advance(t : number) {
            if(this.t0 < t && (<any>Math).fround(1.0 - this.t0) > org.jbox2d.common.Settings.EPSILON) {
                let alpha : number = (<any>Math).fround(((<any>Math).fround(t - this.t0)) / ((<any>Math).fround(1.0 - this.t0)));
                this.c0.x = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - alpha)) * this.c0.x) + (<any>Math).fround(alpha * this.c.x));
                this.c0.y = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - alpha)) * this.c0.y) + (<any>Math).fround(alpha * this.c.y));
                this.a0 = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - alpha)) * this.a0) + (<any>Math).fround(alpha * this.a));
                this.t0 = t;
            }
        }
    }
    Sweep["__class"] = "org.jbox2d.common.Sweep";

}
namespace org.jbox2d.common {
    /**
     * A 2-dimensional vector class.  Used heavily in JBox2d.
     * djm: added ToOut methods
     * @param {number} x
     * @param {number} y
     * @class
     */
    export class Vec2 {
        /**
         * Should we count Vec2 creations?
         */
        public static watchCreations : boolean = true;

        /**
         * Running count of Vec2 creations.  Must be zeroed out
         * manually (perhaps at start of time step).  Incremented
         * in Vec2 constructor if watchCreations flag is true.
         * <BR><BR>
         * Mainly used for optimization purposes, since temporary
         * Vec2 creation is often a bottleneck.
         */
        public static creationCount : number = 0;

        public x : number;

        public y : number;

        public constructor(x? : any, y? : any) {
            if(((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                let __args = arguments;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                (() => {
                    if(Vec2.watchCreations) {
                        ++Vec2.creationCount;
                    }
                    this.x = x;
                    this.y = y;
                })();
            } else if(((x != null && x instanceof <any>org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                let __args = arguments;
                let toCopy : any = __args[0];
                {
                    let __args = arguments;
                    let x : any = toCopy.x;
                    let y : any = toCopy.y;
                    if(this.x===undefined) this.x = 0;
                    if(this.y===undefined) this.y = 0;
                    if(this.x===undefined) this.x = 0;
                    if(this.y===undefined) this.y = 0;
                    (() => {
                        if(Vec2.watchCreations) {
                            ++Vec2.creationCount;
                        }
                        this.x = x;
                        this.y = y;
                    })();
                }
            } else if(x === undefined && y === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let x : any = 0;
                    let y : any = 0;
                    if(this.x===undefined) this.x = 0;
                    if(this.y===undefined) this.y = 0;
                    if(this.x===undefined) this.x = 0;
                    if(this.y===undefined) this.y = 0;
                    (() => {
                        if(Vec2.watchCreations) {
                            ++Vec2.creationCount;
                        }
                        this.x = x;
                        this.y = y;
                    })();
                }
            } else throw new Error('invalid overload');
        }

        /**
         * Zero out this vector.
         */
        public setZero() {
            this.x = 0.0;
            this.y = 0.0;
        }

        public set$float$float(x : number, y : number) {
            this.x = x;
            this.y = y;
        }

        /**
         * Set the vector component-wise.
         * @param {number} x
         * @param {number} y
         */
        public set(x? : any, y? : any) : any {
            if(((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return <any>this.set$float$float(x, y);
            } else if(((x != null && x instanceof <any>org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                return <any>this.set$org_jbox2d_common_Vec2(x);
            } else throw new Error('invalid overload');
        }

        public set$org_jbox2d_common_Vec2(v : Vec2) : Vec2 {
            this.x = v.x;
            this.y = v.y;
            return this;
        }

        /**
         * Return the sum of this vector and another; does not alter either one.
         * @param {org.jbox2d.common.Vec2} v
         * @return {org.jbox2d.common.Vec2}
         */
        public add(v : Vec2) : Vec2 {
            return new Vec2((<any>Math).fround(this.x + v.x), (<any>Math).fround(this.y + v.y));
        }

        /**
         * Return the difference of this vector and another; does not alter either one.
         * @param {org.jbox2d.common.Vec2} v
         * @return {org.jbox2d.common.Vec2}
         */
        public sub(v : Vec2) : Vec2 {
            return new Vec2((<any>Math).fround(this.x - v.x), (<any>Math).fround(this.y - v.y));
        }

        /**
         * Return this vector multiplied by a scalar; does not alter this vector.
         * @param {number} a
         * @return {org.jbox2d.common.Vec2}
         */
        public mul(a : number) : Vec2 {
            return new Vec2((<any>Math).fround(this.x * a), (<any>Math).fround(this.y * a));
        }

        /**
         * Return the negation of this vector; does not alter this vector.
         * @return {org.jbox2d.common.Vec2}
         */
        public negate() : Vec2 {
            return new Vec2(-this.x, -this.y);
        }

        /**
         * Flip the vector and return it - alters this vector.
         * @return {org.jbox2d.common.Vec2}
         */
        public negateLocal() : Vec2 {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        }

        public addLocal$org_jbox2d_common_Vec2(v : Vec2) : Vec2 {
            this.x += v.x;
            this.y += v.y;
            return this;
        }

        public addLocal$float$float(x : number, y : number) : Vec2 {
            this.x += x;
            this.y += y;
            return this;
        }

        /**
         * Adds values to this vector and returns result - alters this vector.
         * @param {number} x
         * @param {number} y
         * @return {org.jbox2d.common.Vec2}
         */
        public addLocal(x? : any, y? : any) : any {
            if(((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return <any>this.addLocal$float$float(x, y);
            } else if(((x != null && x instanceof <any>org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                return <any>this.addLocal$org_jbox2d_common_Vec2(x);
            } else throw new Error('invalid overload');
        }

        /**
         * Subtract another vector from this one and return result - alters this vector.
         * @param {org.jbox2d.common.Vec2} v
         * @return {org.jbox2d.common.Vec2}
         */
        public subLocal(v : Vec2) : Vec2 {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        }

        /**
         * Multiply this vector by a number and return result - alters this vector.
         * @param {number} a
         * @return {org.jbox2d.common.Vec2}
         */
        public mulLocal(a : number) : Vec2 {
            this.x *= a;
            this.y *= a;
            return this;
        }

        /**
         * Return the length of this vector.
         * @return {number}
         */
        public length() : number {
            return org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(this.x * this.x) + (<any>Math).fround(this.y * this.y)));
        }

        /**
         * Return the squared length of this vector.
         * @return {number}
         */
        public lengthSquared() : number {
            return ((<any>Math).fround((<any>Math).fround(this.x * this.x) + (<any>Math).fround(this.y * this.y)));
        }

        /**
         * Normalize this vector and return the length before normalization.  Alters this vector.
         * @return {number}
         */
        public normalize() : number {
            let length : number = this.length();
            if(length < org.jbox2d.common.Settings.EPSILON) {
                return 0.0;
            }
            let invLength : number = (<any>Math).fround(1.0 / length);
            this.x *= invLength;
            this.y *= invLength;
            return length;
        }

        /**
         * True if the vector represents a pair of valid, non-infinite floating point numbers.
         * @return {boolean}
         */
        public isValid() : boolean {
            return this.x !== NaN && this.x !== -Infinity && this.x !== Infinity && this.y !== NaN && this.y !== -Infinity && this.y !== Infinity;
        }

        /**
         * Return a new vector that has positive components.
         * @return {org.jbox2d.common.Vec2}
         */
        public abs() : Vec2 {
            return new Vec2(org.jbox2d.common.MathUtils.abs(this.x), org.jbox2d.common.MathUtils.abs(this.y));
        }

        public absLocal() {
            this.x = org.jbox2d.common.MathUtils.abs(this.x);
            this.y = org.jbox2d.common.MathUtils.abs(this.y);
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public clone() : Vec2 {
            return new Vec2(this.x, this.y);
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            return "(" + this.x + "," + this.y + ")";
        }

        public static abs(a : Vec2) : Vec2 {
            return new Vec2(org.jbox2d.common.MathUtils.abs(a.x), org.jbox2d.common.MathUtils.abs(a.y));
        }

        public static absToOut(a : Vec2, out : Vec2) {
            out.x = org.jbox2d.common.MathUtils.abs(a.x);
            out.y = org.jbox2d.common.MathUtils.abs(a.y);
        }

        public static dot(a : Vec2, b : Vec2) : number {
            return (<any>Math).fround((<any>Math).fround(a.x * b.x) + (<any>Math).fround(a.y * b.y));
        }

        public static cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a : Vec2, b : Vec2) : number {
            return (<any>Math).fround((<any>Math).fround(a.x * b.y) - (<any>Math).fround(a.y * b.x));
        }

        public static cross(a? : any, b? : any) : any {
            if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && ((b != null && b instanceof <any>org.jbox2d.common.Vec2) || b === null)) {
                return <any>org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, b);
            } else if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && ((typeof b === 'number') || b === null)) {
                return <any>org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(a, b);
            } else if(((typeof a === 'number') || a === null) && ((b != null && b instanceof <any>org.jbox2d.common.Vec2) || b === null)) {
                return <any>org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(a, b);
            } else throw new Error('invalid overload');
        }

        public static cross$org_jbox2d_common_Vec2$float(a : Vec2, s : number) : Vec2 {
            return new Vec2((<any>Math).fround(s * a.y), (<any>Math).fround(-s * a.x));
        }

        public static crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(a : Vec2, s : number, out : Vec2) {
            let tempy : number = (<any>Math).fround(-s * a.x);
            out.x = (<any>Math).fround(s * a.y);
            out.y = tempy;
        }

        public static crossToOut(a? : any, s? : any, out? : any) : any {
            if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && ((typeof s === 'number') || s === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Vec2.crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(a, s, out);
            } else if(((typeof a === 'number') || a === null) && ((s != null && s instanceof <any>org.jbox2d.common.Vec2) || s === null) && ((out != null && out instanceof <any>org.jbox2d.common.Vec2) || out === null)) {
                return <any>org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, s, out);
            } else throw new Error('invalid overload');
        }

        public static cross$float$org_jbox2d_common_Vec2(s : number, a : Vec2) : Vec2 {
            return new Vec2((<any>Math).fround(-s * a.y), (<any>Math).fround(s * a.x));
        }

        public static crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(s : number, a : Vec2, out : Vec2) {
            let tempY : number = (<any>Math).fround(s * a.x);
            out.x = (<any>Math).fround(-s * a.y);
            out.y = tempY;
        }

        public static negateToOut(a : Vec2, out : Vec2) {
            out.x = -a.x;
            out.y = -a.y;
        }

        public static min(a : Vec2, b : Vec2) : Vec2 {
            return new Vec2(a.x < b.x?a.x:b.x, a.y < b.y?a.y:b.y);
        }

        public static max(a : Vec2, b : Vec2) : Vec2 {
            return new Vec2(a.x > b.x?a.x:b.x, a.y > b.y?a.y:b.y);
        }

        public static minToOut(a : Vec2, b : Vec2, out : Vec2) {
            out.x = a.x < b.x?a.x:b.x;
            out.y = a.y < b.y?a.y:b.y;
        }

        public static maxToOut(a : Vec2, b : Vec2, out : Vec2) {
            out.x = a.x > b.x?a.x:b.x;
            out.y = a.y > b.y?a.y:b.y;
        }

        /**
         * @see java.lang.Object#hashCode()
         * @return {number}
         */
        public hashCode() : number {
            let prime : number = 31;
            let result : number = 1;
            result = prime * result + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.x);
            result = prime * result + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.y);
            return result;
        }

        /**
         * @see java.lang.Object#equals(java.lang.Object)
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj : any) : boolean {
            if(this === obj) return true;
            if(obj == null) return false;
            if((<any>this.constructor) !== (<any>obj.constructor)) return false;
            let other : Vec2 = <Vec2>obj;
            if(/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.x) !== /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(other.x)) return false;
            if(/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.y) !== /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(other.y)) return false;
            return true;
        }
    }
    Vec2["__class"] = "org.jbox2d.common.Vec2";

}
namespace org.jbox2d.common {
    export class Vec3 {
        public x : number;

        public y : number;

        public z : number;

        public constructor(argX? : any, argY? : any, argZ? : any) {
            if(((typeof argX === 'number') || argX === null) && ((typeof argY === 'number') || argY === null) && ((typeof argZ === 'number') || argZ === null)) {
                let __args = arguments;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                (() => {
                    this.x = argX;
                    this.y = argY;
                    this.z = argZ;
                })();
            } else if(((argX != null && argX instanceof <any>org.jbox2d.common.Vec3) || argX === null) && argY === undefined && argZ === undefined) {
                let __args = arguments;
                let argCopy : any = __args[0];
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                (() => {
                    this.x = argCopy.x;
                    this.y = argCopy.y;
                    this.z = argCopy.z;
                })();
            } else if(argX === undefined && argY === undefined && argZ === undefined) {
                let __args = arguments;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                if(this.x===undefined) this.x = 0;
                if(this.y===undefined) this.y = 0;
                if(this.z===undefined) this.z = 0;
                (() => {
                    this.x = this.y = this.z = 0.0;
                })();
            } else throw new Error('invalid overload');
        }

        public set(argVec : Vec3) {
            this.x = argVec.x;
            this.y = argVec.y;
            this.z = argVec.z;
        }

        public addLocal(argVec : Vec3) : Vec3 {
            this.x += argVec.x;
            this.y += argVec.y;
            this.z += argVec.z;
            return this;
        }

        public add(argVec : Vec3) : Vec3 {
            return new Vec3((<any>Math).fround(this.x + argVec.x), (<any>Math).fround(this.y + argVec.y), (<any>Math).fround(this.z + argVec.z));
        }

        public subLocal(argVec : Vec3) : Vec3 {
            this.x -= argVec.x;
            this.y -= argVec.y;
            this.z -= argVec.z;
            return this;
        }

        public sub(argVec : Vec3) : Vec3 {
            return new Vec3((<any>Math).fround(this.x - argVec.x), (<any>Math).fround(this.y - argVec.y), (<any>Math).fround(this.z - argVec.z));
        }

        public mulLocal(argScalar : number) : Vec3 {
            this.x *= argScalar;
            this.y *= argScalar;
            this.z *= argScalar;
            return this;
        }

        public mul(argScalar : number) : Vec3 {
            return new Vec3((<any>Math).fround(this.x * argScalar), (<any>Math).fround(this.y * argScalar), (<any>Math).fround(this.z * argScalar));
        }

        public negate() : Vec3 {
            return new Vec3(-this.x, -this.y, -this.z);
        }

        public negateLocal() : Vec3 {
            this.x *= -1;
            this.y *= -1;
            this.z *= -1;
            return this;
        }

        public setZero() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }

        public clone() : Vec3 {
            return new Vec3(this);
        }

        /**
         * @see java.lang.Object#hashCode()
         * @return {number}
         */
        public hashCode() : number {
            let prime : number = 31;
            let result : number = 1;
            result = prime * result + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.x);
            result = prime * result + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.y);
            result = prime * result + /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.z);
            return result;
        }

        /**
         * @see java.lang.Object#equals(java.lang.Object)
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj : any) : boolean {
            if(this === obj) return true;
            if(obj == null) return false;
            if((<any>this.constructor) !== (<any>obj.constructor)) return false;
            let other : Vec3 = <Vec3>obj;
            if(/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.x) !== /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(other.x)) return false;
            if(/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.y) !== /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(other.y)) return false;
            if(/* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(this.z) !== /* floatToIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(other.z)) return false;
            return true;
        }

        public static dot(a : Vec3, b : Vec3) : number {
            return (<any>Math).fround((<any>Math).fround((<any>Math).fround(a.x * b.x) + (<any>Math).fround(a.y * b.y)) + (<any>Math).fround(a.z * b.z));
        }

        public static cross(a : Vec3, b : Vec3) : Vec3 {
            return new Vec3((<any>Math).fround((<any>Math).fround(a.y * b.z) - (<any>Math).fround(a.z * b.y)), (<any>Math).fround((<any>Math).fround(a.z * b.x) - (<any>Math).fround(a.x * b.z)), (<any>Math).fround((<any>Math).fround(a.x * b.y) - (<any>Math).fround(a.y * b.x)));
        }

        public static crossToOut(a : Vec3, b : Vec3, out : Vec3) {
            let tempy : number = (<any>Math).fround((<any>Math).fround(a.z * b.x) - (<any>Math).fround(a.x * b.z));
            let tempz : number = (<any>Math).fround((<any>Math).fround(a.x * b.y) - (<any>Math).fround(a.y * b.x));
            out.x = (<any>Math).fround((<any>Math).fround(a.y * b.z) - (<any>Math).fround(a.z * b.y));
            out.y = tempy;
            out.z = tempz;
        }
    }
    Vec3["__class"] = "org.jbox2d.common.Vec3";

}
namespace org.jbox2d.common {
    /**
     * Initialize using a position vector and a rotation matrix.
     * @param {org.jbox2d.common.Vec2} _position
     * @param {org.jbox2d.common.Mat22} _R
     * @class
     */
    export class XForm {
        static __static_initialized : boolean = false;
        static __static_initialize() { if(!XForm.__static_initialized) { XForm.__static_initialized = true; XForm.__static_initializer_0(); } }

        /**
         * The translation caused by the transform
         */
        public position : org.jbox2d.common.Vec2;

        /**
         * A matrix representing a rotation
         */
        public R : org.jbox2d.common.Mat22;

        public static identity : XForm; public static identity_$LI$() : XForm { XForm.__static_initialize(); return XForm.identity; };

        static __static_initializer_0() {
            XForm.identity = new XForm();
            XForm.identity_$LI$().setIdentity();
        }

        public constructor(_position? : any, _R? : any) {
            if(((_position != null && _position instanceof <any>org.jbox2d.common.Vec2) || _position === null) && ((_R != null && _R instanceof <any>org.jbox2d.common.Mat22) || _R === null)) {
                let __args = arguments;
                if(this.position===undefined) this.position = null;
                if(this.R===undefined) this.R = null;
                if(this.position===undefined) this.position = null;
                if(this.R===undefined) this.R = null;
                (() => {
                    this.position = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_position);
                    this.R = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(_R);
                })();
            } else if(((_position != null && _position instanceof <any>org.jbox2d.common.XForm) || _position === null) && _R === undefined) {
                let __args = arguments;
                let xf : any = __args[0];
                if(this.position===undefined) this.position = null;
                if(this.R===undefined) this.R = null;
                if(this.position===undefined) this.position = null;
                if(this.R===undefined) this.R = null;
                (() => {
                    this.position = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(xf.position);
                    this.R = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(xf.R);
                })();
            } else if(_position === undefined && _R === undefined) {
                let __args = arguments;
                if(this.position===undefined) this.position = null;
                if(this.R===undefined) this.R = null;
                if(this.position===undefined) this.position = null;
                if(this.R===undefined) this.R = null;
                (() => {
                    this.position = new org.jbox2d.common.Vec2();
                    this.R = new org.jbox2d.common.Mat22();
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * Set this to equal another transform.
         * @param {org.jbox2d.common.XForm} xf
         * @return {org.jbox2d.common.XForm}
         */
        public set(xf : XForm) : XForm {
            this.position.set$org_jbox2d_common_Vec2(xf.position);
            this.R.set$org_jbox2d_common_Mat22(xf.R);
            return this;
        }

        /**
         * Set this to the identity transform.
         */
        public setIdentity() {
            this.position.setZero();
            this.R.setIdentity();
        }

        public static mul(T : XForm, v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2((<any>Math).fround((<any>Math).fround(T.position.x + (<any>Math).fround(T.R.col1.x * v.x)) + (<any>Math).fround(T.R.col2.x * v.y)), (<any>Math).fround((<any>Math).fround(T.position.y + (<any>Math).fround(T.R.col1.y * v.x)) + (<any>Math).fround(T.R.col2.y * v.y)));
        }

        public static mulToOut(T : XForm, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let tempy : number = (<any>Math).fround((<any>Math).fround(T.position.y + (<any>Math).fround(T.R.col1.y * v.x)) + (<any>Math).fround(T.R.col2.y * v.y));
            out.x = (<any>Math).fround((<any>Math).fround(T.position.x + (<any>Math).fround(T.R.col1.x * v.x)) + (<any>Math).fround(T.R.col2.x * v.y));
            out.y = tempy;
        }

        public static mulTrans(T : XForm, v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let v1x : number = (<any>Math).fround(v.x - T.position.x);
            let v1y : number = (<any>Math).fround(v.y - T.position.y);
            let b : org.jbox2d.common.Vec2 = T.R.col1;
            let b1 : org.jbox2d.common.Vec2 = T.R.col2;
            return new org.jbox2d.common.Vec2(((<any>Math).fround((<any>Math).fround(v1x * b.x) + (<any>Math).fround(v1y * b.y))), ((<any>Math).fround((<any>Math).fround(v1x * b1.x) + (<any>Math).fround(v1y * b1.y))));
        }

        public static mulTransToOut(T : XForm, v : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let v1x : number = (<any>Math).fround(v.x - T.position.x);
            let v1y : number = (<any>Math).fround(v.y - T.position.y);
            let b : org.jbox2d.common.Vec2 = T.R.col1;
            let b1 : org.jbox2d.common.Vec2 = T.R.col2;
            let tempy : number = (<any>Math).fround((<any>Math).fround(v1x * b1.x) + (<any>Math).fround(v1y * b1.y));
            out.x = (<any>Math).fround((<any>Math).fround(v1x * b.x) + (<any>Math).fround(v1y * b.y));
            out.y = tempy;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let s : string = "XForm:\n";
            s += "Position: " + this.position + "\n";
            s += "R: \n" + this.R + "\n";
            return s;
        }
    }
    XForm["__class"] = "org.jbox2d.common.XForm";

}
namespace org.jbox2d.dynamics {
    /**
     * Default body definition.  Defines a body with the following characteristics:
     * <UL>
     * <LI>Zero mass/inertia (you can set this later on the Body with setMassFromShapes)
     * <LI>null userData
     * <LI>Position of (0.0f, 0.0f)
     * <LI>Zero rotation
     * <LI>Zero damping (linear + angular)
     * <LI>Able to sleep, but not sleeping to start
     * <LI>Able to rotate
     * <LI>Not a bullet
     * </UL>
     * @class
     */
    export class BodyDef {
        /**
         * You can use this to initialized the mass properties of the body.
         * If you prefer, you can set the mass properties after the shapes
         * have been added using Body::setMassFromShapes.
         */
        public massData : org.jbox2d.collision.MassData;

        /**
         * Use this to store application specific body data
         */
        public userData : any;

        /**
         * The world position of the body.  Avoid creating bodies at the origin
         * since this can lead to many overlapping shapes.
         */
        public position : org.jbox2d.common.Vec2;

        /**
         * The world angle of the body in radians.
         */
        public angle : number;

        /**
         * Linear damping is use to reduce the linear velocity. The damping parameter
         * can be larger than 1.0f but the damping effect becomes sensitive to the
         * time step when the damping parameter is large.
         */
        public linearDamping : number;

        /**
         * Angular damping is use to reduce the angular velocity. The damping parameter
         * can be larger than 1.0f but the damping effect becomes sensitive to the
         * time step when the damping parameter is large.
         */
        public angularDamping : number;

        /**
         * Set this flag to false if this body should never fall asleep.  Note that
         * this increases CPU usage.
         */
        public allowSleep : boolean;

        /**
         * Is this body initially sleeping?
         */
        public isSleeping : boolean;

        /**
         * Should this body be prevented from rotating?  Useful for characters.
         */
        public fixedRotation : boolean;

        /**
         * Is this a fast moving body that should be prevented from tunneling through
         * other moving bodies? Note that all bodies are prevented from tunneling through
         * static bodies.
         * <BR><BR><em>Warning</em>: You should use this flag sparingly since it increases processing time.
         */
        public isBullet : boolean;

        public constructor() {
            if(this.massData===undefined) this.massData = null;
            if(this.userData===undefined) this.userData = null;
            if(this.position===undefined) this.position = null;
            if(this.angle===undefined) this.angle = 0;
            if(this.linearDamping===undefined) this.linearDamping = 0;
            if(this.angularDamping===undefined) this.angularDamping = 0;
            if(this.allowSleep===undefined) this.allowSleep = false;
            if(this.isSleeping===undefined) this.isSleeping = false;
            if(this.fixedRotation===undefined) this.fixedRotation = false;
            if(this.isBullet===undefined) this.isBullet = false;
            this.massData = new org.jbox2d.collision.MassData();
            this.massData.center.setZero();
            this.massData.mass = 0.0;
            this.massData.I = 0.0;
            this.userData = null;
            this.position = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.angle = 0.0;
            this.linearDamping = 0.0;
            this.angularDamping = 0.0;
            this.allowSleep = true;
            this.isSleeping = false;
            this.fixedRotation = false;
            this.isBullet = false;
        }
    }
    BodyDef["__class"] = "org.jbox2d.dynamics.BodyDef";

}
namespace org.jbox2d.dynamics {
    /**
     * Create a BodyGroup from a group of bodies.
     * @param {Array} bodies
     * @class
     * @author eric
     */
    export class BodyGroup {
        /*private*/ children : Array<BodyGroup> = <any>([]);

        /*private*/ bodies : Array<org.jbox2d.dynamics.Body> = <any>([]);

        /*private*/ world : org.jbox2d.dynamics.World;

        public constructor(...bodies : any[]) {
            if(((bodies != null && bodies instanceof <any>Array && (bodies.length==0 || bodies[0] == null ||(bodies[0] != null && bodies[0] instanceof <any>org.jbox2d.dynamics.Body))) || bodies === null)) {
                let __args = arguments;
                if(this.world===undefined) this.world = null;
                this.children = <any>([]);
                this.bodies = <any>([]);
                if(this.world===undefined) this.world = null;
                (() => {
                    let w : org.jbox2d.dynamics.World = null;
                    for(let index147=0; index147 < bodies.length; index147++) {
                        let b = bodies[index147];
                        {
                            /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(this.bodies, b);
                            if(w == null) w = b.getWorld(); else if(b.getWorld() !== w) {
                                console.info("Cannot add bodies from different worlds to a BodyGroup");
                                if(!((false))) throw new Error("Assertion error line 30: assert (false) : 'Cannot add bodies from different worlds to a BodyGroup';");;
                            }
                        }
                    }
                    this.world = w;
                })();
            } else if(((bodies != null && bodies instanceof <any>Array && (bodies.length==0 || bodies[0] == null ||(bodies[0] != null && bodies[0] instanceof <any>org.jbox2d.dynamics.BodyGroup))) || bodies === null)) {
                let __args = arguments;
                let groups : any[] = __args[0];
                if(this.world===undefined) this.world = null;
                this.children = <any>([]);
                this.bodies = <any>([]);
                if(this.world===undefined) this.world = null;
                (() => {
                    let w : org.jbox2d.dynamics.World = null;
                    for(let index148=0; index148 < groups.length; index148++) {
                        let bg = groups[index148];
                        {
                            /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(this.children, bg);
                            if(w == null) w = bg.getWorld(); else if(bg.getWorld() !== w) {
                                console.info("Cannot add BodyGroups from different worlds to a BodyGroup");
                                if(!((false))) throw new Error("Assertion error line 51: assert (false) : 'Cannot add BodyGroups from different worlds to a BodyGroup';");;
                            }
                        }
                    }
                    this.world = w;
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * Get child BodyGroups. Does not return children-of-children.
         * @return {org.jbox2d.dynamics.BodyGroup[]}
         */
        public getChildren() : Array<BodyGroup> {
            return this.children;
        }

        /**
         * Get bodies. Does not return bodies that are members of child BodyGroups.
         * 
         * @see #getBodiesDeep()
         * @return {org.jbox2d.dynamics.Body[]}
         */
        public getBodies() : Array<org.jbox2d.dynamics.Body> {
            return this.bodies;
        }

        /**
         * Get all bodies in this group and all children, recursively.
         * 
         * @see #getBodies() for non-recursive version
         * @return {org.jbox2d.dynamics.Body[]}
         */
        public getBodiesDeep() : Array<org.jbox2d.dynamics.Body> {
            let res : Array<org.jbox2d.dynamics.Body> = <any>([]);
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(res, this.bodies);
            for(let index149=0; index149 < this.children.length; index149++) {
                let bg = this.children[index149];
                {
                    /* addAll */((l1, l2) => l1.push.apply(l1, l2))(res, bg.getBodiesDeep());
                }
            }
            return res;
        }

        /**
         * @return {org.jbox2d.dynamics.World} the world this BodyGroup lives in
         */
        public getWorld() : org.jbox2d.dynamics.World {
            return this.world;
        }

        /**
         * Create a BodyGroup by traversing the joint tree from a seed body.
         * 
         * @param {org.jbox2d.dynamics.Body} seed
         * @return {org.jbox2d.dynamics.BodyGroup}
         */
        public static fromSeedConnectedByJoints(seed : org.jbox2d.dynamics.Body) : BodyGroup {
            let bodies : Array<org.jbox2d.dynamics.Body> = seed.getConnectedDynamicBodyIsland();
            return <any>new (__Function.prototype.bind.apply(BodyGroup, [null].concat(<any[]>/* toArray */bodies.slice(0))));
        }
    }
    BodyGroup["__class"] = "org.jbox2d.dynamics.BodyGroup";

}
namespace org.jbox2d.dynamics {
    /**
     * This is called when a body's shape passes outside of the world boundary.
     * @class
     */
    export interface BoundaryListener {
        /**
         * This is called for each body that leaves the world boundary.
         * <BR><BR><em>Warning</em>: you can't modify the world inside this callback.
         * @param {org.jbox2d.dynamics.Body} body
         */
        violation(body : org.jbox2d.dynamics.Body);
    }
}
namespace org.jbox2d.dynamics {
    export enum BoundaryResponse {
        FREEZE_BODY, DESTROY_BODY
    }
}
namespace org.jbox2d.dynamics {
    /**
     * Implement this class to get collision results. You can use these results for
     * things like sounds and game logic. You can also get contact results by
     * traversing the contact lists after the time step. However, you might miss
     * some contacts because continuous physics leads to sub-stepping.
     * Additionally you may receive multiple callbacks for the same contact in a
     * single time step.
     * You should strive to make your callbacks efficient because there may be
     * many callbacks per time step.
     * <BR><BR><em>Warning</em>: The contact separation is the last computed value.
     * <BR><BR><em>Warning</em>: You cannot create/destroy Box2D entities inside these callbacks.
     * Buffer any such events and apply them at the end of the time step.
     * @class
     */
    export interface ContactListener {
        /**
         * Called when a contact point is added. This includes the geometry
         * and the forces.
         * @param {org.jbox2d.dynamics.contacts.ContactPoint} point
         */
        add(point : org.jbox2d.dynamics.contacts.ContactPoint);

        /**
         * Called when a contact point persists. This includes the geometry
         * and the forces.
         * @param {org.jbox2d.dynamics.contacts.ContactPoint} point
         */
        persist(point : org.jbox2d.dynamics.contacts.ContactPoint);

        /**
         * Called when a contact point is removed. This includes the last
         * computed geometry and forces.
         * @param {org.jbox2d.dynamics.contacts.ContactPoint} point
         */
        remove(point : org.jbox2d.dynamics.contacts.ContactPoint);

        result(point : org.jbox2d.dynamics.contacts.ContactResult);
    }
}
namespace org.jbox2d.dynamics.contacts {
    /**
     * Base class for contacts between shapes.
     * @author ewjordan
     * @param {org.jbox2d.collision.shapes.Shape} s1
     * @param {org.jbox2d.collision.shapes.Shape} s2
     * @class
     */
    export abstract class Contact {
        public static e_nonSolidFlag : number = 1;

        public static e_slowFlag : number = 2;

        public static e_islandFlag : number = 4;

        public static e_toiFlag : number = 8;

        static s_registers : Array<org.jbox2d.dynamics.contacts.ContactRegister> = null;

        static s_initialized : boolean = false;

        /**
         * The parent world.
         */
        public m_world : org.jbox2d.dynamics.World;

        public m_prev : Contact;

        public m_next : Contact;

        /**
         * Node for connecting bodies.
         */
        public m_node1 : org.jbox2d.dynamics.contacts.ContactEdge;

        /**
         * Node for connecting bodies.
         */
        public m_node2 : org.jbox2d.dynamics.contacts.ContactEdge;

        public m_shape1 : org.jbox2d.collision.shapes.Shape;

        public m_shape2 : org.jbox2d.collision.shapes.Shape;

        /**
         * Combined friction
         */
        public m_friction : number;

        /**
         * Combined restitution
         */
        public m_restitution : number;

        public m_flags : number;

        public m_manifoldCount : number;

        public m_toi : number;

        public abstract evaluate(listener : org.jbox2d.dynamics.ContactListener);

        /**
         * Get the manifold array.
         * @return {org.jbox2d.collision.Manifold[]}
         */
        public abstract getManifolds() : Array<org.jbox2d.collision.Manifold>;

        /**
         * Get the number of manifolds. This is 0 or 1 between convex shapes.
         * This may be greater than 1 for convex-vs-concave shapes. Each
         * manifold holds up to two contact points with a shared contact normal.
         * @return {number}
         */
        public getManifoldCount() : number {
            return this.m_manifoldCount;
        }

        public isSolid() : boolean {
            return (this.m_flags & Contact.e_nonSolidFlag) === 0;
        }

        public constructor(s1? : any, s2? : any) {
            if(((s1 != null && s1 instanceof <any>org.jbox2d.collision.shapes.Shape) || s1 === null) && ((s2 != null && s2 instanceof <any>org.jbox2d.collision.shapes.Shape) || s2 === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    if(this.m_world===undefined) this.m_world = null;
                    if(this.m_prev===undefined) this.m_prev = null;
                    if(this.m_next===undefined) this.m_next = null;
                    if(this.m_node1===undefined) this.m_node1 = null;
                    if(this.m_node2===undefined) this.m_node2 = null;
                    if(this.m_shape1===undefined) this.m_shape1 = null;
                    if(this.m_shape2===undefined) this.m_shape2 = null;
                    if(this.m_friction===undefined) this.m_friction = 0;
                    if(this.m_restitution===undefined) this.m_restitution = 0;
                    if(this.m_flags===undefined) this.m_flags = 0;
                    if(this.m_manifoldCount===undefined) this.m_manifoldCount = 0;
                    if(this.m_toi===undefined) this.m_toi = 0;
                    if(this.m_world===undefined) this.m_world = null;
                    if(this.m_prev===undefined) this.m_prev = null;
                    if(this.m_next===undefined) this.m_next = null;
                    if(this.m_node1===undefined) this.m_node1 = null;
                    if(this.m_node2===undefined) this.m_node2 = null;
                    if(this.m_shape1===undefined) this.m_shape1 = null;
                    if(this.m_shape2===undefined) this.m_shape2 = null;
                    if(this.m_friction===undefined) this.m_friction = 0;
                    if(this.m_restitution===undefined) this.m_restitution = 0;
                    if(this.m_flags===undefined) this.m_flags = 0;
                    if(this.m_manifoldCount===undefined) this.m_manifoldCount = 0;
                    if(this.m_toi===undefined) this.m_toi = 0;
                    (() => {
                        this.m_node1 = new org.jbox2d.dynamics.contacts.ContactEdge();
                        this.m_node2 = new org.jbox2d.dynamics.contacts.ContactEdge();
                    })();
                }
                (() => {
                    this.m_flags = 0;
                    if(s1.isSensor() || s2.isSensor()) {
                        this.m_flags |= Contact.e_nonSolidFlag;
                    }
                    this.m_shape1 = s1;
                    this.m_shape2 = s2;
                    this.m_manifoldCount = 0;
                    this.m_friction = org.jbox2d.common.MathUtils.sqrt((<any>Math).fround(this.m_shape1.m_friction * this.m_shape2.m_friction));
                    this.m_restitution = org.jbox2d.common.MathUtils.max$float$float(this.m_shape1.m_restitution, this.m_shape2.m_restitution);
                    this.m_prev = null;
                    this.m_next = null;
                    this.m_node1.contact = null;
                    this.m_node1.prev = null;
                    this.m_node1.next = null;
                    this.m_node1.other = null;
                    this.m_node2.contact = null;
                    this.m_node2.prev = null;
                    this.m_node2.next = null;
                    this.m_node2.other = null;
                })();
            } else if(s1 === undefined && s2 === undefined) {
                let __args = arguments;
                if(this.m_world===undefined) this.m_world = null;
                if(this.m_prev===undefined) this.m_prev = null;
                if(this.m_next===undefined) this.m_next = null;
                if(this.m_node1===undefined) this.m_node1 = null;
                if(this.m_node2===undefined) this.m_node2 = null;
                if(this.m_shape1===undefined) this.m_shape1 = null;
                if(this.m_shape2===undefined) this.m_shape2 = null;
                if(this.m_friction===undefined) this.m_friction = 0;
                if(this.m_restitution===undefined) this.m_restitution = 0;
                if(this.m_flags===undefined) this.m_flags = 0;
                if(this.m_manifoldCount===undefined) this.m_manifoldCount = 0;
                if(this.m_toi===undefined) this.m_toi = 0;
                if(this.m_world===undefined) this.m_world = null;
                if(this.m_prev===undefined) this.m_prev = null;
                if(this.m_next===undefined) this.m_next = null;
                if(this.m_node1===undefined) this.m_node1 = null;
                if(this.m_node2===undefined) this.m_node2 = null;
                if(this.m_shape1===undefined) this.m_shape1 = null;
                if(this.m_shape2===undefined) this.m_shape2 = null;
                if(this.m_friction===undefined) this.m_friction = 0;
                if(this.m_restitution===undefined) this.m_restitution = 0;
                if(this.m_flags===undefined) this.m_flags = 0;
                if(this.m_manifoldCount===undefined) this.m_manifoldCount = 0;
                if(this.m_toi===undefined) this.m_toi = 0;
                (() => {
                    this.m_node1 = new org.jbox2d.dynamics.contacts.ContactEdge();
                    this.m_node2 = new org.jbox2d.dynamics.contacts.ContactEdge();
                })();
            } else throw new Error('invalid overload');
        }

        public getNext() : Contact {
            return this.m_next;
        }

        public getShape1() : org.jbox2d.collision.shapes.Shape {
            return this.m_shape1;
        }

        public getShape2() : org.jbox2d.collision.shapes.Shape {
            return this.m_shape2;
        }

        public update(listener : org.jbox2d.dynamics.ContactListener) {
            let oldCount : number = this.getManifoldCount();
            this.evaluate(listener);
            let newCount : number = this.getManifoldCount();
            let body1 : org.jbox2d.dynamics.Body = this.m_shape1.getBody();
            let body2 : org.jbox2d.dynamics.Body = this.m_shape2.getBody();
            if(newCount === 0 && oldCount > 0) {
                body1.wakeUp();
                body2.wakeUp();
            }
            if(body1.isStatic() || body1.isBullet() || body2.isStatic() || body2.isBullet()) {
                this.m_flags &= ~Contact.e_slowFlag;
            } else {
                this.m_flags |= Contact.e_slowFlag;
            }
        }

        /**
         * returns a clone of this contact.  rev 166: not used in the engine
         * @return {org.jbox2d.dynamics.contacts.Contact}
         */
        public abstract clone() : Contact;

        public static initializeRegisters() {
            Contact.s_registers = <any>([]);
            Contact.addType(new org.jbox2d.dynamics.contacts.CircleContact(), org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE, org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE);
            Contact.addType(new org.jbox2d.dynamics.contacts.PolyAndCircleContact(), org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE, org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE);
            Contact.addType(new org.jbox2d.dynamics.contacts.PolyContact(), org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE, org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE);
            Contact.addType(new org.jbox2d.dynamics.contacts.PolyAndEdgeContact(), org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE, org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE);
            Contact.addType(new org.jbox2d.dynamics.contacts.EdgeAndCircleContact(), org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE, org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE);
            Contact.addType(new org.jbox2d.dynamics.contacts.PointAndCircleContact(), org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE, org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE);
            Contact.addType(new org.jbox2d.dynamics.contacts.PointAndPolyContact(), org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE, org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE);
        }

        public static addType(createFcn : org.jbox2d.dynamics.contacts.ContactCreateFcn, type1 : org.jbox2d.collision.shapes.ShapeType, type2 : org.jbox2d.collision.shapes.ShapeType) {
            let cr : org.jbox2d.dynamics.contacts.ContactRegister = new org.jbox2d.dynamics.contacts.ContactRegister();
            cr.s1 = type1;
            cr.s2 = type2;
            cr.createFcn = createFcn;
            cr.primary = true;
            /* add */(Contact.s_registers.push(cr)>0);
            if(type1 !== type2) {
                let cr2 : org.jbox2d.dynamics.contacts.ContactRegister = new org.jbox2d.dynamics.contacts.ContactRegister();
                cr2.s2 = type1;
                cr2.s1 = type2;
                cr2.createFcn = createFcn;
                cr2.primary = false;
                /* add */(Contact.s_registers.push(cr2)>0);
            }
        }

        public static createContact(shape1 : org.jbox2d.collision.shapes.Shape, shape2 : org.jbox2d.collision.shapes.Shape) : Contact {
            if(Contact.s_initialized === false) {
                Contact.initializeRegisters();
                Contact.s_initialized = true;
            }
            let type1 : org.jbox2d.collision.shapes.ShapeType = shape1.m_type;
            let type2 : org.jbox2d.collision.shapes.ShapeType = shape2.m_type;
            let register : org.jbox2d.dynamics.contacts.ContactRegister = Contact.getContactRegister(type1, type2);
            if(register != null) {
                if(register.primary) {
                    return register.createFcn.create(shape1, shape2);
                } else {
                    let c : Contact = register.createFcn.create(shape2, shape1);
                    for(let i : number = 0; i < c.getManifoldCount(); ++i) {{
                        let m : org.jbox2d.collision.Manifold = /* get */c.getManifolds()[i];
                        m.normal.negateLocal();
                    };}
                    return c;
                }
            } else {
                return null;
            }
        }

        /*private*/ static getContactRegister(type1 : org.jbox2d.collision.shapes.ShapeType, type2 : org.jbox2d.collision.shapes.ShapeType) : org.jbox2d.dynamics.contacts.ContactRegister {
            for(let i : number = 0; i < /* size */(<number>Contact.s_registers.length); ++i) {{
                let cr : org.jbox2d.dynamics.contacts.ContactRegister = /* get */Contact.s_registers[i];
                if(cr.s1 === type1 && cr.s2 === type2) {
                    return cr;
                }
            };}
            return null;
        }

        public static destroy(contact : Contact) {
            if(!((Contact.s_initialized === true))) throw new Error("Assertion error line 269: assert (s_initialized == true);");;
            if(contact.getManifoldCount() > 0) {
                contact.getShape1().getBody().wakeUp();
                contact.getShape2().getBody().wakeUp();
            }
        }
    }
    Contact["__class"] = "org.jbox2d.dynamics.contacts.Contact";

}
namespace org.jbox2d.dynamics.contacts {
    export class ContactConstraint {
        public points : org.jbox2d.dynamics.contacts.ContactConstraintPoint[];

        public normal : org.jbox2d.common.Vec2;

        public manifold : org.jbox2d.collision.Manifold;

        public body1 : org.jbox2d.dynamics.Body;

        public body2 : org.jbox2d.dynamics.Body;

        public friction : number;

        public restitution : number;

        public pointCount : number;

        public constructor() {
            if(this.points===undefined) this.points = null;
            if(this.normal===undefined) this.normal = null;
            if(this.manifold===undefined) this.manifold = null;
            if(this.body1===undefined) this.body1 = null;
            if(this.body2===undefined) this.body2 = null;
            if(this.friction===undefined) this.friction = 0;
            if(this.restitution===undefined) this.restitution = 0;
            if(this.pointCount===undefined) this.pointCount = 0;
            this.points = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);
            for(let i : number = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; i++) {{
                this.points[i] = new org.jbox2d.dynamics.contacts.ContactConstraintPoint();
            };}
            this.pointCount = 0;
            this.normal = new org.jbox2d.common.Vec2();
            this.manifold = new org.jbox2d.collision.Manifold();
        }

        public set(cp : ContactConstraint) {
            this.pointCount = cp.pointCount;
            this.normal.set$org_jbox2d_common_Vec2(cp.normal);
            this.manifold.set(cp.manifold);
            this.friction = cp.friction;
            this.restitution = cp.restitution;
            this.body1 = cp.body1;
            this.body2 = cp.body2;
            for(let i : number = 0; i < cp.pointCount; i++) {{
                this.points[i].set(cp.points[i]);
            };}
        }
    }
    ContactConstraint["__class"] = "org.jbox2d.dynamics.contacts.ContactConstraint";

}
namespace org.jbox2d.dynamics.contacts {
    export class ContactConstraintPoint {
        public localAnchor1 : org.jbox2d.common.Vec2;

        public localAnchor2 : org.jbox2d.common.Vec2;

        public r1 : org.jbox2d.common.Vec2;

        public r2 : org.jbox2d.common.Vec2;

        public normalImpulse : number;

        public tangentImpulse : number;

        public positionImpulse : number;

        public normalMass : number;

        public tangentMass : number;

        public equalizedMass : number;

        public separation : number;

        public velocityBias : number;

        public constructor() {
            if(this.localAnchor1===undefined) this.localAnchor1 = null;
            if(this.localAnchor2===undefined) this.localAnchor2 = null;
            if(this.r1===undefined) this.r1 = null;
            if(this.r2===undefined) this.r2 = null;
            if(this.normalImpulse===undefined) this.normalImpulse = 0;
            if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
            if(this.positionImpulse===undefined) this.positionImpulse = 0;
            if(this.normalMass===undefined) this.normalMass = 0;
            if(this.tangentMass===undefined) this.tangentMass = 0;
            if(this.equalizedMass===undefined) this.equalizedMass = 0;
            if(this.separation===undefined) this.separation = 0;
            if(this.velocityBias===undefined) this.velocityBias = 0;
            this.localAnchor1 = new org.jbox2d.common.Vec2();
            this.localAnchor2 = new org.jbox2d.common.Vec2();
            this.r1 = new org.jbox2d.common.Vec2();
            this.r2 = new org.jbox2d.common.Vec2();
        }

        public set(cp : ContactConstraintPoint) {
            this.localAnchor1.set$org_jbox2d_common_Vec2(cp.localAnchor1);
            this.localAnchor2.set$org_jbox2d_common_Vec2(cp.localAnchor2);
            this.r1.set$org_jbox2d_common_Vec2(cp.r1);
            this.r2.set$org_jbox2d_common_Vec2(cp.r2);
            this.normalImpulse = cp.normalImpulse;
            this.tangentImpulse = cp.tangentImpulse;
            this.positionImpulse = cp.positionImpulse;
            this.normalMass = cp.normalMass;
            this.tangentMass = cp.tangentMass;
            this.equalizedMass = cp.equalizedMass;
            this.separation = cp.separation;
            this.velocityBias = cp.velocityBias;
        }
    }
    ContactConstraintPoint["__class"] = "org.jbox2d.dynamics.contacts.ContactConstraintPoint";

}
namespace org.jbox2d.dynamics.contacts {
    export interface ContactCreateFcn {
        create(s1 : org.jbox2d.collision.shapes.Shape, s2 : org.jbox2d.collision.shapes.Shape) : org.jbox2d.dynamics.contacts.Contact;
    }
}
namespace org.jbox2d.dynamics.contacts {
    /**
     * A contact edge is used to connect bodies and contacts together
     * in a contact graph where each body is a node and each contact
     * is an edge. A contact edge belongs to a doubly linked list
     * maintained in each attached body. Each contact has two contact
     * nodes, one for each attached body.
     * @class
     */
    export class ContactEdge {
        /**
         * Provides quick access to the other body attached.
         */
        public other : org.jbox2d.dynamics.Body;

        /**
         * The contact.
         */
        public contact : org.jbox2d.dynamics.contacts.Contact;

        /**
         * The previous contact edge in the body's contact list.
         */
        public prev : ContactEdge;

        /**
         * The next contact edge in the body's contact list.
         */
        public next : ContactEdge;

        public set(argToCopy : ContactEdge) {
            this.other = argToCopy.other;
            this.contact = argToCopy.contact;
            this.prev = argToCopy.prev;
            this.next = argToCopy.next;
        }

        constructor() {
            if(this.other===undefined) this.other = null;
            if(this.contact===undefined) this.contact = null;
            if(this.prev===undefined) this.prev = null;
            if(this.next===undefined) this.next = null;
        }
    }
    ContactEdge["__class"] = "org.jbox2d.dynamics.contacts.ContactEdge";

}
namespace org.jbox2d.dynamics.contacts {
    export class ContactPoint {
        /**
         * The first shape
         */
        public shape1 : org.jbox2d.collision.shapes.Shape;

        /**
         * The second shape
         */
        public shape2 : org.jbox2d.collision.shapes.Shape;

        /**
         * Position in world coordinates
         */
        public position : org.jbox2d.common.Vec2;

        /**
         * Velocity of point on body2 relative to point on body1 (pre-solver)
         */
        public velocity : org.jbox2d.common.Vec2;

        /**
         * Points from shape1 to shape2
         */
        public normal : org.jbox2d.common.Vec2;

        /**
         * The separation is negative when shapes are touching
         */
        public separation : number;

        /**
         * The combined friction coefficient
         */
        public friction : number;

        /**
         * The combined restitution coefficient
         */
        public restitution : number;

        /**
         * The contact id identifies the features in contact
         */
        public id : org.jbox2d.collision.ContactID;

        public constructor() {
            if(this.shape1===undefined) this.shape1 = null;
            if(this.shape2===undefined) this.shape2 = null;
            if(this.position===undefined) this.position = null;
            if(this.velocity===undefined) this.velocity = null;
            if(this.normal===undefined) this.normal = null;
            if(this.separation===undefined) this.separation = 0;
            if(this.friction===undefined) this.friction = 0;
            if(this.restitution===undefined) this.restitution = 0;
            if(this.id===undefined) this.id = null;
            this.position = new org.jbox2d.common.Vec2();
            this.normal = new org.jbox2d.common.Vec2();
            this.velocity = new org.jbox2d.common.Vec2();
            this.id = new org.jbox2d.collision.ContactID();
        }
    }
    ContactPoint["__class"] = "org.jbox2d.dynamics.contacts.ContactPoint";

}
namespace org.jbox2d.dynamics.contacts {
    export class ContactRegister {
        public s1 : org.jbox2d.collision.shapes.ShapeType;

        public s2 : org.jbox2d.collision.shapes.ShapeType;

        public createFcn : org.jbox2d.dynamics.contacts.ContactCreateFcn;

        public primary : boolean;

        constructor() {
            if(this.s1===undefined) this.s1 = null;
            if(this.s2===undefined) this.s2 = null;
            if(this.createFcn===undefined) this.createFcn = null;
            if(this.primary===undefined) this.primary = false;
        }
    }
    ContactRegister["__class"] = "org.jbox2d.dynamics.contacts.ContactRegister";

}
namespace org.jbox2d.dynamics.contacts {
    /**
     * This structure is used to report contact point results.
     * @class
     */
    export class ContactResult {
        /**
         * The first shape
         */
        public shape1 : org.jbox2d.collision.shapes.Shape;

        /**
         * The second shape
         */
        public shape2 : org.jbox2d.collision.shapes.Shape;

        /**
         * Position in world coordinates
         */
        public position : org.jbox2d.common.Vec2;

        /**
         * Points from shape1 to shape2
         */
        public normal : org.jbox2d.common.Vec2;

        /**
         * The normal impulse applied to body2
         */
        public normalImpulse : number;

        /**
         * The tangent impulse applied to body2
         */
        public tangentImpulse : number;

        /**
         * The contact id identifies the features in contact
         */
        public id : org.jbox2d.collision.ContactID;

        public constructor() {
            if(this.shape1===undefined) this.shape1 = null;
            if(this.shape2===undefined) this.shape2 = null;
            if(this.position===undefined) this.position = null;
            if(this.normal===undefined) this.normal = null;
            if(this.normalImpulse===undefined) this.normalImpulse = 0;
            if(this.tangentImpulse===undefined) this.tangentImpulse = 0;
            if(this.id===undefined) this.id = null;
            this.position = new org.jbox2d.common.Vec2();
            this.normal = new org.jbox2d.common.Vec2();
            this.id = new org.jbox2d.collision.ContactID();
        }
    }
    ContactResult["__class"] = "org.jbox2d.dynamics.contacts.ContactResult";

}
namespace org.jbox2d.dynamics.contacts {
    export class ContactSolver {
        public m_step : org.jbox2d.dynamics.TimeStep;

        public m_constraints : org.jbox2d.dynamics.contacts.ContactConstraint[];

        public m_constraintCount : number;

        public constructor() {
            if(this.m_step===undefined) this.m_step = null;
            if(this.m_constraints===undefined) this.m_constraints = null;
            if(this.m_constraintCount===undefined) this.m_constraintCount = 0;
        }

        public init(step : org.jbox2d.dynamics.TimeStep, contacts : org.jbox2d.dynamics.contacts.Contact[], contactCount : number) {
            this.m_step = step;
            this.m_constraintCount = 0;
            for(let i : number = 0; i < contactCount; i++) {{
                if(!((contacts[i].isSolid()))) throw new Error("Assertion error line 19: assert (contacts[i].isSolid());");;
                this.m_constraintCount += contacts[i].getManifoldCount();
            };}
            this.m_constraints = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_constraintCount);
            for(let i : number = 0; i < this.m_constraintCount; i++) {{
                this.m_constraints[i] = new org.jbox2d.dynamics.contacts.ContactConstraint();
            };}
            let count : number = 0;
            for(let i : number = 0; i < contactCount; i++) {{
                let contact : org.jbox2d.dynamics.contacts.Contact = contacts[i];
                let b1 : org.jbox2d.dynamics.Body = contact.m_shape1.getBody();
                let b2 : org.jbox2d.dynamics.Body = contact.m_shape2.getBody();
                let manifoldCount : number = contact.getManifoldCount();
                let manifolds : Array<org.jbox2d.collision.Manifold> = contact.getManifolds();
                let friction : number = contact.m_friction;
                let restitution : number = contact.m_restitution;
                let v1 : org.jbox2d.common.Vec2 = b1.m_linearVelocity;
                let v2 : org.jbox2d.common.Vec2 = b2.m_linearVelocity;
                let w1 : number = b1.m_angularVelocity;
                let w2 : number = b2.m_angularVelocity;
                for(let j : number = 0; j < manifoldCount; ++j) {{
                    let manifold : org.jbox2d.collision.Manifold = /* get */manifolds[j];
                    if(!((manifold.pointCount > 0))) throw new Error("Assertion error line 41: assert (manifold.pointCount > 0) : 'Manifold ' + j + ' has length 0';");;
                    let normal : org.jbox2d.common.Vec2 = manifold.normal;
                    if(!((count < this.m_constraintCount))) throw new Error("Assertion error line 43: assert (count < m_constraintCount);");;
                    let c : org.jbox2d.dynamics.contacts.ContactConstraint = this.m_constraints[count];
                    c.body1 = b1;
                    c.body2 = b2;
                    c.manifold = manifold;
                    c.normal.set$org_jbox2d_common_Vec2(normal);
                    c.pointCount = manifold.pointCount;
                    c.friction = friction;
                    c.restitution = restitution;
                    for(let k : number = 0; k < c.pointCount; ++k) {{
                        let cp : org.jbox2d.collision.ManifoldPoint = manifold.points[k];
                        let ccp : org.jbox2d.dynamics.contacts.ContactConstraintPoint = c.points[k];
                        ccp.normalImpulse = cp.normalImpulse;
                        ccp.tangentImpulse = cp.tangentImpulse;
                        ccp.separation = cp.separation;
                        ccp.positionImpulse = 0.0;
                        ccp.localAnchor1.set$org_jbox2d_common_Vec2(cp.localPoint1);
                        ccp.localAnchor2.set$org_jbox2d_common_Vec2(cp.localPoint2);
                        let v3x : number = (<any>Math).fround(cp.localPoint1.x - b1.m_sweep.localCenter.x);
                        let v3y : number = (<any>Math).fround(cp.localPoint1.y - b1.m_sweep.localCenter.y);
                        ccp.r1.set$float$float((<any>Math).fround((<any>Math).fround(b1.m_xf.R.col1.x * v3x) + (<any>Math).fround(b1.m_xf.R.col2.x * v3y)), (<any>Math).fround((<any>Math).fround(b1.m_xf.R.col1.y * v3x) + (<any>Math).fround(b1.m_xf.R.col2.y * v3y)));
                        let v4x : number = (<any>Math).fround(cp.localPoint2.x - b2.m_sweep.localCenter.x);
                        let v4y : number = (<any>Math).fround(cp.localPoint2.y - b2.m_sweep.localCenter.y);
                        ccp.r2.set$float$float((<any>Math).fround((<any>Math).fround(b2.m_xf.R.col1.x * v4x) + (<any>Math).fround(b2.m_xf.R.col2.x * v4y)), (<any>Math).fround((<any>Math).fround(b2.m_xf.R.col1.y * v4x) + (<any>Math).fround(b2.m_xf.R.col2.y * v4y)));
                        let rn1 : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(ccp.r1, normal);
                        let rn2 : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(ccp.r2, normal);
                        rn1 *= rn1;
                        rn2 *= rn2;
                        let kNormal : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b1.m_invMass + b2.m_invMass) + (<any>Math).fround(b1.m_invI * rn1)) + (<any>Math).fround(b2.m_invI * rn2));
                        if(!((kNormal > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 72: assert (kNormal > Settings.EPSILON) : 'kNormal was ' + kNormal;");;
                        ccp.normalMass = (<any>Math).fround(1.0 / kNormal);
                        let kEqualized : number = (<any>Math).fround((<any>Math).fround(b1.m_mass * b1.m_invMass) + (<any>Math).fround(b2.m_mass * b2.m_invMass));
                        kEqualized += (<any>Math).fround((<any>Math).fround((<any>Math).fround(b1.m_mass * b1.m_invI) * rn1) + (<any>Math).fround((<any>Math).fround(b2.m_mass * b2.m_invI) * rn2));
                        if(!((kEqualized > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 76: assert (kEqualized > Settings.EPSILON) : 'kEqualized was ' + kEqualized;");;
                        ccp.equalizedMass = (<any>Math).fround(1.0 / kEqualized);
                        let tangentx : number = normal.y;
                        let tangenty : number = -normal.x;
                        let a : org.jbox2d.common.Vec2 = ccp.r1;
                        let rt1 : number = (<any>Math).fround((<any>Math).fround(a.x * tangenty) - (<any>Math).fround(a.y * tangentx));
                        let a1 : org.jbox2d.common.Vec2 = ccp.r2;
                        let rt2 : number = (<any>Math).fround((<any>Math).fround(a1.x * tangenty) - (<any>Math).fround(a1.y * tangentx));
                        rt1 *= rt1;
                        rt2 *= rt2;
                        let kTangent : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b1.m_invMass + b2.m_invMass) + (<any>Math).fround(b1.m_invI * rt1)) + (<any>Math).fround(b2.m_invI * rt2));
                        if(!((kTangent > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 87: assert (kTangent > Settings.EPSILON);");;
                        ccp.tangentMass = (<any>Math).fround(1.0 / kTangent);
                        ccp.velocityBias = 0.0;
                        if(ccp.separation > 0.0) {
                            ccp.velocityBias = (<any>Math).fround(-60.0 * ccp.separation);
                        }
                        let a2 : org.jbox2d.common.Vec2 = ccp.r2;
                        let a3 : org.jbox2d.common.Vec2 = ccp.r1;
                        let bufferx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(-w2 * a2.y) - ((<any>Math).fround(-w1 * a3.y))) + v2.x) - v1.x);
                        let buffery : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(w2 * a2.x) - (<any>Math).fround(w1 * a3.x)) + v2.y) - v1.y);
                        let vRel : number = (<any>Math).fround((<any>Math).fround(c.normal.x * bufferx) + (<any>Math).fround(c.normal.y * buffery));
                        if(vRel < -org.jbox2d.common.Settings.velocityThreshold_$LI$()) {
                            ccp.velocityBias += (<any>Math).fround(-c.restitution * vRel);
                        }
                    };}
                    ++count;
                };}
            };}
            if(!((count === this.m_constraintCount))) throw new Error("Assertion error line 105: assert (count == m_constraintCount);");;
        }

        public initVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            for(let i : number = 0; i < this.m_constraintCount; ++i) {{
                let c : org.jbox2d.dynamics.contacts.ContactConstraint = this.m_constraints[i];
                let b1 : org.jbox2d.dynamics.Body = c.body1;
                let b2 : org.jbox2d.dynamics.Body = c.body2;
                let invMass1 : number = b1.m_invMass;
                let invI1 : number = b1.m_invI;
                let invMass2 : number = b2.m_invMass;
                let invI2 : number = b2.m_invI;
                let normalx : number = c.normal.x;
                let normaly : number = c.normal.y;
                let tangentx : number = normaly;
                let tangenty : number = -normalx;
                if(step.warmStarting) {
                    for(let j : number = 0; j < c.pointCount; ++j) {{
                        let ccp : org.jbox2d.dynamics.contacts.ContactConstraintPoint = c.points[j];
                        ccp.normalImpulse *= step.dtRatio;
                        ccp.tangentImpulse *= step.dtRatio;
                        let px : number = ((<any>Math).fround((<any>Math).fround(ccp.normalImpulse * normalx) + (<any>Math).fround(ccp.tangentImpulse * tangentx)));
                        let py : number = ((<any>Math).fround((<any>Math).fround(ccp.normalImpulse * normaly) + (<any>Math).fround(ccp.tangentImpulse * tangenty)));
                        b1.m_angularVelocity -= (<any>Math).fround(invI1 * ((<any>Math).fround((<any>Math).fround(ccp.r1.x * py) - (<any>Math).fround(ccp.r1.y * px))));
                        b1.m_linearVelocity.x -= (<any>Math).fround(px * invMass1);
                        b1.m_linearVelocity.y -= (<any>Math).fround(py * invMass1);
                        b2.m_angularVelocity += (<any>Math).fround(invI2 * ((<any>Math).fround((<any>Math).fround(ccp.r2.x * py) - (<any>Math).fround(ccp.r2.y * px))));
                        b2.m_linearVelocity.x += (<any>Math).fround(px * invMass2);
                        b2.m_linearVelocity.y += (<any>Math).fround(py * invMass2);
                    };}
                } else {
                    for(let j : number = 0; j < c.pointCount; ++j) {{
                        let ccp : org.jbox2d.dynamics.contacts.ContactConstraintPoint = c.points[j];
                        ccp.normalImpulse = 0.0;
                        ccp.tangentImpulse = 0.0;
                    };}
                }
            };}
        }

        public solveVelocityConstraints() {
            for(let i : number = 0; i < this.m_constraintCount; ++i) {{
                let c : org.jbox2d.dynamics.contacts.ContactConstraint = this.m_constraints[i];
                let b1 : org.jbox2d.dynamics.Body = c.body1;
                let b2 : org.jbox2d.dynamics.Body = c.body2;
                let w1 : number = b1.m_angularVelocity;
                let w2 : number = b2.m_angularVelocity;
                let v1x : number = b1.m_linearVelocity.x;
                let v1y : number = b1.m_linearVelocity.y;
                let v2x : number = b2.m_linearVelocity.x;
                let v2y : number = b2.m_linearVelocity.y;
                let invMass1 : number = b1.m_invMass;
                let invI1 : number = b1.m_invI;
                let invMass2 : number = b2.m_invMass;
                let invI2 : number = b2.m_invI;
                let normalx : number = c.normal.x;
                let normaly : number = c.normal.y;
                let tangentx : number = normaly;
                let tangenty : number = -normalx;
                let friction : number = c.friction;
                for(let j : number = 0; j < c.pointCount; ++j) {{
                    let ccp : org.jbox2d.dynamics.contacts.ContactConstraintPoint = c.points[j];
                    let dvx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v2x - (<any>Math).fround(w2 * ccp.r2.y)) - v1x) + (<any>Math).fround(w1 * ccp.r1.y));
                    let dvy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v2y + (<any>Math).fround(w2 * ccp.r2.x)) - v1y) - (<any>Math).fround(w1 * ccp.r1.x));
                    let vn : number = (<any>Math).fround((<any>Math).fround(dvx * normalx) + (<any>Math).fround(dvy * normaly));
                    let lambda : number = (<any>Math).fround(-ccp.normalMass * ((<any>Math).fround(vn - ccp.velocityBias)));
                    let newImpulse : number = org.jbox2d.common.MathUtils.max$float$float((<any>Math).fround(ccp.normalImpulse + lambda), 0.0);
                    lambda = (<any>Math).fround(newImpulse - ccp.normalImpulse);
                    let Px : number = (<any>Math).fround(lambda * normalx);
                    let Py : number = (<any>Math).fround(lambda * normaly);
                    v1x -= (<any>Math).fround(invMass1 * Px);
                    v1y -= (<any>Math).fround(invMass1 * Py);
                    w1 -= (<any>Math).fround(invI1 * ((<any>Math).fround((<any>Math).fround(ccp.r1.x * Py) - (<any>Math).fround(ccp.r1.y * Px))));
                    v2x += (<any>Math).fround(invMass2 * Px);
                    v2y += (<any>Math).fround(invMass2 * Py);
                    w2 += (<any>Math).fround(invI2 * ((<any>Math).fround((<any>Math).fround(ccp.r2.x * Py) - (<any>Math).fround(ccp.r2.y * Px))));
                    ccp.normalImpulse = newImpulse;
                };}
                for(let j : number = 0; j < c.pointCount; ++j) {{
                    let ccp : org.jbox2d.dynamics.contacts.ContactConstraintPoint = c.points[j];
                    let dvx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v2x - (<any>Math).fround(w2 * ccp.r2.y)) - v1x) + (<any>Math).fround(w1 * ccp.r1.y));
                    let dvy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(v2y + (<any>Math).fround(w2 * ccp.r2.x)) - v1y) - (<any>Math).fround(w1 * ccp.r1.x));
                    let vt : number = (<any>Math).fround((<any>Math).fround(dvx * tangentx) + (<any>Math).fround(dvy * tangenty));
                    let lambda : number = (<any>Math).fround(ccp.tangentMass * (-vt));
                    let maxFriction : number = (<any>Math).fround(friction * ccp.normalImpulse);
                    let newImpulse : number = org.jbox2d.common.MathUtils.max$float$float(-maxFriction, org.jbox2d.common.MathUtils.min((<any>Math).fround(ccp.tangentImpulse + lambda), maxFriction));
                    lambda = (<any>Math).fround(newImpulse - ccp.tangentImpulse);
                    let px : number = (<any>Math).fround(lambda * tangentx);
                    let py : number = (<any>Math).fround(lambda * tangenty);
                    v1x -= (<any>Math).fround(px * invMass1);
                    v1y -= (<any>Math).fround(py * invMass1);
                    w1 -= (<any>Math).fround(invI1 * ((<any>Math).fround((<any>Math).fround(ccp.r1.x * py) - (<any>Math).fround(ccp.r1.y * px))));
                    v2x += (<any>Math).fround(px * invMass2);
                    v2y += (<any>Math).fround(py * invMass2);
                    w2 += (<any>Math).fround(invI2 * ((<any>Math).fround((<any>Math).fround(ccp.r2.x * py) - (<any>Math).fround(ccp.r2.y * px))));
                    ccp.tangentImpulse = newImpulse;
                };}
                b1.m_linearVelocity.x = v1x;
                b1.m_linearVelocity.y = v1y;
                b1.m_angularVelocity = w1;
                b2.m_linearVelocity.x = v2x;
                b2.m_linearVelocity.y = v2y;
                b2.m_angularVelocity = w2;
            };}
        }

        public finalizeVelocityConstraints() {
            for(let i : number = 0; i < this.m_constraintCount; ++i) {{
                let c : org.jbox2d.dynamics.contacts.ContactConstraint = this.m_constraints[i];
                let m : org.jbox2d.collision.Manifold = c.manifold;
                for(let j : number = 0; j < c.pointCount; ++j) {{
                    m.points[j].normalImpulse = c.points[j].normalImpulse;
                    m.points[j].tangentImpulse = c.points[j].tangentImpulse;
                };}
            };}
        }

        public solvePositionConstraints(baumgarte : number) : boolean {
            let minSeparation : number = 0.0;
            for(let i : number = 0; i < this.m_constraintCount; ++i) {{
                let c : org.jbox2d.dynamics.contacts.ContactConstraint = this.m_constraints[i];
                let b1 : org.jbox2d.dynamics.Body = c.body1;
                let b2 : org.jbox2d.dynamics.Body = c.body2;
                let invMass1 : number = (<any>Math).fround(b1.m_mass * b1.m_invMass);
                let invI1 : number = (<any>Math).fround(b1.m_mass * b1.m_invI);
                let invMass2 : number = (<any>Math).fround(b2.m_mass * b2.m_invMass);
                let invI2 : number = (<any>Math).fround(b2.m_mass * b2.m_invI);
                let normal : org.jbox2d.common.Vec2 = c.normal;
                for(let j : number = 0; j < c.pointCount; ++j) {{
                    let ccp : org.jbox2d.dynamics.contacts.ContactConstraintPoint = c.points[j];
                    let vx : number = (<any>Math).fround(ccp.localAnchor1.x - b1.m_sweep.localCenter.x);
                    let vy : number = (<any>Math).fround(ccp.localAnchor1.y - b1.m_sweep.localCenter.y);
                    let r1x : number = (<any>Math).fround((<any>Math).fround(b1.m_xf.R.col1.x * vx) + (<any>Math).fround(b1.m_xf.R.col2.x * vy));
                    let r1y : number = (<any>Math).fround((<any>Math).fround(b1.m_xf.R.col1.y * vx) + (<any>Math).fround(b1.m_xf.R.col2.y * vy));
                    vx = (<any>Math).fround(ccp.localAnchor2.x - b2.m_sweep.localCenter.x);
                    vy = (<any>Math).fround(ccp.localAnchor2.y - b2.m_sweep.localCenter.y);
                    let r2x : number = (<any>Math).fround((<any>Math).fround(b2.m_xf.R.col1.x * vx) + (<any>Math).fround(b2.m_xf.R.col2.x * vy));
                    let r2y : number = (<any>Math).fround((<any>Math).fround(b2.m_xf.R.col1.y * vx) + (<any>Math).fround(b2.m_xf.R.col2.y * vy));
                    let dpx : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b2.m_sweep.c.x + r2x) - b1.m_sweep.c.x) - r1x);
                    let dpy : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b2.m_sweep.c.y + r2y) - b1.m_sweep.c.y) - r1y);
                    let separation : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(dpx * normal.x) + (<any>Math).fround(dpy * normal.y)) + ccp.separation);
                    minSeparation = org.jbox2d.common.MathUtils.min(minSeparation, separation);
                    let C : number = (<any>Math).fround(baumgarte * org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(separation + org.jbox2d.common.Settings.linearSlop_$LI$()), -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), 0.0));
                    let dImpulse : number = (<any>Math).fround(-ccp.equalizedMass * C);
                    let impulse0 : number = ccp.positionImpulse;
                    ccp.positionImpulse = org.jbox2d.common.MathUtils.max$float$float((<any>Math).fround(impulse0 + dImpulse), 0.0);
                    dImpulse = (<any>Math).fround(ccp.positionImpulse - impulse0);
                    let impulsex : number = (<any>Math).fround(dImpulse * normal.x);
                    let impulsey : number = (<any>Math).fround(dImpulse * normal.y);
                    b1.m_sweep.c.x -= (<any>Math).fround(invMass1 * impulsex);
                    b1.m_sweep.c.y -= (<any>Math).fround(invMass1 * impulsey);
                    b1.m_sweep.a -= (<any>Math).fround(invI1 * ((<any>Math).fround((<any>Math).fround(r1x * impulsey) - (<any>Math).fround(r1y * impulsex))));
                    b1.synchronizeTransform();
                    b2.m_sweep.c.x += (<any>Math).fround(invMass2 * impulsex);
                    b2.m_sweep.c.y += (<any>Math).fround(invMass2 * impulsey);
                    b2.m_sweep.a += (<any>Math).fround(invI2 * ((<any>Math).fround((<any>Math).fround(r2x * impulsey) - (<any>Math).fround(r2y * impulsex))));
                    b2.synchronizeTransform();
                };}
            };}
            return minSeparation >= (<any>Math).fround(-1.5 * org.jbox2d.common.Settings.linearSlop_$LI$());
        }
    }
    ContactSolver["__class"] = "org.jbox2d.dynamics.contacts.ContactSolver";

}
namespace org.jbox2d.dynamics.controllers {
    /**
     * 
     * Base class for controllers. Controllers are a convience for encapsulating common
     * per-step functionality.
     * @class
     */
    export class Controller {
        /**
         * Controllers override this to implement per-step functionality.
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public step(step : org.jbox2d.dynamics.TimeStep) {
        }

        /**
         * Controllers override this to provide debug drawing.
         * @param {org.jbox2d.dynamics.DebugDraw} debugDraw
         */
        public draw(debugDraw : org.jbox2d.dynamics.DebugDraw) {
        }

        /**
         * Adds a body to the controller list.
         * @param {org.jbox2d.dynamics.Body} body
         */
        public addBody(body : org.jbox2d.dynamics.Body) {
            let edge : org.jbox2d.dynamics.controllers.ControllerEdge = new org.jbox2d.dynamics.controllers.ControllerEdge();
            edge.body = body;
            edge.controller = this;
            edge.nextBody = this.m_bodyList;
            edge.prevBody = null;
            if(this.m_bodyList != null) {
                this.m_bodyList.prevBody = edge;
            }
            this.m_bodyList = edge;
            ++this.m_bodyCount;
            edge.nextController = body.m_controllerList;
            edge.prevController = null;
            if(body.m_controllerList != null) body.m_controllerList.prevController = edge;
            body.m_controllerList = edge;
        }

        /**
         * Removes a body from the controller list.
         * @param {org.jbox2d.dynamics.Body} body
         */
        public removeBody(body : org.jbox2d.dynamics.Body) {
            if(!((this.m_bodyCount > 0))) throw new Error("Assertion error line 49: assert (m_bodyCount > 0);");;
            let edge : org.jbox2d.dynamics.controllers.ControllerEdge = this.m_bodyList;
            while((edge != null && edge.body !== body)) {{
                edge = edge.nextBody;
            }};
            if(!((edge != null))) throw new Error("Assertion error line 54: assert (edge != null);");;
            if(edge.prevBody != null) {
                edge.prevBody.nextBody = edge.nextBody;
            }
            if(edge.nextBody != null) {
                edge.nextBody.prevBody = edge.prevBody;
            }
            if(edge === this.m_bodyList) {
                this.m_bodyList = edge.nextBody;
            }
            --this.m_bodyCount;
            if(edge.prevController != null) edge.prevController.nextController = edge.nextController;
            if(edge.nextController != null) edge.nextController.prevController = edge.prevController;
            if(edge === body.m_controllerList) body.m_controllerList = edge.nextController;
        }

        /**
         * Removes all bodies from the controller list.
         */
        public clear() {
            while((this.m_bodyList != null)) {{
                let edge : org.jbox2d.dynamics.controllers.ControllerEdge = this.m_bodyList;
                this.m_bodyList = edge.nextBody;
                if(edge.prevController != null) edge.prevController.nextController = edge.nextController;
                if(edge.nextController != null) edge.nextController.prevController = edge.prevController;
                if(edge === edge.body.m_controllerList) edge.body.m_controllerList = edge.nextController;
            }};
            this.m_bodyCount = 0;
        }

        /**
         * Get the next controller in the world's body list.
         * @return {org.jbox2d.dynamics.controllers.Controller}
         */
        public getNext() : Controller {
            return this.m_next;
        }

        /**
         * Get the parent world of this body.
         * @return {org.jbox2d.dynamics.World}
         */
        public getWorld() : org.jbox2d.dynamics.World {
            return this.m_world;
        }

        /**
         * Get the attached body list
         * @return {org.jbox2d.dynamics.controllers.ControllerEdge}
         */
        public getBodyList() : org.jbox2d.dynamics.controllers.ControllerEdge {
            return this.m_bodyList;
        }

        public m_world : org.jbox2d.dynamics.World;

        m_bodyList : org.jbox2d.dynamics.controllers.ControllerEdge;

        m_bodyCount : number;

        constructor(def : org.jbox2d.dynamics.controllers.ControllerDef) {
            if(this.m_world===undefined) this.m_world = null;
            if(this.m_bodyList===undefined) this.m_bodyList = null;
            if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
            if(this.m_prev===undefined) this.m_prev = null;
            if(this.m_next===undefined) this.m_next = null;
            this.m_world = null;
            this.m_bodyList = null;
            this.m_bodyCount = 0;
            this.m_prev = null;
            this.m_next = null;
        }

        public m_prev : Controller;

        public m_next : Controller;
    }
    Controller["__class"] = "org.jbox2d.dynamics.controllers.Controller";

}
namespace org.jbox2d.dynamics.controllers {
    /**
     * @author eric
     * @class
     */
    export abstract class ControllerDef {
        public abstract create() : org.jbox2d.dynamics.controllers.Controller;
    }
    ControllerDef["__class"] = "org.jbox2d.dynamics.controllers.ControllerDef";

}
namespace org.jbox2d.dynamics.controllers {
    /**
     * @author eric
     * @class
     */
    export class ControllerEdge {
        /**
         * provides quick access to other end of this edge.
         */
        public controller : org.jbox2d.dynamics.controllers.Controller;

        /**
         * the body
         */
        public body : org.jbox2d.dynamics.Body;

        /**
         * the previous controller edge in the controllers's joint list
         */
        public prevBody : ControllerEdge;

        /**
         * the next controller edge in the controllers's joint list
         */
        public nextBody : ControllerEdge;

        /**
         * the previous controller edge in the body's joint list
         */
        public prevController : ControllerEdge;

        /**
         * the next controller edge in the body's joint list
         */
        public nextController : ControllerEdge;

        constructor() {
            if(this.controller===undefined) this.controller = null;
            if(this.body===undefined) this.body = null;
            if(this.prevBody===undefined) this.prevBody = null;
            if(this.nextBody===undefined) this.nextBody = null;
            if(this.prevController===undefined) this.prevController = null;
            if(this.nextController===undefined) this.nextController = null;
        }
    }
    ControllerEdge["__class"] = "org.jbox2d.dynamics.controllers.ControllerEdge";

}
namespace org.jbox2d.dynamics {
    /**
     * Implement this abstract class to allow JBox2d to
     * automatically draw your physics for debugging purposes.
     * Not intended to replace your own custom rendering
     * routines!
     * @param {*} viewport
     * @class
     */
    export abstract class DebugDraw {
        public static e_shapeBit : number = 1;

        public static e_jointBit : number = 2;

        public static e_coreShapeBit : number = 4;

        public static e_aabbBit : number = 8;

        public static e_obbBit : number = 16;

        public static e_pairBit : number = 32;

        public static e_centerOfMassBit : number = 64;

        public static e_controllerBit : number = 128;

        m_drawFlags : number;

        viewportTransform : org.jbox2d.common.IViewportTransform;

        public constructor(viewport : org.jbox2d.common.IViewportTransform) {
            if(this.m_drawFlags===undefined) this.m_drawFlags = 0;
            if(this.viewportTransform===undefined) this.viewportTransform = null;
            this.m_drawFlags = 0;
            this.viewportTransform = viewport;
        }

        public setFlags(flags : number) {
            this.m_drawFlags = flags;
        }

        public getFlags() : number {
            return this.m_drawFlags;
        }

        public appendFlags(flags : number) {
            this.m_drawFlags |= flags;
        }

        public clearFlags(flags : number) {
            this.m_drawFlags &= ~flags;
        }

        public abstract drawPolygon(vertices : org.jbox2d.common.Vec2[], vertexCount : number, color : org.jbox2d.common.Color3f);

        public abstract drawSolidPolygon(vertices : org.jbox2d.common.Vec2[], vertexCount : number, color : org.jbox2d.common.Color3f);

        public abstract drawCircle(center : org.jbox2d.common.Vec2, radius : number, color : org.jbox2d.common.Color3f);

        public abstract drawSolidCircle(center : org.jbox2d.common.Vec2, radius : number, axis : org.jbox2d.common.Vec2, color : org.jbox2d.common.Color3f);

        public abstract drawPoint(position : org.jbox2d.common.Vec2, f : number, color3f : org.jbox2d.common.Color3f);

        public abstract drawSegment(p1 : org.jbox2d.common.Vec2, p2 : org.jbox2d.common.Vec2, color : org.jbox2d.common.Color3f);

        public abstract drawXForm(xf : org.jbox2d.common.XForm);

        public abstract drawString(x : number, y : number, s : string, color : org.jbox2d.common.Color3f);

        public getViewportTranform() : org.jbox2d.common.IViewportTransform {
            return this.viewportTransform;
        }

        /**
         * @param {number} x
         * @param {number} y
         * @param {number} scale
         * @see IViewportTransform#setCamera(float, float, float)
         */
        public setCamera(x : number, y : number, scale : number) {
            this.viewportTransform.setCamera(x, y, scale);
        }

        public getScreenToWorldToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen : org.jbox2d.common.Vec2, argWorld : org.jbox2d.common.Vec2) {
            this.viewportTransform.getScreenToWorld(argScreen, argWorld);
        }

        public getWorldToScreenToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld : org.jbox2d.common.Vec2, argScreen : org.jbox2d.common.Vec2) {
            this.viewportTransform.getWorldToScreen(argWorld, argScreen);
        }

        public getWorldToScreenToOut$float$float$org_jbox2d_common_Vec2(worldX : number, worldY : number, argScreen : org.jbox2d.common.Vec2) {
            argScreen.set$float$float(worldX, worldY);
            this.viewportTransform.getWorldToScreen(argScreen, argScreen);
        }

        /**
         * Takes the world coordinates and puts the corresponding screen
         * coordinates in argScreen.
         * @param {number} worldX
         * @param {number} worldY
         * @param {org.jbox2d.common.Vec2} argScreen
         */
        public getWorldToScreenToOut(worldX? : any, worldY? : any, argScreen? : any) : any {
            if(((typeof worldX === 'number') || worldX === null) && ((typeof worldY === 'number') || worldY === null) && ((argScreen != null && argScreen instanceof <any>org.jbox2d.common.Vec2) || argScreen === null)) {
                return <any>this.getWorldToScreenToOut$float$float$org_jbox2d_common_Vec2(worldX, worldY, argScreen);
            } else if(((worldX != null && worldX instanceof <any>org.jbox2d.common.Vec2) || worldX === null) && ((worldY != null && worldY instanceof <any>org.jbox2d.common.Vec2) || worldY === null) && argScreen === undefined) {
                return <any>this.getWorldToScreenToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(worldX, worldY);
            } else throw new Error('invalid overload');
        }

        public getWorldToScreen$org_jbox2d_common_Vec2(argWorld : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let screen : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.viewportTransform.getWorldToScreen(argWorld, screen);
            return screen;
        }

        public getWorldToScreen$float$float(worldX : number, worldY : number) : org.jbox2d.common.Vec2 {
            let argScreen : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(worldX, worldY);
            this.viewportTransform.getWorldToScreen(argScreen, argScreen);
            return argScreen;
        }

        /**
         * Takes the world coordinates and returns the screen
         * coordinates.
         * @param {number} worldX
         * @param {number} worldY
         * @return {org.jbox2d.common.Vec2}
         */
        public getWorldToScreen(worldX? : any, worldY? : any) : any {
            if(((typeof worldX === 'number') || worldX === null) && ((typeof worldY === 'number') || worldY === null)) {
                return <any>this.getWorldToScreen$float$float(worldX, worldY);
            } else if(((worldX != null && worldX instanceof <any>org.jbox2d.common.Vec2) || worldX === null) && worldY === undefined) {
                return <any>this.getWorldToScreen$org_jbox2d_common_Vec2(worldX);
            } else throw new Error('invalid overload');
        }

        public getScreenToWorldToOut$float$float$org_jbox2d_common_Vec2(screenX : number, screenY : number, argWorld : org.jbox2d.common.Vec2) {
            argWorld.set$float$float(screenX, screenY);
            this.viewportTransform.getScreenToWorld(argWorld, argWorld);
        }

        /**
         * takes the screen coordinates and puts the corresponding
         * world coordinates in argWorld.
         * @param {number} screenX
         * @param {number} screenY
         * @param {org.jbox2d.common.Vec2} argWorld
         */
        public getScreenToWorldToOut(screenX? : any, screenY? : any, argWorld? : any) : any {
            if(((typeof screenX === 'number') || screenX === null) && ((typeof screenY === 'number') || screenY === null) && ((argWorld != null && argWorld instanceof <any>org.jbox2d.common.Vec2) || argWorld === null)) {
                return <any>this.getScreenToWorldToOut$float$float$org_jbox2d_common_Vec2(screenX, screenY, argWorld);
            } else if(((screenX != null && screenX instanceof <any>org.jbox2d.common.Vec2) || screenX === null) && ((screenY != null && screenY instanceof <any>org.jbox2d.common.Vec2) || screenY === null) && argWorld === undefined) {
                return <any>this.getScreenToWorldToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(screenX, screenY);
            } else throw new Error('invalid overload');
        }

        public getScreenToWorld$org_jbox2d_common_Vec2(argScreen : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let world : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.viewportTransform.getScreenToWorld(argScreen, world);
            return world;
        }

        public getScreenToWorld$float$float(screenX : number, screenY : number) : org.jbox2d.common.Vec2 {
            let screen : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(screenX, screenY);
            this.viewportTransform.getScreenToWorld(screen, screen);
            return screen;
        }

        /**
         * takes the screen coordinates and returns the
         * world coordinates.
         * @param {number} screenX
         * @param {number} screenY
         * @return {org.jbox2d.common.Vec2}
         */
        public getScreenToWorld(screenX? : any, screenY? : any) : any {
            if(((typeof screenX === 'number') || screenX === null) && ((typeof screenY === 'number') || screenY === null)) {
                return <any>this.getScreenToWorld$float$float(screenX, screenY);
            } else if(((screenX != null && screenX instanceof <any>org.jbox2d.common.Vec2) || screenX === null) && screenY === undefined) {
                return <any>this.getScreenToWorld$org_jbox2d_common_Vec2(screenX);
            } else throw new Error('invalid overload');
        }
    }
    DebugDraw["__class"] = "org.jbox2d.dynamics.DebugDraw";

}
namespace org.jbox2d.dynamics {
    /**
     * Default sample implementation of ContactFilter.
     * @class
     */
    export class DefaultContactFilter implements org.jbox2d.dynamics.ContactFilter {
        /**
         * Return true if contact calculations should be performed between these two shapes.
         * If you implement your own collision filter you may want to build from this implementation.
         * @param {org.jbox2d.collision.shapes.Shape} shape1
         * @param {org.jbox2d.collision.shapes.Shape} shape2
         * @return {boolean}
         */
        public shouldCollide(shape1 : org.jbox2d.collision.shapes.Shape, shape2 : org.jbox2d.collision.shapes.Shape) : boolean {
            let filter1 : org.jbox2d.collision.FilterData = shape1.getFilterData();
            let filter2 : org.jbox2d.collision.FilterData = shape2.getFilterData();
            if(filter1.groupIndex === filter2.groupIndex && filter1.groupIndex !== 0) {
                return filter1.groupIndex > 0;
            }
            let collide : boolean = (filter1.maskBits & filter2.categoryBits) !== 0 && (filter1.categoryBits & filter2.maskBits) !== 0;
            return collide;
        }

        public rayCollide(userData : any, shape : org.jbox2d.collision.shapes.Shape) : boolean {
            if(userData == null) {
                return true;
            }
            return this.shouldCollide(<org.jbox2d.collision.shapes.Shape>userData, shape);
        }

        constructor() {
        }
    }
    DefaultContactFilter["__class"] = "org.jbox2d.dynamics.DefaultContactFilter";
    DefaultContactFilter["__interfaces"] = ["org.jbox2d.dynamics.ContactFilter"];


}
namespace org.jbox2d.dynamics {
    /**
     * Joints and shapes are destroyed when their associated
     * body is destroyed. Implement this listener so that you
     * may nullify references to these joints and shapes.
     * @class
     */
    export interface DestructionListener {
        /**
         * Called when any joint is about to be destroyed due
         * to the destruction of one of its attached bodies.
         * @param {org.jbox2d.dynamics.joints.Joint} joint
         */
        sayGoodbye(joint? : any) : any;
    }
}
namespace org.jbox2d.dynamics.joints {
    export class Jacobian {
        public linear1 : org.jbox2d.common.Vec2;

        public angular1 : number;

        public linear2 : org.jbox2d.common.Vec2;

        public angular2 : number;

        public constructor() {
            if(this.linear1===undefined) this.linear1 = null;
            if(this.angular1===undefined) this.angular1 = 0;
            if(this.linear2===undefined) this.linear2 = null;
            if(this.angular2===undefined) this.angular2 = 0;
            this.linear1 = new org.jbox2d.common.Vec2();
            this.linear2 = new org.jbox2d.common.Vec2();
            this.angular1 = 0;
            this.angular2 = 0;
        }

        setZero() {
            this.linear1.setZero();
            this.angular1 = 0.0;
            this.linear2.setZero();
            this.angular2 = 0.0;
        }

        set(x1 : org.jbox2d.common.Vec2, a1 : number, x2 : org.jbox2d.common.Vec2, a2 : number) {
            this.linear1.set$org_jbox2d_common_Vec2(x1);
            this.angular1 = a1;
            this.linear2.set$org_jbox2d_common_Vec2(x2);
            this.angular2 = a2;
        }

        compute(x1 : org.jbox2d.common.Vec2, a1 : number, x2 : org.jbox2d.common.Vec2, a2 : number) : number {
            return (<any>Math).fround((<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.dot(this.linear1, x1) + (<any>Math).fround(this.angular1 * a1)) + org.jbox2d.common.Vec2.dot(this.linear2, x2)) + (<any>Math).fround(this.angular2 * a2));
        }
    }
    Jacobian["__class"] = "org.jbox2d.dynamics.joints.Jacobian";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Base class for all Joints
     * @param {org.jbox2d.dynamics.joints.JointDef} description
     * @class
     */
    export abstract class Joint {
        public m_type : org.jbox2d.dynamics.joints.JointType;

        public m_prev : Joint;

        public m_next : Joint;

        public m_node1 : org.jbox2d.dynamics.joints.JointEdge;

        public m_node2 : org.jbox2d.dynamics.joints.JointEdge;

        public m_body1 : org.jbox2d.dynamics.Body;

        public m_body2 : org.jbox2d.dynamics.Body;

        public m_islandFlag : boolean;

        public m_collideConnected : boolean;

        public m_userData : any;

        public m_inv_dt : number;

        public constructor(description : org.jbox2d.dynamics.joints.JointDef) {
            if(this.m_type===undefined) this.m_type = null;
            if(this.m_prev===undefined) this.m_prev = null;
            if(this.m_next===undefined) this.m_next = null;
            if(this.m_node1===undefined) this.m_node1 = null;
            if(this.m_node2===undefined) this.m_node2 = null;
            if(this.m_body1===undefined) this.m_body1 = null;
            if(this.m_body2===undefined) this.m_body2 = null;
            if(this.m_islandFlag===undefined) this.m_islandFlag = false;
            if(this.m_collideConnected===undefined) this.m_collideConnected = false;
            if(this.m_userData===undefined) this.m_userData = null;
            if(this.m_inv_dt===undefined) this.m_inv_dt = 0;
            this.m_type = description.type;
            this.m_prev = null;
            this.m_next = null;
            this.m_node1 = new org.jbox2d.dynamics.joints.JointEdge();
            this.m_node2 = new org.jbox2d.dynamics.joints.JointEdge();
            this.m_body1 = description.body1;
            this.m_body2 = description.body2;
            this.m_collideConnected = description.collideConnected;
            this.m_islandFlag = false;
            this.m_userData = description.userData;
        }

        public static destroy(j : Joint) {
            j.destructor();
            return;
        }

        public destructor() {
        }

        public static create(description : org.jbox2d.dynamics.joints.JointDef) : Joint {
            let joint : Joint = null;
            if(description.type === org.jbox2d.dynamics.joints.JointType.DISTANCE_JOINT) {
                joint = new org.jbox2d.dynamics.joints.DistanceJoint(<org.jbox2d.dynamics.joints.DistanceJointDef>description);
            } else if(description.type === org.jbox2d.dynamics.joints.JointType.MOUSE_JOINT) {
                joint = new org.jbox2d.dynamics.joints.MouseJoint(<org.jbox2d.dynamics.joints.MouseJointDef>description);
            } else if(description.type === org.jbox2d.dynamics.joints.JointType.PRISMATIC_JOINT) {
                joint = new org.jbox2d.dynamics.joints.PrismaticJoint(<org.jbox2d.dynamics.joints.PrismaticJointDef>description);
            } else if(description.type === org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT) {
                joint = new org.jbox2d.dynamics.joints.RevoluteJoint(<org.jbox2d.dynamics.joints.RevoluteJointDef>description);
            } else if(description.type === org.jbox2d.dynamics.joints.JointType.PULLEY_JOINT) {
                joint = new org.jbox2d.dynamics.joints.PulleyJoint(<org.jbox2d.dynamics.joints.PulleyJointDef>description);
            } else if(description.type === org.jbox2d.dynamics.joints.JointType.GEAR_JOINT) {
                joint = new org.jbox2d.dynamics.joints.GearJoint(<org.jbox2d.dynamics.joints.GearJointDef>description);
            } else if(description.type === org.jbox2d.dynamics.joints.JointType.CONSTANT_VOLUME_JOINT) {
                joint = new org.jbox2d.dynamics.joints.ConstantVolumeJoint(<org.jbox2d.dynamics.joints.ConstantVolumeJointDef>description);
            } else {
                if(!(false)) throw new Error("Assertion error line 79: assert false;");;
            }
            return joint;
        }

        /**
         * Get the type of the concrete joint.
         * @return {org.jbox2d.dynamics.joints.JointType}
         */
        public getType() : org.jbox2d.dynamics.joints.JointType {
            return this.m_type;
        }

        /**
         * Get the first body attached to this joint.
         * @return {org.jbox2d.dynamics.Body}
         */
        public getBody1() : org.jbox2d.dynamics.Body {
            return this.m_body1;
        }

        /**
         * Get the second body attached to this joint.
         * @return {org.jbox2d.dynamics.Body}
         */
        public getBody2() : org.jbox2d.dynamics.Body {
            return this.m_body2;
        }

        /**
         * Get the anchor point on body1 in world coordinates.
         * @return {org.jbox2d.common.Vec2}
         */
        public abstract getAnchor1() : org.jbox2d.common.Vec2;

        /**
         * Get the anchor point on body2 in world coordinates.
         * @return {org.jbox2d.common.Vec2}
         */
        public abstract getAnchor2() : org.jbox2d.common.Vec2;

        /**
         * Get the reaction force on body2 at the joint anchor.
         * @return {org.jbox2d.common.Vec2}
         */
        public abstract getReactionForce() : org.jbox2d.common.Vec2;

        /**
         * Get the reaction torque on body2.
         * @return {number}
         */
        public abstract getReactionTorque() : number;

        /**
         * Get the next joint the world joint list.
         * @return {org.jbox2d.dynamics.joints.Joint}
         */
        public getNext() : Joint {
            return this.m_next;
        }

        /**
         * Get the user data pointer.
         * @return {*}
         */
        public getUserData() : any {
            return this.m_userData;
        }

        /**
         * Set the user data pointer.
         * @param {*} o
         */
        public setUserData(o : any) {
            this.m_userData = o;
        }

        public abstract initVelocityConstraints(step : org.jbox2d.dynamics.TimeStep);

        public abstract solveVelocityConstraints(step : org.jbox2d.dynamics.TimeStep);

        public initPositionConstraints() {
            return;
        }

        /**
         * This returns true if the position errors are within tolerance.
         * @return {boolean}
         */
        public abstract solvePositionConstraints() : boolean;
    }
    Joint["__class"] = "org.jbox2d.dynamics.joints.Joint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Base class for all joint definitions
     * @class
     */
    export abstract class JointDef {
        public type : org.jbox2d.dynamics.joints.JointType;

        public body1 : org.jbox2d.dynamics.Body;

        public body2 : org.jbox2d.dynamics.Body;

        public userData : any;

        public collideConnected : boolean;

        public constructor() {
            if(this.type===undefined) this.type = null;
            if(this.body1===undefined) this.body1 = null;
            if(this.body2===undefined) this.body2 = null;
            if(this.userData===undefined) this.userData = null;
            if(this.collideConnected===undefined) this.collideConnected = false;
            this.type = org.jbox2d.dynamics.joints.JointType.UNKNOWN_JOINT;
            this.body1 = null;
            this.body2 = null;
            this.userData = null;
            this.collideConnected = false;
        }
    }
    JointDef["__class"] = "org.jbox2d.dynamics.joints.JointDef";

}
namespace org.jbox2d.dynamics.joints {
    export class JointEdge {
        public other : org.jbox2d.dynamics.Body;

        public joint : org.jbox2d.dynamics.joints.Joint;

        public prev : JointEdge;

        public next : JointEdge;

        constructor() {
            if(this.other===undefined) this.other = null;
            if(this.joint===undefined) this.joint = null;
            if(this.prev===undefined) this.prev = null;
            if(this.next===undefined) this.next = null;
        }
    }
    JointEdge["__class"] = "org.jbox2d.dynamics.joints.JointEdge";

}
namespace org.jbox2d.dynamics.joints {
    export enum JointType {
        UNKNOWN_JOINT, REVOLUTE_JOINT, PRISMATIC_JOINT, DISTANCE_JOINT, PULLEY_JOINT, MOUSE_JOINT, GEAR_JOINT, CONSTANT_VOLUME_JOINT
    }
}
namespace org.jbox2d.dynamics.joints {
    export enum LimitState {
        INACTIVE_LIMIT, AT_LOWER_LIMIT, AT_UPPER_LIMIT, EQUAL_LIMITS
    }
}
namespace org.jbox2d.dynamics {
    /**
     * This interface allows registration within a JBox2d World
     * to be run immediately after the physics step.  This is
     * useful if you need to do something every step, but would
     * prefer not to have to manually code your step routine
     * differently, instead letting the engine handle the calling.
     * @class
     */
    export interface Steppable {
        step(dt : number, iterations : number);
    }
}
namespace org.jbox2d.dynamics {
    /**
     * A holder for time step information.
     * @class
     */
    export class TimeStep {
        public dt : number;

        public inv_dt : number;

        public dtRatio : number;

        public warmStarting : boolean;

        public positionCorrection : boolean;

        public maxIterations : number;

        constructor() {
            if(this.dt===undefined) this.dt = 0;
            if(this.inv_dt===undefined) this.inv_dt = 0;
            if(this.dtRatio===undefined) this.dtRatio = 0;
            if(this.warmStarting===undefined) this.warmStarting = false;
            if(this.positionCorrection===undefined) this.positionCorrection = false;
            if(this.maxIterations===undefined) this.maxIterations = 0;
        }
    }
    TimeStep["__class"] = "org.jbox2d.dynamics.TimeStep";

}
namespace org.jbox2d.p5 {
    /**
     * Set of static methods for creating more complex bodies easily.
     * @class
     */
    export class BodyUtils {    }
    BodyUtils["__class"] = "org.jbox2d.p5.BodyUtils";

}
namespace org.jbox2d.p5 {
    /**
     * A class to hold static methods for applying forces to bodies / shapes /
     * objects in various ways. If you find yourself duplicating code to do things
     * like this, then add it here!
     * 
     * @author Greg
     * 
     * @class
     */
    export class ForceUtils {
        /**
         * Pushes a body towards the specified location.
         * @param {org.jbox2d.dynamics.Body} b
         * @param {org.jbox2d.common.Vec2} worldTarget
         * @param {number} force
         */
        public pushTowards(b : org.jbox2d.dynamics.Body, worldTarget : org.jbox2d.common.Vec2, force : number) {
            let bodyVec : org.jbox2d.common.Vec2 = b.getMemberWorldCenter();
            worldTarget.subLocal(bodyVec);
            worldTarget.normalize();
            worldTarget.mulLocal((<any>Math).fround(force));
            b.applyForce(worldTarget, bodyVec);
        }

        /**
         * Pushes a body in the specified direction.
         * @param {org.jbox2d.dynamics.Body} b
         * @param {org.jbox2d.common.Vec2} dir
         * @param {number} force
         */
        public push(b : org.jbox2d.dynamics.Body, dir : org.jbox2d.common.Vec2, force : number) {
            let bodyVec : org.jbox2d.common.Vec2 = b.getMemberWorldCenter();
            dir.normalize();
            if(force > 0) {
                dir.mulLocal((<any>Math).fround(force));
            }
            b.applyForce(dir, bodyVec);
        }
    }
    ForceUtils["__class"] = "org.jbox2d.p5.ForceUtils";

}
namespace org.jbox2d.p5 {
    /**
     * Tracks the reaction force of a given joint, and destroys the joint if the reaction force is above
     * a given threshold AND is between the minimum and maximum allowable angles. This is useful for creating
     * mouse-controlled joints where the "release" should only happen in one direction, and when a certain
     * force threshold is reached.
     * @author Greg
     * @param {org.jbox2d.dynamics.joints.Joint} joint
     * @param {number} reactionThreshold
     * @class
     */
    export class JointBreaker implements org.jbox2d.dynamics.Steppable {
        joint : org.jbox2d.dynamics.joints.Joint;

        reactionThreshold : number;

        angleLo : number;

        angleHi : number;

        public constructor(joint : org.jbox2d.dynamics.joints.Joint, reactionThreshold : number) {
            if(this.joint===undefined) this.joint = null;
            if(this.reactionThreshold===undefined) this.reactionThreshold = 0;
            if(this.angleLo===undefined) this.angleLo = 0;
            if(this.angleHi===undefined) this.angleHi = 0;
            this.joint = joint;
            this.reactionThreshold = reactionThreshold;
        }

        public step(dt : number, iterations : number) {
            if(this.joint != null) {
                let force : org.jbox2d.common.Vec2 = this.joint.getReactionForce();
                let forceAngle : number = org.jbox2d.p5.PhysicsUtils.angle$org_jbox2d_common_Vec2(force);
                let forceMag : number = force.length();
                if(forceMag > this.reactionThreshold) {
                    if(this.angleLo === this.angleHi || (forceAngle >= this.angleLo && forceAngle <= this.angleHi)) {
                        this.joint.getBody1().getWorld().destroyJoint(this.joint);
                        this.joint = null;
                        this.joint.getBody1().getWorld().unregisterPostStep(this);
                    }
                }
            }
        }

        /**
         * Sets the range of angles between which this jointbreaker will break the joint. Angles are in radians,
         * relative to due east.
         * @param {number} lo
         * @param {number} hi
         */
        public setAngleLimits(lo : number, hi : number) {
            this.angleLo = lo;
            this.angleHi = hi;
        }
    }
    JointBreaker["__class"] = "org.jbox2d.p5.JointBreaker";
    JointBreaker["__interfaces"] = ["org.jbox2d.dynamics.Steppable"];


}
namespace org.jbox2d.p5 {
    export class JointUtils {
        public static createDistanceJoint$org_jbox2d_dynamics_World$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(w : org.jbox2d.dynamics.World, pA : org.jbox2d.common.Vec2, pB : org.jbox2d.common.Vec2) : org.jbox2d.dynamics.joints.DistanceJoint {
            let bodies : org.jbox2d.dynamics.Body[] = JointUtils.getTwoDistinctBodies(w, pA, pB);
            if(bodies == null || bodies.length !== 2) return null;
            let jd : org.jbox2d.dynamics.joints.DistanceJointDef = new org.jbox2d.dynamics.joints.DistanceJointDef();
            jd.initialize(bodies[0], bodies[1], pA, pB);
            return <org.jbox2d.dynamics.joints.DistanceJoint>w.createJoint(jd);
        }

        /**
         * Creates a distance joint between bodies that touch the given points,
         * anchored at those points. Returns null if there are not two different
         * bodies at the points given. Behavior is undetermined if more than one
         * body touches a point.
         * 
         * @param {org.jbox2d.dynamics.World} w
         * World to add joint to and read bodies from
         * @param {org.jbox2d.common.Vec2} pA
         * First point to attach to
         * @param {org.jbox2d.common.Vec2} pB
         * Second point to attach to
         * @return {org.jbox2d.dynamics.joints.DistanceJoint} Joint created, or null if impossible to create the joint
         */
        public static createDistanceJoint(w? : any, pA? : any, pB? : any) : any {
            if(((w != null && w instanceof <any>org.jbox2d.dynamics.World) || w === null) && ((pA != null && pA instanceof <any>org.jbox2d.common.Vec2) || pA === null) && ((pB != null && pB instanceof <any>org.jbox2d.common.Vec2) || pB === null)) {
                return <any>org.jbox2d.p5.JointUtils.createDistanceJoint$org_jbox2d_dynamics_World$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(w, pA, pB);
            } else if(((w != null && w instanceof <any>org.jbox2d.dynamics.Body) || w === null) && ((pA != null && pA instanceof <any>org.jbox2d.dynamics.Body) || pA === null) && pB === undefined) {
                return <any>org.jbox2d.p5.JointUtils.createDistanceJoint$org_jbox2d_dynamics_Body$org_jbox2d_dynamics_Body(w, pA);
            } else throw new Error('invalid overload');
        }

        public static createDistanceJoint$org_jbox2d_dynamics_Body$org_jbox2d_dynamics_Body(a : org.jbox2d.dynamics.Body, b : org.jbox2d.dynamics.Body) : org.jbox2d.dynamics.joints.DistanceJoint {
            let jd : org.jbox2d.dynamics.joints.DistanceJointDef = new org.jbox2d.dynamics.joints.DistanceJointDef();
            jd.body1 = a;
            jd.body2 = b;
            let length : number = a.getMemberPosition().subLocal(b.getMemberPosition()).length();
            jd.length = length;
            let j : org.jbox2d.dynamics.joints.DistanceJoint = <org.jbox2d.dynamics.joints.DistanceJoint>a.getWorld().createJoint(jd);
            return j;
        }

        /**
         * Creates a RevoluteJoint between two bodies that rotates around a given
         * point in World coordinates.
         * 
         * @param {org.jbox2d.dynamics.Body} a
         * @param {org.jbox2d.dynamics.Body} b
         * @param {org.jbox2d.common.Vec2} worldCenter
         * @return
         * @return {org.jbox2d.dynamics.joints.RevoluteJoint}
         */
        public static createRevoluteJoint(a : org.jbox2d.dynamics.Body, b : org.jbox2d.dynamics.Body, worldCenter : org.jbox2d.common.Vec2) : org.jbox2d.dynamics.joints.RevoluteJoint {
            let jd : org.jbox2d.dynamics.joints.RevoluteJointDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
            jd.body1 = a;
            jd.body2 = b;
            jd.localAnchor1 = a.getLocalPoint(worldCenter);
            jd.localAnchor2 = b.getLocalPoint(worldCenter);
            let j : org.jbox2d.dynamics.joints.RevoluteJoint = <org.jbox2d.dynamics.joints.RevoluteJoint>a.getWorld().createJoint(jd);
            return j;
        }

        /**
         * <p>
         * Finds a pair of non-identical bodies that have shapes touching points pA
         * and pB, loaded resp. into the 0th and 1st elements of the returned array.
         * Returns null array if no such pair exists.
         * </p>
         * <p>
         * This method is useful for creating joints based on location, where the
         * two bodies in a joint must be distinct.
         * </p>
         * 
         * @param {org.jbox2d.dynamics.World} w
         * @param {org.jbox2d.common.Vec2} pA
         * @param {org.jbox2d.common.Vec2} pB
         * @return {Array} a Body array containing two distinct bodies, or NULL if no
         * distinct bodies exist at the given points.
         * @private
         */
        /*private*/ static getTwoDistinctBodies(w : org.jbox2d.dynamics.World, pA : org.jbox2d.common.Vec2, pB : org.jbox2d.common.Vec2) : org.jbox2d.dynamics.Body[] {
            let aabb1 : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB(new org.jbox2d.common.Vec2((<any>Math).fround(pA.x - 0.001), (<any>Math).fround(pA.y - 0.001)), new org.jbox2d.common.Vec2((<any>Math).fround(pA.x + 0.001), (<any>Math).fround(pA.y + 0.001)));
            let aabb2 : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB(new org.jbox2d.common.Vec2((<any>Math).fround(pB.x - 0.001), (<any>Math).fround(pB.y - 0.001)), new org.jbox2d.common.Vec2((<any>Math).fround(pB.x + 0.001), (<any>Math).fround(pB.y + 0.001)));
            let maxCount : number = 10;
            let shapes1 : org.jbox2d.collision.shapes.Shape[] = w.query(aabb1, maxCount);
            if(shapes1[0] == null) return null;
            let shapes2 : org.jbox2d.collision.shapes.Shape[] = w.query(aabb2, maxCount);
            if(shapes2[0] == null) return null;
            let found : boolean = false;
            let i : number = 0;
            let j : number = 0;
            let body1 : org.jbox2d.dynamics.Body = null;
            let body2 : org.jbox2d.dynamics.Body = null;
            while((!found)) {{
                if(i >= shapes1.length || shapes1[i] == null) return null;
                if(shapes1[i].testPoint(shapes1[i].getBody().getMemberXForm(), pA)) body1 = shapes1[i++].getBody();
                for(j = 0; j < shapes2.length; ++j) {{
                    if(shapes2[j] == null) break;
                    if(shapes2[j].testPoint(shapes2[j].getBody().getMemberXForm(), pB)) body2 = shapes2[j].getBody();
                    if(body2 !== body1) {
                        found = true;
                        break;
                    }
                };}
            }};
            if(body1 == null || body2 == null) return null;
            let bodies : org.jbox2d.dynamics.Body[] = [body1, body2];
            return bodies;
        }
    }
    JointUtils["__class"] = "org.jbox2d.p5.JointUtils";

}
namespace org.jbox2d.p5 {
    /**
     * Set up a physics world.
     * 
     * @param {*} parent The PApplet this physics world should use
     * @param {number} gravX The x component of gravity, in meters/sec^2
     * @param {number} gravY The y component of gravity, in meters/sec^2
     * @param {number} screenAABBWidth The world's width, in pixels - should be significantly larger than the area you intend to use
     * @param {number} screenAABBHeight The world's height, in pixels - should be significantly larger than the area you intend to use
     * @param {number} borderBoxWidth The containing box's width - should be smaller than the world width, so that no object can escape
     * @param {number} borderBoxHeight The containing box's height - should be smaller than the world height, so that no object can escape
     * @param {number} pixelsPerMeter Pixels per physical meter
     * @param {number} screenW
     * @param {number} screenH
     * @class
     * @author ewjordan
     */
    export class Physics {
        /*private*/ m_world : org.jbox2d.dynamics.World;

        /*private*/ m_parent : any;

        /**
         * m_draw is used by default for both drawing
         * and coordinate conversions; if a custom
         * rendering method is set, m_draw is <em>still</em>
         * used for coordinate conversions, so bear this
         * in mind.  In particular, however, none of the
         * camera functionality of ProcessingDebugDraw is
         * used, so don't expect anything like that.  All
         * the conversion does is applies a simple (read: unchanging)
         * scaling and translation from the default screen space to
         * the world space.  Any monkey business with cameras
         * and transformations is up to the user, and it's up
         * to the user to keep track of it.
         */
        /*private*/ m_draw : org.jbox2d.testbed.ProcessingDebugDraw;

        /*private*/ m_gravity : org.jbox2d.common.Vec2;

        public m_worldAABB : org.jbox2d.collision.AABB;

        /*private*/ m_settings : org.jbox2d.testbed.TestSettings;

        /*private*/ m_border : org.jbox2d.dynamics.Body[];

        /*private*/ m_density : number;

        /*private*/ m_restitution : number;

        /*private*/ m_friction : number;

        /*private*/ m_bullet : boolean;

        /*private*/ m_sensor : boolean;

        /*private*/ m_customRenderingMethod : { owner: any, name: string, fn : Function };

        /*private*/ m_customRenderingObject : any;

        public constructor(parent? : any, screenW? : any, screenH? : any, gravX? : any, gravY? : any, screenAABBWidth? : any, screenAABBHeight? : any, borderBoxWidth? : any, borderBoxHeight? : any, pixelsPerMeter? : any) {
            if(((parent != null && (parent["__interfaces"] != null && parent["__interfaces"].indexOf("def.processing.core.PApplet") >= 0 || parent.constructor != null && parent.constructor["__interfaces"] != null && parent.constructor["__interfaces"].indexOf("def.processing.core.PApplet") >= 0)) || parent === null) && ((typeof screenW === 'number') || screenW === null) && ((typeof screenH === 'number') || screenH === null) && ((typeof gravX === 'number') || gravX === null) && ((typeof gravY === 'number') || gravY === null) && ((typeof screenAABBWidth === 'number') || screenAABBWidth === null) && ((typeof screenAABBHeight === 'number') || screenAABBHeight === null) && ((typeof borderBoxWidth === 'number') || borderBoxWidth === null) && ((typeof borderBoxHeight === 'number') || borderBoxHeight === null) && ((typeof pixelsPerMeter === 'number') || pixelsPerMeter === null)) {
                let __args = arguments;
                if(this.m_world===undefined) this.m_world = null;
                if(this.m_parent===undefined) this.m_parent = null;
                if(this.m_draw===undefined) this.m_draw = null;
                if(this.m_gravity===undefined) this.m_gravity = null;
                if(this.m_worldAABB===undefined) this.m_worldAABB = null;
                if(this.m_settings===undefined) this.m_settings = null;
                if(this.m_border===undefined) this.m_border = null;
                if(this.m_density===undefined) this.m_density = 0;
                if(this.m_restitution===undefined) this.m_restitution = 0;
                if(this.m_friction===undefined) this.m_friction = 0;
                if(this.m_bullet===undefined) this.m_bullet = false;
                if(this.m_sensor===undefined) this.m_sensor = false;
                if(this.m_customRenderingMethod===undefined) this.m_customRenderingMethod = null;
                if(this.m_customRenderingObject===undefined) this.m_customRenderingObject = null;
                if(this.m_world===undefined) this.m_world = null;
                if(this.m_parent===undefined) this.m_parent = null;
                if(this.m_draw===undefined) this.m_draw = null;
                if(this.m_gravity===undefined) this.m_gravity = null;
                if(this.m_worldAABB===undefined) this.m_worldAABB = null;
                if(this.m_settings===undefined) this.m_settings = null;
                if(this.m_border===undefined) this.m_border = null;
                if(this.m_density===undefined) this.m_density = 0;
                if(this.m_restitution===undefined) this.m_restitution = 0;
                if(this.m_friction===undefined) this.m_friction = 0;
                if(this.m_bullet===undefined) this.m_bullet = false;
                if(this.m_sensor===undefined) this.m_sensor = false;
                if(this.m_customRenderingMethod===undefined) this.m_customRenderingMethod = null;
                if(this.m_customRenderingObject===undefined) this.m_customRenderingObject = null;
                (() => {
                    this.m_parent = parent;
                    this.m_draw = new org.jbox2d.testbed.ProcessingDebugDraw(this.m_parent);
                    this.m_gravity = new org.jbox2d.common.Vec2(gravX, gravY);
                    this.m_draw.setCamera(0, 0, pixelsPerMeter);
                    let minWorldAABB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround((<any>Math).fround(-screenAABBWidth * 0.5) / pixelsPerMeter), (<any>Math).fround((<any>Math).fround(-screenAABBHeight * 0.5) / pixelsPerMeter));
                    let maxWorldAABB : org.jbox2d.common.Vec2 = minWorldAABB.mul(-1.0);
                    let doSleep : boolean = true;
                    this.m_world = new org.jbox2d.dynamics.World(new org.jbox2d.collision.AABB(minWorldAABB, maxWorldAABB), this.m_gravity, doSleep);
                    this.m_world.setDebugDraw(this.m_draw);
                    this.m_world.setDrawDebugData(false);
                    this.m_settings = new org.jbox2d.testbed.TestSettings();
                    this.setDensity(0.0);
                    this.setRestitution(0.1);
                    this.setFriction(0.4);
                    this.setBullet(false);
                    this.setSensor(false);
                    this.m_border = this.createHollowBox((<any>Math).fround(screenW * 0.5), (<any>Math).fround(screenH * 0.5), borderBoxWidth, borderBoxHeight, 10.0);
                    parent.registerMethod("draw", this);
                })();
            } else if(((parent != null && (parent["__interfaces"] != null && parent["__interfaces"].indexOf("def.processing.core.PApplet") >= 0 || parent.constructor != null && parent.constructor["__interfaces"] != null && parent.constructor["__interfaces"].indexOf("def.processing.core.PApplet") >= 0)) || parent === null) && ((typeof screenW === 'number') || screenW === null) && ((typeof screenH === 'number') || screenH === null) && gravX === undefined && gravY === undefined && screenAABBWidth === undefined && screenAABBHeight === undefined && borderBoxWidth === undefined && borderBoxHeight === undefined && pixelsPerMeter === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let gravX : any = 0.0;
                    let gravY : any = -10.0;
                    let screenAABBWidth : any = (<any>Math).fround(2 * __args[1]);
                    let screenAABBHeight : any = (<any>Math).fround(2 * __args[2]);
                    let borderBoxWidth : any = __args[1];
                    let borderBoxHeight : any = __args[2];
                    let pixelsPerMeter : any = 10.0;
                    if(this.m_world===undefined) this.m_world = null;
                    if(this.m_parent===undefined) this.m_parent = null;
                    if(this.m_draw===undefined) this.m_draw = null;
                    if(this.m_gravity===undefined) this.m_gravity = null;
                    if(this.m_worldAABB===undefined) this.m_worldAABB = null;
                    if(this.m_settings===undefined) this.m_settings = null;
                    if(this.m_border===undefined) this.m_border = null;
                    if(this.m_density===undefined) this.m_density = 0;
                    if(this.m_restitution===undefined) this.m_restitution = 0;
                    if(this.m_friction===undefined) this.m_friction = 0;
                    if(this.m_bullet===undefined) this.m_bullet = false;
                    if(this.m_sensor===undefined) this.m_sensor = false;
                    if(this.m_customRenderingMethod===undefined) this.m_customRenderingMethod = null;
                    if(this.m_customRenderingObject===undefined) this.m_customRenderingObject = null;
                    if(this.m_world===undefined) this.m_world = null;
                    if(this.m_parent===undefined) this.m_parent = null;
                    if(this.m_draw===undefined) this.m_draw = null;
                    if(this.m_gravity===undefined) this.m_gravity = null;
                    if(this.m_worldAABB===undefined) this.m_worldAABB = null;
                    if(this.m_settings===undefined) this.m_settings = null;
                    if(this.m_border===undefined) this.m_border = null;
                    if(this.m_density===undefined) this.m_density = 0;
                    if(this.m_restitution===undefined) this.m_restitution = 0;
                    if(this.m_friction===undefined) this.m_friction = 0;
                    if(this.m_bullet===undefined) this.m_bullet = false;
                    if(this.m_sensor===undefined) this.m_sensor = false;
                    if(this.m_customRenderingMethod===undefined) this.m_customRenderingMethod = null;
                    if(this.m_customRenderingObject===undefined) this.m_customRenderingObject = null;
                    (() => {
                        this.m_parent = parent;
                        this.m_draw = new org.jbox2d.testbed.ProcessingDebugDraw(this.m_parent);
                        this.m_gravity = new org.jbox2d.common.Vec2(gravX, gravY);
                        this.m_draw.setCamera(0, 0, pixelsPerMeter);
                        let minWorldAABB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround((<any>Math).fround(-screenAABBWidth * 0.5) / pixelsPerMeter), (<any>Math).fround((<any>Math).fround(-screenAABBHeight * 0.5) / pixelsPerMeter));
                        let maxWorldAABB : org.jbox2d.common.Vec2 = minWorldAABB.mul(-1.0);
                        let doSleep : boolean = true;
                        this.m_world = new org.jbox2d.dynamics.World(new org.jbox2d.collision.AABB(minWorldAABB, maxWorldAABB), this.m_gravity, doSleep);
                        this.m_world.setDebugDraw(this.m_draw);
                        this.m_world.setDrawDebugData(false);
                        this.m_settings = new org.jbox2d.testbed.TestSettings();
                        this.setDensity(0.0);
                        this.setRestitution(0.1);
                        this.setFriction(0.4);
                        this.setBullet(false);
                        this.setSensor(false);
                        this.m_border = this.createHollowBox((<any>Math).fround(screenW * 0.5), (<any>Math).fround(screenH * 0.5), borderBoxWidth, borderBoxHeight, 10.0);
                        parent.registerMethod("draw", this);
                    })();
                }
            } else throw new Error('invalid overload');
        }

        /**
         * Called automatically by Processing.
         */
        public draw() {
            this.m_world.setWarmStarting(this.m_settings.enableWarmStarting);
            this.m_world.setPositionCorrection(this.m_settings.enablePositionCorrection);
            this.m_world.setContinuousPhysics(this.m_settings.enableTOI);
            this.m_world.step((<any>Math).fround(1.0 / this.m_settings.hz), this.m_settings.iterationCount);
            if(this.m_customRenderingMethod == null) {
                this.defaultDraw(this.m_world);
            } else {
                try {
                    /* invoke */this.m_customRenderingMethod.fn.apply(this.m_customRenderingObject, [this.m_world]);
                } catch(e) {
                    console.error("error " + e);
                    console.error(e.message, e);
                    this.m_parent.exit();
                };
            }
        }

        /**
         * For advanced users only.
         * <BR><BR>
         * Set a custom rendering method to be called.  Use this
         * if the default renderer is not drawing things the way
         * you like, or if you need more flexibility.  This
         * will allow a very modular approach to rendering, whereby
         * you can change the entire graphical style on the fly by
         * switching the render function.  Hopefully some people a
         * lot more graphically skilled than I am will provide some
         * cool looking functions for this purpose!
         * <BR><BR>
         * The method is set through Java's reflection API, so you
         * may call any method that takes a World object as a parameter.
         * The usual Java way is to force implementation of an interace,
         * but this way you can write things in a simpler manner, within
         * the PDE and without multiple tabs or pure Java.
         * Just pass the object that has the method along with the name
         * of the method.
         * <BR><BR>
         * e.g. if you have the following method defined in your
         * sketch:
         * <pre>
         * void myDrawMethod(World world) {
         * // Do a bunch of stuff
         * }
         * </pre>
         * then inside either the draw or setup functions you could write:
         * <pre>
         * setCustomRenderingMethod(this, "myDrawMethod");</pre>
         * to register that function.  Use unsetCustomRenderingMethod() to
         * go back to the default renderer.
         * <BR><BR>
         * If you're interested in writing your own renderer, you'll likely need
         * to look at the source code, which you can get to from http://www.jbox2d.org.
         * In particular, the org.jbox2d.dynamics.World file has a drawDebugData()
         * function, which, after some preprocessing, makes some calls out to
         * org.jbox2d.testbed.ProcessingDebugDraw to do the actual drawing.  That
         * should give you a place to start from, at least.
         * <BR><BR>
         * Note also that this rendering method has nothing to do with
         * Java2d vs. P3D vs. OpenGL - that choice is made at the
         * beginning of your sketch, and this library won't let you change it!
         * This functionality merely relates to the way bodies and shapes
         * are translated into drawing calls; the drawing calls themselves
         * rely on whatever renderer you chose in your size() function.
         * <BR><BR>
         * @param {*} object The object in which your method is defined ('this' should work if
         * the object is defined in a .pde file and not within a class)
         * @param {string} methodName The name of the method (without the parenthesis) to call
         */
        public setCustomRenderingMethod(object : any, methodName : string) {
            let c : any = (<any>object.constructor);
            try {
                let methodArgs : any[] = [org.jbox2d.dynamics.World];
                let method : { owner: any, name: string, fn : Function } = /* getMethod */((c,p) => { if(c.prototype.hasOwnProperty(p) && typeof c.prototype[p] == 'function') return {owner:c,name:p,fn:c.prototype[p]}; else return null; })(c,methodName);
                this.m_customRenderingObject = object;
                this.m_customRenderingMethod = method;
            } catch(e) {
                console.error("Could not register " + methodName + "(World) for " + object + ", make sure the method name is spelled correctly and that the method takes a World object as an argument!" + e);
                console.error(e.message, e);
            };
        }

        /**
         * Clear any custom rendering method that has been set, and
         * revert to the default Box2d debug renderer.
         */
        public unsetCustomRenderingMethod() {
            this.m_customRenderingMethod = null;
            this.m_customRenderingObject = null;
        }

        /**
         * Draws the scene using the default render options.
         * Automatically called by the engine unless you have
         * specified your own rendering routine.
         * @param {org.jbox2d.dynamics.World} world
         */
        public defaultDraw(world : org.jbox2d.dynamics.World) {
            this.m_draw.setFlags(0);
            if(this.m_settings.drawShapes) this.m_draw.appendFlags(org.jbox2d.dynamics.DebugDraw.e_shapeBit);
            if(this.m_settings.drawJoints) this.m_draw.appendFlags(org.jbox2d.dynamics.DebugDraw.e_jointBit);
            if(this.m_settings.drawCoreShapes) this.m_draw.appendFlags(org.jbox2d.dynamics.DebugDraw.e_coreShapeBit);
            if(this.m_settings.drawAABBs) this.m_draw.appendFlags(org.jbox2d.dynamics.DebugDraw.e_aabbBit);
            if(this.m_settings.drawOBBs) this.m_draw.appendFlags(org.jbox2d.dynamics.DebugDraw.e_obbBit);
            if(this.m_settings.drawPairs) this.m_draw.appendFlags(org.jbox2d.dynamics.DebugDraw.e_pairBit);
            if(this.m_settings.drawCOMs) this.m_draw.appendFlags(org.jbox2d.dynamics.DebugDraw.e_centerOfMassBit);
            world.setDrawDebugData(true);
            world.drawDebugData();
            world.setDrawDebugData(false);
        }

        /**
         * Get an editable copy of the current TestSettings so
         * that you may change certain aspects of the simulation
         * and display.  You do not need to re-set anything after
         * editing these settings, the changes take effect immediately.
         * <BR><BR>
         * The list of useful fields in the TestSettings objects follows:
         * <pre>
         * public int hz; // "frame" rate of physics simulation - best to leave at 60
         * public int iterationCount; // number of constraint iterations - set to 10 normally
         * public boolean enableWarmStarting; // makes constraints work better by reusing last results
         * public boolean enablePositionCorrection; // leave this on...without it, things turn to mush
         * public boolean enableTOI; // enable/disable continuous collision detection
         * public boolean drawShapes;
         * public boolean drawJoints;
         * public boolean drawCoreShapes;
         * public boolean drawOBBs;
         * public boolean drawCOMs;
         * public boolean drawImpulses;
         * public boolean drawAABBs;
         * public boolean drawPairs;
         * public boolean drawContactPoints;
         * public boolean drawContactNormals;
         * public boolean drawContactForces;
         * public boolean drawFrictionForces;
         * </pre>
         * Note: the drawing settings only affect the default debug renderer.
         * If you have specified your own renderer, you will have to manually
         * read off and apply these settings if you wish to use them.
         * @return {org.jbox2d.testbed.TestSettings} A reference to the active TestSettings object
         */
        public getSettings() : org.jbox2d.testbed.TestSettings {
            return this.m_settings;
        }

        /**
         * Create a hollow box of the given screen dimensions.
         * @param {number} centerX Center of box x coordinate (in screen coordinates)
         * @param {number} centerY Center of box y coordinate (in screen coordinates)
         * @param {number} width Width of box (screen scale)
         * @param {number} height Height of box (screen scale)
         * @param {number} thickness Thickness of box edge (screen scale)
         * @return
         * @return {Array}
         */
        public createHollowBox(centerX : number, centerY : number, width : number, height : number, thickness : number) : org.jbox2d.dynamics.Body[] {
            let result : org.jbox2d.dynamics.Body[] = [null, null, null, null];
            result[0] = this.createRect((<any>Math).fround((<any>Math).fround(centerX - (<any>Math).fround(width * 0.5)) - (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerY - (<any>Math).fround(height * 0.5)) - (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerX - (<any>Math).fround(width * 0.5)) + (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerY + (<any>Math).fround(height * 0.5)) + (<any>Math).fround(thickness * 0.5)));
            result[1] = this.createRect((<any>Math).fround((<any>Math).fround(centerX + (<any>Math).fround(width * 0.5)) - (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerY - (<any>Math).fround(height * 0.5)) - (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerX + (<any>Math).fround(width * 0.5)) + (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerY + (<any>Math).fround(height * 0.5)) + (<any>Math).fround(thickness * 0.5)));
            result[2] = this.createRect((<any>Math).fround((<any>Math).fround(centerX - (<any>Math).fround(width * 0.5)) - (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerY + (<any>Math).fround(height * 0.5)) - (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerX + (<any>Math).fround(width * 0.5)) + (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerY + (<any>Math).fround(height * 0.5)) + (<any>Math).fround(thickness * 0.5)));
            result[3] = this.createRect((<any>Math).fround((<any>Math).fround(centerX - (<any>Math).fround(width * 0.5)) - (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerY - (<any>Math).fround(height * 0.5)) - (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerX + (<any>Math).fround(width * 0.5)) + (<any>Math).fround(thickness * 0.5)), (<any>Math).fround((<any>Math).fround(centerY - (<any>Math).fround(height * 0.5)) + (<any>Math).fround(thickness * 0.5)));
            return result;
        }

        /**
         * Create a rectangle given by screen coordinates of corners.
         * @param {number} x0
         * @param {number} y0
         * @param {number} x1
         * @param {number} y1
         * @return
         * @return {org.jbox2d.dynamics.Body}
         */
        public createRect(x0 : number, y0 : number, x1 : number, y1 : number) : org.jbox2d.dynamics.Body {
            let cxs : number = (<any>Math).fround(((<any>Math).fround(x0 + x1)) * 0.5);
            let cys : number = (<any>Math).fround(((<any>Math).fround(y0 + y1)) * 0.5);
            let wxs : number = org.jbox2d.common.MathUtils.abs((<any>Math).fround(x1 - x0));
            let wys : number = org.jbox2d.common.MathUtils.abs((<any>Math).fround(y1 - y0));
            let center : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(cxs, cys);
            let halfWidthWorld : number = (<any>Math).fround(0.5 * this.screenToWorld$float$org_jbox2d_common_Vec2(wxs, new org.jbox2d.common.Vec2(1, 0)));
            let halfHeightWorld : number = (<any>Math).fround(0.5 * this.screenToWorld$float$org_jbox2d_common_Vec2(wys, new org.jbox2d.common.Vec2(1, 0)));
            let pd : org.jbox2d.collision.shapes.PolygonDef = new org.jbox2d.collision.shapes.PolygonDef();
            pd.setAsBox$float$float(halfWidthWorld, halfHeightWorld);
            this.setShapeDefProperties(pd);
            let bd : org.jbox2d.dynamics.BodyDef = new org.jbox2d.dynamics.BodyDef();
            this.setBodyDefProperties(bd);
            let b : org.jbox2d.dynamics.Body = this.m_world.createBody(bd);
            b.createShape(pd);
            if(this.m_density > 0.0) b.setMassFromShapes();
            b.setXForm(center, 0.0);
            return b;
        }

        /**
         * Create a circle in screen coordinates
         * @param {number} x
         * @param {number} y
         * @param {number} r
         * @return
         * @return {org.jbox2d.dynamics.Body}
         */
        public createCircle(x : number, y : number, r : number) : org.jbox2d.dynamics.Body {
            let center : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(x, y);
            let rad : number = this.screenToWorld$float$org_jbox2d_common_Vec2(r, new org.jbox2d.common.Vec2(1, 0));
            let cd : org.jbox2d.collision.shapes.CircleDef = new org.jbox2d.collision.shapes.CircleDef();
            cd.radius = rad;
            this.setShapeDefProperties(cd);
            let bd : org.jbox2d.dynamics.BodyDef = new org.jbox2d.dynamics.BodyDef();
            this.setBodyDefProperties(bd);
            let b : org.jbox2d.dynamics.Body = this.m_world.createBody(bd);
            b.createShape(cd);
            if(this.m_density > 0.0) b.setMassFromShapes();
            b.setXForm(center, 0.0);
            return b;
        }

        /**
         * Create a polygon based on vertices.
         * <BR><BR>
         * Polygons must be:
         * <ul>
         * <li>Ordered clockwise in screen coordinates (which
         * becomes counterclockwise in world coordinates).
         * <li>Non self-intersecting.
         * <li>Convex
         * </ul>
         * Failure to adhere to any of these restrictions may cause
         * simulation crashes or problems.  In particular, if your
         * objects are showing up as static objects instead of dynamic
         * ones, and are not colliding correctly, you have probably
         * not met the clockwise ordering requirement.
         * <BR><BR>
         * This can be called with any number of vertices passed as
         * pairs of interleaved floats, for instance:
         * <pre>
         * createPolygon(x0,y0,x1,y1,x2,y2,x3,y3);</pre>
         * or
         * <pre>
         * createPolygon(x0,y0,x1,y1,x2,y2,x3,y3,x4,y4,x5,y5);</pre>
         * or
         * <pre>
         * float[] xyInterleaved = {x0,y0,x1,y1,x2,y2,x3,y3,x4,y4};
         * createPolygon(xyInterleaved);</pre>
         * are all fine.
         * @param {Array} vertices Any number of pairs of x,y floats, or an array of the same (screen coordinates)
         * @return
         * @return {org.jbox2d.dynamics.Body}
         */
        public createPolygon(...vertices : number[]) : org.jbox2d.dynamics.Body {
            if(vertices.length % 2 !== 0) throw Object.defineProperty(new Error("Vertices must be given as pairs of x,y coordinates, but number of passed parameters was odd."), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
            let nVertices : number = (vertices.length / 2|0);
            let pd : org.jbox2d.collision.shapes.PolygonDef = new org.jbox2d.collision.shapes.PolygonDef();
            for(let i : number = 0; i < nVertices; ++i) {{
                let v : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(vertices[2 * i], vertices[2 * i + 1]);
                pd.addVertex(v);
            };}
            this.setShapeDefProperties(pd);
            let bd : org.jbox2d.dynamics.BodyDef = new org.jbox2d.dynamics.BodyDef();
            this.setBodyDefProperties(bd);
            let b : org.jbox2d.dynamics.Body = this.m_world.createBody(bd);
            b.createShape(pd);
            if(this.m_density > 0.0) b.setMassFromShapes();
            return b;
        }

        /**
         * Create a distance (stick) joint between two bodies
         * that holds the specified points at a constant distance.
         * <BR><BR>
         * Once the distance joint is created, it may be turned into
         * a "soft" distance joint by using DistanceJoint::setFrequencyHz(float)
         * to set the frequency to a non-zero value, and using
         * DistanceJoint::setDampingRatio(float) to tune the damping constant.
         * <BR><BR>
         * Distance joints do not support joint limits or motors.
         * @param {org.jbox2d.dynamics.Body} a First body
         * @param {org.jbox2d.dynamics.Body} b Second body
         * @param {number} xa x component of anchor point on first body (screen coordinates)
         * @param {number} ya y component of anchor point on first body (screen coordinates)
         * @param {number} xb x component of anchor point on second body (screen coordinates)
         * @param {number} yb y component of anchor point on second body (screen coordinates)
         * @return {org.jbox2d.dynamics.joints.DistanceJoint} Newly created DistanceJoint
         */
        public createDistanceJoint(a : org.jbox2d.dynamics.Body, b : org.jbox2d.dynamics.Body, xa : number, ya : number, xb : number, yb : number) : org.jbox2d.dynamics.joints.DistanceJoint {
            let va : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(xa, ya);
            let vb : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(xb, yb);
            let jd : org.jbox2d.dynamics.joints.DistanceJointDef = new org.jbox2d.dynamics.joints.DistanceJointDef();
            jd.initialize(a, b, va, vb);
            return <org.jbox2d.dynamics.joints.DistanceJoint>this.m_world.createJoint(jd);
        }

        /**
         * Create a revolute (pin) joint between the two bodies
         * at the given position.
         * <BR><BR>
         * Joint limits and motors may be set once the joint is created.
         * @param {org.jbox2d.dynamics.Body} a First body
         * @param {org.jbox2d.dynamics.Body} b Second body
         * @param {number} x x coordinate of pin joint location (screen coordinates)
         * @param {number} y y coordinate of pin joint location (screen coordinates)
         * @return {org.jbox2d.dynamics.joints.RevoluteJoint} Newly created RevoluteJoint
         */
        public createRevoluteJoint(a : org.jbox2d.dynamics.Body, b : org.jbox2d.dynamics.Body, x : number, y : number) : org.jbox2d.dynamics.joints.RevoluteJoint {
            let v : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(x, y);
            return org.jbox2d.p5.JointUtils.createRevoluteJoint(a, b, v);
        }

        /**
         * Create a prismatic (piston) joint between two bodies
         * that allows movement in the given direction.
         * <BR><BR>
         * dirX and dirY can be given in screen coordinates or
         * world coordinates, scaling does not matter.
         * <BR><BR>
         * Joint limits and motors may be set once the joint is created.
         * @param {org.jbox2d.dynamics.Body} a First body
         * @param {org.jbox2d.dynamics.Body} b Second body
         * @param {number} dirX x component of allowed movement direction
         * @param {number} dirY y component of allowed movement direction
         * @return {org.jbox2d.dynamics.joints.PrismaticJoint} Newly created PrismaticJoint
         */
        public createPrismaticJoint(a : org.jbox2d.dynamics.Body, b : org.jbox2d.dynamics.Body, dirX : number, dirY : number) : org.jbox2d.dynamics.joints.PrismaticJoint {
            let dir : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(dirX, dirY);
            dir.normalize();
            let pjd : org.jbox2d.dynamics.joints.PrismaticJointDef = new org.jbox2d.dynamics.joints.PrismaticJointDef();
            pjd.initialize(a, b, (a.getMemberWorldCenter().add(b.getMemberWorldCenter())).mul(0.5), dir);
            return <org.jbox2d.dynamics.joints.PrismaticJoint>this.m_world.createJoint(pjd);
        }

        /**
         * Create a pulley joint between the
         * The pulley joint is connected to two bodies and two fixed ground points.
         * The pulley supports a ratio such that:
         * length1 + ratio * length2 = constant
         * Yes, the force transmitted is scaled by the ratio.
         * <BR><BR>
         * The ground anchors are the points where the "rope" touches the pulley,
         * and the anchors are the points on the bodies where the rope is attached.
         * <BR><BR>
         * Joint limits may be set after the joint is created.
         * @param {org.jbox2d.dynamics.Body} a First body
         * @param {org.jbox2d.dynamics.Body} b Second body
         * @param {number} groundAnchorAx x coordinate of (fixed) ground anchor for body a, in screen coordinates
         * @param {number} groundAnchorAy y coordinate of (fixed) ground anchor for body a, in screen coordinates
         * @param {number} groundAnchorBx x coordinate of (fixed) ground anchor for body b, in screen coordinates
         * @param {number} groundAnchorBy y coordinate of (fixed) ground anchor for body b, in screen coordinates
         * @param {number} anchorAx x coordinate of body anchor for body a, in screen coordinates
         * @param {number} anchorAy y coordinate of body anchor for body a, in screen coordinates
         * @param {number} anchorBx x coordinate of body anchor for body b, in screen coordinates
         * @param {number} anchorBy y coordinate of body anchor for body b, in screen coordinates
         * @param {number} ratio "Block and tackle" ratio
         * @return {org.jbox2d.dynamics.joints.PulleyJoint} Newly created PulleyJoint
         */
        public createPulleyJoint(a : org.jbox2d.dynamics.Body, b : org.jbox2d.dynamics.Body, groundAnchorAx : number, groundAnchorAy : number, groundAnchorBx : number, groundAnchorBy : number, anchorAx : number, anchorAy : number, anchorBx : number, anchorBy : number, ratio : number) : org.jbox2d.dynamics.joints.PulleyJoint {
            let gA : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(groundAnchorAx, groundAnchorAy);
            let gB : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(groundAnchorBx, groundAnchorBy);
            let aA : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(anchorAx, anchorAy);
            let aB : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(anchorBx, anchorBy);
            let pjd : org.jbox2d.dynamics.joints.PulleyJointDef = new org.jbox2d.dynamics.joints.PulleyJointDef();
            pjd.initialize(a, b, gA, gB, aA, aB, ratio);
            return <org.jbox2d.dynamics.joints.PulleyJoint>this.m_world.createJoint(pjd);
        }

        /**
         * Create a gear joint, which binds together two existing
         * revolute or prismatic joints (any combination will work).
         * The provided joints must attach a dynamic body to a static body.
         * <BR><BR>
         * A gear joint is used to connect two joints together. Either joint
         * can be a revolute or prismatic joint. You specify a gear ratio
         * to bind the motions together:
         * coordinate1 + ratio * coordinate2 = constant
         * The ratio can be negative or positive. If one joint is a revolute joint
         * and the other joint is a prismatic joint, then the ratio will have units
         * of length or units of 1/length.
         * <BR><em>Warning</em>: The revolute and prismatic joints must be attached to
         * fixed bodies (which must be body1 on those joints).
         * @param {org.jbox2d.dynamics.joints.Joint} pj1 First joint (revolute or prismatic)
         * @param {org.jbox2d.dynamics.joints.Joint} pj2 Second joint (revolute or prismatic)
         * @param {number} ratio Gear ratio
         * @return {org.jbox2d.dynamics.joints.GearJoint} Newly created GearJoint
         */
        public createGearJoint(pj1 : org.jbox2d.dynamics.joints.Joint, pj2 : org.jbox2d.dynamics.joints.Joint, ratio : number) : org.jbox2d.dynamics.joints.GearJoint {
            if(!(pj1.getType() === org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT || pj1.getType() === org.jbox2d.dynamics.joints.JointType.PRISMATIC_JOINT)) {
                throw Object.defineProperty(new Error("Gear joints can only be created between combinations of revolute and prismatic joints."), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
            } else if(!(pj1.getType() === org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT || pj1.getType() === org.jbox2d.dynamics.joints.JointType.PRISMATIC_JOINT)) {
                throw Object.defineProperty(new Error("Gear joints can only be created between combinations of revolute and prismatic joints."), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
            }
            let gjd : org.jbox2d.dynamics.joints.GearJointDef = new org.jbox2d.dynamics.joints.GearJointDef();
            gjd.joint1 = pj1;
            gjd.joint2 = pj2;
            gjd.ratio = ratio;
            return <org.jbox2d.dynamics.joints.GearJoint>this.m_world.createJoint(gjd);
        }

        /**
         * Sets the body def properties based on the current state
         * of the physics handler.
         * 
         * @param {org.jbox2d.dynamics.BodyDef} bd
         * @private
         */
        /*private*/ setBodyDefProperties(bd : org.jbox2d.dynamics.BodyDef) {
            bd.isBullet = this.m_bullet;
        }

        /**
         * Sets the shape def properties based on the current state
         * of the physics handler.
         * 
         * @param {org.jbox2d.collision.shapes.ShapeDef} sd Shape def to set
         * @private
         */
        /*private*/ setShapeDefProperties(sd : org.jbox2d.collision.shapes.ShapeDef) {
            sd.density = this.m_density;
            sd.friction = this.m_friction;
            sd.restitution = this.m_restitution;
            sd.isSensor = this.m_sensor;
        }

        /**
         * Set the density used for newly created shapes.
         * @param {number} d
         */
        public setDensity(d : number) {
            this.m_density = d;
        }

        /**
         * Get the density being used for newly created shapes.
         * @return
         * @return {number}
         */
        public getDensity() : number {
            return this.m_density;
        }

        /**
         * Set the restitution used for newly created shapes.
         * @param {number} r
         */
        public setRestitution(r : number) {
            this.m_restitution = r;
        }

        /**
         * Get the restitution being used for newly created shapes.
         * @return
         * @return {number}
         */
        public getRestitution() : number {
            return this.m_restitution;
        }

        /**
         * Set the friction used for newly created shapes.
         * @param {number} f
         */
        public setFriction(f : number) {
            this.m_friction = f;
        }

        /**
         * Get the friction being used for newly created shapes.
         * @return
         * @return {number}
         */
        public getFriction() : number {
            return this.m_friction;
        }

        /**
         * Get the viewport transform, which transforms (moves, scales, and rotates)
         * the world to show us what we see in our window.
         * @return
         * @return {*}
         */
        public getViewportTransform() : org.jbox2d.common.IViewportTransform {
            return this.m_draw.getViewportTranform();
        }

        /**
         * Set to true to create new bodies as "bullets,"
         * which use (slower) continuous collision detection
         * against other moving bodies.
         * <BR><BR>
         * <em>Warning:</em> continuous collision detection between
         * moving bodies is slow, and should be used sparingly.  All
         * bodies use continuous collision detection against static
         * scenery, so for most purposes your bodies should not be
         * marked as bullets.
         * @param {boolean} bullet
         */
        public setBullet(bullet : boolean) {
            this.m_bullet = bullet;
        }

        /**
         * Are newly created bodies being created as bullets?
         * @return {boolean}
         */
        public getBullet() : boolean {
            return this.m_bullet;
        }

        /**
         * Set to true to create new shapes as sensors.  Sensors
         * do not respond to collisions physically, but they
         * generate contact events.  This can be useful if you
         * need to check whether a body is in a certain geometrical
         * area.
         * @param {boolean} sensor
         */
        public setSensor(sensor : boolean) {
            this.m_sensor = sensor;
        }

        /**
         * Are newly created shapes being created as sensors?
         * @return {boolean}
         */
        public getSensor() : boolean {
            return this.m_sensor;
        }

        /**
         * Destroy this world, unregistering it from the PApplet.
         * If this is not called, the world will still be active
         * and simulating, as upon creation it is registered with
         * the PApplet's draw events.
         */
        public destroy() {
            this.m_parent.unregisterMethod("draw", this);
        }

        /**
         * Get the current physics world.
         * <BR><BR>
         * <em>Warning:</em> anything involving a World object directly
         * is not strictly supported as part of this Processing library.
         * It <em>is</em> supported as part of JBox2d, however, so there
         * is quite a bit you can do, and you can always ask for help if
         * you run into trouble.  Note that all coordinates and vectors
         * in JBox2d proper are in world coordinates, not screen coordinates,
         * so you will likely need to use the screenToWorld and worldToScreen
         * functions to convert back and forth as necessary.
         * @return {org.jbox2d.dynamics.World} The active physics world
         */
        public getWorld() : org.jbox2d.dynamics.World {
            return this.m_world;
        }

        /**
         * 
         * Get the border Body[] array, or null
         * if the border has been removed.
         * @return {Array}
         */
        public getBorder() : org.jbox2d.dynamics.Body[] {
            return this.m_border;
        }

        /**
         * Remove the solid border if it exists.
         */
        public removeBorder() {
            if(this.m_border == null) return;
            for(let i : number = 0; i < this.m_border.length; ++i) {{
                this.removeBody(this.m_border[i]);
            };}
            this.m_border = null;
        }

        /**
         * Remove a body from the world.
         * @param {org.jbox2d.dynamics.Body} b
         */
        public removeBody(b : org.jbox2d.dynamics.Body) {
            this.m_world.destroyBody(b);
        }

        /**
         * Remove a joint from the world.
         * @param {org.jbox2d.dynamics.joints.Joint} j
         */
        public removeJoint(j : org.jbox2d.dynamics.joints.Joint) {
            this.m_world.destroyJoint(j);
        }

        public applyForce$org_jbox2d_dynamics_Body$float$float(b : org.jbox2d.dynamics.Body, fx : number, fy : number) {
            let fv : org.jbox2d.common.Vec2 = this.screenToWorldVector$float$float(fx, fy);
            b.applyForce(fv, b.getMemberWorldCenter());
        }

        public applyForce$org_jbox2d_dynamics_Body$org_jbox2d_common_Vec2(b : org.jbox2d.dynamics.Body, f : org.jbox2d.common.Vec2) {
            b.applyForce(this.screenToWorldVector$org_jbox2d_common_Vec2(f), b.getMemberWorldCenter());
        }

        public applyForce$org_jbox2d_dynamics_Body$float$float$float$float(b : org.jbox2d.dynamics.Body, fx : number, fy : number, pointX : number, pointY : number) {
            let fv : org.jbox2d.common.Vec2 = this.screenToWorldVector$float$float(fx, fy);
            let point : org.jbox2d.common.Vec2 = this.screenToWorld$float$float(pointX, pointY);
            b.applyForce(fv, point);
        }

        /**
         * Apply a force to a body at a point.
         * @param {org.jbox2d.dynamics.Body} b Body you wish to apply force to
         * @param {number} fx x component of force (in pixel units)
         * @param {number} fy y component of force (in pixel units)
         * @param {number} pointX x coordinate of application point (in screen/pixel coordinates)
         * @param {number} pointY y coordinate of application point (in screen/pixel coordinates)
         */
        public applyForce(b? : any, fx? : any, fy? : any, pointX? : any, pointY? : any) : any {
            if(((b != null && b instanceof <any>org.jbox2d.dynamics.Body) || b === null) && ((typeof fx === 'number') || fx === null) && ((typeof fy === 'number') || fy === null) && ((typeof pointX === 'number') || pointX === null) && ((typeof pointY === 'number') || pointY === null)) {
                return <any>this.applyForce$org_jbox2d_dynamics_Body$float$float$float$float(b, fx, fy, pointX, pointY);
            } else if(((b != null && b instanceof <any>org.jbox2d.dynamics.Body) || b === null) && ((fx != null && fx instanceof <any>org.jbox2d.common.Vec2) || fx === null) && ((fy != null && fy instanceof <any>org.jbox2d.common.Vec2) || fy === null) && pointX === undefined && pointY === undefined) {
                return <any>this.applyForce$org_jbox2d_dynamics_Body$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b, fx, fy);
            } else if(((b != null && b instanceof <any>org.jbox2d.dynamics.Body) || b === null) && ((typeof fx === 'number') || fx === null) && ((typeof fy === 'number') || fy === null) && pointX === undefined && pointY === undefined) {
                return <any>this.applyForce$org_jbox2d_dynamics_Body$float$float(b, fx, fy);
            } else if(((b != null && b instanceof <any>org.jbox2d.dynamics.Body) || b === null) && ((fx != null && fx instanceof <any>org.jbox2d.common.Vec2) || fx === null) && fy === undefined && pointX === undefined && pointY === undefined) {
                return <any>this.applyForce$org_jbox2d_dynamics_Body$org_jbox2d_common_Vec2(b, fx);
            } else throw new Error('invalid overload');
        }

        public applyForce$org_jbox2d_dynamics_Body$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b : org.jbox2d.dynamics.Body, f : org.jbox2d.common.Vec2, point : org.jbox2d.common.Vec2) {
            b.applyForce(this.screenToWorldVector$org_jbox2d_common_Vec2(f), this.screenToWorld$org_jbox2d_common_Vec2(point));
        }

        /**
         * 
         * Get the location of the body's origin (screen coordinates) -
         * note that this does <em>not</em> usually correspond to the
         * center of mass position, which may be obtained by calling
         * {@link #getCMPosition(Body)}.
         * @param {org.jbox2d.dynamics.Body} b
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public getPosition(b : org.jbox2d.dynamics.Body) : org.jbox2d.common.Vec2 {
            return this.worldToScreen$org_jbox2d_common_Vec2(b.getMemberPosition());
        }

        /**
         * Get the center of mass position (screen coordinates)
         * @param {org.jbox2d.dynamics.Body} b
         * @return {org.jbox2d.common.Vec2}
         */
        public getCMPosition(b : org.jbox2d.dynamics.Body) : org.jbox2d.common.Vec2 {
            return this.worldToScreen$org_jbox2d_common_Vec2(b.getMemberWorldCenter());
        }

        /**
         * Get the angle (in radians)
         * @param {org.jbox2d.dynamics.Body} b
         * @return {number}
         */
        public getAngle(b : org.jbox2d.dynamics.Body) : number {
            return b.getAngle();
        }

        /**
         * Screen space to world space conversion for position.
         * @param {number} x
         * @param {number} y
         * @return {number}
         */
        public screenToWorldX(x : number, y : number) : number {
            return this.m_draw.getScreenToWorld$float$float(x, y).x;
        }

        /**
         * Screen space to world space conversion for position.
         * @param {number} x
         * @param {number} y
         * @return {number}
         */
        public screenToWorldY(x : number, y : number) : number {
            return this.m_draw.getScreenToWorld$float$float(x, y).y;
        }

        public screenToWorld$float$float(x : number, y : number) : org.jbox2d.common.Vec2 {
            return this.m_draw.getScreenToWorld$float$float(x, y);
        }

        public screenToWorld$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return this.m_draw.getScreenToWorld$org_jbox2d_common_Vec2(v);
        }

        public screenToWorld$float$org_jbox2d_common_Vec2(length : number, vector : org.jbox2d.common.Vec2) : number {
            let ret : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(vector);
            ret.normalize();
            ret.mulLocal(length);
            this.m_draw.getViewportTranform().vectorInverseTransform(ret, ret);
            return ret.length();
        }

        /**
         * Screen length to world length, on the given vector direction
         * @param {number} length
         * @param {org.jbox2d.common.Vec2} vector
         * @return {number}
         */
        public screenToWorld(length? : any, vector? : any) : any {
            if(((typeof length === 'number') || length === null) && ((vector != null && vector instanceof <any>org.jbox2d.common.Vec2) || vector === null)) {
                return <any>this.screenToWorld$float$org_jbox2d_common_Vec2(length, vector);
            } else if(((typeof length === 'number') || length === null) && ((typeof vector === 'number') || vector === null)) {
                return <any>this.screenToWorld$float$float(length, vector);
            } else if(((length != null && length instanceof <any>org.jbox2d.common.Vec2) || length === null) && vector === undefined) {
                return <any>this.screenToWorld$org_jbox2d_common_Vec2(length);
            } else throw new Error('invalid overload');
        }

        /**
         * World space to screen space conversion for position.
         * @param {number} x
         * @param {number} y
         * @return {number}
         */
        public worldToScreenX(x : number, y : number) : number {
            return this.m_draw.getWorldToScreen$float$float(x, y).x;
        }

        /**
         * World space to screen space conversion for position.
         * @param {number} x
         * @param {number} y
         * @return {number}
         */
        public worldToScreenY(x : number, y : number) : number {
            return this.m_draw.getWorldToScreen$float$float(x, y).y;
        }

        public worldToScreen$float$float(x : number, y : number) : org.jbox2d.common.Vec2 {
            return this.m_draw.getWorldToScreen$float$float(x, y);
        }

        public worldToScreen$org_jbox2d_common_Vec2(v : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return this.m_draw.getWorldToScreen$org_jbox2d_common_Vec2(v);
        }

        public worldToScreen$float$org_jbox2d_common_Vec2(length : number, vector : org.jbox2d.common.Vec2) : number {
            let ret : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(vector);
            ret.normalize();
            ret.mulLocal(length);
            this.m_draw.getViewportTranform().vectorTransform(ret, ret);
            return ret.length();
        }

        /**
         * World length to screen length, on the given vector direction
         * @param {number} length
         * @param {org.jbox2d.common.Vec2} vector
         * @return {number}
         */
        public worldToScreen(length? : any, vector? : any) : any {
            if(((typeof length === 'number') || length === null) && ((vector != null && vector instanceof <any>org.jbox2d.common.Vec2) || vector === null)) {
                return <any>this.worldToScreen$float$org_jbox2d_common_Vec2(length, vector);
            } else if(((typeof length === 'number') || length === null) && ((typeof vector === 'number') || vector === null)) {
                return <any>this.worldToScreen$float$float(length, vector);
            } else if(((length != null && length instanceof <any>org.jbox2d.common.Vec2) || length === null) && vector === undefined) {
                return <any>this.worldToScreen$org_jbox2d_common_Vec2(length);
            } else throw new Error('invalid overload');
        }

        public screenToWorldVector$org_jbox2d_common_Vec2(screenV : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let ret : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.m_draw.getViewportTranform().vectorInverseTransform(screenV, ret);
            if(this.m_draw.getViewportTranform().isYFlip()) {
                ret.y *= -1;
            }
            return ret;
        }

        public screenToWorldVector$float$float(sx : number, sy : number) : org.jbox2d.common.Vec2 {
            let ret : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(sx, sy);
            this.m_draw.getViewportTranform().vectorInverseTransform(ret, ret);
            if(this.m_draw.getViewportTranform().isYFlip()) {
                ret.y *= -1;
            }
            return ret;
        }

        public screenToWorldVector(sx? : any, sy? : any) : any {
            if(((typeof sx === 'number') || sx === null) && ((typeof sy === 'number') || sy === null)) {
                return <any>this.screenToWorldVector$float$float(sx, sy);
            } else if(((sx != null && sx instanceof <any>org.jbox2d.common.Vec2) || sx === null) && sy === undefined) {
                return <any>this.screenToWorldVector$org_jbox2d_common_Vec2(sx);
            } else throw new Error('invalid overload');
        }

        public worldToScreenVector$org_jbox2d_common_Vec2(worldV : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let ret : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.m_draw.getViewportTranform().vectorTransform(worldV, ret);
            if(this.m_draw.getViewportTranform().isYFlip()) {
                ret.y *= -1;
            }
            return ret;
        }

        public worldToScreenVector$float$float(wx : number, wy : number) : org.jbox2d.common.Vec2 {
            let ret : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(wx, wy);
            this.m_draw.getViewportTranform().vectorTransform(ret, ret);
            if(this.m_draw.getViewportTranform().isYFlip()) {
                ret.y *= -1;
            }
            return ret;
        }

        public worldToScreenVector(wx? : any, wy? : any) : any {
            if(((typeof wx === 'number') || wx === null) && ((typeof wy === 'number') || wy === null)) {
                return <any>this.worldToScreenVector$float$float(wx, wy);
            } else if(((wx != null && wx instanceof <any>org.jbox2d.common.Vec2) || wx === null) && wy === undefined) {
                return <any>this.worldToScreenVector$org_jbox2d_common_Vec2(wx);
            } else throw new Error('invalid overload');
        }
    }
    Physics["__class"] = "org.jbox2d.p5.Physics";

}
namespace org.jbox2d.p5 {
    export class PhysicsUtils {
        /**
         * In case you want to do something to a body during each creation (such as add an Actor object),
         * you can override the PhysicsUtils class and override this method.
         * @return
         * @return {org.jbox2d.dynamics.BodyDef}
         */
        public static newBodyDef() : org.jbox2d.dynamics.BodyDef {
            let bd : org.jbox2d.dynamics.BodyDef = new org.jbox2d.dynamics.BodyDef();
            return bd;
        }

        public static angle$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a : org.jbox2d.common.Vec2, b : org.jbox2d.common.Vec2) : number {
            let theta : number = (<any>Math).fround((Math.atan2(b.y, b.x) - Math.atan2(a.y, a.x)));
            return theta;
        }

        /**
         * Returns the clockwise angle from vector A to vector B.
         * @param {org.jbox2d.common.Vec2} a
         * @param {org.jbox2d.common.Vec2} b
         * @return
         * @return {number}
         */
        public static angle(a? : any, b? : any) : any {
            if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && ((b != null && b instanceof <any>org.jbox2d.common.Vec2) || b === null)) {
                return <any>org.jbox2d.p5.PhysicsUtils.angle$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, b);
            } else if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && b === undefined) {
                return <any>org.jbox2d.p5.PhysicsUtils.angle$org_jbox2d_common_Vec2(a);
            } else throw new Error('invalid overload');
        }

        public static angle$org_jbox2d_common_Vec2(a : org.jbox2d.common.Vec2) : number {
            return PhysicsUtils.angle$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(new org.jbox2d.common.Vec2(1, 0), a);
        }
    }
    PhysicsUtils["__class"] = "org.jbox2d.p5.PhysicsUtils";

}
namespace org.jbox2d.p5 {
    /**
     * A general class for holding static methods that do things with or to
     * polygons. Things like convex decomposition, polygon merging, &etc...
     * 
     * @author Greg
     * 
     * @class
     */
    export class PolygonUtils {    }
    PolygonUtils["__class"] = "org.jbox2d.p5.PolygonUtils";

}
namespace org.jbox2d.pooling.arrays {
    export abstract class DynamicTLArray<I> {
        /*private*/ tlMap : DynamicTLArray.TLHashMap<number, I[]> = <any>((() => { let __o : any = new DynamicTLArray.TLHashMap<number, I[]>(); __o.__delegate = new DynamicTLArray.TLHashMap<number, I[]>(); return __o; })());

        public get(argLength : number) : I[] {
            if(!((argLength > 0))) throw new Error("Assertion error line 6: assert (argLength > 0);");;
            let map : any = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(this.tlMap);
            if(!/* containsKey */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return true; } return false; })(<any>map, argLength)) {
                /* put */((m,k,v) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { m.entries[i].value=v; return; } m.entries.push({key:k,value:v,getKey: function() { return this.key }, getValue: function() { return this.value }}); })(<any>map, argLength, this.getInitializedArray(argLength));
            }
            if(!((/* get */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return m.entries[i].value; } return null; })(<any>map, argLength).length === argLength))) throw new Error("Assertion error line 11: assert (map.get(argLength).length == argLength) : 'Array not built of correct length';");;
            return /* get */((m,k) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { return m.entries[i].value; } return null; })(<any>map, argLength);
        }

        public recycle(argArray : I[]) {
        }

        abstract getInitializedArray(argLength : number) : I[];
    }
    DynamicTLArray["__class"] = "org.jbox2d.pooling.arrays.DynamicTLArray";


    export namespace DynamicTLArray {

        export class TLHashMap<K, V> {
            initialValue() : any {
                return <any>({});
            }

            constructor() {
            }
        }
        TLHashMap["__class"] = "org.jbox2d.pooling.arrays.DynamicTLArray.TLHashMap";

    }

}
namespace org.jbox2d.pooling {
    export class SingletonPool {
        static pool : SingletonPool.Pool; public static pool_$LI$() : SingletonPool.Pool { if(SingletonPool.pool == null) SingletonPool.pool = (() => { let __o : any = new SingletonPool.Pool(); __o.__delegate = new SingletonPool.Pool(); return __o; })(); return SingletonPool.pool; };

        public static getCollideCircle() : org.jbox2d.collision.shapes.CollideCircle {
            return /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(SingletonPool.pool_$LI$()).collideCircle;
        }

        public static getCollidePoly() : org.jbox2d.collision.shapes.CollidePoly {
            return /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(SingletonPool.pool_$LI$()).collidePoly;
        }

        public static getDistance() : org.jbox2d.collision.Distance {
            return /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(SingletonPool.pool_$LI$()).distance;
        }
    }
    SingletonPool["__class"] = "org.jbox2d.pooling.SingletonPool";


    export namespace SingletonPool {

        export class Singletons {
            public collideCircle : org.jbox2d.collision.shapes.CollideCircle = new org.jbox2d.collision.shapes.CollideCircle();

            public collidePoly : org.jbox2d.collision.shapes.CollidePoly = new org.jbox2d.collision.shapes.CollidePoly();

            public distance : org.jbox2d.collision.Distance = new org.jbox2d.collision.Distance();

            constructor() {
            }
        }
        Singletons["__class"] = "org.jbox2d.pooling.SingletonPool.Singletons";


        export class Pool {
            initialValue() : SingletonPool.Singletons {
                return new SingletonPool.Singletons();
            }

            constructor() {
            }
        }
        Pool["__class"] = "org.jbox2d.pooling.SingletonPool.Pool";

    }

}
namespace org.jbox2d.pooling.stacks {
    export abstract class DynamicTLStack<T> {
        /*private*/ tlStack : org.jbox2d.pooling.TLStack<T> = <any>((() => { let __o : any = new org.jbox2d.pooling.TLStack<T>(); __o.__delegate = new org.jbox2d.pooling.TLStack<T>(); return __o; })());

        public get() : T {
            let stack : Array<T> = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(this.tlStack);
            if(/* isEmpty */(stack.length == 0)) {
                /* push */(stack.push(this.newObjectInstance())>0);
                /* push */(stack.push(this.newObjectInstance())>0);
                /* push */(stack.push(this.newObjectInstance())>0);
            }
            return /* pop */stack.pop();
        }

        public recycle(argObject : T) {
            /* push */(/* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(this.tlStack).push(argObject)>0);
        }

        abstract newObjectInstance() : T;
    }
    DynamicTLStack["__class"] = "org.jbox2d.pooling.stacks.DynamicTLStack";

}
namespace org.jbox2d.pooling {
    export class TLAABB {
        initialValue() : org.jbox2d.collision.AABB {
            return new org.jbox2d.collision.AABB();
        }
    }
    TLAABB["__class"] = "org.jbox2d.pooling.TLAABB";

}
namespace org.jbox2d.pooling {
    export class TLBoundValues {
        initialValue() : org.jbox2d.collision.BoundValues {
            return new org.jbox2d.collision.BoundValues();
        }
    }
    TLBoundValues["__class"] = "org.jbox2d.pooling.TLBoundValues";

}
namespace org.jbox2d.pooling {
    export class TLContactPoint {
        initialValue() : org.jbox2d.dynamics.contacts.ContactPoint {
            return new org.jbox2d.dynamics.contacts.ContactPoint();
        }
    }
    TLContactPoint["__class"] = "org.jbox2d.pooling.TLContactPoint";

}
namespace org.jbox2d.pooling {
    export class TLContactSolver {
        initialValue() : org.jbox2d.dynamics.contacts.ContactSolver {
            return new org.jbox2d.dynamics.contacts.ContactSolver();
        }
    }
    TLContactSolver["__class"] = "org.jbox2d.pooling.TLContactSolver";

}
namespace org.jbox2d.pooling {
    export class TLManifold {
        initialValue() : org.jbox2d.collision.Manifold {
            return new org.jbox2d.collision.Manifold();
        }
    }
    TLManifold["__class"] = "org.jbox2d.pooling.TLManifold";

}
namespace org.jbox2d.pooling {
    export class TLMassData {
        initialValue() : org.jbox2d.collision.MassData {
            return new org.jbox2d.collision.MassData();
        }
    }
    TLMassData["__class"] = "org.jbox2d.pooling.TLMassData";

}
namespace org.jbox2d.pooling {
    export class TLMat22 {
        initialValue() : org.jbox2d.common.Mat22 {
            return new org.jbox2d.common.Mat22();
        }
    }
    TLMat22["__class"] = "org.jbox2d.pooling.TLMat22";

}
namespace org.jbox2d.pooling {
    export class TLStack<T> {
        initialValue() : Array<T> {
            return <any>([]);
        }
    }
    TLStack["__class"] = "org.jbox2d.pooling.TLStack";

}
namespace org.jbox2d.pooling {
    export class TLTimeStep {
        /**
         * 
         * @return {org.jbox2d.dynamics.TimeStep}
         */
        initialValue() : org.jbox2d.dynamics.TimeStep {
            return new org.jbox2d.dynamics.TimeStep();
        }
    }
    TLTimeStep["__class"] = "org.jbox2d.pooling.TLTimeStep";

}
namespace org.jbox2d.pooling {
    export class TLVec2 {
        initialValue() : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2();
        }
    }
    TLVec2["__class"] = "org.jbox2d.pooling.TLVec2";

}
namespace org.jbox2d.pooling {
    export class TLXForm {
        initialValue() : org.jbox2d.common.XForm {
            return new org.jbox2d.common.XForm();
        }
    }
    TLXForm["__class"] = "org.jbox2d.pooling.TLXForm";

}
namespace org.jbox2d.testbed {
    /**
     * Holder for storing contact information.
     * @class
     */
    export class ExampleContactPoint {
        public shape1 : org.jbox2d.collision.shapes.Shape;

        public shape2 : org.jbox2d.collision.shapes.Shape;

        public normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public position : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public velocity : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        public id : org.jbox2d.collision.ContactID = new org.jbox2d.collision.ContactID();

        public state : number;

        constructor() {
            if(this.shape1===undefined) this.shape1 = null;
            if(this.shape2===undefined) this.shape2 = null;
            if(this.state===undefined) this.state = 0;
        }
    }
    ExampleContactPoint["__class"] = "org.jbox2d.testbed.ExampleContactPoint";

}
namespace org.jbox2d.testbed.mathtests {
    export class SinCosTable {
        public static TWOPI : number; public static TWOPI_$LI$() : number { if(SinCosTable.TWOPI == null) SinCosTable.TWOPI = (<any>Math).fround((Math.PI * 2)); return SinCosTable.TWOPI; };

        public static LERP_LOOKUP : boolean = true;

        public precision : number;

        public tableLength : number;

        public sinLUT : number[];

        public constructor(argPrecision : number) {
            if(this.precision===undefined) this.precision = 0;
            if(this.tableLength===undefined) this.tableLength = 0;
            if(this.sinLUT===undefined) this.sinLUT = null;
            this.precision = argPrecision;
            this.tableLength = (<number>Math.ceil((<any>Math).fround(SinCosTable.TWOPI_$LI$() / this.precision))|0);
            this.sinLUT = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.tableLength);
            for(let i : number = 0; i < this.tableLength; i++) {{
                this.sinLUT[i] = (<any>Math).fround(Math.sin((<any>Math).fround(i * this.precision)));
            };}
        }

        public sin(x : number) : number {
            x %= SinCosTable.TWOPI_$LI$();
            if(SinCosTable.LERP_LOOKUP) {
                x /= this.precision;
                let index : number = (<number>x|0);
                if(index !== 0) {
                    x %= index;
                }
                if(index === this.tableLength - 1) {
                    return ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1 - x)) * this.sinLUT[index]) + (<any>Math).fround(x * this.sinLUT[0])));
                } else {
                    return ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1 - x)) * this.sinLUT[index]) + (<any>Math).fround(x * this.sinLUT[index + 1])));
                }
            } else {
                return this.sinLUT[org.jbox2d.common.MathUtils.round((<any>Math).fround(x / this.precision)) % this.tableLength];
            }
        }
    }
    SinCosTable["__class"] = "org.jbox2d.testbed.mathtests.SinCosTable";

}
namespace org.jbox2d.testbed.mathtests {}
namespace org.jbox2d.testbed {
    /**
     * Settings for the current test.  Mostly self-explanatory.
     * <BR><BR>
     * The settings from here are applied during AbstractExample::step().
     * @class
     */
    export class TestSettings {
        public hz : number;

        public iterationCount : number;

        public enableWarmStarting : boolean;

        public enablePositionCorrection : boolean;

        public enableTOI : boolean;

        public pause : boolean;

        public singleStep : boolean;

        public drawShapes : boolean;

        public drawJoints : boolean;

        public drawCoreShapes : boolean;

        public drawOBBs : boolean;

        public drawCOMs : boolean;

        public drawStats : boolean;

        public drawImpulses : boolean;

        public drawAABBs : boolean;

        public drawPairs : boolean;

        public drawContactPoints : boolean;

        public drawContactNormals : boolean;

        public drawContactForces : boolean;

        public drawFrictionForces : boolean;

        public drawControllers : boolean;

        public constructor() {
            if(this.hz===undefined) this.hz = 0;
            if(this.iterationCount===undefined) this.iterationCount = 0;
            if(this.enableWarmStarting===undefined) this.enableWarmStarting = false;
            if(this.enablePositionCorrection===undefined) this.enablePositionCorrection = false;
            if(this.enableTOI===undefined) this.enableTOI = false;
            if(this.pause===undefined) this.pause = false;
            if(this.singleStep===undefined) this.singleStep = false;
            if(this.drawShapes===undefined) this.drawShapes = false;
            if(this.drawJoints===undefined) this.drawJoints = false;
            if(this.drawCoreShapes===undefined) this.drawCoreShapes = false;
            if(this.drawOBBs===undefined) this.drawOBBs = false;
            if(this.drawCOMs===undefined) this.drawCOMs = false;
            if(this.drawStats===undefined) this.drawStats = false;
            if(this.drawImpulses===undefined) this.drawImpulses = false;
            if(this.drawAABBs===undefined) this.drawAABBs = false;
            if(this.drawPairs===undefined) this.drawPairs = false;
            if(this.drawContactPoints===undefined) this.drawContactPoints = false;
            if(this.drawContactNormals===undefined) this.drawContactNormals = false;
            if(this.drawContactForces===undefined) this.drawContactForces = false;
            if(this.drawFrictionForces===undefined) this.drawFrictionForces = false;
            if(this.drawControllers===undefined) this.drawControllers = false;
            this.hz = 60;
            this.iterationCount = 10;
            this.drawStats = true;
            this.drawAABBs = false;
            this.drawPairs = false;
            this.drawShapes = true;
            this.drawJoints = true;
            this.drawCoreShapes = false;
            this.drawContactPoints = false;
            this.drawContactNormals = false;
            this.drawContactForces = false;
            this.drawFrictionForces = false;
            this.drawOBBs = false;
            this.drawCOMs = false;
            this.enableWarmStarting = true;
            this.enablePositionCorrection = true;
            this.enableTOI = true;
            this.drawControllers = true;
            this.pause = false;
            this.singleStep = false;
        }
    }
    TestSettings["__class"] = "org.jbox2d.testbed.TestSettings";

}
namespace org.jbox2d.testbed.timingTests {
    /**
     * Benchmark - piston example (constantly bumping a bunch of
     * circles and boxes).  Should be a decent mix of circle and
     * polygon collisions/contacts, though very little joint work.
     * 
     * Rev 129 performance summary (details below class definition in source code):
     * 
     * No bullets:
     * 1.6 Average FPS: 			390.21332
     * 1.6 -server Average FPS: 	470.05365
     * 
     * (131+: with 1024M heap, 1.6 -server: 578.7675 FPS!)
     * 
     * All bullets:
     * 1.6 Average FPS: 			185.98808
     * 1.6 -server Average FPS: 	221.55266
     * 
     * 
     * (C++ performance for no bullets is ~708 FPS, for comparison's sake)
     * @author eric
     * @class
     */
    export class PistonBenchmark implements org.jbox2d.testbed.timingTests.SimpleTest {
        public static BULLETS : boolean = false;

        public m_joint1 : org.jbox2d.dynamics.joints.RevoluteJoint;

        public m_joint2 : org.jbox2d.dynamics.joints.PrismaticJoint;

        public create(world : org.jbox2d.dynamics.World) {
            {
                let sd : org.jbox2d.collision.shapes.PolygonDef = new org.jbox2d.collision.shapes.PolygonDef();
                sd.setAsBox$float$float(0.5, 2.0);
                sd.density = 1.0;
                let rjd : org.jbox2d.dynamics.joints.RevoluteJointDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
                let prevBody : org.jbox2d.dynamics.Body = world.getGroundBody();
                let bd : org.jbox2d.dynamics.BodyDef = new org.jbox2d.dynamics.BodyDef();
                bd.position.set$float$float(0.0, 7.0);
                let body : org.jbox2d.dynamics.Body = world.createBody(bd);
                body.createShape(sd);
                body.setMassFromShapes();
                rjd.initialize(prevBody, body, new org.jbox2d.common.Vec2(0.0, 5.0));
                rjd.motorSpeed = (<any>Math).fround(1.0 * 3.1415);
                rjd.maxMotorTorque = 3.4028235E38;
                rjd.enableMotor = true;
                this.m_joint1 = <org.jbox2d.dynamics.joints.RevoluteJoint>world.createJoint(rjd);
                prevBody = body;
                sd.setAsBox$float$float(0.5, 4.0);
                bd.position.set$float$float(0.0, 13.0);
                body = world.createBody(bd);
                body.createShape(sd);
                body.setMassFromShapes();
                rjd.initialize(prevBody, body, new org.jbox2d.common.Vec2(0.0, 9.0));
                rjd.enableMotor = false;
                world.createJoint(rjd);
                prevBody = body;
                sd.setAsBox$float$float(5.0, 1.5);
                bd.position.set$float$float(0.0, 17.0);
                body = world.createBody(bd);
                body.createShape(sd);
                body.setMassFromShapes();
                rjd.initialize(prevBody, body, new org.jbox2d.common.Vec2(0.0, 17.0));
                world.createJoint(rjd);
                let pjd : org.jbox2d.dynamics.joints.PrismaticJointDef = new org.jbox2d.dynamics.joints.PrismaticJointDef();
                pjd.initialize(world.getGroundBody(), body, new org.jbox2d.common.Vec2(0.0, 17.0), new org.jbox2d.common.Vec2(0.0, 1.0));
                pjd.enableMotor = false;
                this.m_joint2 = <org.jbox2d.dynamics.joints.PrismaticJoint>world.createJoint(pjd);
                for(let i : number = 0; i < 100; ++i) {{
                    sd.setAsBox$float$float(0.4, 0.3);
                    sd.density = 0.1;
                    bd.position.set$float$float(-1.0, (<any>Math).fround(23.0 + i));
                    if(PistonBenchmark.BULLETS) bd.isBullet = true; else bd.isBullet = false;
                    body = world.createBody(bd);
                    body.createShape(sd);
                    body.setMassFromShapes();
                };}
                let cd : org.jbox2d.collision.shapes.CircleDef = new org.jbox2d.collision.shapes.CircleDef();
                cd.density = 2.0;
                cd.radius = 0.36;
                for(let i : number = 0; i < 100; ++i) {{
                    bd.position.set$float$float(1.0, (<any>Math).fround(23.0 + i));
                    if(PistonBenchmark.BULLETS) bd.isBullet = true; else bd.isBullet = false;
                    body = world.createBody(bd);
                    body.createShape(cd);
                    body.setMassFromShapes();
                };}
                sd.density = 0.0;
                sd.friction = 0.0;
                sd.setAsBox$float$float(1.0, 100.0);
                bd = new org.jbox2d.dynamics.BodyDef();
                bd.position.set$float$float(-6.1, 50.0);
                let bod : org.jbox2d.dynamics.Body = world.createBody(bd);
                bod.createShape(sd);
                bd.position.set$float$float(6.1, 50.0);
                bod = world.createBody(bd);
                bod.createShape(sd);
            };
        }

        public toString() : string {
            return "Piston test";
        }

        constructor() {
            if(this.m_joint1===undefined) this.m_joint1 = null;
            if(this.m_joint2===undefined) this.m_joint2 = null;
        }
    }
    PistonBenchmark["__class"] = "org.jbox2d.testbed.timingTests.PistonBenchmark";
    PistonBenchmark["__interfaces"] = ["org.jbox2d.testbed.timingTests.SimpleTest"];


}
namespace org.jbox2d.testbed.timingTests {
    export interface SimpleTest {
        create(world : org.jbox2d.dynamics.World);
    }
}
namespace org.jbox2d.util.blob {
    export interface BlobContainer {
        /**
         * Is the Vec2 within the desired geometry?
         * @param {org.jbox2d.common.Vec2} p The point to test
         * @return {boolean} True if the geometry contains the point
         */
        containsPoint(p : org.jbox2d.common.Vec2) : boolean;

        /**
         * Get the world AABB of the container.
         * @return {org.jbox2d.collision.AABB}
         */
        getAABB() : org.jbox2d.collision.AABB;
    }
}
namespace org.jbox2d.util.blob {
    /**
     * BlobMaker offers a static API for the creation of blobs.
     * @class
     */
    export class BlobMaker {
        public static pointRadius : number = 3.0;

        public static pointDensity : number = 1.0;

        public static pointFriction : number = 0.5;

        public static createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World(s : org.jbox2d.util.blob.BlobStructure, c : org.jbox2d.util.blob.BlobContainer, w : org.jbox2d.dynamics.World) {
            BlobMaker.createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float(s, c, w, 1.0, 1.0);
        }

        public static createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float(s : org.jbox2d.util.blob.BlobStructure, c : org.jbox2d.util.blob.BlobContainer, w : org.jbox2d.dynamics.World, scaleX : number, scaleY : number) {
            BlobMaker.createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float$float$float(s, c, w, scaleX, scaleY, 0.0, 0.0);
        }

        public static createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float$float$float(s : org.jbox2d.util.blob.BlobStructure, c : org.jbox2d.util.blob.BlobContainer, w : org.jbox2d.dynamics.World, scaleX : number, scaleY : number, transX : number, transY : number) {
            let aabb : org.jbox2d.collision.AABB = c.getAABB();
            while((transX > 0.0)) {transX -= scaleX};
            while((transY > 0.0)) {transY -= scaleY};
            let xMin : number = (<any>Math).fround(aabb.lowerBound.x + transX);
            let yMin : number = (<any>Math).fround(aabb.lowerBound.y + transY);
            let nWidth : number = (<number>Math.ceil((<any>Math).fround(((<any>Math).fround(aabb.upperBound.x - xMin)) / scaleX))|0);
            let nHeight : number = (<number>Math.ceil((<any>Math).fround(((<any>Math).fround(aabb.upperBound.y - yMin)) / scaleY))|0);
            nWidth += 3;
            nHeight += 3;
            let nPerCell : number = /* size */(<number>s.points.length);
            let nPoints : number = nPerCell * nWidth * nHeight;
            console.info(nWidth + " " + nHeight);
            let bodies : org.jbox2d.dynamics.Body[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(nPoints);
            let cd : org.jbox2d.collision.shapes.CircleDef = new org.jbox2d.collision.shapes.CircleDef();
            cd.radius = BlobMaker.pointRadius;
            cd.density = BlobMaker.pointDensity;
            cd.friction = BlobMaker.pointFriction;
            let index : number = 0;
            for(let j : number = 0; j < nHeight; ++j) {{
                let yStart : number = (<any>Math).fround((<any>Math).fround(yMin + transY) + (<any>Math).fround(j * scaleY));
                for(let i : number = 0; i < nWidth; ++i) {{
                    let xStart : number = (<any>Math).fround((<any>Math).fround(xMin + transX) + (<any>Math).fround(i * scaleX));
                    for(let k : number = 0; k < nPerCell; ++k) {{
                        let position : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(/* get */s.points[k].position.x + xStart), (<any>Math).fround(/* get */s.points[k].position.y + yStart));
                        if(!c.containsPoint(position)) {
                            bodies[index++] = null;
                            continue;
                        }
                        let bd : org.jbox2d.dynamics.BodyDef = new org.jbox2d.dynamics.BodyDef();
                        bd.position = position;
                        bd.fixedRotation = false;
                        bd.angularDamping = 0.2;
                        bodies[index] = w.createBody(bd);
                        bodies[index].createShape(cd);
                        bodies[index].setMassFromShapes();
                        ++index;
                    };}
                };}
            };}
            for(let j : number = 0; j < nHeight; ++j) {{
                let rowStartIndex : number = j * nWidth * nPerCell;
                for(let i : number = 0; i < nWidth; ++i) {{
                    let boxStartIndex : number = rowStartIndex + i * nPerCell;
                    let indexUR : number = -(nWidth - 1) * nPerCell + boxStartIndex;
                    let indexR : number = nPerCell + boxStartIndex;
                    let indexDR : number = (nWidth + 1) * nPerCell + boxStartIndex;
                    let indexD : number = nWidth * nPerCell + boxStartIndex;
                    for(let k : number = 0; k < /* size */(<number>s.connections.length); ++k) {{
                        let iiff : org.jbox2d.util.blob.BlobStructure.IntIntFloatFloat = /* get */s.connections[k];
                        let a : number = iiff.a + boxStartIndex;
                        let b : number = iiff.b + boxStartIndex;
                        let freq : number = iiff.c;
                        let damp : number = iiff.d;
                        BlobMaker.createConnection(bodies, a, b, freq, damp, w);
                    };}
                    for(let k : number = 0; k < /* size */(<number>s.connectionsR.length); ++k) {{
                        let iiff : org.jbox2d.util.blob.BlobStructure.IntIntFloatFloat = /* get */s.connectionsR[k];
                        let a : number = iiff.a + boxStartIndex;
                        let b : number = iiff.b + indexR;
                        let freq : number = iiff.c;
                        let damp : number = iiff.d;
                        BlobMaker.createConnection(bodies, a, b, freq, damp, w);
                    };}
                    for(let k : number = 0; k < /* size */(<number>s.connectionsDR.length); ++k) {{
                        let iiff : org.jbox2d.util.blob.BlobStructure.IntIntFloatFloat = /* get */s.connectionsDR[k];
                        let a : number = iiff.a + boxStartIndex;
                        let b : number = iiff.b + indexDR;
                        let freq : number = iiff.c;
                        let damp : number = iiff.d;
                        BlobMaker.createConnection(bodies, a, b, freq, damp, w);
                    };}
                    for(let k : number = 0; k < /* size */(<number>s.connectionsD.length); ++k) {{
                        let iiff : org.jbox2d.util.blob.BlobStructure.IntIntFloatFloat = /* get */s.connectionsD[k];
                        let a : number = iiff.a + boxStartIndex;
                        let b : number = iiff.b + indexD;
                        let freq : number = iiff.c;
                        let damp : number = iiff.d;
                        BlobMaker.createConnection(bodies, a, b, freq, damp, w);
                    };}
                    for(let k : number = 0; k < /* size */(<number>s.connectionsUR.length); ++k) {{
                        if(j === 0) break;
                        let iiff : org.jbox2d.util.blob.BlobStructure.IntIntFloatFloat = /* get */s.connectionsUR[k];
                        let a : number = iiff.a + boxStartIndex;
                        let b : number = iiff.b + indexUR;
                        let freq : number = iiff.c;
                        let damp : number = iiff.d;
                        BlobMaker.createConnection(bodies, a, b, freq, damp, w);
                    };}
                };}
            };}
        }

        /**
         * Creates a blob in a given physics world.
         * Applies the specified x/y scaling to the structure before fill.
         * <BR><BR>
         * The fill procedure aligns the structure with the upper
         * left corner of the container AABB, applies the scaling,
         * shifts the cell by the requested translation amounts,
         * then repeats the structure until the AABB is filled,
         * testing at each point whether the container is supposed
         * to have geometry there.
         * @param {org.jbox2d.util.blob.BlobStructure} s The BlobStructure definition
         * @param {*} c The BlobContainer that specifies the geometry to fill
         * @param {org.jbox2d.dynamics.World} w The World to create the blob in
         * @param {number} scaleX The world width of one repeating cell of the structure
         * @param {number} scaleY The world height of one repeating cell of the structure
         * @param {number} transX The world x offset of the cells from the AABB edge
         * @param {number} transY The world y offset of the cells from the AABB edge
         */
        public static createBlob(s? : any, c? : any, w? : any, scaleX? : any, scaleY? : any, transX? : any, transY? : any) : any {
            if(((s != null && s instanceof <any>org.jbox2d.util.blob.BlobStructure) || s === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0)) || c === null) && ((w != null && w instanceof <any>org.jbox2d.dynamics.World) || w === null) && ((typeof scaleX === 'number') || scaleX === null) && ((typeof scaleY === 'number') || scaleY === null) && ((typeof transX === 'number') || transX === null) && ((typeof transY === 'number') || transY === null)) {
                return <any>org.jbox2d.util.blob.BlobMaker.createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float$float$float(s, c, w, scaleX, scaleY, transX, transY);
            } else if(((s != null && s instanceof <any>org.jbox2d.util.blob.BlobStructure) || s === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0)) || c === null) && ((w != null && w instanceof <any>org.jbox2d.dynamics.World) || w === null) && ((typeof scaleX === 'number') || scaleX === null) && ((typeof scaleY === 'number') || scaleY === null) && transX === undefined && transY === undefined) {
                return <any>org.jbox2d.util.blob.BlobMaker.createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float(s, c, w, scaleX, scaleY);
            } else if(((s != null && s instanceof <any>org.jbox2d.util.blob.BlobStructure) || s === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0)) || c === null) && ((w != null && w instanceof <any>org.jbox2d.dynamics.World) || w === null) && scaleX === undefined && scaleY === undefined && transX === undefined && transY === undefined) {
                return <any>org.jbox2d.util.blob.BlobMaker.createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World(s, c, w);
            } else throw new Error('invalid overload');
        }

        /*private*/ static createConnection(bodies : org.jbox2d.dynamics.Body[], a : number, b : number, frequency : number, damping : number, w : org.jbox2d.dynamics.World) : org.jbox2d.dynamics.joints.Joint {
            if(a >= bodies.length || b >= bodies.length || bodies[a] == null || bodies[b] == null) return null;
            let jd : org.jbox2d.dynamics.joints.DistanceJointDef = new org.jbox2d.dynamics.joints.DistanceJointDef();
            jd.collideConnected = false;
            jd.dampingRatio = damping;
            jd.frequencyHz = frequency;
            jd.initialize(bodies[a], bodies[b], bodies[a].getMemberPosition(), bodies[b].getMemberPosition());
            return w.createJoint(jd);
        }
    }
    BlobMaker["__class"] = "org.jbox2d.util.blob.BlobMaker";

}
namespace org.jbox2d.util.blob {
    export class BlobPoint {
        public position : org.jbox2d.common.Vec2;

        public mass : number = 1.0;

        public constructor(x : number, y : number) {
            if(this.position===undefined) this.position = null;
            this.position = new org.jbox2d.common.Vec2(x, y);
        }
    }
    BlobPoint["__class"] = "org.jbox2d.util.blob.BlobPoint";

}
namespace org.jbox2d.util.blob {
    /**
     * <p>Class for a toroidal repeating blob structure.
     * Should be subclassed with code to initialize
     * the structure in appropriate ways, such as for
     * a hexagonal lattice or a uniform grid.</p>
     * <p>Blobs are defined within an AABB from
     * (0,0)->(1,1) that is then repeated to fill the
     * full space after scaling (using the BlobMaker methods).
     * The connections list keeps track of pairs of BlobPoints
     * by index that are connected, and the connections* lists keep
     * track of connections outside the AABB (to the
     * corresponding points in the next regions).
     * </p>
     * <p>
     * Connections should only be defined once per pair.
     * </p>
     * <p>
     * This class does not allow for arbitrary repeated structures,
     * but most structures of interest will be expressible
     * as toroidally repeating in this way.
     * </p>
     * @class
     */
    export class BlobStructure {
        points : Array<org.jbox2d.util.blob.BlobPoint>;

        connections : Array<BlobStructure.IntIntFloatFloat>;

        connectionsR : Array<BlobStructure.IntIntFloatFloat>;

        connectionsDR : Array<BlobStructure.IntIntFloatFloat>;

        connectionsD : Array<BlobStructure.IntIntFloatFloat>;

        connectionsUR : Array<BlobStructure.IntIntFloatFloat>;

        currentFrequency : number = 10.0;

        currentDamping : number = 0.9;

        updateSprings() {
            for(let index150=0; index150 < this.connections.length; index150++) {
                let iiff = this.connections[index150];
                {
                    iiff.c = this.currentFrequency;
                    iiff.d = this.currentDamping;
                }
            }
            for(let index151=0; index151 < this.connectionsR.length; index151++) {
                let iiff = this.connectionsR[index151];
                {
                    iiff.c = this.currentFrequency;
                    iiff.d = this.currentDamping;
                }
            }
            for(let index152=0; index152 < this.connectionsDR.length; index152++) {
                let iiff = this.connectionsDR[index152];
                {
                    iiff.c = this.currentFrequency;
                    iiff.d = this.currentDamping;
                }
            }
            for(let index153=0; index153 < this.connectionsD.length; index153++) {
                let iiff = this.connectionsD[index153];
                {
                    iiff.c = this.currentFrequency;
                    iiff.d = this.currentDamping;
                }
            }
            for(let index154=0; index154 < this.connectionsUR.length; index154++) {
                let iiff = this.connectionsUR[index154];
                {
                    iiff.c = this.currentFrequency;
                    iiff.d = this.currentDamping;
                }
            }
        }

        public setSpringFrequency(freq : number) {
            this.currentFrequency = freq;
            this.updateSprings();
        }

        public getSpringFrequency() : number {
            return this.currentFrequency;
        }

        public setSpringDamping(damp : number) {
            this.currentDamping = damp;
            this.updateSprings();
        }

        public getSpringDamping() : number {
            return this.currentDamping;
        }

        public constructor() {
            if(this.points===undefined) this.points = null;
            if(this.connections===undefined) this.connections = null;
            if(this.connectionsR===undefined) this.connectionsR = null;
            if(this.connectionsDR===undefined) this.connectionsDR = null;
            if(this.connectionsD===undefined) this.connectionsD = null;
            if(this.connectionsUR===undefined) this.connectionsUR = null;
            this.points = <any>([]);
            this.connections = <any>([]);
            this.connectionsR = <any>([]);
            this.connectionsDR = <any>([]);
            this.connectionsD = <any>([]);
            this.connectionsUR = <any>([]);
        }

        public addPoint(p : org.jbox2d.util.blob.BlobPoint) : number {
            if(p.position.x < 0.0 || p.position.x > 1.0 || p.position.y < 0.0 || p.position.y > 1.0) throw Object.defineProperty(new Error("Points must be within (0,0)->(1,1) in a BlobStructure."), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
            /* add */(this.points.push(p)>0);
            return this.points.indexOf(p);
        }

        public addConnection$int$int(a : number, b : number) {
            /* add */(this.connections.push(new BlobStructure.IntIntFloatFloat(this, a, b, this.currentFrequency, this.currentDamping))>0);
        }

        public addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(a : number, b : number, r : BlobStructure.Region) {
            switch((r)) {
            case org.jbox2d.util.blob.BlobStructure.Region.CENTER:
                this.addConnection$int$int(a, b);
                break;
            case org.jbox2d.util.blob.BlobStructure.Region.RIGHT:
                /* add */(this.connectionsR.push(new BlobStructure.IntIntFloatFloat(this, a, b, this.currentFrequency, this.currentDamping))>0);
                break;
            case org.jbox2d.util.blob.BlobStructure.Region.DOWN_RIGHT:
                /* add */(this.connectionsDR.push(new BlobStructure.IntIntFloatFloat(this, a, b, this.currentFrequency, this.currentDamping))>0);
                break;
            case org.jbox2d.util.blob.BlobStructure.Region.DOWN:
                /* add */(this.connectionsD.push(new BlobStructure.IntIntFloatFloat(this, a, b, this.currentFrequency, this.currentDamping))>0);
                break;
            case org.jbox2d.util.blob.BlobStructure.Region.UP_RIGHT:
                /* add */(this.connectionsUR.push(new BlobStructure.IntIntFloatFloat(this, a, b, this.currentFrequency, this.currentDamping))>0);
                break;
            }
        }

        /**
         * 
         * Add a connection between point at index a in the fundamental domain
         * and point at index b in region r.
         * <BR><BR>
         * Point indices can be obtained when points are added by storing the
         * return value of the addPoint method.
         * @param {number} a
         * @param {number} b
         * @param {org.jbox2d.util.blob.BlobStructure.Region} r
         */
        public addConnection(a? : any, b? : any, r? : any) : any {
            if(((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null) && ((typeof r === 'number') || r === null)) {
                return <any>this.addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(a, b, r);
            } else if(((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null) && r === undefined) {
                return <any>this.addConnection$int$int(a, b);
            } else throw new Error('invalid overload');
        }
    }
    BlobStructure["__class"] = "org.jbox2d.util.blob.BlobStructure";


    export namespace BlobStructure {

        export class IntIntFloatFloat {
            public __parent: any;
            public a : number;

            public b : number;

            public c : number;

            public d : number;

            public constructor(__parent: any, _a : number, _b : number, _c : number, _d : number) {
                this.__parent = __parent;
                if(this.a===undefined) this.a = 0;
                if(this.b===undefined) this.b = 0;
                if(this.c===undefined) this.c = 0;
                if(this.d===undefined) this.d = 0;
                this.a = _a;
                this.b = _b;
                this.c = _c;
                this.d = _d;
            }
        }
        IntIntFloatFloat["__class"] = "org.jbox2d.util.blob.BlobStructure.IntIntFloatFloat";


        /**
         * Determines what region in toroidal space we're referring to.
         * @enum
         * @property {org.jbox2d.util.blob.BlobStructure.Region} DOWN
         * @property {org.jbox2d.util.blob.BlobStructure.Region} RIGHT
         * @property {org.jbox2d.util.blob.BlobStructure.Region} DOWN_RIGHT
         * @property {org.jbox2d.util.blob.BlobStructure.Region} UP_RIGHT
         * @property {org.jbox2d.util.blob.BlobStructure.Region} CENTER
         * @class
         */
        export enum Region {
            DOWN, RIGHT, DOWN_RIGHT, UP_RIGHT, CENTER
        }
    }

}
namespace org.jbox2d.util.blob {
    /**
     * A circular blob container specified by radius and center.
     * @param {org.jbox2d.common.Vec2} _center
     * @param {number} _radius
     * @class
     */
    export class CircularBlobContainer implements org.jbox2d.util.blob.BlobContainer {
        /*private*/ centerX : number;

        /*private*/ centerY : number;

        /*private*/ radius : number;

        /*private*/ radiusSqr : number;

        public constructor(_center : org.jbox2d.common.Vec2, _radius : number) {
            if(this.centerX===undefined) this.centerX = 0;
            if(this.centerY===undefined) this.centerY = 0;
            if(this.radius===undefined) this.radius = 0;
            if(this.radiusSqr===undefined) this.radiusSqr = 0;
            this.centerX = _center.x;
            this.centerY = _center.y;
            this.radius = _radius;
            this.radiusSqr = (<any>Math).fround(_radius * _radius);
        }

        public getRadius() : number {
            return this.radius;
        }

        public setRadius(r : number) {
            this.radius = r;
            this.radiusSqr = (<any>Math).fround(r * r);
        }

        public getCenter() : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2(this.centerX, this.centerY);
        }

        public setCenter(c : org.jbox2d.common.Vec2) {
            this.centerX = c.x;
            this.centerY = c.y;
        }

        public containsPoint(p : org.jbox2d.common.Vec2) : boolean {
            let distSqr : number = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(p.x - this.centerX)) * ((<any>Math).fround(p.x - this.centerX))) + (<any>Math).fround(((<any>Math).fround(p.y - this.centerY)) * ((<any>Math).fround(p.y - this.centerY))));
            if(distSqr > this.radiusSqr) return false;
            return true;
        }

        public getAABB() : org.jbox2d.collision.AABB {
            let min : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(this.centerX - (<any>Math).fround(this.radius * 1.2)), (<any>Math).fround(this.centerY - (<any>Math).fround(this.radius * 1.2)));
            let max : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(this.centerX + (<any>Math).fround(this.radius * 1.2)), (<any>Math).fround(this.centerY + (<any>Math).fround(this.radius * 1.2)));
            return new org.jbox2d.collision.AABB(min, max);
        }
    }
    CircularBlobContainer["__class"] = "org.jbox2d.util.blob.CircularBlobContainer";
    CircularBlobContainer["__interfaces"] = ["org.jbox2d.util.blob.BlobContainer"];


}
namespace org.jbox2d.util.blob {
    /**
     * A donut blob container specified by two radii and a center.
     * @param {org.jbox2d.common.Vec2} _center
     * @param {number} _radiusSmall
     * @param {number} _radiusLarge
     * @class
     */
    export class DonutBlobContainer implements org.jbox2d.util.blob.BlobContainer {
        /*private*/ centerX : number;

        /*private*/ centerY : number;

        /*private*/ radiusLarge : number;

        /*private*/ radiusSmallSqr : number;

        /*private*/ radiusLargeSqr : number;

        public constructor(_center : org.jbox2d.common.Vec2, _radiusSmall : number, _radiusLarge : number) {
            if(this.centerX===undefined) this.centerX = 0;
            if(this.centerY===undefined) this.centerY = 0;
            if(this.radiusLarge===undefined) this.radiusLarge = 0;
            if(this.radiusSmallSqr===undefined) this.radiusSmallSqr = 0;
            if(this.radiusLargeSqr===undefined) this.radiusLargeSqr = 0;
            this.centerX = _center.x;
            this.centerY = _center.y;
            this.radiusLarge = _radiusLarge;
            this.radiusSmallSqr = (<any>Math).fround(_radiusSmall * _radiusSmall);
            this.radiusLargeSqr = (<any>Math).fround(_radiusLarge * _radiusLarge);
        }

        public containsPoint(p : org.jbox2d.common.Vec2) : boolean {
            let distSqr : number = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(p.x - this.centerX)) * ((<any>Math).fround(p.x - this.centerX))) + (<any>Math).fround(((<any>Math).fround(p.y - this.centerY)) * ((<any>Math).fround(p.y - this.centerY))));
            if(distSqr > this.radiusLargeSqr) return false;
            if(distSqr < this.radiusSmallSqr) return false;
            return true;
        }

        public getAABB() : org.jbox2d.collision.AABB {
            let min : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(this.centerX - (<any>Math).fround(1.2 * this.radiusLarge)), (<any>Math).fround(this.centerY - (<any>Math).fround(1.2 * this.radiusLarge)));
            let max : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(this.centerX + (<any>Math).fround(1.2 * this.radiusLarge)), (<any>Math).fround(this.centerY + (<any>Math).fround(1.2 * this.radiusLarge)));
            return new org.jbox2d.collision.AABB(min, max);
        }
    }
    DonutBlobContainer["__class"] = "org.jbox2d.util.blob.DonutBlobContainer";
    DonutBlobContainer["__interfaces"] = ["org.jbox2d.util.blob.BlobContainer"];


}
namespace org.jbox2d.util.nonconvex {
    export class Triangle {
        public x : number[];

        public y : number[];

        public constructor(x1? : any, y1? : any, x2? : any, y2? : any, x3? : any, y3? : any) {
            if(((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    if(this.x===undefined) this.x = null;
                    if(this.y===undefined) this.y = null;
                    if(this.x===undefined) this.x = null;
                    if(this.y===undefined) this.y = null;
                    (() => {
                        this.x = [0, 0, 0];
                        this.y = [0, 0, 0];
                    })();
                }
                (() => {
                    let dx1 : number = (<any>Math).fround(x2 - x1);
                    let dx2 : number = (<any>Math).fround(x3 - x1);
                    let dy1 : number = (<any>Math).fround(y2 - y1);
                    let dy2 : number = (<any>Math).fround(y3 - y1);
                    let cross : number = (<any>Math).fround((<any>Math).fround(dx1 * dy2) - (<any>Math).fround(dx2 * dy1));
                    let ccw : boolean = (cross > 0);
                    if(ccw) {
                        this.x[0] = x1;
                        this.x[1] = x2;
                        this.x[2] = x3;
                        this.y[0] = y1;
                        this.y[1] = y2;
                        this.y[2] = y3;
                    } else {
                        this.x[0] = x1;
                        this.x[1] = x3;
                        this.x[2] = x2;
                        this.y[0] = y1;
                        this.y[1] = y3;
                        this.y[2] = y2;
                    }
                })();
            } else if(x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined && x3 === undefined && y3 === undefined) {
                let __args = arguments;
                if(this.x===undefined) this.x = null;
                if(this.y===undefined) this.y = null;
                if(this.x===undefined) this.x = null;
                if(this.y===undefined) this.y = null;
                (() => {
                    this.x = [0, 0, 0];
                    this.y = [0, 0, 0];
                })();
            } else throw new Error('invalid overload');
        }

        public set(t : Triangle) {
            this.x[0] = t.x[0];
            this.x[1] = t.x[1];
            this.x[2] = t.x[2];
            this.y[0] = t.y[0];
            this.y[1] = t.y[1];
            this.y[2] = t.y[2];
        }

        public containsPoint(_x : number, _y : number) : boolean {
            let vx2 : number = (<any>Math).fround(_x - this.x[0]);
            let vy2 : number = (<any>Math).fround(_y - this.y[0]);
            let vx1 : number = (<any>Math).fround(this.x[1] - this.x[0]);
            let vy1 : number = (<any>Math).fround(this.y[1] - this.y[0]);
            let vx0 : number = (<any>Math).fround(this.x[2] - this.x[0]);
            let vy0 : number = (<any>Math).fround(this.y[2] - this.y[0]);
            let dot00 : number = (<any>Math).fround((<any>Math).fround(vx0 * vx0) + (<any>Math).fround(vy0 * vy0));
            let dot01 : number = (<any>Math).fround((<any>Math).fround(vx0 * vx1) + (<any>Math).fround(vy0 * vy1));
            let dot02 : number = (<any>Math).fround((<any>Math).fround(vx0 * vx2) + (<any>Math).fround(vy0 * vy2));
            let dot11 : number = (<any>Math).fround((<any>Math).fround(vx1 * vx1) + (<any>Math).fround(vy1 * vy1));
            let dot12 : number = (<any>Math).fround((<any>Math).fround(vx1 * vx2) + (<any>Math).fround(vy1 * vy2));
            let invDenom : number = (<any>Math).fround(1.0 / ((<any>Math).fround((<any>Math).fround(dot00 * dot11) - (<any>Math).fround(dot01 * dot01))));
            let u : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(dot11 * dot02) - (<any>Math).fround(dot01 * dot12))) * invDenom);
            let v : number = (<any>Math).fround(((<any>Math).fround((<any>Math).fround(dot00 * dot12) - (<any>Math).fround(dot01 * dot02))) * invDenom);
            return ((u >= 0) && (v >= 0) && ((<any>Math).fround(u + v) <= 1));
        }
    }
    Triangle["__class"] = "org.jbox2d.util.nonconvex.Triangle";

}
namespace org.jbox2d.util.sph {
    export class Parameter {
        public numPts : number;

        public velocityScale : number;

        public initVel : org.jbox2d.common.Vec2;

        public initMass : number;

        public initDensity : number;

        public initPressure : number;

        public initPtSpacing : number;

        public h : number;

        public c : number;

        public machNum : number;

        public betaMax : number;

        public nu : number;

        public bodyFX : number;

        public bodyFY : number;

        public densityVariation : number;

        public lengthScale : number;

        public firstOutput : number;

        public outputEvery : number;

        public numSteps : number;

        public deltaT : number;

        public constructor(p? : any) {
            if(((p != null && p instanceof <any>org.jbox2d.util.sph.Parameter) || p === null)) {
                let __args = arguments;
                if(this.numPts===undefined) this.numPts = 0;
                if(this.velocityScale===undefined) this.velocityScale = 0;
                if(this.initVel===undefined) this.initVel = null;
                if(this.initMass===undefined) this.initMass = 0;
                if(this.initDensity===undefined) this.initDensity = 0;
                if(this.initPressure===undefined) this.initPressure = 0;
                if(this.initPtSpacing===undefined) this.initPtSpacing = 0;
                if(this.h===undefined) this.h = 0;
                if(this.c===undefined) this.c = 0;
                if(this.machNum===undefined) this.machNum = 0;
                if(this.betaMax===undefined) this.betaMax = 0;
                if(this.nu===undefined) this.nu = 0;
                if(this.bodyFX===undefined) this.bodyFX = 0;
                if(this.bodyFY===undefined) this.bodyFY = 0;
                if(this.densityVariation===undefined) this.densityVariation = 0;
                if(this.lengthScale===undefined) this.lengthScale = 0;
                if(this.firstOutput===undefined) this.firstOutput = 0;
                if(this.outputEvery===undefined) this.outputEvery = 0;
                if(this.numSteps===undefined) this.numSteps = 0;
                if(this.deltaT===undefined) this.deltaT = 0;
                if(this.numPts===undefined) this.numPts = 0;
                if(this.velocityScale===undefined) this.velocityScale = 0;
                if(this.initVel===undefined) this.initVel = null;
                if(this.initMass===undefined) this.initMass = 0;
                if(this.initDensity===undefined) this.initDensity = 0;
                if(this.initPressure===undefined) this.initPressure = 0;
                if(this.initPtSpacing===undefined) this.initPtSpacing = 0;
                if(this.h===undefined) this.h = 0;
                if(this.c===undefined) this.c = 0;
                if(this.machNum===undefined) this.machNum = 0;
                if(this.betaMax===undefined) this.betaMax = 0;
                if(this.nu===undefined) this.nu = 0;
                if(this.bodyFX===undefined) this.bodyFX = 0;
                if(this.bodyFY===undefined) this.bodyFY = 0;
                if(this.densityVariation===undefined) this.densityVariation = 0;
                if(this.lengthScale===undefined) this.lengthScale = 0;
                if(this.firstOutput===undefined) this.firstOutput = 0;
                if(this.outputEvery===undefined) this.outputEvery = 0;
                if(this.numSteps===undefined) this.numSteps = 0;
                if(this.deltaT===undefined) this.deltaT = 0;
                (() => {
                    this.numPts = p.numPts;
                    this.velocityScale = p.velocityScale;
                    this.initVel = p.initVel;
                    this.initMass = p.initMass;
                    this.initDensity = p.initDensity;
                    this.initPressure = p.initPressure;
                    this.initPtSpacing = p.initPtSpacing;
                    this.h = p.h;
                    this.c = p.c;
                    this.machNum = p.machNum;
                    this.betaMax = p.betaMax;
                    this.nu = p.nu;
                    this.bodyFX = p.bodyFX;
                    this.bodyFY = p.bodyFY;
                    this.densityVariation = p.densityVariation;
                    this.lengthScale = p.lengthScale;
                    this.firstOutput = p.firstOutput;
                    this.outputEvery = p.outputEvery;
                    this.numSteps = p.numSteps;
                    this.deltaT = p.deltaT;
                })();
            } else if(p === undefined) {
                let __args = arguments;
                if(this.numPts===undefined) this.numPts = 0;
                if(this.velocityScale===undefined) this.velocityScale = 0;
                if(this.initVel===undefined) this.initVel = null;
                if(this.initMass===undefined) this.initMass = 0;
                if(this.initDensity===undefined) this.initDensity = 0;
                if(this.initPressure===undefined) this.initPressure = 0;
                if(this.initPtSpacing===undefined) this.initPtSpacing = 0;
                if(this.h===undefined) this.h = 0;
                if(this.c===undefined) this.c = 0;
                if(this.machNum===undefined) this.machNum = 0;
                if(this.betaMax===undefined) this.betaMax = 0;
                if(this.nu===undefined) this.nu = 0;
                if(this.bodyFX===undefined) this.bodyFX = 0;
                if(this.bodyFY===undefined) this.bodyFY = 0;
                if(this.densityVariation===undefined) this.densityVariation = 0;
                if(this.lengthScale===undefined) this.lengthScale = 0;
                if(this.firstOutput===undefined) this.firstOutput = 0;
                if(this.outputEvery===undefined) this.outputEvery = 0;
                if(this.numSteps===undefined) this.numSteps = 0;
                if(this.deltaT===undefined) this.deltaT = 0;
                if(this.numPts===undefined) this.numPts = 0;
                if(this.velocityScale===undefined) this.velocityScale = 0;
                if(this.initVel===undefined) this.initVel = null;
                if(this.initMass===undefined) this.initMass = 0;
                if(this.initDensity===undefined) this.initDensity = 0;
                if(this.initPressure===undefined) this.initPressure = 0;
                if(this.initPtSpacing===undefined) this.initPtSpacing = 0;
                if(this.h===undefined) this.h = 0;
                if(this.c===undefined) this.c = 0;
                if(this.machNum===undefined) this.machNum = 0;
                if(this.betaMax===undefined) this.betaMax = 0;
                if(this.nu===undefined) this.nu = 0;
                if(this.bodyFX===undefined) this.bodyFX = 0;
                if(this.bodyFY===undefined) this.bodyFY = 0;
                if(this.densityVariation===undefined) this.densityVariation = 0;
                if(this.lengthScale===undefined) this.lengthScale = 0;
                if(this.firstOutput===undefined) this.firstOutput = 0;
                if(this.outputEvery===undefined) this.outputEvery = 0;
                if(this.numSteps===undefined) this.numSteps = 0;
                if(this.deltaT===undefined) this.deltaT = 0;
                (() => {
                    this.numPts = 0;
                    this.velocityScale = 0;
                    this.initVel = new org.jbox2d.common.Vec2(0, 0);
                    this.initMass = 0;
                    this.initDensity = 0;
                    this.initPressure = 0;
                    this.initPtSpacing = 0;
                    this.h = 0;
                    this.c = 0;
                    this.machNum = 0;
                    this.deltaT = 0;
                    this.outputEvery = 0;
                    this.betaMax = 0;
                    this.numSteps = 0;
                    this.firstOutput = 0;
                    this.nu = 0;
                    this.bodyFX = 0;
                    this.bodyFY = 0;
                    this.densityVariation = 0;
                    this.lengthScale = 0;
                })();
            } else throw new Error('invalid overload');
        }
    }
    Parameter["__class"] = "org.jbox2d.util.sph.Parameter";

}
namespace org.jbox2d.util.sph {
    export class Particle {
        public pos : org.jbox2d.common.Vec2;

        public vel : org.jbox2d.common.Vec2;

        public mass : number;

        deleted : number;

        public constructor(p? : any, v? : any, m? : any) {
            if(((p != null && p instanceof <any>org.jbox2d.common.Vec2) || p === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((typeof m === 'number') || m === null)) {
                let __args = arguments;
                if(this.pos===undefined) this.pos = null;
                if(this.vel===undefined) this.vel = null;
                if(this.mass===undefined) this.mass = 0;
                if(this.deleted===undefined) this.deleted = 0;
                if(this.pos===undefined) this.pos = null;
                if(this.vel===undefined) this.vel = null;
                if(this.mass===undefined) this.mass = 0;
                if(this.deleted===undefined) this.deleted = 0;
                (() => {
                    this.pos = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(p);
                    this.vel = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(v);
                    this.mass = m;
                })();
            } else if(((p != null && p instanceof <any>org.jbox2d.util.sph.Particle) || p === null) && v === undefined && m === undefined) {
                let __args = arguments;
                let P : any = __args[0];
                if(this.pos===undefined) this.pos = null;
                if(this.vel===undefined) this.vel = null;
                if(this.mass===undefined) this.mass = 0;
                if(this.deleted===undefined) this.deleted = 0;
                if(this.pos===undefined) this.pos = null;
                if(this.vel===undefined) this.vel = null;
                if(this.mass===undefined) this.mass = 0;
                if(this.deleted===undefined) this.deleted = 0;
                (() => {
                    this.pos = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(P.pos);
                    this.vel = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(P.vel);
                    this.mass = P.mass;
                    this.deleted = P.deleted;
                })();
            } else if(p === undefined && v === undefined && m === undefined) {
                let __args = arguments;
                if(this.pos===undefined) this.pos = null;
                if(this.vel===undefined) this.vel = null;
                if(this.mass===undefined) this.mass = 0;
                if(this.deleted===undefined) this.deleted = 0;
                if(this.pos===undefined) this.pos = null;
                if(this.vel===undefined) this.vel = null;
                if(this.mass===undefined) this.mass = 0;
                if(this.deleted===undefined) this.deleted = 0;
                (() => {
                    this.pos = new org.jbox2d.common.Vec2();
                    this.vel = new org.jbox2d.common.Vec2();
                    this.mass = 0.0;
                    this.deleted = 1;
                })();
            } else throw new Error('invalid overload');
        }

        public deleteParticle() {
            this.deleted = 1;
        }

        public undeleteParticle() {
            this.deleted = 0;
        }

        public isEmpty() : boolean {
            return ((this.deleted !== 0)?true:false);
        }
    }
    Particle["__class"] = "org.jbox2d.util.sph.Particle";

}
namespace org.jbox2d.util.sph {
    export class SPHGroup {
        public t : org.jbox2d.util.sph.SmoothParticle[];

        public param : org.jbox2d.util.sph.Parameter;

        public constructor(nParts : number, aabb : org.jbox2d.collision.AABB, parent : any, tStep : number) {
            if(this.t===undefined) this.t = null;
            if(this.param===undefined) this.param = null;
            this.param = new org.jbox2d.util.sph.Parameter();
            this.param.numPts = nParts;
            this.param.initVel = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.param.machNum = 0.5;
            this.param.initDensity = 1000.0;
            this.param.initPressure = 10000.0;
            this.param.nu = 1000.0;
            this.param.deltaT = tStep;
            this.param.numSteps = 500000;
            this.param.outputEvery = 5000;
            this.param.firstOutput = 0;
            this.param.densityVariation = 0.3;
            this.param.lengthScale = 1000.0;
            this.param.bodyFX = 0.0;
            this.param.bodyFY = 0.0;
            this.param.c = 1.0;
            this.param.h = 1000.0;
            this.t = (s => { let a=[]; while(s-->0) a.push(null); return a; })(nParts);
            for(let i : number = 0; i < nParts; ++i) {{
                let x : number = parent.random(aabb.lowerBound.x, aabb.upperBound.x);
                let y : number = parent.random(aabb.lowerBound.y, aabb.upperBound.y);
                this.t[i] = new org.jbox2d.util.sph.SmoothParticle();
                this.t[i].pos.set$org_jbox2d_common_Vec2(new org.jbox2d.common.Vec2(x, y));
                this.t[i].vel.set$org_jbox2d_common_Vec2(this.param.initVel);
                this.t[i].mass = (1.0);
                this.t[i].setDensity(this.param.initDensity);
                this.t[i].setPressure(this.param.initPressure);
                this.t[i].setSmoothingLength(this.param.h);
                this.t[i].setSpeedSound(this.param.c);
                this.t[i].undeleteParticle();
                this.t[i].ID = i;
                this.t[i].setShapeID(-1);
            };}
        }

        /**
         * This method calculates the pressure of each particle
         */
        public calcPressure() {
            for(let i : number = 0; i < this.t.length; i++) {{
                if(!this.t[i].isEmpty()) {
                    this.t[i].setMinMaxDensity();
                    this.t[i].calcPressure(this.param);
                }
            };}
        }

        /**
         * Calculates SPH density/velocity contributions to p1 as a result of p2.
         * @param {org.jbox2d.util.sph.SmoothParticle} p1
         * @param {org.jbox2d.util.sph.SmoothParticle} p2
         */
        public calcSPHEquations(p1 : org.jbox2d.util.sph.SmoothParticle, p2 : org.jbox2d.util.sph.SmoothParticle) {
            if(p1.isEmpty() || p2.isEmpty()) console.info("Panic!  Particle is empty!");
            let v_aB : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(((<any>Math).fround(p1.vel.x - p2.vel.x)), ((<any>Math).fround(p1.vel.y - p2.vel.y)));
            p1.calcChangeDensity(p2, v_aB);
            p1.calcChangeVelocity(p2, v_aB, this.param);
            p1.addForceX(this.param);
            p1.addForceY(this.param);
        }

        /**
         * Calculates the correct timestep given the current setup of the system, prints
         * a message if the current time step is too large.
         */
        public calcCorrectDeltaT() {
            let i : number = 0;
            let accelX : number = 0;
            let accelY : number = 0;
            let maxAccelSquared : number = 0;
            let accelSquared : number = 0;
            maxAccelSquared = 0;
            for(i = 0; i < this.t.length; i++) {{
                if(!this.t[i].isEmpty()) {
                    accelX = this.t[i].getChangeVelocityX();
                    accelY = this.t[i].getChangeVelocityY();
                    accelSquared = accelX * accelX + accelY * accelY;
                    if(accelSquared > maxAccelSquared) maxAccelSquared = accelSquared;
                }
            };}
            let calcDeltaT : number = 10000000;
            if(maxAccelSquared > 0.0) {
                calcDeltaT = 0.25 * Math.sqrt(this.param.h / Math.sqrt(maxAccelSquared));
            }
            if(calcDeltaT < this.param.deltaT) {
                console.info("current DT: " + this.param.deltaT + " is not small enough.");
                console.info("It should be: " + calcDeltaT);
            }
        }

        /**
         * Handle a time step, including SPH forces
         */
        public updateParticles() {
            this.calcPressure();
            for(let i : number = 0; i < this.t.length; ++i) {{
                this.t[i].zeroSPHVars();
                for(let j : number = 0; j < this.t.length; ++j) {{
                    if(i === j) continue;
                    this.calcSPHEquations(this.t[i], this.t[j]);
                };}
            };}
            let dt : number = (<any>Math).fround(this.param.deltaT);
            for(let i : number = 0; i < this.t.length; ++i) {{
                let p : org.jbox2d.util.sph.SmoothParticle = this.t[i];
                p.vel.x += (<any>Math).fround((<any>Math).fround(p.getChangeVelocityX()) * dt);
                p.vel.y += (<any>Math).fround((<any>Math).fround(p.getChangeVelocityY()) * dt);
                p.density += (<any>Math).fround((<any>Math).fround(p.getChangeDensity()) * dt);
                p.pos.x += (<any>Math).fround(p.vel.x * dt);
                p.pos.y += (<any>Math).fround(p.vel.y * dt);
                console.info(p.getChangeVelocityY());
            };}
        }
    }
    SPHGroup["__class"] = "org.jbox2d.util.sph.SPHGroup";

}
namespace org.jbox2d.collision.shapes {
    /**
     * creates the circle definition at the given point with
     * a radius of 1
     * @param {org.jbox2d.common.Vec2} argVec
     * @class
     * @extends org.jbox2d.collision.shapes.ShapeDef
     */
    export class CircleDef extends org.jbox2d.collision.shapes.ShapeDef {
        public radius : number;

        public localPosition : org.jbox2d.common.Vec2;

        public constructor(argVec? : any) {
            if(((argVec != null && argVec instanceof <any>org.jbox2d.common.Vec2) || argVec === null)) {
                let __args = arguments;
                super();
                if(this.radius===undefined) this.radius = 0;
                if(this.localPosition===undefined) this.localPosition = null;
                if(this.radius===undefined) this.radius = 0;
                if(this.localPosition===undefined) this.localPosition = null;
                (() => {
                    this.localPosition = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(argVec);
                    this.type = org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE;
                    this.radius = 1.0;
                })();
            } else if(argVec === undefined) {
                let __args = arguments;
                super();
                if(this.radius===undefined) this.radius = 0;
                if(this.localPosition===undefined) this.localPosition = null;
                if(this.radius===undefined) this.radius = 0;
                if(this.localPosition===undefined) this.localPosition = null;
                (() => {
                    this.type = org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE;
                    this.localPosition = new org.jbox2d.common.Vec2(0.0, 0.0);
                    this.radius = 1.0;
                })();
            } else throw new Error('invalid overload');
        }
    }
    CircleDef["__class"] = "org.jbox2d.collision.shapes.CircleDef";

}
namespace org.jbox2d.collision.shapes {
    export class EdgeChainDef extends org.jbox2d.collision.shapes.ShapeDef {
        /**
         * The vertices in local coordinates.
         */
        /*private*/ vertices : Array<org.jbox2d.common.Vec2>;

        /**
         * Whether to create an extra edge between the first and last vertices.
         */
        /*private*/ isALoop : boolean;

        public constructor() {
            super();
            if(this.vertices===undefined) this.vertices = null;
            if(this.isALoop===undefined) this.isALoop = false;
            this.type = org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE;
            this.isALoop = true;
            this.vertices = <any>([]);
        }

        /**
         * Add a vertex to the chain.
         * @param {org.jbox2d.common.Vec2} newV
         */
        public addVertex(newV : org.jbox2d.common.Vec2) {
            /* add */(this.vertices.push(newV)>0);
        }

        /**
         * Get the number of vertices in the chain.
         * @return
         * @return {number}
         */
        public getVertexCount() : number {
            return /* size */(<number>this.vertices.length);
        }

        /**
         * Is the chain a closed loop?  If so,
         * an extra edge will be created between the
         * first and last vertices.
         * @return {boolean}
         */
        public isLoop() : boolean {
            return this.isALoop;
        }

        /**
         * Set whether an extra edge should be
         * created between first and last vertices.
         * @param {boolean} isLoop True if the chain should be a closed loop
         */
        public setIsLoop(isLoop : boolean) {
            this.isALoop = isLoop;
        }

        /**
         * Return the raw vertex list.  Modifications
         * will effect the edge chain.
         * @return
         * @return {org.jbox2d.common.Vec2[]}
         */
        public getVertices() : Array<org.jbox2d.common.Vec2> {
            return this.vertices;
        }
    }
    EdgeChainDef["__class"] = "org.jbox2d.collision.shapes.EdgeChainDef";

}
namespace org.jbox2d.collision.shapes {
    /**
     * Point shape definition.
     * @class
     * @extends org.jbox2d.collision.shapes.ShapeDef
     */
    export class PointDef extends org.jbox2d.collision.shapes.ShapeDef {
        public localPosition : org.jbox2d.common.Vec2;

        public mass : number;

        public constructor() {
            super();
            if(this.localPosition===undefined) this.localPosition = null;
            if(this.mass===undefined) this.mass = 0;
            this.type = org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE;
            this.localPosition = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.mass = 0.0;
        }
    }
    PointDef["__class"] = "org.jbox2d.collision.shapes.PointDef";

}
namespace org.jbox2d.collision.shapes {
    /**
     * Convex polygon. The vertices must be in CCW order for a right-handed
     * coordinate system with the z-axis coming out of the screen.
     * Add vertices using PolygonDef.add(Vec2),
     * and create the polygon shape using Body::createShape(ShapeDef).
     * @class
     * @extends org.jbox2d.collision.shapes.ShapeDef
     */
    export class PolygonDef extends org.jbox2d.collision.shapes.ShapeDef {
        /**
         * The polygon vertices in local coordinates.
         * <BR><BR>
         * Accessing this field is discouraged - it remains
         * public for the moment, but that is likely to change.
         * Please use addVertex(Vec2) and getVertexList/Array
         * instead to add to or inspect the current vertices.
         */
        public vertices : Array<org.jbox2d.common.Vec2>;

        public set(copyMe : PolygonDef) {
            this.density = copyMe.density;
            this.filter = new org.jbox2d.collision.FilterData();
            this.filter.set(copyMe.filter);
            this.friction = copyMe.friction;
            this.isSensor = copyMe.isSensor;
            this.restitution = copyMe.restitution;
            this.type = copyMe.type;
            this.userData = copyMe.userData;
            this.vertices = <any>([]);
            for(let i : number = 0; i < /* size */(<number>copyMe.vertices.length); ++i) {{
                this.addVertex(/* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(/* get */copyMe.vertices[i]));
            };}
        }

        public constructor() {
            super();
            if(this.vertices===undefined) this.vertices = null;
            this.type = org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE;
            this.vertices = <any>([]);
        }

        /**
         * Add a vertex to the polygon.
         * @param {org.jbox2d.common.Vec2} v
         */
        public addVertex(v : org.jbox2d.common.Vec2) {
            /* add */(this.vertices.push(v)>0);
        }

        /**
         * Removes all vertices.
         */
        public clearVertices() {
            /* clear */(this.vertices.length = 0);
        }

        /**
         * Return the vertex list as an array.
         * @return {Array}
         */
        public getVertexArray() : org.jbox2d.common.Vec2[] {
            return /* toArray */this.vertices.slice(0);
        }

        /**
         * Return the vertex list as a List<Vec2>.
         * @return {org.jbox2d.common.Vec2[]}
         */
        public getVertexList() : Array<org.jbox2d.common.Vec2> {
            return this.vertices;
        }

        public setAsBox$float$float(hx : number, hy : number) {
            /* clear */(this.vertices.length = 0);
            /* add */(this.vertices.push(new org.jbox2d.common.Vec2(-hx, -hy))>0);
            /* add */(this.vertices.push(new org.jbox2d.common.Vec2(hx, -hy))>0);
            /* add */(this.vertices.push(new org.jbox2d.common.Vec2(hx, hy))>0);
            /* add */(this.vertices.push(new org.jbox2d.common.Vec2(-hx, hy))>0);
        }

        public setAsBox$float$float$org_jbox2d_common_Vec2$float(hx : number, hy : number, center : org.jbox2d.common.Vec2, angle : number) {
            this.setAsBox$float$float(hx, hy);
            let xf : org.jbox2d.common.XForm = new org.jbox2d.common.XForm();
            xf.position.set$org_jbox2d_common_Vec2(center);
            xf.R.set$float(angle);
            for(let i : number = 0; i < /* size */(<number>this.vertices.length); ++i) {{
                org.jbox2d.common.XForm.mulToOut(xf, /* get */this.vertices[i], /* get */this.vertices[i]);
            };}
        }

        /**
         * Build vertices to represent an oriented box.
         * @param {number} hx the half-width.
         * @param {number} hy the half-height.
         * @param {org.jbox2d.common.Vec2} center the center of the box in local coordinates.
         * @param {number} angle the rotation of the box in local coordinates.
         */
        public setAsBox(hx? : any, hy? : any, center? : any, angle? : any) : any {
            if(((typeof hx === 'number') || hx === null) && ((typeof hy === 'number') || hy === null) && ((center != null && center instanceof <any>org.jbox2d.common.Vec2) || center === null) && ((typeof angle === 'number') || angle === null)) {
                return <any>this.setAsBox$float$float$org_jbox2d_common_Vec2$float(hx, hy, center, angle);
            } else if(((typeof hx === 'number') || hx === null) && ((typeof hy === 'number') || hy === null) && center === undefined && angle === undefined) {
                return <any>this.setAsBox$float$float(hx, hy);
            } else throw new Error('invalid overload');
        }

        /**
         * Return the number of vertices.
         * @return {number}
         */
        public getVertexCount() : number {
            return /* size */(<number>this.vertices.length);
        }
    }
    PolygonDef["__class"] = "org.jbox2d.collision.shapes.PolygonDef";

}
namespace org.jbox2d.collision {
    export class PairManager {
        public static NULL_PAIR : number; public static NULL_PAIR_$LI$() : number { if(PairManager.NULL_PAIR == null) PairManager.NULL_PAIR = 2147483647; return PairManager.NULL_PAIR; };

        public static NULL_PROXY : number; public static NULL_PROXY_$LI$() : number { if(PairManager.NULL_PROXY == null) PairManager.NULL_PROXY = 2147483647; return PairManager.NULL_PROXY; };

        public static TABLE_CAPACITY : number; public static TABLE_CAPACITY_$LI$() : number { if(PairManager.TABLE_CAPACITY == null) PairManager.TABLE_CAPACITY = org.jbox2d.common.Settings.maxPairs_$LI$(); return PairManager.TABLE_CAPACITY; };

        public static TABLE_MASK : number; public static TABLE_MASK_$LI$() : number { if(PairManager.TABLE_MASK == null) PairManager.TABLE_MASK = PairManager.TABLE_CAPACITY_$LI$() - 1; return PairManager.TABLE_MASK; };

        public m_pairs : org.jbox2d.collision.Pair[];

        public m_pairCount : number;

        public m_hashTable : number[];

        public m_broadPhase : org.jbox2d.collision.BroadPhase;

        public m_callback : org.jbox2d.collision.PairCallback;

        public m_freePair : number;

        public m_pairBuffer : org.jbox2d.collision.BufferedPair[];

        public m_pairBufferCount : number;

        public constructor() {
            if(this.m_pairs===undefined) this.m_pairs = null;
            if(this.m_pairCount===undefined) this.m_pairCount = 0;
            if(this.m_hashTable===undefined) this.m_hashTable = null;
            if(this.m_broadPhase===undefined) this.m_broadPhase = null;
            if(this.m_callback===undefined) this.m_callback = null;
            if(this.m_freePair===undefined) this.m_freePair = 0;
            if(this.m_pairBuffer===undefined) this.m_pairBuffer = null;
            if(this.m_pairBufferCount===undefined) this.m_pairBufferCount = 0;
            this.m_pairs = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxPairs_$LI$());
            this.m_hashTable = (s => { let a=[]; while(s-->0) a.push(0); return a; })(PairManager.TABLE_CAPACITY_$LI$());
            this.m_pairBuffer = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxPairs_$LI$());
            if(!(org.jbox2d.common.MathUtils.isPowerOfTwo(PairManager.TABLE_CAPACITY_$LI$()) === true)) throw new Error("Assertion error line 39: assert MathUtils.isPowerOfTwo(PairManager.TABLE_CAPACITY) == true;");;
            if(!(PairManager.TABLE_CAPACITY_$LI$() >= org.jbox2d.common.Settings.maxPairs_$LI$())) throw new Error("Assertion error line 40: assert PairManager.TABLE_CAPACITY >= Settings.maxPairs;");;
            for(let i : number = 0; i < PairManager.TABLE_CAPACITY_$LI$(); ++i) {{
                this.m_hashTable[i] = PairManager.NULL_PAIR_$LI$();
            };}
            this.m_freePair = 0;
            for(let i : number = 0; i < org.jbox2d.common.Settings.maxPairs_$LI$(); ++i) {{
                this.m_pairs[i] = new org.jbox2d.collision.Pair();
                this.m_pairs[i].proxyId1 = PairManager.NULL_PROXY_$LI$();
                this.m_pairs[i].proxyId2 = PairManager.NULL_PROXY_$LI$();
                this.m_pairs[i].userData = null;
                this.m_pairs[i].status = 0;
                this.m_pairs[i].next = i + 1;
                this.m_pairBuffer[i] = new org.jbox2d.collision.BufferedPair();
            };}
            this.m_pairs[org.jbox2d.common.Settings.maxPairs_$LI$() - 1].next = PairManager.NULL_PAIR_$LI$();
            this.m_pairCount = 0;
            this.m_pairBufferCount = 0;
        }

        public initialize(broadPhase : org.jbox2d.collision.BroadPhase, callback : org.jbox2d.collision.PairCallback) {
            this.m_broadPhase = broadPhase;
            this.m_callback = callback;
        }

        public addPair(proxyId1 : number, proxyId2 : number) : org.jbox2d.collision.Pair {
            if(proxyId1 > proxyId2) {
                proxyId1 += proxyId2;
                proxyId2 = proxyId1 - proxyId2;
                proxyId1 -= proxyId2;
            }
            let hash : number = this.hash(proxyId1, proxyId2) & PairManager.TABLE_MASK_$LI$();
            let pair : org.jbox2d.collision.Pair = this.find$int$int$int(proxyId1, proxyId2, hash);
            if(pair != null) {
                return pair;
            }
            if(!((this.m_pairCount < org.jbox2d.common.Settings.maxPairs_$LI$()))) throw new Error("Assertion error line 75: assert (m_pairCount < Settings.maxPairs) : 'Too many pairs (' + m_pairCount + ' shape AABB overlaps) - this usually means you have too many bodies, or you need to increase Settings.maxPairs.';");;
            if(!((this.m_freePair !== PairManager.NULL_PAIR_$LI$()))) throw new Error("Assertion error line 76: assert (m_freePair != PairManager.NULL_PAIR);");;
            let pairIndex : number = this.m_freePair;
            pair = this.m_pairs[pairIndex];
            this.m_freePair = pair.next;
            pair.proxyId1 = proxyId1;
            pair.proxyId2 = proxyId2;
            pair.status = 0;
            pair.userData = null;
            pair.next = this.m_hashTable[hash];
            this.m_hashTable[hash] = pairIndex;
            ++this.m_pairCount;
            return pair;
        }

        public removePair(proxyId1 : number, proxyId2 : number) : any {
            if(!((this.m_pairCount > 0))) throw new Error("Assertion error line 91: assert (m_pairCount > 0);");;
            if(proxyId1 > proxyId2) {
                proxyId1 += proxyId2;
                proxyId2 = proxyId1 - proxyId2;
                proxyId1 -= proxyId2;
            }
            let hash : number = this.hash(proxyId1, proxyId2) & PairManager.TABLE_MASK_$LI$();
            if(org.jbox2d.collision.BroadPhase.debugPrint) {
                console.info("removePair(" + proxyId1 + "," + proxyId2 + ") hash=" + hash);
            }
            let derefnode : number = this.m_hashTable[hash];
            let isHash : boolean = true;
            let pderefnode : number = 0;
            while((derefnode !== PairManager.NULL_PAIR_$LI$())) {{
                if(this.equals$org_jbox2d_collision_Pair$int$int(this.m_pairs[derefnode], proxyId1, proxyId2)) {
                    let index : number = derefnode;
                    if(isHash) {
                        this.m_hashTable[hash] = this.m_pairs[this.m_hashTable[hash]].next;
                    } else {
                        this.m_pairs[pderefnode].next = this.m_pairs[derefnode].next;
                    }
                    let pair : org.jbox2d.collision.Pair = this.m_pairs[index];
                    let userData : any = pair.userData;
                    pair.next = this.m_freePair;
                    pair.proxyId1 = PairManager.NULL_PROXY_$LI$();
                    pair.proxyId2 = PairManager.NULL_PROXY_$LI$();
                    pair.userData = null;
                    pair.status = 0;
                    this.m_freePair = index;
                    --this.m_pairCount;
                    return userData;
                } else {
                    pderefnode = derefnode;
                    derefnode = this.m_pairs[derefnode].next;
                    isHash = false;
                }
            }};
            if(!((false))) throw new Error("Assertion error line 128: assert (false) : 'Attempted to remove a pair that does not exist';");;
            return null;
        }

        /**
         * Buffer a pair for addition. We may add a pair that is not in the pair manager
         * or pair buffer. We may add a pair that is already in the pair manager and
         * pair buffer. If the added pair is not a new pair, then it must be in the pair
         * buffer (because RemovePair was called).
         * @param {number} id1
         * @param {number} id2
         */
        public addBufferedPair(id1 : number, id2 : number) {
            if(!((id1 !== PairManager.NULL_PROXY_$LI$() && id2 !== PairManager.NULL_PROXY_$LI$()))) throw new Error("Assertion error line 141: assert (id1 != PairManager.NULL_PROXY && id2 != PairManager.NULL_PROXY);");;
            if(!((this.m_pairBufferCount < org.jbox2d.common.Settings.maxPairs_$LI$()))) throw new Error("Assertion error line 142: assert (m_pairBufferCount < Settings.maxPairs);");;
            let pair : org.jbox2d.collision.Pair = this.addPair(id1, id2);
            if(pair.isBuffered() === false) {
                if(!((pair.isFinal() === false))) throw new Error("Assertion error line 145: assert (pair.isFinal() == false);");;
                pair.setBuffered();
                this.m_pairBuffer[this.m_pairBufferCount].proxyId1 = pair.proxyId1;
                this.m_pairBuffer[this.m_pairBufferCount].proxyId2 = pair.proxyId2;
                ++this.m_pairBufferCount;
                if(!((this.m_pairBufferCount <= this.m_pairCount))) throw new Error("Assertion error line 150: assert (m_pairBufferCount <= m_pairCount);");;
            }
            pair.clearRemoved();
            if(org.jbox2d.collision.BroadPhase.s_validate) {
                this.validateBuffer();
            }
        }

        /**
         * Buffer a pair for removal.
         * 
         * @param {number} id1
         * @param {number} id2
         */
        public removeBufferedPair(id1 : number, id2 : number) {
            if(!((id1 !== PairManager.NULL_PROXY_$LI$() && id2 !== PairManager.NULL_PROXY_$LI$()))) throw new Error("Assertion error line 165: assert (id1 != PairManager.NULL_PROXY && id2 != PairManager.NULL_PROXY);");;
            if(!((this.m_pairBufferCount < org.jbox2d.common.Settings.maxPairs_$LI$()))) throw new Error("Assertion error line 166: assert (m_pairBufferCount < Settings.maxPairs);");;
            let pair : org.jbox2d.collision.Pair = this.find$int$int(id1, id2);
            if(pair == null) {
                return;
            }
            if(pair.isBuffered() === false) {
                if(!((pair.isFinal() === true))) throw new Error("Assertion error line 172: assert (pair.isFinal() == true);");;
                pair.setBuffered();
                this.m_pairBuffer[this.m_pairBufferCount].proxyId1 = pair.proxyId1;
                this.m_pairBuffer[this.m_pairBufferCount].proxyId2 = pair.proxyId2;
                ++this.m_pairBufferCount;
                if(!((this.m_pairBufferCount <= this.m_pairCount))) throw new Error("Assertion error line 177: assert (m_pairBufferCount <= m_pairCount);");;
            }
            pair.setRemoved();
            if(org.jbox2d.collision.BroadPhase.s_validate) {
                this.validateBuffer();
            }
        }

        /**
         * commits the proxies
         */
        public commit() {
            let removeCount : number = 0;
            let proxies : org.jbox2d.collision.Proxy[] = this.m_broadPhase.m_proxyPool;
            for(let i : number = 0; i < this.m_pairBufferCount; ++i) {{
                let pair : org.jbox2d.collision.Pair = this.find$int$int(this.m_pairBuffer[i].proxyId1, this.m_pairBuffer[i].proxyId2);
                if(!((pair.isBuffered()))) throw new Error("Assertion error line 193: assert (pair.isBuffered());");;
                pair.clearBuffered();
                if(!((pair.proxyId1 < org.jbox2d.common.Settings.maxProxies && pair.proxyId2 < org.jbox2d.common.Settings.maxProxies))) throw new Error("Assertion error line 195: assert (pair.proxyId1 < Settings.maxProxies && pair.proxyId2 < Settings.maxProxies);");;
                let proxy1 : org.jbox2d.collision.Proxy = proxies[pair.proxyId1];
                let proxy2 : org.jbox2d.collision.Proxy = proxies[pair.proxyId2];
                if(!((proxy1.isValid()))) throw new Error("Assertion error line 198: assert (proxy1.isValid());");;
                if(!((proxy2.isValid()))) throw new Error("Assertion error line 199: assert (proxy2.isValid());");;
                if(pair.isRemoved()) {
                    if(pair.isFinal() === true) {
                        this.m_callback.pairRemoved(proxy1.userData, proxy2.userData, pair.userData);
                    }
                    this.m_pairBuffer[removeCount].proxyId1 = pair.proxyId1;
                    this.m_pairBuffer[removeCount].proxyId2 = pair.proxyId2;
                    ++removeCount;
                } else {
                    if(!((this.m_broadPhase.testOverlap$org_jbox2d_collision_Proxy$org_jbox2d_collision_Proxy(proxy1, proxy2) === true))) throw new Error("Assertion error line 208: assert (m_broadPhase.testOverlap(proxy1, proxy2) == true);");;
                    if(pair.isFinal() === false) {
                        if(org.jbox2d.collision.BroadPhase.debugPrint) {
                            console.info("add pair " + proxy1.userData + " == " + proxy2.userData);
                        }
                        pair.userData = this.m_callback.pairAdded(proxy1.userData, proxy2.userData);
                        pair.setFinal();
                    }
                }
            };}
            if(org.jbox2d.collision.BroadPhase.debugPrint && removeCount > 0) {
                console.info("pair manager removeCount=" + removeCount);
            }
            for(let i : number = 0; i < removeCount; ++i) {{
                this.removePair(this.m_pairBuffer[i].proxyId1, this.m_pairBuffer[i].proxyId2);
            };}
            this.m_pairBufferCount = 0;
            if(org.jbox2d.collision.BroadPhase.s_validate) {
                this.validateTable();
            }
        }

        /**
         * Unimplemented - for debugging purposes only in C++ version
         */
        public validateBuffer() {
        }

        /**
         * For debugging
         */
        public validateTable() {
            for(let i : number = 0; i < PairManager.TABLE_CAPACITY_$LI$(); ++i) {{
                let index : number = this.m_hashTable[i];
                while((index !== PairManager.NULL_PAIR_$LI$())) {{
                    let pair : org.jbox2d.collision.Pair = this.m_pairs[index];
                    if(!((pair.isBuffered() === false))) throw new Error("Assertion error line 244: assert (pair.isBuffered() == false);");;
                    if(!((pair.isFinal() === true))) throw new Error("Assertion error line 245: assert (pair.isFinal() == true);");;
                    if(!((pair.isRemoved() === false))) throw new Error("Assertion error line 246: assert (pair.isRemoved() == false);");;
                    if(!((pair.proxyId1 !== pair.proxyId2))) throw new Error("Assertion error line 247: assert (pair.proxyId1 != pair.proxyId2);");;
                    if(!((pair.proxyId1 < org.jbox2d.common.Settings.maxProxies))) throw new Error("Assertion error line 248: assert (pair.proxyId1 < Settings.maxProxies);");;
                    if(!((pair.proxyId2 < org.jbox2d.common.Settings.maxProxies))) throw new Error("Assertion error line 249: assert (pair.proxyId2 < Settings.maxProxies);");;
                    let proxy1 : org.jbox2d.collision.Proxy = this.m_broadPhase.m_proxyPool[pair.proxyId1];
                    let proxy2 : org.jbox2d.collision.Proxy = this.m_broadPhase.m_proxyPool[pair.proxyId2];
                    if(!((proxy1.isValid() === true))) throw new Error("Assertion error line 252: assert (proxy1.isValid() == true);");;
                    if(!((proxy2.isValid() === true))) throw new Error("Assertion error line 253: assert (proxy2.isValid() == true);");;
                    if(!((this.m_broadPhase.testOverlap$org_jbox2d_collision_Proxy$org_jbox2d_collision_Proxy(proxy1, proxy2) === true))) throw new Error("Assertion error line 254: assert (m_broadPhase.testOverlap(proxy1, proxy2) == true);");;
                    index = pair.next;
                }};
            };}
        }

        public find$int$int$int(proxyId1 : number, proxyId2 : number, hash : number) : org.jbox2d.collision.Pair {
            let index : number = this.m_hashTable[hash];
            if(org.jbox2d.collision.BroadPhase.debugPrint) {
                console.info("find(" + proxyId1 + "," + proxyId2 + ") hash=" + hash + " tableIdx=" + index);
            }
            while((index !== PairManager.NULL_PAIR_$LI$() && this.equals$org_jbox2d_collision_Pair$int$int(this.m_pairs[index], proxyId1, proxyId2) === false)) {{
                index = this.m_pairs[index].next;
            }};
            if(index === PairManager.NULL_PAIR_$LI$()) {
                return null;
            }
            if(!(index < org.jbox2d.common.Settings.maxPairs_$LI$())) throw new Error("Assertion error line 271: assert index < Settings.maxPairs;");;
            return this.m_pairs[index];
        }

        /**
         * finds the pair with the given hash
         * 
         * @param {number} proxyId1
         * @param {number} proxyId2
         * @param {number} hash
         * @return
         * @return {org.jbox2d.collision.Pair}
         */
        public find(proxyId1? : any, proxyId2? : any, hash? : any) : any {
            if(((typeof proxyId1 === 'number') || proxyId1 === null) && ((typeof proxyId2 === 'number') || proxyId2 === null) && ((typeof hash === 'number') || hash === null)) {
                return <any>this.find$int$int$int(proxyId1, proxyId2, hash);
            } else if(((typeof proxyId1 === 'number') || proxyId1 === null) && ((typeof proxyId2 === 'number') || proxyId2 === null) && hash === undefined) {
                return <any>this.find$int$int(proxyId1, proxyId2);
            } else throw new Error('invalid overload');
        }

        public find$int$int(proxyId1 : number, proxyId2 : number) : org.jbox2d.collision.Pair {
            if(proxyId1 > proxyId2) {
                let tmp : number = proxyId1;
                proxyId1 = proxyId2;
                proxyId2 = tmp;
            }
            let hash : number = this.hash(proxyId1, proxyId2) & PairManager.TABLE_MASK_$LI$();
            return this.find$int$int$int(proxyId1, proxyId2, hash);
        }

        /*private*/ hash(proxyId1 : number, proxyId2 : number) : number {
            let key : number = (proxyId2 << 16) | proxyId1;
            key = ~key + (key << 15);
            key = key ^ (key >>> 12);
            key = key + (key << 2);
            key = key ^ (key >>> 4);
            key = key * 2057;
            key = key ^ (key >>> 16);
            return key;
        }

        public equals$org_jbox2d_collision_Pair$int$int(pair : org.jbox2d.collision.Pair, proxyId1 : number, proxyId2 : number) : boolean {
            return pair.proxyId1 === proxyId1 && pair.proxyId2 === proxyId2;
        }

        /**
         * returns if the pair has the two proxy id's
         * 
         * @param {org.jbox2d.collision.Pair} pair
         * @param {number} proxyId1
         * @param {number} proxyId2
         * @return
         * @return {boolean}
         */
        public equals(pair? : any, proxyId1? : any, proxyId2? : any) : any {
            if(((pair != null && pair instanceof <any>org.jbox2d.collision.Pair) || pair === null) && ((typeof proxyId1 === 'number') || proxyId1 === null) && ((typeof proxyId2 === 'number') || proxyId2 === null)) {
                return <any>this.equals$org_jbox2d_collision_Pair$int$int(pair, proxyId1, proxyId2);
            } else if(((pair != null && pair instanceof <any>org.jbox2d.collision.BufferedPair) || pair === null) && ((proxyId1 != null && proxyId1 instanceof <any>org.jbox2d.collision.BufferedPair) || proxyId1 === null) && proxyId2 === undefined) {
                return <any>this.equals$org_jbox2d_collision_BufferedPair$org_jbox2d_collision_BufferedPair(pair, proxyId1);
            } else throw new Error('invalid overload');
        }

        public equals$org_jbox2d_collision_BufferedPair$org_jbox2d_collision_BufferedPair(pair1 : org.jbox2d.collision.BufferedPair, pair2 : org.jbox2d.collision.BufferedPair) : boolean {
            return pair1.proxyId1 === pair2.proxyId1 && pair1.proxyId2 === pair2.proxyId2;
        }

        /**
         * For sorting. Returns if the first pair's proxyid's are less than the second
         * pair, starting with proxyId1
         * 
         * @param {org.jbox2d.collision.BufferedPair} pair1
         * @param {org.jbox2d.collision.BufferedPair} pair2
         * @return
         * @return {boolean}
         */
        public minor(pair1 : org.jbox2d.collision.BufferedPair, pair2 : org.jbox2d.collision.BufferedPair) : boolean {
            if(pair1.proxyId1 < pair2.proxyId1) {
                return true;
            }
            if(pair1.proxyId1 === pair2.proxyId1) {
                return pair1.proxyId2 < pair2.proxyId2;
            }
            return false;
        }
    }
    PairManager["__class"] = "org.jbox2d.collision.PairManager";

}
namespace org.jbox2d.common {
    /**
     * A few math methods that don't fit very well anywhere else.
     * @class
     */
    export class MathUtils {
        static __static_initialized : boolean = false;
        static __static_initialize() { if(!MathUtils.__static_initialized) { MathUtils.__static_initialized = true; MathUtils.__static_initializer_0(); } }

        public static PI : number; public static PI_$LI$() : number { MathUtils.__static_initialize(); if(MathUtils.PI == null) MathUtils.PI = (<any>Math).fround(Math.PI); return MathUtils.PI; };

        public static TWOPI : number; public static TWOPI_$LI$() : number { MathUtils.__static_initialize(); if(MathUtils.TWOPI == null) MathUtils.TWOPI = (<any>Math).fround((Math.PI * 2)); return MathUtils.TWOPI; };

        public static sinLUT : number[]; public static sinLUT_$LI$() : number[] { MathUtils.__static_initialize(); if(MathUtils.sinLUT == null) MathUtils.sinLUT = (s => { let a=[]; while(s-->0) a.push(0); return a; })(org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$()); return MathUtils.sinLUT; };

        public static cosLUT : number[]; public static cosLUT_$LI$() : number[] { MathUtils.__static_initialize(); if(MathUtils.cosLUT == null) MathUtils.cosLUT = (s => { let a=[]; while(s-->0) a.push(0); return a; })(org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$()); return MathUtils.cosLUT; };

        static __static_initializer_0() {
            for(let i : number = 0; i < org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$(); i++) {{
                MathUtils.sinLUT_$LI$()[i] = (<any>Math).fround(Math.sin((<any>Math).fround(i * org.jbox2d.common.Settings.SINCOS_LUT_PRECISION)));
                MathUtils.cosLUT_$LI$()[i] = (<any>Math).fround(Math.cos((<any>Math).fround(i * org.jbox2d.common.Settings.SINCOS_LUT_PRECISION)));
            };}
        }

        public static sin(x : number) : number {
            if(org.jbox2d.common.Settings.SINCOS_LUT_ENABLED) {
                x %= MathUtils.TWOPI_$LI$();
                while((x < 0)) {{
                    x += MathUtils.TWOPI_$LI$();
                }};
                if(org.jbox2d.common.Settings.SINCOS_LUT_LERP) {
                    x /= org.jbox2d.common.Settings.SINCOS_LUT_PRECISION;
                    let index : number = (<number>x|0);
                    if(index !== 0) {
                        x %= index;
                    }
                    if(index === org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$() - 1) {
                        return ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1 - x)) * MathUtils.sinLUT_$LI$()[index]) + (<any>Math).fround(x * MathUtils.sinLUT_$LI$()[0])));
                    } else {
                        return ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1 - x)) * MathUtils.sinLUT_$LI$()[index]) + (<any>Math).fround(x * MathUtils.sinLUT_$LI$()[index + 1])));
                    }
                } else {
                    return MathUtils.sinLUT_$LI$()[MathUtils.round((<any>Math).fround(x / org.jbox2d.common.Settings.SINCOS_LUT_PRECISION)) % org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$()];
                }
            } else {
                return (<any>Math).fround(Math.sin(x));
            }
        }

        public static cos(x : number) : number {
            if(org.jbox2d.common.Settings.SINCOS_LUT_ENABLED) {
                x %= MathUtils.TWOPI_$LI$();
                while((x < 0)) {{
                    x += MathUtils.TWOPI_$LI$();
                }};
                if(org.jbox2d.common.Settings.SINCOS_LUT_LERP) {
                    x /= org.jbox2d.common.Settings.SINCOS_LUT_PRECISION;
                    let index : number = (<number>x|0);
                    if(index !== 0) {
                        x %= index;
                    }
                    if(index === org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$() - 1) {
                        return ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1 - x)) * MathUtils.cosLUT_$LI$()[index]) + (<any>Math).fround(x * MathUtils.cosLUT_$LI$()[0])));
                    } else {
                        return ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1 - x)) * MathUtils.cosLUT_$LI$()[index]) + (<any>Math).fround(x * MathUtils.cosLUT_$LI$()[index + 1])));
                    }
                } else {
                    return MathUtils.cosLUT_$LI$()[MathUtils.round((<any>Math).fround(x / org.jbox2d.common.Settings.SINCOS_LUT_PRECISION)) % org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$()];
                }
            } else {
                return (<any>Math).fround(Math.cos(x));
            }
        }

        public static abs(x : number) : number {
            if(org.jbox2d.common.Settings.FAST_MATH) {
                return x > 0?x:-x;
            } else {
                return Math.abs(x);
            }
        }

        public static floor(x : number) : number {
            if(org.jbox2d.common.Settings.FAST_MATH) {
                return x > 0?(<number>x|0):(<number>x|0) - 1;
            } else {
                return (<number>Math.floor(x)|0);
            }
        }

        public static ceil(x : number) : number {
            if(org.jbox2d.common.Settings.FAST_MATH) {
                return MathUtils.floor((<any>Math).fround(x + 0.5));
            } else {
                return (<number>Math.ceil(x)|0);
            }
        }

        public static round(x : number) : number {
            if(org.jbox2d.common.Settings.FAST_MATH) {
                return MathUtils.floor((<any>Math).fround(x + 0.5));
            } else {
                return Math.round(x);
            }
        }

        public static max$float$float(a : number, b : number) : number {
            return a > b?a:b;
        }

        public static max$int$int(a : number, b : number) : number {
            return a > b?a:b;
        }

        public static max(a? : any, b? : any) : any {
            if(((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null)) {
                return <any>org.jbox2d.common.MathUtils.max$int$int(a, b);
            } else if(((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null)) {
                return <any>org.jbox2d.common.MathUtils.max$float$float(a, b);
            } else throw new Error('invalid overload');
        }

        public static min(a : number, b : number) : number {
            return a < b?a:b;
        }

        public static map(val : number, fromMin : number, fromMax : number, toMin : number, toMax : number) : number {
            let mult : number = (<any>Math).fround(((<any>Math).fround(val - fromMin)) / ((<any>Math).fround(fromMax - fromMin)));
            let res : number = (<any>Math).fround(toMin + (<any>Math).fround(mult * ((<any>Math).fround(toMax - toMin))));
            return res;
        }

        public static clamp$float$float$float(a : number, low : number, high : number) : number {
            return MathUtils.max$float$float(low, MathUtils.min(a, high));
        }

        public static clamp$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a : org.jbox2d.common.Vec2, low : org.jbox2d.common.Vec2, high : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let min : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            org.jbox2d.common.Vec2.minToOut(a, high, min);
            org.jbox2d.common.Vec2.maxToOut(low, min, min);
            return min;
        }

        public static clamp(a? : any, low? : any, high? : any) : any {
            if(((a != null && a instanceof <any>org.jbox2d.common.Vec2) || a === null) && ((low != null && low instanceof <any>org.jbox2d.common.Vec2) || low === null) && ((high != null && high instanceof <any>org.jbox2d.common.Vec2) || high === null)) {
                return <any>org.jbox2d.common.MathUtils.clamp$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, low, high);
            } else if(((typeof a === 'number') || a === null) && ((typeof low === 'number') || low === null) && ((typeof high === 'number') || high === null)) {
                return <any>org.jbox2d.common.MathUtils.clamp$float$float$float(a, low, high);
            } else throw new Error('invalid overload');
        }

        public static clampToOut(a : org.jbox2d.common.Vec2, low : org.jbox2d.common.Vec2, high : org.jbox2d.common.Vec2, dest : org.jbox2d.common.Vec2) {
            org.jbox2d.common.Vec2.minToOut(a, high, dest);
            org.jbox2d.common.Vec2.maxToOut(low, dest, dest);
        }

        /**
         * Next Largest Power of 2: Given a binary integer value x, the next largest
         * power of 2 can be computed by a SWAR algorithm that recursively "folds"
         * the upper bits into the lower bits. This process yields a bit vector with
         * the same most significant 1 as x, but all 1's below it. Adding 1 to that
         * value yields the next largest power of 2.
         * @param {number} x
         * @return {number}
         */
        public static nextPowerOfTwo(x : number) : number {
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            return x + 1;
        }

        public static isPowerOfTwo(x : number) : boolean {
            return x > 0 && (x & x - 1) === 0;
        }

        public static atan2(y : number, x : number) : number {
            if(org.jbox2d.common.Settings.FAST_MATH) {
                let abs_y : number = (<any>Math).fround(MathUtils.abs(y) + 1.0E-10);
                let angle : number;
                let r : number;
                if(x >= 0) {
                    r = (<any>Math).fround(((<any>Math).fround(x - abs_y)) / ((<any>Math).fround(x + abs_y)));
                    angle = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(0.1963 * r) * r) * r) - (<any>Math).fround(0.9817 * r)) + (<any>Math).fround(org.jbox2d.common.Settings.pi_$LI$() / 4));
                } else {
                    r = (<any>Math).fround(((<any>Math).fround(x + abs_y)) / ((<any>Math).fround(abs_y - x)));
                    angle = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(0.1963 * r) * r) * r) - (<any>Math).fround(0.9817 * r)) + (<any>Math).fround((<any>Math).fround(3 * org.jbox2d.common.Settings.pi_$LI$()) / 4));
                }
                if(y < 0) {
                    return -angle;
                } else {
                    return angle;
                }
            } else {
                return (<any>Math).fround(Math.atan2(y, x));
            }
        }

        /**
         * Computes a fast approximation to <code>Math.pow(a, b)</code>.
         * Adapted from <url>http://www.dctsystems.co.uk/Software/power.html</url>.
         * 
         * @param {number} a
         * a positive number
         * @param {number} b
         * a number
         * @return {number} a^b
         */
        public static pow(a : number, b : number) : number {
            if(org.jbox2d.common.Settings.FAST_MATH) {
                let x : number = /* floatToRawIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(a);
                x *= (<any>Math).fround(1.0 / (1 << 23));
                x = (<any>Math).fround(x - 127);
                let y : number = (<any>Math).fround(x - MathUtils.floor(x));
                b *= (<any>Math).fround(x + (<any>Math).fround(((<any>Math).fround(y - (<any>Math).fround(y * y))) * 0.346607));
                y = (<any>Math).fround(b - MathUtils.floor(b));
                y = (<any>Math).fround(((<any>Math).fround(y - (<any>Math).fround(y * y))) * 0.33971);
                return ((v) => { let buf = new ArrayBuffer(4); (new Uint32Array(buf))[0]=v; return (new Float32Array(buf))[0]; })((<number>((<any>Math).fround(((<any>Math).fround((<any>Math).fround(b + 127) - y)) * (1 << 23)))|0));
            } else {
                return (<any>Math).fround(Math.pow(a, b));
            }
        }

        public static sqrt(x : number) : number {
            return (<any>Math).fround(Math.sqrt(x));
        }

        public static invSqrt(x : number) : number {
            let xhalf : number = (<any>Math).fround(0.5 * x);
            let i : number = /* floatToRawIntBits */((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0]=f; return (new Uint32Array(buf))[0]; })(x);
            i = 1597463007 - (i >> 1);
            x = ((v) => { let buf = new ArrayBuffer(4); (new Uint32Array(buf))[0]=v; return (new Float32Array(buf))[0]; })(i);
            x *= (<any>Math).fround(1.5 - (<any>Math).fround((<any>Math).fround(xhalf * x) * x));
            x *= (<any>Math).fround(1.5 - (<any>Math).fround((<any>Math).fround(xhalf * x) * x));
            x *= (<any>Math).fround(1.5 - (<any>Math).fround((<any>Math).fround(xhalf * x) * x));
            x *= (<any>Math).fround(1.5 - (<any>Math).fround((<any>Math).fround(xhalf * x) * x));
            return x;
        }
    }
    MathUtils["__class"] = "org.jbox2d.common.MathUtils";

}
namespace org.jbox2d.util.nonconvex {
    /**
     * 
     * @author ewjordan
     * @param {Array} _x
     * @param {Array} _y
     * @param {number} nVert
     * @class
     */
    export class Polygon {
        static toiSlop : number; public static toiSlop_$LI$() : number { if(Polygon.toiSlop == null) Polygon.toiSlop = org.jbox2d.common.Settings.toiSlop_$LI$(); return Polygon.toiSlop; };

        public static B2_POLYGON_REPORT_ERRORS : boolean = true;

        static COLLAPSE_DIST_SQR : number; public static COLLAPSE_DIST_SQR_$LI$() : number { if(Polygon.COLLAPSE_DIST_SQR == null) Polygon.COLLAPSE_DIST_SQR = (<any>Math).fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON); return Polygon.COLLAPSE_DIST_SQR; };

        static maxPolygonVertices : number; public static maxPolygonVertices_$LI$() : number { if(Polygon.maxPolygonVertices == null) Polygon.maxPolygonVertices = org.jbox2d.common.Settings.maxPolygonVertices; return Polygon.maxPolygonVertices; };

        public nVertices : number;

        public x : number[];

        public y : number[];

        areaIsSet : boolean;

        area : number;

        /**
         * Check if the lines a0->a1 and b0->b1 cross.
         * If they do, intersectionPoint will be filled
         * with the point of crossing.
         * 
         * Grazing lines should not return true, though
         * this is not very robust.
         * 
         * @param {org.jbox2d.common.Vec2} a0
         * @param {org.jbox2d.common.Vec2} a1
         * @param {org.jbox2d.common.Vec2} b0
         * @param {org.jbox2d.common.Vec2} b1
         * @param {org.jbox2d.common.Vec2} intersectionPoint
         * @return {boolean}
         */
        static intersect(a0 : org.jbox2d.common.Vec2, a1 : org.jbox2d.common.Vec2, b0 : org.jbox2d.common.Vec2, b1 : org.jbox2d.common.Vec2, intersectionPoint : org.jbox2d.common.Vec2) : boolean {
            if(a0 === b0 || a0 === b1 || a1 === b0 || a1 === b1) return false;
            let x1 : number = a0.x;
            let y1 : number = a0.y;
            let x2 : number = a1.x;
            let y2 : number = a1.y;
            let x3 : number = b0.x;
            let y3 : number = b0.y;
            let x4 : number = b1.x;
            let y4 : number = b1.y;
            if(org.jbox2d.common.MathUtils.max$float$float(x1, x2) < org.jbox2d.common.MathUtils.min(x3, x4) || org.jbox2d.common.MathUtils.max$float$float(x3, x4) < org.jbox2d.common.MathUtils.min(x1, x2)) return false;
            if(org.jbox2d.common.MathUtils.max$float$float(y1, y2) < org.jbox2d.common.MathUtils.min(y3, y4) || org.jbox2d.common.MathUtils.max$float$float(y3, y4) < org.jbox2d.common.MathUtils.min(y1, y2)) return false;
            let ua : number = ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(x4 - x3)) * ((<any>Math).fround(y1 - y3))) - (<any>Math).fround(((<any>Math).fround(y4 - y3)) * ((<any>Math).fround(x1 - x3)))));
            let ub : number = ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(x2 - x1)) * ((<any>Math).fround(y1 - y3))) - (<any>Math).fround(((<any>Math).fround(y2 - y1)) * ((<any>Math).fround(x1 - x3)))));
            let denom : number = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(y4 - y3)) * ((<any>Math).fround(x2 - x1))) - (<any>Math).fround(((<any>Math).fround(x4 - x3)) * ((<any>Math).fround(y2 - y1))));
            if(org.jbox2d.common.MathUtils.abs(denom) < org.jbox2d.common.Settings.EPSILON) {
                return false;
            }
            ua /= denom;
            ub /= denom;
            if((0 < ua) && (ua < 1) && (0 < ub) && (ub < 1)) {
                intersectionPoint.x = ((<any>Math).fround(x1 + (<any>Math).fround(ua * ((<any>Math).fround(x2 - x1)))));
                intersectionPoint.y = ((<any>Math).fround(y1 + (<any>Math).fround(ua * ((<any>Math).fround(y2 - y1)))));
                return true;
            }
            return false;
        }

        intersect(a0 : org.jbox2d.common.Vec2, a1 : org.jbox2d.common.Vec2, b0 : org.jbox2d.common.Vec2, b1 : org.jbox2d.common.Vec2) : boolean {
            let myVec : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(0.0, 0.0);
            return Polygon.intersect(a0, a1, b0, b1, myVec);
        }

        public constructor(_x? : any, _y? : any, nVert? : any) {
            if(((_x != null && _x instanceof <any>Array && (_x.length==0 || _x[0] == null ||(typeof _x[0] === 'number'))) || _x === null) && ((_y != null && _y instanceof <any>Array && (_y.length==0 || _y[0] == null ||(typeof _y[0] === 'number'))) || _y === null) && ((typeof nVert === 'number') || nVert === null)) {
                let __args = arguments;
                if(this.nVertices===undefined) this.nVertices = 0;
                if(this.x===undefined) this.x = null;
                if(this.y===undefined) this.y = null;
                if(this.areaIsSet===undefined) this.areaIsSet = false;
                if(this.area===undefined) this.area = 0;
                if(this.nVertices===undefined) this.nVertices = 0;
                if(this.x===undefined) this.x = null;
                if(this.y===undefined) this.y = null;
                if(this.areaIsSet===undefined) this.areaIsSet = false;
                if(this.area===undefined) this.area = 0;
                (() => {
                    this.nVertices = nVert;
                    this.x = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                    this.y = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                    for(let i : number = 0; i < this.nVertices; ++i) {{
                        this.x[i] = _x[i];
                        this.y[i] = _y[i];
                    };}
                    this.areaIsSet = false;
                })();
            } else if(((_x != null && _x instanceof <any>Array && (_x.length==0 || _x[0] == null ||(typeof _x[0] === 'number'))) || _x === null) && ((_y != null && _y instanceof <any>Array && (_y.length==0 || _y[0] == null ||(typeof _y[0] === 'number'))) || _y === null) && nVert === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let nVert : any = __args[0].length;
                    if(this.nVertices===undefined) this.nVertices = 0;
                    if(this.x===undefined) this.x = null;
                    if(this.y===undefined) this.y = null;
                    if(this.areaIsSet===undefined) this.areaIsSet = false;
                    if(this.area===undefined) this.area = 0;
                    if(this.nVertices===undefined) this.nVertices = 0;
                    if(this.x===undefined) this.x = null;
                    if(this.y===undefined) this.y = null;
                    if(this.areaIsSet===undefined) this.areaIsSet = false;
                    if(this.area===undefined) this.area = 0;
                    (() => {
                        this.nVertices = nVert;
                        this.x = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                        this.y = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                        for(let i : number = 0; i < this.nVertices; ++i) {{
                            this.x[i] = _x[i];
                            this.y[i] = _y[i];
                        };}
                        this.areaIsSet = false;
                    })();
                }
            } else if(((_x != null && _x instanceof <any>Array && (_x.length==0 || _x[0] == null ||(_x[0] != null && _x[0] instanceof <any>org.jbox2d.common.Vec2))) || _x === null) && ((typeof _y === 'number') || _y === null) && nVert === undefined) {
                let __args = arguments;
                let v : any = __args[0];
                let nVert : any = __args[1];
                if(this.nVertices===undefined) this.nVertices = 0;
                if(this.x===undefined) this.x = null;
                if(this.y===undefined) this.y = null;
                if(this.areaIsSet===undefined) this.areaIsSet = false;
                if(this.area===undefined) this.area = 0;
                if(this.nVertices===undefined) this.nVertices = 0;
                if(this.x===undefined) this.x = null;
                if(this.y===undefined) this.y = null;
                if(this.areaIsSet===undefined) this.areaIsSet = false;
                if(this.area===undefined) this.area = 0;
                (() => {
                    this.nVertices = nVert;
                    this.x = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                    this.y = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                    for(let i : number = 0; i < this.nVertices; ++i) {{
                        this.x[i] = v[i].x;
                        this.y[i] = v[i].y;
                    };}
                    this.areaIsSet = false;
                })();
            } else if(((_x != null && _x instanceof <any>Array && (_x.length==0 || _x[0] == null ||(_x[0] != null && _x[0] instanceof <any>org.jbox2d.common.Vec2))) || _x === null) && _y === undefined && nVert === undefined) {
                let __args = arguments;
                let v : any = __args[0];
                {
                    let __args = arguments;
                    let nVert : any = __args[0].length;
                    if(this.nVertices===undefined) this.nVertices = 0;
                    if(this.x===undefined) this.x = null;
                    if(this.y===undefined) this.y = null;
                    if(this.areaIsSet===undefined) this.areaIsSet = false;
                    if(this.area===undefined) this.area = 0;
                    if(this.nVertices===undefined) this.nVertices = 0;
                    if(this.x===undefined) this.x = null;
                    if(this.y===undefined) this.y = null;
                    if(this.areaIsSet===undefined) this.areaIsSet = false;
                    if(this.area===undefined) this.area = 0;
                    (() => {
                        this.nVertices = nVert;
                        this.x = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                        this.y = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                        for(let i : number = 0; i < this.nVertices; ++i) {{
                            this.x[i] = v[i].x;
                            this.y[i] = v[i].y;
                        };}
                        this.areaIsSet = false;
                    })();
                }
            } else if(((_x != null && _x instanceof <any>org.jbox2d.util.nonconvex.Triangle) || _x === null) && _y === undefined && nVert === undefined) {
                let __args = arguments;
                let t : any = __args[0];
                if(this.nVertices===undefined) this.nVertices = 0;
                if(this.x===undefined) this.x = null;
                if(this.y===undefined) this.y = null;
                if(this.areaIsSet===undefined) this.areaIsSet = false;
                if(this.area===undefined) this.area = 0;
                if(this.nVertices===undefined) this.nVertices = 0;
                if(this.x===undefined) this.x = null;
                if(this.y===undefined) this.y = null;
                if(this.areaIsSet===undefined) this.areaIsSet = false;
                if(this.area===undefined) this.area = 0;
                (() => {
                    this.nVertices = 3;
                    this.x = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                    this.y = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                    for(let i : number = 0; i < this.nVertices; ++i) {{
                        this.x[i] = t.x[i];
                        this.y[i] = t.y[i];
                    };}
                })();
            } else if(_x === undefined && _y === undefined && nVert === undefined) {
                let __args = arguments;
                if(this.nVertices===undefined) this.nVertices = 0;
                if(this.x===undefined) this.x = null;
                if(this.y===undefined) this.y = null;
                if(this.areaIsSet===undefined) this.areaIsSet = false;
                if(this.area===undefined) this.area = 0;
                if(this.nVertices===undefined) this.nVertices = 0;
                if(this.x===undefined) this.x = null;
                if(this.y===undefined) this.y = null;
                if(this.areaIsSet===undefined) this.areaIsSet = false;
                if(this.area===undefined) this.area = 0;
                (() => {
                    this.x = null;
                    this.y = null;
                    this.nVertices = 0;
                    this.areaIsSet = false;
                })();
            } else throw new Error('invalid overload');
        }

        getArea() : number {
            this.area = 0.0;
            this.area += (<any>Math).fround((<any>Math).fround(this.x[this.nVertices - 1] * this.y[0]) - (<any>Math).fround(this.x[0] * this.y[this.nVertices - 1]));
            for(let i : number = 0; i < this.nVertices - 1; ++i) {{
                this.area += (<any>Math).fround((<any>Math).fround(this.x[i] * this.y[i + 1]) - (<any>Math).fround(this.x[i + 1] * this.y[i]));
            };}
            this.area *= 0.5;
            this.areaIsSet = true;
            return this.area;
        }

        isCCW() : boolean {
            return (this.getArea() > 0.0);
        }

        mergeParallelEdges(tolerance : number) {
            if(this.nVertices <= 3) return;
            let mergeMe : boolean[] = (s => { let a=[]; while(s-->0) a.push(false); return a; })(this.nVertices);
            let newNVertices : number = this.nVertices;
            for(let i : number = 0; i < this.nVertices; ++i) {{
                let lower : number = (i === 0)?(this.nVertices - 1):(i - 1);
                let middle : number = i;
                let upper : number = (i === this.nVertices - 1)?(0):(i + 1);
                let dx0 : number = (<any>Math).fround(this.x[middle] - this.x[lower]);
                let dy0 : number = (<any>Math).fround(this.y[middle] - this.y[lower]);
                let dx1 : number = (<any>Math).fround(this.x[upper] - this.x[middle]);
                let dy1 : number = (<any>Math).fround(this.y[upper] - this.y[middle]);
                let norm0 : number = (<any>Math).fround(Math.sqrt((<any>Math).fround((<any>Math).fround(dx0 * dx0) + (<any>Math).fround(dy0 * dy0))));
                let norm1 : number = (<any>Math).fround(Math.sqrt((<any>Math).fround((<any>Math).fround(dx1 * dx1) + (<any>Math).fround(dy1 * dy1))));
                if(!(norm0 > 0.0 && norm1 > 0.0) && newNVertices > 3) {
                    mergeMe[i] = true;
                    --newNVertices;
                }
                dx0 /= norm0;
                dy0 /= norm0;
                dx1 /= norm1;
                dy1 /= norm1;
                let cross : number = (<any>Math).fround((<any>Math).fround(dx0 * dy1) - (<any>Math).fround(dx1 * dy0));
                let dot : number = (<any>Math).fround((<any>Math).fround(dx0 * dx1) + (<any>Math).fround(dy0 * dy1));
                if(org.jbox2d.common.MathUtils.abs(cross) < tolerance && dot > 0 && newNVertices > 3) {
                    mergeMe[i] = true;
                    --newNVertices;
                } else {
                    mergeMe[i] = false;
                }
            };}
            if(newNVertices === this.nVertices || newNVertices === 0) {
                return;
            }
            let newx : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(newNVertices);
            let newy : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(newNVertices);
            let currIndex : number = 0;
            for(let i : number = 0; i < this.nVertices; ++i) {{
                if(mergeMe[i] || newNVertices === 0 || currIndex === newNVertices) continue;
                if(!((currIndex < newNVertices))) throw new Error("Assertion error line 274: assert (currIndex < newNVertices);");;
                newx[currIndex] = this.x[i];
                newy[currIndex] = this.y[i];
                ++currIndex;
            };}
            this.x = newx;
            this.y = newy;
            this.nVertices = newNVertices;
        }

        public getVertexVecs() : org.jbox2d.common.Vec2[] {
            let out : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.nVertices);
            for(let i : number = 0; i < this.nVertices; ++i) {{
                out[i] = new org.jbox2d.common.Vec2(this.x[i], this.y[i]);
            };}
            return out;
        }

        public set(p : Polygon) {
            if(this.nVertices !== p.nVertices) {
                this.nVertices = p.nVertices;
                this.x = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
                this.y = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices);
            }
            for(let i : number = 0; i < this.nVertices; ++i) {{
                this.x[i] = p.x[i];
                this.y[i] = p.y[i];
            };}
            this.areaIsSet = false;
        }

        /**
         * Assuming the polygon is simple, checks if it is convex.
         * @return {boolean}
         */
        public isConvex() : boolean {
            let isPositive : boolean = false;
            for(let i : number = 0; i < this.nVertices; ++i) {{
                let lower : number = (i === 0)?(this.nVertices - 1):(i - 1);
                let middle : number = i;
                let upper : number = (i === this.nVertices - 1)?(0):(i + 1);
                let dx0 : number = (<any>Math).fround(this.x[middle] - this.x[lower]);
                let dy0 : number = (<any>Math).fround(this.y[middle] - this.y[lower]);
                let dx1 : number = (<any>Math).fround(this.x[upper] - this.x[middle]);
                let dy1 : number = (<any>Math).fround(this.y[upper] - this.y[middle]);
                let cross : number = (<any>Math).fround((<any>Math).fround(dx0 * dy1) - (<any>Math).fround(dx1 * dy0));
                let newIsP : boolean = (cross >= 0)?true:false;
                if(i === 0) {
                    isPositive = newIsP;
                } else if(isPositive !== newIsP) {
                    return false;
                }
            };}
            return true;
        }

        public static polyCentroid(vs : org.jbox2d.common.Vec2[], count : number) : org.jbox2d.common.Vec2 {
            let c : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(0.0, 0.0);
            let area : number = 0.0;
            let inv3 : number = (<any>Math).fround(1.0 / 3.0);
            let pRef : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(0.0, 0.0);
            for(let i : number = 0; i < count; ++i) {{
                let p1 : org.jbox2d.common.Vec2 = pRef;
                let p2 : org.jbox2d.common.Vec2 = vs[i];
                let p3 : org.jbox2d.common.Vec2 = i + 1 < count?vs[i + 1]:vs[0];
                let e1 : org.jbox2d.common.Vec2 = p2.sub(p1);
                let e2 : org.jbox2d.common.Vec2 = p3.sub(p1);
                let D : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2);
                let triangleArea : number = (<any>Math).fround(0.5 * D);
                area += triangleArea;
                c.x += (<any>Math).fround((<any>Math).fround(triangleArea * inv3) * ((<any>Math).fround((<any>Math).fround(p1.x + p2.x) + p3.x)));
                c.y += (<any>Math).fround((<any>Math).fround(triangleArea * inv3) * ((<any>Math).fround((<any>Math).fround(p1.y + p2.y) + p3.y)));
            };}
            c.x *= (<any>Math).fround(1.0 / area);
            c.y *= (<any>Math).fround(1.0 / area);
            return c;
        }

        public isUsable$boolean(printErrors : boolean) : boolean {
            let error : number = -1;
            let noError : boolean = true;
            if(this.nVertices < 3 || this.nVertices > Polygon.maxPolygonVertices_$LI$()) {
                noError = false;
                error = 0;
            }
            if(!this.isConvex()) {
                noError = false;
                error = 1;
            }
            if(!this.isSimple()) {
                noError = false;
                error = 2;
            }
            if(this.getArea() < org.jbox2d.common.Settings.EPSILON) {
                noError = false;
                error = 3;
            }
            let normals : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.nVertices);
            let vertices : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.nVertices);
            for(let i : number = 0; i < this.nVertices; ++i) {{
                vertices[i] = new org.jbox2d.common.Vec2(this.x[i], this.y[i]);
                let i1 : number = i;
                let i2 : number = i + 1 < this.nVertices?i + 1:0;
                let edge : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(this.x[i2] - this.x[i1]), (<any>Math).fround(this.y[i2] - this.y[i1]));
                normals[i] = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(edge, 1.0);
                normals[i].normalize();
            };}
            for(let i : number = 0; i < this.nVertices; ++i) {{
                let iminus : number = (i === 0)?this.nVertices - 1:i - 1;
                let cross : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(normals[iminus], normals[i]);
                cross = org.jbox2d.common.MathUtils.clamp$float$float$float(cross, -1.0, 1.0);
                let angle : number = (<any>Math).fround(Math.asin(cross));
                if(angle <= org.jbox2d.common.Settings.angularSlop_$LI$()) {
                    noError = false;
                    error = 4;
                    break;
                }
                for(let j : number = 0; j < this.nVertices; ++j) {{
                    if(j === i || j === (i + 1) % this.nVertices) {
                        continue;
                    }
                    let s : number = org.jbox2d.common.Vec2.dot(normals[i], vertices[j].sub(vertices[i]));
                    if(s >= -org.jbox2d.common.Settings.linearSlop_$LI$()) {
                        noError = false;
                        error = 5;
                    }
                };}
                let centroid : org.jbox2d.common.Vec2 = Polygon.polyCentroid(vertices, this.nVertices);
                let n1 : org.jbox2d.common.Vec2 = normals[iminus];
                let n2 : org.jbox2d.common.Vec2 = normals[i];
                let v : org.jbox2d.common.Vec2 = vertices[i].sub(centroid);
                let d : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
                d.x = (<any>Math).fround(org.jbox2d.common.Vec2.dot(n1, v) - Polygon.toiSlop_$LI$());
                d.y = (<any>Math).fround(org.jbox2d.common.Vec2.dot(n2, v) - Polygon.toiSlop_$LI$());
                if((d.x < 0.0) || (d.y < 0.0)) {
                    noError = false;
                    error = 6;
                }
            };}
            if(!noError && printErrors) {
                console.info("Found invalid polygon, ");
                switch((error)) {
                case 0:
                    console.info("must have between 3 and " + org.jbox2d.common.Settings.maxPolygonVertices + " vertices.");
                    break;
                case 1:
                    console.info("must be convex.\n");
                    break;
                case 2:
                    console.info("must be simple (cannot intersect itself).\n");
                    break;
                case 3:
                    console.info("area is too small.\n");
                    break;
                case 4:
                    console.info("sides are too close to parallel.\n");
                    break;
                case 5:
                    console.info("polygon is too thin.\n");
                    break;
                case 6:
                    console.info("core shape generation would move edge past centroid (too thin).\n");
                    break;
                default:
                    console.info("don\'t know why.\n");
                    if(!(false)) throw new Error("Assertion error line 439: assert false;");;
                }
            }
            return noError;
        }

        /**
         * Checks if polygon is valid for use in Box2d engine.
         * Last ditch effort to ensure no invalid polygons are
         * added to world geometry.
         * 
         * Performs a full check, for simplicity, convexity,
         * orientation, minimum angle, and volume.  This won't
         * be very efficient, and a lot of it is redundant when
         * other tools in this section are used.
         * @param {boolean} printErrors
         * @return {boolean}
         */
        public isUsable(printErrors? : any) : any {
            if(((typeof printErrors === 'boolean') || printErrors === null)) {
                return <any>this.isUsable$boolean(printErrors);
            } else if(printErrors === undefined) {
                return <any>this.isUsable$();
            } else throw new Error('invalid overload');
        }

        public isUsable$() : boolean {
            return this.isUsable$boolean(Polygon.B2_POLYGON_REPORT_ERRORS);
        }

        public isSimple() : boolean {
            for(let i : number = 0; i < this.nVertices; ++i) {{
                let iplus : number = (i + 1 > this.nVertices - 1)?0:i + 1;
                let a1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(this.x[i], this.y[i]);
                let a2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(this.x[iplus], this.y[iplus]);
                for(let j : number = i + 1; j < this.nVertices; ++j) {{
                    let jplus : number = (j + 1 > this.nVertices - 1)?0:j + 1;
                    let b1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(this.x[j], this.y[j]);
                    let b2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(this.x[jplus], this.y[jplus]);
                    if(this.intersect(a1, a2, b1, b2)) {
                        return false;
                    }
                };}
            };}
            return true;
        }

        /**
         * Tries to add a triangle to the polygon. Returns null if it can't connect
         * properly, otherwise returns a pointer to the new Polygon. Assumes bitwise
         * equality of joined vertex positions.
         * 
         * Remember to delete the pointer afterwards.
         * TODO: Make this return a Polygon instead
         * of a pointer to a heap-allocated one.
         * 
         * For internal use.
         * @param {org.jbox2d.util.nonconvex.Triangle} t
         * @return {org.jbox2d.util.nonconvex.Polygon}
         */
        public add(t : org.jbox2d.util.nonconvex.Triangle) : Polygon {
            let firstP : number = -1;
            let firstT : number = -1;
            let secondP : number = -1;
            let secondT : number = -1;
            for(let i : number = 0; i < this.nVertices; i++) {{
                if(t.x[0] === this.x[i] && t.y[0] === this.y[i]) {
                    if(firstP === -1) {
                        firstP = i;
                        firstT = 0;
                    } else {
                        secondP = i;
                        secondT = 0;
                    }
                } else if(t.x[1] === this.x[i] && t.y[1] === this.y[i]) {
                    if(firstP === -1) {
                        firstP = i;
                        firstT = 1;
                    } else {
                        secondP = i;
                        secondT = 1;
                    }
                } else if(t.x[2] === this.x[i] && t.y[2] === this.y[i]) {
                    if(firstP === -1) {
                        firstP = i;
                        firstT = 2;
                    } else {
                        secondP = i;
                        secondT = 2;
                    }
                } else {
                }
            };}
            if(firstP === 0 && secondP === this.nVertices - 1) {
                firstP = this.nVertices - 1;
                secondP = 0;
            }
            if(secondP === -1) {
                return null;
            }
            let tipT : number = 0;
            if(tipT === firstT || tipT === secondT) tipT = 1;
            if(tipT === firstT || tipT === secondT) tipT = 2;
            let newx : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices + 1);
            let newy : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.nVertices + 1);
            let currOut : number = 0;
            for(let i : number = 0; i < this.nVertices; i++) {{
                newx[currOut] = this.x[i];
                newy[currOut] = this.y[i];
                if(i === firstP) {
                    ++currOut;
                    newx[currOut] = t.x[tipT];
                    newy[currOut] = t.y[tipT];
                }
                ++currOut;
            };}
            let result : Polygon = new Polygon(newx, newy, this.nVertices + 1);
            return result;
        }

        /**
         * Adds this polygon to a PolyDef.
         * @param {org.jbox2d.collision.shapes.PolygonDef} pd
         */
        public addTo(pd : org.jbox2d.collision.shapes.PolygonDef) {
            if(this.nVertices < 3) return;
            let vecs : org.jbox2d.common.Vec2[] = this.getVertexVecs();
            if(!((this.nVertices <= org.jbox2d.common.Settings.maxPolygonVertices))) throw new Error("Assertion error line 566: assert (nVertices <= Settings.maxPolygonVertices);");;
            let offset : number = 0;
            for(let i : number = 0; i < this.nVertices; ++i) {{
                if(vecs[i].x === vecs[Polygon.remainder(i + 1, this.nVertices)].x && vecs[i].y === vecs[Polygon.remainder(i + 1, this.nVertices)].y) {
                    offset++;
                    continue;
                }
                /* add */(pd.vertices.push(vecs[i])>0);
            };}
        }

        /**
         * Finds and fixes "pinch points," points where two polygon
         * vertices are at the same point.
         * 
         * If a pinch point is found, pin is broken up into poutA and poutB
         * and true is returned; otherwise, returns false.
         * 
         * Mostly for internal use.
         * 
         * O(N^2) time, which sucks...
         * @param {org.jbox2d.util.nonconvex.Polygon} pin
         * @param {org.jbox2d.util.nonconvex.Polygon} poutA
         * @param {org.jbox2d.util.nonconvex.Polygon} poutB
         * @return {boolean}
         * @private
         */
        /*private*/ static resolvePinchPoint(pin : Polygon, poutA : Polygon, poutB : Polygon) : boolean {
            if(pin.nVertices < 3) return false;
            let tol : number = 0.001;
            let hasPinchPoint : boolean = false;
            let pinchIndexA : number = -1;
            let pinchIndexB : number = -1;
            for(let i : number = 0; i < pin.nVertices; ++i) {{
                for(let j : number = i + 1; j < pin.nVertices; ++j) {{
                    if(org.jbox2d.common.MathUtils.abs((<any>Math).fround(pin.x[i] - pin.x[j])) < tol && org.jbox2d.common.MathUtils.abs((<any>Math).fround(pin.y[i] - pin.y[j])) < tol && j !== i + 1) {
                        pinchIndexA = i;
                        pinchIndexB = j;
                        hasPinchPoint = true;
                        break;
                    }
                };}
                if(hasPinchPoint) break;
            };}
            if(hasPinchPoint) {
                let sizeA : number = pinchIndexB - pinchIndexA;
                if(sizeA === pin.nVertices) return false;
                let xA : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(sizeA);
                let yA : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(sizeA);
                for(let i : number = 0; i < sizeA; ++i) {{
                    let ind : number = Polygon.remainder(pinchIndexA + i, pin.nVertices);
                    xA[i] = pin.x[ind];
                    yA[i] = pin.y[ind];
                };}
                let tempA : Polygon = new Polygon(xA, yA, sizeA);
                poutA.set(tempA);
                let sizeB : number = pin.nVertices - sizeA;
                let xB : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(sizeB);
                let yB : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(sizeB);
                for(let i : number = 0; i < sizeB; ++i) {{
                    let ind : number = Polygon.remainder(pinchIndexB + i, pin.nVertices);
                    xB[i] = pin.x[ind];
                    yB[i] = pin.y[ind];
                };}
                let tempB : Polygon = new Polygon(xB, yB, sizeB);
                poutB.set(tempB);
            }
            return hasPinchPoint;
        }

        /**
         * Triangulates a polygon using simple ear-clipping algorithm. Returns
         * size of Triangle array unless the polygon can't be triangulated.
         * This should only happen if the polygon self-intersects,
         * though it will not _always_ return null for a bad polygon - it is the
         * caller's responsibility to check for self-intersection, and if it
         * doesn't, it should at least check that the return value is non-null
         * before using. You're warned!
         * 
         * Triangles may be degenerate, especially if you have identical points
         * in the input to the algorithm.  Check this before you use them.
         * 
         * This is totally unoptimized, so for large polygons it should not be part
         * of the simulation loop.
         * 
         * Returns:
         * -1 if algorithm fails (self-intersection most likely)
         * 0 if there are not enough vertices to triangulate anything.
         * Number of triangles if triangulation was successful.
         * 
         * results will be filled with results - ear clipping always creates vNum - 2
         * or fewer (due to pinch point polygon snipping), so allocate an array of
         * this size.
         * @param {Array} xv
         * @param {Array} yv
         * @param {number} vNum
         * @param {Array} results
         * @return {number}
         */
        public static triangulatePolygon(xv : number[], yv : number[], vNum : number, results : org.jbox2d.util.nonconvex.Triangle[]) : number {
            if(vNum < 3) return 0;
            let pA : Polygon = new Polygon();
            let pB : Polygon = new Polygon();
            let pin : Polygon = new Polygon(xv, yv, vNum);
            if(Polygon.resolvePinchPoint(pin, pA, pB)) {
                let mergeA : org.jbox2d.util.nonconvex.Triangle[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(pA.nVertices);
                let mergeB : org.jbox2d.util.nonconvex.Triangle[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(pB.nVertices);
                for(let i : number = 0; i < pA.nVertices; ++i) {{
                    mergeA[i] = new org.jbox2d.util.nonconvex.Triangle();
                };}
                for(let i : number = 0; i < pB.nVertices; ++i) {{
                    mergeB[i] = new org.jbox2d.util.nonconvex.Triangle();
                };}
                let nA : number = Polygon.triangulatePolygon(pA.x, pA.y, pA.nVertices, mergeA);
                let nB : number = Polygon.triangulatePolygon(pB.x, pB.y, pB.nVertices, mergeB);
                if(nA === -1 || nB === -1) {
                    return -1;
                }
                for(let i : number = 0; i < nA; ++i) {{
                    results[i].set(mergeA[i]);
                };}
                for(let i : number = 0; i < nB; ++i) {{
                    results[nA + i].set(mergeB[i]);
                };}
                return (nA + nB);
            }
            let buffer : org.jbox2d.util.nonconvex.Triangle[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(vNum - 2);
            for(let i : number = 0; i < buffer.length; ++i) {{
                buffer[i] = new org.jbox2d.util.nonconvex.Triangle();
            };}
            let bufferSize : number = 0;
            let xrem : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(vNum);
            let yrem : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(vNum);
            for(let i : number = 0; i < vNum; ++i) {{
                xrem[i] = xv[i];
                yrem[i] = yv[i];
            };}
            let xremLength : number = vNum;
            while((vNum > 3)) {{
                let earIndex : number = -1;
                let earMaxMinCross : number = -1000.0;
                for(let i : number = 0; i < vNum; ++i) {{
                    if(Polygon.isEar(i, xrem, yrem, vNum)) {
                        let lower : number = Polygon.remainder(i - 1, vNum);
                        let upper : number = Polygon.remainder(i + 1, vNum);
                        let d1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(xrem[upper] - xrem[i]), (<any>Math).fround(yrem[upper] - yrem[i]));
                        let d2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(xrem[i] - xrem[lower]), (<any>Math).fround(yrem[i] - yrem[lower]));
                        let d3 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(xrem[lower] - xrem[upper]), (<any>Math).fround(yrem[lower] - yrem[upper]));
                        d1.normalize();
                        d2.normalize();
                        d3.normalize();
                        let cross12 : number = org.jbox2d.common.MathUtils.abs(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(d1, d2));
                        let cross23 : number = org.jbox2d.common.MathUtils.abs(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(d2, d3));
                        let cross31 : number = org.jbox2d.common.MathUtils.abs(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(d3, d1));
                        let minCross : number = org.jbox2d.common.MathUtils.min(cross12, org.jbox2d.common.MathUtils.min(cross23, cross31));
                        if(minCross > earMaxMinCross) {
                            earIndex = i;
                            earMaxMinCross = minCross;
                        }
                    }
                };}
                if(earIndex === -1) {
                    if(Polygon.B2_POLYGON_REPORT_ERRORS) {
                        let dump : Polygon = new Polygon(xrem, yrem, vNum);
                        console.info("Couldn\'t find an ear, dumping remaining poly:\n");
                        dump.printFormatted();
                        console.info("Please submit this dump to ewjordan at Box2d forums\n");
                    }
                    for(let i : number = 0; i < bufferSize; i++) {{
                        results[i].set(buffer[i]);
                    };}
                    if(bufferSize > 0) return bufferSize; else return -1;
                }
                --vNum;
                let newx : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(vNum);
                let newy : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(vNum);
                let currDest : number = 0;
                for(let i : number = 0; i < vNum; ++i) {{
                    if(currDest === earIndex) ++currDest;
                    newx[i] = xrem[currDest];
                    newy[i] = yrem[currDest];
                    ++currDest;
                };}
                let under : number = (earIndex === 0)?(vNum):(earIndex - 1);
                let over : number = (earIndex === vNum)?0:(earIndex + 1);
                let toAdd : org.jbox2d.util.nonconvex.Triangle = new org.jbox2d.util.nonconvex.Triangle(xrem[earIndex], yrem[earIndex], xrem[over], yrem[over], xrem[under], yrem[under]);
                buffer[bufferSize] = toAdd;
                ++bufferSize;
                xrem = newx;
                yrem = newy;
            }};
            let toAdd : org.jbox2d.util.nonconvex.Triangle = new org.jbox2d.util.nonconvex.Triangle(xrem[1], yrem[1], xrem[2], yrem[2], xrem[0], yrem[0]);
            buffer[bufferSize] = toAdd;
            ++bufferSize;
            if(!((bufferSize === xremLength - 2))) throw new Error("Assertion error line 760: assert (bufferSize == xremLength - 2);");;
            for(let i : number = 0; i < bufferSize; i++) {{
                results[i].set(buffer[i]);
            };}
            return bufferSize;
        }

        /**
         * Turns a list of triangles into a list of convex polygons. Very simple
         * method - start with a seed triangle, keep adding triangles to it until
         * you can't add any more without making the polygon non-convex.
         * 
         * Returns an integer telling how many polygons were created.  Will fill
         * polys array up to polysLength entries, which may be smaller or larger
         * than the return value.
         * 
         * Takes O(N*P) where P is the number of resultant polygons, N is triangle
         * count.
         * 
         * The final polygon list will not necessarily be minimal, though in
         * practice it works fairly well.
         * @param {Array} triangulated
         * @param {number} triangulatedLength
         * @param {Array} polys
         * @param {number} polysLength
         * @return {number}
         */
        public static polygonizeTriangles(triangulated : org.jbox2d.util.nonconvex.Triangle[], triangulatedLength : number, polys : Polygon[], polysLength : number) : number {
            let polyIndex : number = 0;
            if(triangulatedLength <= 0) {
                return 0;
            } else {
                let covered : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(triangulatedLength);
                for(let i : number = 0; i < triangulatedLength; ++i) {{
                    covered[i] = 0;
                    if(((triangulated[i].x[0] === triangulated[i].x[1]) && (triangulated[i].y[0] === triangulated[i].y[1])) || ((triangulated[i].x[1] === triangulated[i].x[2]) && (triangulated[i].y[1] === triangulated[i].y[2])) || ((triangulated[i].x[0] === triangulated[i].x[2]) && (triangulated[i].y[0] === triangulated[i].y[2]))) {
                        covered[i] = 1;
                    }
                };}
                let notDone : boolean = true;
                while((notDone)) {{
                    let currTri : number = -1;
                    for(let i : number = 0; i < triangulatedLength; ++i) {{
                        if(covered[i] !== 0) continue;
                        currTri = i;
                        break;
                    };}
                    if(currTri === -1) {
                        notDone = false;
                    } else {
                        let poly : Polygon = new Polygon(triangulated[currTri]);
                        covered[currTri] = 1;
                        let index : number = 0;
                        for(let i : number = 0; i < 2 * triangulatedLength; ++i, ++index) {{
                            while((index >= triangulatedLength)) {index -= triangulatedLength};
                            if(covered[index] !== 0) {
                                continue;
                            }
                            let newP : Polygon = poly.add(triangulated[index]);
                            if(newP == null) {
                                continue;
                            }
                            if(newP.nVertices > Polygon.maxPolygonVertices_$LI$()) {
                                newP = null;
                                continue;
                            }
                            if(newP.isConvex()) {
                                poly.set(newP);
                                newP = null;
                                covered[index] = 1;
                            } else {
                                newP = null;
                            }
                        };}
                        if(polyIndex < polysLength) {
                            poly.mergeParallelEdges(org.jbox2d.common.Settings.angularSlop_$LI$());
                            if(poly.nVertices >= 3) polys[polyIndex].set(poly);
                        }
                        if(poly.nVertices >= 3) polyIndex++;
                    }
                }};
            }
            return polyIndex;
        }

        /**
         * Checks if vertex i is the tip of an ear in polygon defined by xv[] and
         * yv[].
         * 
         * Assumes clockwise orientation of polygon...ick
         * @param {number} i
         * @param {Array} xv
         * @param {Array} yv
         * @param {number} xvLength
         * @return {boolean}
         * @private
         */
        /*private*/ static isEar(i : number, xv : number[], yv : number[], xvLength : number) : boolean {
            let dx0 : number;
            let dy0 : number;
            let dx1 : number;
            let dy1 : number;
            dx0 = dy0 = dx1 = dy1 = 0;
            if(i >= xvLength || i < 0 || xvLength < 3) {
                return false;
            }
            let upper : number = i + 1;
            let lower : number = i - 1;
            if(i === 0) {
                dx0 = (<any>Math).fround(xv[0] - xv[xvLength - 1]);
                dy0 = (<any>Math).fround(yv[0] - yv[xvLength - 1]);
                dx1 = (<any>Math).fround(xv[1] - xv[0]);
                dy1 = (<any>Math).fround(yv[1] - yv[0]);
                lower = xvLength - 1;
            } else if(i === xvLength - 1) {
                dx0 = (<any>Math).fround(xv[i] - xv[i - 1]);
                dy0 = (<any>Math).fround(yv[i] - yv[i - 1]);
                dx1 = (<any>Math).fround(xv[0] - xv[i]);
                dy1 = (<any>Math).fround(yv[0] - yv[i]);
                upper = 0;
            } else {
                dx0 = (<any>Math).fround(xv[i] - xv[i - 1]);
                dy0 = (<any>Math).fround(yv[i] - yv[i - 1]);
                dx1 = (<any>Math).fround(xv[i + 1] - xv[i]);
                dy1 = (<any>Math).fround(yv[i + 1] - yv[i]);
            }
            let cross : number = (<any>Math).fround((<any>Math).fround(dx0 * dy1) - (<any>Math).fround(dx1 * dy0));
            if(cross > 0) return false;
            let myTri : org.jbox2d.util.nonconvex.Triangle = new org.jbox2d.util.nonconvex.Triangle(xv[i], yv[i], xv[upper], yv[upper], xv[lower], yv[lower]);
            for(let j : number = 0; j < xvLength; ++j) {{
                if(j === i || j === lower || j === upper) continue;
                if(myTri.containsPoint(xv[j], yv[j])) return false;
            };}
            return true;
        }

        public static reversePolygon$org_jbox2d_util_nonconvex_Polygon(p : Polygon) {
            Polygon.reversePolygon$float_A$float_A$int(p.x, p.y, p.nVertices);
            if(p.areaIsSet) p.area *= -1;
        }

        public static reversePolygon$float_A$float_A$int(x : number[], y : number[], n : number) {
            if(n === 1) return;
            let low : number = 0;
            let high : number = n - 1;
            while((low < high)) {{
                let buffer : number = x[low];
                x[low] = x[high];
                x[high] = buffer;
                buffer = y[low];
                y[low] = y[high];
                y[high] = buffer;
                ++low;
                --high;
            }};
        }

        public static reversePolygon(x? : any, y? : any, n? : any) : any {
            if(((x != null && x instanceof <any>Array && (x.length==0 || x[0] == null ||(typeof x[0] === 'number'))) || x === null) && ((y != null && y instanceof <any>Array && (y.length==0 || y[0] == null ||(typeof y[0] === 'number'))) || y === null) && ((typeof n === 'number') || n === null)) {
                return <any>org.jbox2d.util.nonconvex.Polygon.reversePolygon$float_A$float_A$int(x, y, n);
            } else if(((x != null && x instanceof <any>org.jbox2d.util.nonconvex.Polygon) || x === null) && y === undefined && n === undefined) {
                return <any>org.jbox2d.util.nonconvex.Polygon.reversePolygon$org_jbox2d_util_nonconvex_Polygon(x);
            } else throw new Error('invalid overload');
        }

        /**
         * Decomposes a non-convex polygon into a number of convex polygons, up
         * to maxPolys (remaining pieces are thrown out, but the total number
         * is returned, so the return value can be greater than maxPolys).
         * 
         * Each resulting polygon will have no more than maxVerticesPerPolygon
         * vertices (set to b2MaxPolyVertices by default, though you can change
         * this).
         * 
         * Returns -1 if operation fails (usually due to self-intersection of
         * polygon).
         * @param {org.jbox2d.util.nonconvex.Polygon} p
         * @param {Array} results
         * @param {number} maxPolys
         * @return {number}
         */
        public static decomposeConvex(p : Polygon, results : Polygon[], maxPolys : number) : number {
            if(p.nVertices < 3) return 0;
            let triangulated : org.jbox2d.util.nonconvex.Triangle[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(p.nVertices - 2);
            for(let i : number = 0; i < triangulated.length; ++i) {{
                triangulated[i] = new org.jbox2d.util.nonconvex.Triangle();
            };}
            let nTri : number;
            if(p.isCCW()) {
                let tempP : Polygon = new Polygon();
                tempP.set(p);
                Polygon.reversePolygon$float_A$float_A$int(tempP.x, tempP.y, tempP.nVertices);
                nTri = Polygon.triangulatePolygon(tempP.x, tempP.y, tempP.nVertices, triangulated);
            } else {
                nTri = Polygon.triangulatePolygon(p.x, p.y, p.nVertices, triangulated);
            }
            if(nTri < 1) {
                return -1;
            }
            let nPolys : number = Polygon.polygonizeTriangles(triangulated, nTri, results, maxPolys);
            return nPolys;
        }

        /**
         * Decomposes a polygon into convex polygons and adds all pieces to a b2BodyDef
         * using a prototype b2PolyDef. All fields of the prototype are used for every
         * shape except the vertices (friction, restitution, density, filter, etc).
         * 
         * If you want finer control, you'll have to add everything by hand.
         * 
         * This is the simplest method to add a complicated polygon to a body.
         * @param {org.jbox2d.util.nonconvex.Polygon} p
         * @param {org.jbox2d.dynamics.Body} bd
         * @param {org.jbox2d.collision.shapes.PolygonDef} prototype
         */
        public static decomposeConvexAndAddTo(p : Polygon, bd : org.jbox2d.dynamics.Body, prototype : org.jbox2d.collision.shapes.PolygonDef) {
            if(p.nVertices < 3) return;
            let decomposed : Polygon[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(p.nVertices - 2);
            for(let i : number = 0; i < decomposed.length; ++i) {{
                decomposed[i] = new Polygon();
            };}
            let nPolys : number = Polygon.decomposeConvex(p, decomposed, p.nVertices - 2);
            let pdarray : org.jbox2d.collision.shapes.PolygonDef[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(2 * p.nVertices);
            for(let i : number = 0; i < pdarray.length; ++i) {{
                pdarray[i] = new org.jbox2d.collision.shapes.PolygonDef();
            };}
            let extra : number = 0;
            for(let i : number = 0; i < nPolys; ++i) {{
                let toAdd : org.jbox2d.collision.shapes.PolygonDef = pdarray[i + extra];
                toAdd.set(prototype);
                let curr : Polygon = decomposed[i];
                if(curr.nVertices === 3) {
                    for(let j : number = 0; j < 3; ++j) {{
                        let lower : number = (j === 0)?(curr.nVertices - 1):(j - 1);
                        let middle : number = j;
                        let upper : number = (j === curr.nVertices - 1)?(0):(j + 1);
                        let dx0 : number = (<any>Math).fround(curr.x[middle] - curr.x[lower]);
                        let dy0 : number = (<any>Math).fround(curr.y[middle] - curr.y[lower]);
                        let dx1 : number = (<any>Math).fround(curr.x[upper] - curr.x[middle]);
                        let dy1 : number = (<any>Math).fround(curr.y[upper] - curr.y[middle]);
                        let norm0 : number = (<any>Math).fround(Math.sqrt((<any>Math).fround((<any>Math).fround(dx0 * dx0) + (<any>Math).fround(dy0 * dy0))));
                        let norm1 : number = (<any>Math).fround(Math.sqrt((<any>Math).fround((<any>Math).fround(dx1 * dx1) + (<any>Math).fround(dy1 * dy1))));
                        if(!(norm0 > 0.0 && norm1 > 0.0)) {
                            continue;
                        }
                        dx0 /= norm0;
                        dy0 /= norm0;
                        dx1 /= norm1;
                        dy1 /= norm1;
                        let cross : number = (<any>Math).fround((<any>Math).fround(dx0 * dy1) - (<any>Math).fround(dx1 * dy0));
                        let dot : number = (<any>Math).fround((<any>Math).fround(dx0 * dx1) + (<any>Math).fround(dy0 * dy1));
                        if(org.jbox2d.common.MathUtils.abs(cross) < org.jbox2d.common.Settings.angularSlop_$LI$() && dot > 0) {
                            let dx2 : number = (<any>Math).fround(curr.x[lower] - curr.x[upper]);
                            let dy2 : number = (<any>Math).fround(curr.y[lower] - curr.y[upper]);
                            let norm2 : number = (<any>Math).fround(Math.sqrt((<any>Math).fround((<any>Math).fround(dx2 * dx2) + (<any>Math).fround(dy2 * dy2))));
                            if(norm2 === 0.0) {
                                continue;
                            }
                            dx2 /= norm2;
                            dy2 /= norm2;
                            let thisArea : number = curr.getArea();
                            let thisHeight : number = (<any>Math).fround((<any>Math).fround(2.0 * thisArea) / norm2);
                            let buffer2 : number = dx2;
                            dx2 = dy2;
                            dy2 = -buffer2;
                            let newX1 : number[] = [(<any>Math).fround(curr.x[middle] + (<any>Math).fround(dx2 * thisHeight)), curr.x[lower], curr.x[middle]];
                            let newY1 : number[] = [(<any>Math).fround(curr.y[middle] + (<any>Math).fround(dy2 * thisHeight)), curr.y[lower], curr.y[middle]];
                            let newX2 : number[] = [newX1[0], curr.x[middle], curr.x[upper]];
                            let newY2 : number[] = [newY1[0], curr.y[middle], curr.y[upper]];
                            let p1 : Polygon = new Polygon(newX1, newY1, 3);
                            let p2 : Polygon = new Polygon(newX2, newY2, 3);
                            if(p1.isUsable()) {
                                p1.addTo(toAdd);
                                bd.createShape(toAdd);
                                ++extra;
                            } else if(Polygon.B2_POLYGON_REPORT_ERRORS) {
                                console.error("Didn\'t add unusable polygon.  Dumping vertices:\n");
                                p1.print();
                            }
                            if(p2.isUsable()) {
                                p2.addTo(pdarray[i + extra]);
                                bd.createShape(pdarray[i + extra]);
                            } else if(Polygon.B2_POLYGON_REPORT_ERRORS) {
                                console.error("Didn\'t add unusable polygon.  Dumping vertices:\n");
                                p2.print();
                            }
                            continue;
                        }
                    };}
                }
                if(decomposed[i].isUsable()) {
                    decomposed[i].addTo(toAdd);
                    bd.createShape(toAdd);
                } else if(Polygon.B2_POLYGON_REPORT_ERRORS) {
                    console.info("Didn\'t add unusable polygon.  Dumping vertices:\n");
                    decomposed[i].print();
                }
            };}
            return;
        }

        public static convexHull$org_jbox2d_common_Vec2_A$int(v : org.jbox2d.common.Vec2[], nVert : number) : Polygon {
            let cloudX : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(nVert);
            let cloudY : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(nVert);
            for(let i : number = 0; i < nVert; ++i) {{
                cloudX[i] = v[i].x;
                cloudY[i] = v[i].y;
            };}
            let result : Polygon = Polygon.convexHull$float_A$float_A$int(cloudX, cloudY, nVert);
            return result;
        }

        public static convexHull$float_A$float_A$int(cloudX : number[], cloudY : number[], nVert : number) : Polygon {
            if(!((nVert > 2))) throw new Error("Assertion error line 1073: assert (nVert > 2);");;
            let edgeList : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(nVert);
            let numEdges : number = 0;
            let minY : number = 3.4028235E38;
            let minYIndex : number = nVert;
            for(let i : number = 0; i < nVert; ++i) {{
                if(cloudY[i] < minY) {
                    minY = cloudY[i];
                    minYIndex = i;
                }
            };}
            let startIndex : number = minYIndex;
            let winIndex : number = -1;
            let dx : number = -1.0;
            let dy : number = 0.0;
            while((winIndex !== minYIndex)) {{
                let newdx : number = 0.0;
                let newdy : number = 0.0;
                let maxDot : number = -2.0;
                for(let i : number = 0; i < nVert; ++i) {{
                    if(i === startIndex) continue;
                    newdx = (<any>Math).fround(cloudX[i] - cloudX[startIndex]);
                    newdy = (<any>Math).fround(cloudY[i] - cloudY[startIndex]);
                    let nrm : number = (<any>Math).fround(Math.sqrt((<any>Math).fround((<any>Math).fround(newdx * newdx) + (<any>Math).fround(newdy * newdy))));
                    nrm = (nrm === 0.0)?1.0:nrm;
                    newdx /= nrm;
                    newdy /= nrm;
                    let newDot : number = (<any>Math).fround((<any>Math).fround(newdx * dx) + (<any>Math).fround(newdy * dy));
                    if(newDot > maxDot) {
                        maxDot = newDot;
                        winIndex = i;
                    }
                };}
                edgeList[numEdges++] = winIndex;
                dx = (<any>Math).fround(cloudX[winIndex] - cloudX[startIndex]);
                dy = (<any>Math).fround(cloudY[winIndex] - cloudY[startIndex]);
                let nrm : number = (<any>Math).fround(Math.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy))));
                nrm = (nrm === 0.0)?1.0:nrm;
                dx /= nrm;
                dy /= nrm;
                startIndex = winIndex;
            }};
            let xres : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(numEdges);
            let yres : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(numEdges);
            for(let i : number = 0; i < numEdges; i++) {{
                xres[i] = cloudX[edgeList[i]];
                yres[i] = cloudY[edgeList[i]];
            };}
            let returnVal : Polygon = new Polygon(xres, yres, numEdges);
            returnVal.mergeParallelEdges(org.jbox2d.common.Settings.angularSlop_$LI$());
            return returnVal;
        }

        public static convexHull(cloudX? : any, cloudY? : any, nVert? : any) : any {
            if(((cloudX != null && cloudX instanceof <any>Array && (cloudX.length==0 || cloudX[0] == null ||(typeof cloudX[0] === 'number'))) || cloudX === null) && ((cloudY != null && cloudY instanceof <any>Array && (cloudY.length==0 || cloudY[0] == null ||(typeof cloudY[0] === 'number'))) || cloudY === null) && ((typeof nVert === 'number') || nVert === null)) {
                return <any>org.jbox2d.util.nonconvex.Polygon.convexHull$float_A$float_A$int(cloudX, cloudY, nVert);
            } else if(((cloudX != null && cloudX instanceof <any>Array && (cloudX.length==0 || cloudX[0] == null ||(cloudX[0] != null && cloudX[0] instanceof <any>org.jbox2d.common.Vec2))) || cloudX === null) && ((typeof cloudY === 'number') || cloudY === null) && nVert === undefined) {
                return <any>org.jbox2d.util.nonconvex.Polygon.convexHull$org_jbox2d_common_Vec2_A$int(cloudX, cloudY);
            } else throw new Error('invalid overload');
        }

        static isRighter(sinA : number, cosA : number, sinB : number, cosB : number) : boolean {
            if(sinA < 0) {
                if(sinB > 0 || cosA <= cosB) return true; else return false;
            } else {
                if(sinB < 0 || cosA <= cosB) return false; else return true;
            }
        }

        /*private*/ static remainder(x : number, modulus : number) : number {
            let rem : number = x % modulus;
            while((rem < 0)) {{
                rem += modulus;
            }};
            return rem;
        }

        public static traceEdge(p : Polygon) : Polygon {
            let nodes : org.jbox2d.util.nonconvex.PolyNode[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(p.nVertices * p.nVertices);
            let nNodes : number = 0;
            for(let i : number = 0; i < nodes.length; ++i) {{
                nodes[i] = new org.jbox2d.util.nonconvex.PolyNode();
            };}
            for(let i : number = 0; i < p.nVertices; ++i) {{
                let pos : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(p.x[i], p.y[i]);
                nodes[i].position = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(pos);
                ++nNodes;
                let iplus : number = (i === p.nVertices - 1)?0:i + 1;
                let iminus : number = (i === 0)?p.nVertices - 1:i - 1;
                nodes[i].addConnection(nodes[iplus]);
                nodes[i].addConnection(nodes[iminus]);
            };}
            let dirty : boolean = true;
            let counter : number = 0;
            while((dirty)) {{
                dirty = false;
                for(let i : number = 0; i < nNodes; ++i) {{
                    for(let j : number = 0; j < nodes[i].nConnected; ++j) {{
                        for(let k : number = 0; k < nNodes; ++k) {{
                            if(k === i || nodes[k] === nodes[i].connected[j]) continue;
                            for(let l : number = 0; l < nodes[k].nConnected; ++l) {{
                                if(nodes[k].connected[l] === nodes[i].connected[j] || nodes[k].connected[l] === nodes[i]) continue;
                                let intersectPt : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
                                let crosses : boolean = Polygon.intersect(nodes[i].position, nodes[i].connected[j].position, nodes[k].position, nodes[k].connected[l].position, intersectPt);
                                if(crosses) {
                                    dirty = true;
                                    let connj : org.jbox2d.util.nonconvex.PolyNode = nodes[i].connected[j];
                                    let connl : org.jbox2d.util.nonconvex.PolyNode = nodes[k].connected[l];
                                    nodes[i].connected[j].removeConnection(nodes[i]);
                                    nodes[i].removeConnection(connj);
                                    nodes[k].connected[l].removeConnection(nodes[k]);
                                    nodes[k].removeConnection(connl);
                                    nodes[nNodes] = new org.jbox2d.util.nonconvex.PolyNode(intersectPt);
                                    nodes[nNodes].addConnection(nodes[i]);
                                    nodes[i].addConnection(nodes[nNodes]);
                                    nodes[nNodes].addConnection(nodes[k]);
                                    nodes[k].addConnection(nodes[nNodes]);
                                    nodes[nNodes].addConnection(connj);
                                    connj.addConnection(nodes[nNodes]);
                                    nodes[nNodes].addConnection(connl);
                                    connl.addConnection(nodes[nNodes]);
                                    ++nNodes;
                                    break;
                                }
                                if(dirty) break;
                            };}
                            if(dirty) break;
                        };}
                        if(dirty) break;
                    };}
                    if(dirty) break;
                };}
                ++counter;
            }};
            let foundDupe : boolean = true;
            let nActive : number = nNodes;
            while((foundDupe)) {{
                foundDupe = false;
                for(let i : number = 0; i < nNodes; ++i) {{
                    if(nodes[i].nConnected === 0) continue;
                    for(let j : number = i + 1; j < nNodes; ++j) {{
                        if(nodes[j].nConnected === 0) continue;
                        let diff : org.jbox2d.common.Vec2 = nodes[i].position.sub(nodes[j].position);
                        if(diff.lengthSquared() <= Polygon.COLLAPSE_DIST_SQR_$LI$()) {
                            if(nActive <= 3) return new Polygon();
                            --nActive;
                            foundDupe = true;
                            let inode : org.jbox2d.util.nonconvex.PolyNode = nodes[i];
                            let jnode : org.jbox2d.util.nonconvex.PolyNode = nodes[j];
                            let njConn : number = jnode.nConnected;
                            for(let k : number = 0; k < njConn; ++k) {{
                                let knode : org.jbox2d.util.nonconvex.PolyNode = jnode.connected[k];
                                if(!((knode !== jnode))) throw new Error("Assertion error line 1225: assert (knode != jnode);");;
                                if(knode !== inode) {
                                    inode.addConnection(knode);
                                    knode.addConnection(inode);
                                }
                                knode.removeConnection(jnode);
                            };}
                            jnode.nConnected = 0;
                        }
                    };}
                };}
            }};
            let minY : number = 3.4028235E38;
            let maxX : number = -3.4028235E38;
            let minYIndex : number = -1;
            for(let i : number = 0; i < nNodes; ++i) {{
                if(nodes[i].position.y < minY && nodes[i].nConnected > 1) {
                    minY = nodes[i].position.y;
                    minYIndex = i;
                    maxX = nodes[i].position.x;
                } else if(nodes[i].position.y === minY && nodes[i].position.x > maxX && nodes[i].nConnected > 1) {
                    minYIndex = i;
                    maxX = nodes[i].position.x;
                }
            };}
            let origDir : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(1.0, 0.0);
            let resultVecs : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(4 * nNodes);
            let nResultVecs : number = 0;
            let currentNode : org.jbox2d.util.nonconvex.PolyNode = nodes[minYIndex];
            let startNode : org.jbox2d.util.nonconvex.PolyNode = currentNode;
            if(!((currentNode.nConnected > 0))) throw new Error("Assertion error line 1255: assert (currentNode.nConnected > 0);");;
            let nextNode : org.jbox2d.util.nonconvex.PolyNode = currentNode.getRightestConnection$org_jbox2d_common_Vec2(origDir);
            if(nextNode == null) {
                startNode = nextNode;
            }
            resultVecs[0] = startNode.position;
            ++nResultVecs;
            while((nextNode !== startNode)) {{
                if(nResultVecs > 4 * nNodes) {
                    if(!((false))) throw new Error("Assertion error line 1264: assert (false);");;
                }
                resultVecs[nResultVecs++] = nextNode.position;
                let oldNode : org.jbox2d.util.nonconvex.PolyNode = currentNode;
                currentNode = nextNode;
                nextNode = currentNode.getRightestConnection$org_jbox2d_util_nonconvex_PolyNode(oldNode);
                if(nextNode == null) break;
            }};
            let xres : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(nResultVecs);
            let yres : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(nResultVecs);
            for(let i : number = 0; i < nResultVecs; ++i) {{
                xres[i] = resultVecs[i].x;
                yres[i] = resultVecs[i].y;
            };}
            let retval : Polygon = new Polygon(xres, yres, nResultVecs);
            return retval;
        }

        public print() {
            this.printFormatted();
        }

        printFormatted() {
            console.info("float xv[] = {");
            for(let i : number = 0; i < this.nVertices; ++i) {{
                console.info("%ff,");
            };}
            console.info("};\nfloat yv[] = {");
            for(let i : number = 0; i < this.nVertices; ++i) {{
                console.info("%ff,");
            };}
            console.info("};\n");
        }
    }
    Polygon["__class"] = "org.jbox2d.util.nonconvex.Polygon";


    export class PolyNode {
        static MAX_CONNECTED : number = 32;

        nConnected : number;

        visited : boolean;

        position : org.jbox2d.common.Vec2;

        connected : PolyNode[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(PolyNode.MAX_CONNECTED);

        public constructor(pos? : any) {
            if(((pos != null && pos instanceof <any>org.jbox2d.common.Vec2) || pos === null)) {
                let __args = arguments;
                if(this.nConnected===undefined) this.nConnected = 0;
                if(this.visited===undefined) this.visited = false;
                if(this.position===undefined) this.position = null;
                this.connected = (s => { let a=[]; while(s-->0) a.push(null); return a; })(PolyNode.MAX_CONNECTED);
                if(this.nConnected===undefined) this.nConnected = 0;
                if(this.visited===undefined) this.visited = false;
                if(this.position===undefined) this.position = null;
                (() => {
                    this.position = pos;
                    this.nConnected = 0;
                    this.visited = false;
                })();
            } else if(pos === undefined) {
                let __args = arguments;
                if(this.nConnected===undefined) this.nConnected = 0;
                if(this.visited===undefined) this.visited = false;
                if(this.position===undefined) this.position = null;
                this.connected = (s => { let a=[]; while(s-->0) a.push(null); return a; })(PolyNode.MAX_CONNECTED);
                if(this.nConnected===undefined) this.nConnected = 0;
                if(this.visited===undefined) this.visited = false;
                if(this.position===undefined) this.position = null;
                (() => {
                    this.nConnected = 0;
                    this.visited = false;
                })();
            } else throw new Error('invalid overload');
        }

        addConnection(toMe : PolyNode) {
            if(!((this.nConnected < PolyNode.MAX_CONNECTED))) throw new Error("Assertion error line 1344: assert (nConnected < MAX_CONNECTED);");;
            for(let i : number = 0; i < this.nConnected; ++i) {{
                if(this.connected[i] === toMe) return;
            };}
            this.connected[this.nConnected] = toMe;
            ++this.nConnected;
        }

        removeConnection(fromMe : PolyNode) {
            let isFound : boolean = false;
            let foundIndex : number = -1;
            for(let i : number = 0; i < this.nConnected; ++i) {{
                if(fromMe === this.connected[i]) {
                    isFound = true;
                    foundIndex = i;
                    break;
                }
            };}
            if(!((isFound))) throw new Error("Assertion error line 1362: assert (isFound);");;
            --this.nConnected;
            for(let i : number = foundIndex; i < this.nConnected; ++i) {{
                this.connected[i] = this.connected[i + 1];
            };}
        }

        removeConnectionByIndex(index : number) {
            --this.nConnected;
            for(let i : number = index; i < this.nConnected; ++i) {{
                this.connected[i] = this.connected[i + 1];
            };}
        }

        isConnectedTo(me : PolyNode) : boolean {
            let isFound : boolean = false;
            for(let i : number = 0; i < this.nConnected; ++i) {{
                if(me === this.connected[i]) {
                    isFound = true;
                    break;
                }
            };}
            return isFound;
        }

        public getRightestConnection$org_jbox2d_util_nonconvex_PolyNode(incoming : PolyNode) : PolyNode {
            if(this.nConnected === 0) {
                if(!((false))) throw new Error("Assertion error line 1389: assert (false);");;
                return null;
            }
            if(this.nConnected === 1) {
                return incoming;
            }
            let inDir : org.jbox2d.common.Vec2 = this.position.sub(incoming.position);
            let inLength : number = inDir.normalize();
            if(!((inLength > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 1397: assert (inLength > Settings.EPSILON);");;
            let result : PolyNode = null;
            for(let i : number = 0; i < this.nConnected; ++i) {{
                if(this.connected[i] === incoming) continue;
                let testDir : org.jbox2d.common.Vec2 = this.connected[i].position.sub(this.position);
                let testLengthSqr : number = testDir.lengthSquared();
                testDir.normalize();
                if(!((testLengthSqr >= org.jbox2d.util.nonconvex.Polygon.COLLAPSE_DIST_SQR_$LI$()))) throw new Error("Assertion error line 1404: assert (testLengthSqr >= Polygon.COLLAPSE_DIST_SQR);");;
                let myCos : number = org.jbox2d.common.Vec2.dot(inDir, testDir);
                let mySin : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(inDir, testDir);
                if(result != null) {
                    let resultDir : org.jbox2d.common.Vec2 = result.position.sub(this.position);
                    resultDir.normalize();
                    let resCos : number = org.jbox2d.common.Vec2.dot(inDir, resultDir);
                    let resSin : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(inDir, resultDir);
                    if(org.jbox2d.util.nonconvex.Polygon.isRighter(mySin, myCos, resSin, resCos)) {
                        result = this.connected[i];
                    }
                } else {
                    result = this.connected[i];
                }
            };}
            if(!((result != null))) throw new Error("Assertion error line 1419: assert (result != null);");;
            return result;
        }

        public getRightestConnection(incoming? : any) : any {
            if(((incoming != null && incoming instanceof <any>org.jbox2d.util.nonconvex.PolyNode) || incoming === null)) {
                return <any>this.getRightestConnection$org_jbox2d_util_nonconvex_PolyNode(incoming);
            } else if(((incoming != null && incoming instanceof <any>org.jbox2d.common.Vec2) || incoming === null)) {
                return <any>this.getRightestConnection$org_jbox2d_common_Vec2(incoming);
            } else throw new Error('invalid overload');
        }

        getRightestConnection$org_jbox2d_common_Vec2(incomingDir : org.jbox2d.common.Vec2) : PolyNode {
            let diff : org.jbox2d.common.Vec2 = this.position.sub(incomingDir);
            let temp : PolyNode = new PolyNode(diff);
            let res : PolyNode = this.getRightestConnection$org_jbox2d_util_nonconvex_PolyNode(temp);
            if(!((res != null))) throw new Error("Assertion error line 1435: assert (res != null);");;
            return res;
        }
    }
    PolyNode["__class"] = "org.jbox2d.util.nonconvex.PolyNode";

}
namespace org.jbox2d.dynamics.contacts {
    export class NullContact extends org.jbox2d.dynamics.contacts.Contact {
        /**
         * 
         * @param {*} cl
         */
        public evaluate(cl : org.jbox2d.dynamics.ContactListener) {
        }

        public constructor() {
            super();
        }

        public clone() : org.jbox2d.dynamics.contacts.Contact {
            return new NullContact();
        }

        /**
         * 
         * @return {org.jbox2d.collision.Manifold[]}
         */
        public getManifolds() : Array<org.jbox2d.collision.Manifold> {
            console.info("NullContact.GetManifolds()");
            return null;
        }

        public getFirstManifold() : org.jbox2d.collision.Manifold {
            console.info("NullContact.GetFirstManifold()");
            return null;
        }
    }
    NullContact["__class"] = "org.jbox2d.dynamics.contacts.NullContact";

}
namespace org.jbox2d.dynamics.controllers {
    /**
     * @author eric
     * @extends org.jbox2d.dynamics.controllers.Controller
     * @class
     */
    export class BuoyancyController extends org.jbox2d.dynamics.controllers.Controller {
        constructor(def : org.jbox2d.dynamics.controllers.BuoyancyControllerDef) {
            super(def);
            if(this.offset===undefined) this.offset = 0;
            if(this.density===undefined) this.density = 0;
            if(this.linearDrag===undefined) this.linearDrag = 0;
            if(this.angularDrag===undefined) this.angularDrag = 0;
            if(this.useDensity===undefined) this.useDensity = false;
            if(this.useWorldGravity===undefined) this.useWorldGravity = false;
            this.normal = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.normal);
            this.offset = def.offset;
            this.density = def.density;
            this.velocity = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.velocity);
            this.linearDrag = def.linearDrag;
            this.angularDrag = def.angularDrag;
            this.useDensity = def.useDensity;
            this.useWorldGravity = def.useWorldGravity;
            this.gravity = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.gravity);
        }

        /**
         * The outer surface normal
         */
        public normal : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The height of the fluid surface along the normal
         */
        public offset : number;

        /**
         * The fluid density
         */
        public density : number;

        /**
         * Fluid velocity, for drag calculations
         */
        public velocity : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * Linear drag co-efficient
         */
        public linearDrag : number;

        /**
         * Linear drag co-efficient
         */
        public angularDrag : number;

        /**
         * If false, bodies are assumed to be uniformly dense, otherwise use the shapes densities
         */
        public useDensity : boolean;

        /**
         * If true, gravity is taken from the world instead of the gravity parameter.
         */
        public useWorldGravity : boolean;

        /**
         * Gravity vector, if the world's gravity is not used
         */
        public gravity : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public step(step : org.jbox2d.dynamics.TimeStep) {
            if(this.m_bodyList == null) return;
            if(this.useWorldGravity) {
                this.gravity = this.m_world.getGravity();
            }
            for(let i : org.jbox2d.dynamics.controllers.ControllerEdge = this.m_bodyList; i != null; i = i.nextBody) {{
                let body : org.jbox2d.dynamics.Body = i.body;
                if(body.isSleeping()) {
                    continue;
                }
                let areac : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(0, 0);
                let massc : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(0, 0);
                let area : number = 0;
                let mass : number = 0;
                for(let shape : org.jbox2d.collision.shapes.Shape = body.getShapeList(); shape != null; shape = shape.getNext()) {{
                    let sc : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(0, 0);
                    let sarea : number = shape.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(this.normal, this.offset, sc);
                    area += sarea;
                    areac.x += (<any>Math).fround(sarea * sc.x);
                    areac.y += (<any>Math).fround(sarea * sc.y);
                    let shapeDensity : number = 0;
                    if(this.useDensity) {
                        shapeDensity = shape.getDensity();
                    } else {
                        shapeDensity = 1;
                    }
                    mass += (<any>Math).fround(sarea * shapeDensity);
                    massc.x += (<any>Math).fround((<any>Math).fround(sarea * sc.x) * shapeDensity);
                    massc.y += (<any>Math).fround((<any>Math).fround(sarea * sc.y) * shapeDensity);
                };}
                areac.x /= area;
                areac.y /= area;
                massc.x /= mass;
                massc.y /= mass;
                if(area < org.jbox2d.common.Settings.EPSILON) continue;
                let buoyancyForce : org.jbox2d.common.Vec2 = this.gravity.mul((<any>Math).fround(-this.density * area));
                body.applyForce(buoyancyForce, massc);
                let dragForce : org.jbox2d.common.Vec2 = body.getLinearVelocityFromWorldPoint(areac).sub(this.velocity);
                dragForce.mulLocal((<any>Math).fround(-this.linearDrag * area));
                body.applyForce(dragForce, areac);
                body.applyTorque((<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(-body.getInertia() / body.getMass()) * area) * body.getAngularVelocity()) * this.angularDrag));
            };}
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.DebugDraw} debugDraw
         */
        public draw(debugDraw : org.jbox2d.dynamics.DebugDraw) {
            let r : number = 1000;
            let p1 : org.jbox2d.common.Vec2 = this.normal.mul(this.offset).addLocal$org_jbox2d_common_Vec2(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(this.normal, r));
            let p2 : org.jbox2d.common.Vec2 = this.normal.mul(this.offset).subLocal(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(this.normal, r));
            let color : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f(0, 0, (<any>Math).fround(255 * 0.8));
            let vertices : org.jbox2d.common.Vec2[] = [p1, p2, p2.sub(this.normal.mul(r)), p1.sub(this.normal.mul(r))];
            debugDraw.drawSolidPolygon(vertices, 4, color);
        }
    }
    BuoyancyController["__class"] = "org.jbox2d.dynamics.controllers.BuoyancyController";

}
namespace org.jbox2d.dynamics.controllers {
    /**
     * @author eric
     * @class
     * @extends org.jbox2d.dynamics.controllers.ControllerDef
     */
    export class BuoyancyControllerDef extends org.jbox2d.dynamics.controllers.ControllerDef {
        public normal : org.jbox2d.common.Vec2;

        public offset : number;

        public density : number;

        public velocity : org.jbox2d.common.Vec2;

        public linearDrag : number;

        public angularDrag : number;

        public useDensity : boolean;

        public useWorldGravity : boolean;

        public gravity : org.jbox2d.common.Vec2;

        public constructor() {
            super();
            if(this.normal===undefined) this.normal = null;
            if(this.offset===undefined) this.offset = 0;
            if(this.density===undefined) this.density = 0;
            if(this.velocity===undefined) this.velocity = null;
            if(this.linearDrag===undefined) this.linearDrag = 0;
            if(this.angularDrag===undefined) this.angularDrag = 0;
            if(this.useDensity===undefined) this.useDensity = false;
            if(this.useWorldGravity===undefined) this.useWorldGravity = false;
            if(this.gravity===undefined) this.gravity = null;
            this.normal = new org.jbox2d.common.Vec2(0, 1);
            this.offset = 0;
            this.density = 0;
            this.velocity = new org.jbox2d.common.Vec2(0, 0);
            this.linearDrag = 0;
            this.angularDrag = 0;
            this.useDensity = false;
            this.useWorldGravity = true;
            this.gravity = new org.jbox2d.common.Vec2(0, 0);
        }

        /**
         * @see org.jbox2d.dynamics.controllers.ControllerDef#create()
         * @return {org.jbox2d.dynamics.controllers.Controller}
         */
        public create() : org.jbox2d.dynamics.controllers.Controller {
            return new org.jbox2d.dynamics.controllers.BuoyancyController(this);
        }
    }
    BuoyancyControllerDef["__class"] = "org.jbox2d.dynamics.controllers.BuoyancyControllerDef";

}
namespace org.jbox2d.testbed {
    /**
     * Implementation of DebugDraw using Processing (http://www.processing.org)
     * 
     * @author ewjordan
     * @param {*} pApplet
     * @class
     * @extends org.jbox2d.dynamics.DebugDraw
     */
    export class ProcessingDebugDraw extends org.jbox2d.dynamics.DebugDraw {
        public static screen : ProcessingDebugDraw = null;

        /*private*/ firstTime : boolean = true;

        public g : any;

        public pg : PGraphics;

        public m_font : PFont;

        public fontHeight : number;

        /*private*/ transform : org.jbox2d.common.OBBViewportTransform;

        public constructor(pApplet : any) {
            super(new org.jbox2d.common.OBBViewportTransform());
            if(this.g===undefined) this.g = null;
            if(this.pg===undefined) this.pg = null;
            if(this.m_font===undefined) this.m_font = null;
            if(this.fontHeight===undefined) this.fontHeight = 0;
            if(this.transform===undefined) this.transform = null;
            this.transform = <org.jbox2d.common.OBBViewportTransform><any>super.getViewportTranform();
            this.g = pApplet;
            this.pg = this.g.createGraphics(pApplet.displayWidth, pApplet.displayHeight);
            ProcessingDebugDraw.screen = this;
            this.m_font = this.g.createFont("LucidaGrande-Bold", 12);
            this.fontHeight = 14.0;
            this.viewportTransform.setCamera(320 + (this.g.width / 2|0), 240 + (this.g.height / 2|0), 20);
            this.viewportTransform['setExtents$float$float']((this.g.width / 2|0), (this.g.height / 2|0));
            this.viewportTransform.setYFlip(true);
        }

        static circlePt : org.jbox2d.common.Vec2; public static circlePt_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.circlePt == null) ProcessingDebugDraw.circlePt = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.circlePt; };

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argCenter
         * @param {number} radius
         * @param {org.jbox2d.common.Color3f} color
         */
        public drawCircle(argCenter : org.jbox2d.common.Vec2, radius : number, color : org.jbox2d.common.Color3f) {
            this.viewportTransform.getWorldToScreen(argCenter, ProcessingDebugDraw.center_$LI$());
            this.g.noFill();
            let k_segments : number = 16.0;
            let k_increment : number = (<any>Math).fround((<any>Math).fround(2.0 * org.jbox2d.common.MathUtils.PI_$LI$()) / k_segments);
            let theta : number = 0.0;
            this.g.stroke(color.x, color.y, color.z);
            this.g.noFill();
            this.g.beginShape(PConstants.POLYGON);
            for(let i : number = 0; i < k_segments; ++i) {{
                let vx : number = (<any>Math).fround(radius * org.jbox2d.common.MathUtils.cos(theta));
                let vy : number = (<any>Math).fround(radius * org.jbox2d.common.MathUtils.sin(theta));
                ProcessingDebugDraw.circlePt_$LI$().set$float$float(vx, vy);
                this.viewportTransform.vectorTransform(ProcessingDebugDraw.circlePt_$LI$(), ProcessingDebugDraw.circlePt_$LI$());
                ProcessingDebugDraw.circlePt_$LI$().addLocal$org_jbox2d_common_Vec2(ProcessingDebugDraw.center_$LI$());
                this.g.vertex(ProcessingDebugDraw.circlePt_$LI$().x, ProcessingDebugDraw.circlePt_$LI$().y);
                theta += k_increment;
            };}
            ProcessingDebugDraw.circlePt_$LI$().set$float$float(radius, 0);
            this.viewportTransform.vectorTransform(ProcessingDebugDraw.circlePt_$LI$(), ProcessingDebugDraw.circlePt_$LI$());
            ProcessingDebugDraw.circlePt_$LI$().addLocal$org_jbox2d_common_Vec2(ProcessingDebugDraw.center_$LI$());
            this.g.vertex(ProcessingDebugDraw.circlePt_$LI$().x, ProcessingDebugDraw.circlePt_$LI$().y);
            this.g.endShape();
        }

        static p : org.jbox2d.common.Vec2; public static p_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.p == null) ProcessingDebugDraw.p = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.p; };

        static center : org.jbox2d.common.Vec2; public static center_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.center == null) ProcessingDebugDraw.center = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.center; };

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argCenter
         * @param {number} radius
         * @param {org.jbox2d.common.Vec2} axis
         * @param {org.jbox2d.common.Color3f} color
         */
        public drawSolidCircle(argCenter : org.jbox2d.common.Vec2, radius : number, axis : org.jbox2d.common.Vec2, color : org.jbox2d.common.Color3f) {
            this.viewportTransform.getWorldToScreen(argCenter, ProcessingDebugDraw.center_$LI$());
            let k_segments : number = 16.0;
            let k_increment : number = (<any>Math).fround((<any>Math).fround(2.0 * org.jbox2d.common.MathUtils.PI_$LI$()) / k_segments);
            let theta : number = 0.0;
            this.g.fill((<any>Math).fround(0.5 * color.x), (<any>Math).fround(0.5 * color.y), (<any>Math).fround(0.5 * color.z), (<any>Math).fround(0.5 * 255.0));
            this.g.stroke(color.x, color.y, color.z, 255.0);
            this.g.beginShape(PConstants.POLYGON);
            for(let i : number = 0; i < k_segments; ++i) {{
                let vx : number = (<any>Math).fround(radius * org.jbox2d.common.MathUtils.cos(theta));
                let vy : number = (<any>Math).fround(radius * org.jbox2d.common.MathUtils.sin(theta));
                ProcessingDebugDraw.circlePt_$LI$().set$float$float(vx, vy);
                this.viewportTransform.vectorTransform(ProcessingDebugDraw.circlePt_$LI$(), ProcessingDebugDraw.circlePt_$LI$());
                ProcessingDebugDraw.circlePt_$LI$().addLocal$org_jbox2d_common_Vec2(ProcessingDebugDraw.center_$LI$());
                this.g.vertex(ProcessingDebugDraw.circlePt_$LI$().x, ProcessingDebugDraw.circlePt_$LI$().y);
                theta += k_increment;
            };}
            ProcessingDebugDraw.circlePt_$LI$().set$float$float(radius, 0);
            this.viewportTransform.vectorTransform(ProcessingDebugDraw.circlePt_$LI$(), ProcessingDebugDraw.circlePt_$LI$());
            ProcessingDebugDraw.circlePt_$LI$().addLocal$org_jbox2d_common_Vec2(ProcessingDebugDraw.center_$LI$());
            this.g.vertex(ProcessingDebugDraw.circlePt_$LI$().x, ProcessingDebugDraw.circlePt_$LI$().y);
            this.g.endShape();
            this.getWorldToScreenToOut$float$float$org_jbox2d_common_Vec2((<any>Math).fround(argCenter.x + (<any>Math).fround(radius * axis.x)), (<any>Math).fround(argCenter.y + (<any>Math).fround(radius * axis.y)), ProcessingDebugDraw.p_$LI$());
            this.g.beginShape(PConstants.LINES);
            this.g.vertex(ProcessingDebugDraw.center_$LI$().x, ProcessingDebugDraw.center_$LI$().y);
            this.g.vertex(ProcessingDebugDraw.p_$LI$().x, ProcessingDebugDraw.p_$LI$().y);
            this.g.endShape();
        }

        static v1 : org.jbox2d.common.Vec2; public static v1_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.v1 == null) ProcessingDebugDraw.v1 = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.v1; };

        static v2 : org.jbox2d.common.Vec2; public static v2_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.v2 == null) ProcessingDebugDraw.v2 = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.v2; };

        /**
         * 
         * @param {Array} vertices
         * @param {number} vertexCount
         * @param {org.jbox2d.common.Color3f} color
         */
        public drawPolygon(vertices : org.jbox2d.common.Vec2[], vertexCount : number, color : org.jbox2d.common.Color3f) {
            this.g.stroke(color.x, color.y, color.z);
            this.g.noFill();
            for(let i : number = 0; i < vertexCount; ++i) {{
                let ind : number = (i + 1 < vertexCount)?i + 1:(i + 1 - vertexCount);
                this.viewportTransform.getWorldToScreen(vertices[i], ProcessingDebugDraw.v1_$LI$());
                this.viewportTransform.getWorldToScreen(vertices[ind], ProcessingDebugDraw.v2_$LI$());
                this.g.line(ProcessingDebugDraw.v1_$LI$().x, ProcessingDebugDraw.v1_$LI$().y, ProcessingDebugDraw.v2_$LI$().x, ProcessingDebugDraw.v2_$LI$().y);
            };}
        }

        static v : org.jbox2d.common.Vec2; public static v_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.v == null) ProcessingDebugDraw.v = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.v; };

        /**
         * 
         * @param {Array} vertices
         * @param {number} vertexCount
         * @param {org.jbox2d.common.Color3f} color
         */
        public drawSolidPolygon(vertices : org.jbox2d.common.Vec2[], vertexCount : number, color : org.jbox2d.common.Color3f) {
            this.g.noStroke();
            this.g.fill((<any>Math).fround(0.5 * color.x), (<any>Math).fround(0.5 * color.y), (<any>Math).fround(0.5 * color.z), (<any>Math).fround(0.5 * 255.0));
            this.g.beginShape(PConstants.POLYGON);
            for(let i : number = 0; i < vertexCount; ++i) {{
                this.viewportTransform.getWorldToScreen(vertices[i], ProcessingDebugDraw.v_$LI$());
                this.g.vertex(ProcessingDebugDraw.v_$LI$().x, ProcessingDebugDraw.v_$LI$().y);
            };}
            this.g.endShape();
            this.g.stroke(color.x, color.y, color.z, 255.0);
            for(let i : number = 0; i < vertexCount; ++i) {{
                let ind : number = (i + 1 < vertexCount)?i + 1:(i + 1 - vertexCount);
                this.viewportTransform.getWorldToScreen(vertices[i], ProcessingDebugDraw.v1_$LI$());
                this.viewportTransform.getWorldToScreen(vertices[ind], ProcessingDebugDraw.v2_$LI$());
                this.g.line(ProcessingDebugDraw.v1_$LI$().x, ProcessingDebugDraw.v1_$LI$().y, ProcessingDebugDraw.v2_$LI$().x, ProcessingDebugDraw.v2_$LI$().y);
            };}
        }

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argP1
         * @param {org.jbox2d.common.Vec2} argP2
         * @param {org.jbox2d.common.Color3f} color
         */
        public drawSegment(argP1 : org.jbox2d.common.Vec2, argP2 : org.jbox2d.common.Vec2, color : org.jbox2d.common.Color3f) {
            this.viewportTransform.getWorldToScreen(argP1, ProcessingDebugDraw.p1_$LI$());
            this.viewportTransform.getWorldToScreen(argP2, ProcessingDebugDraw.p2_$LI$());
            this.g.stroke(color.x, color.y, color.z);
            this.g.beginShape(PConstants.LINES);
            this.g.vertex(ProcessingDebugDraw.p1_$LI$().x, ProcessingDebugDraw.p1_$LI$().y);
            this.g.vertex(ProcessingDebugDraw.p2_$LI$().x, ProcessingDebugDraw.p2_$LI$().y);
            this.g.endShape();
        }

        static p1 : org.jbox2d.common.Vec2; public static p1_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.p1 == null) ProcessingDebugDraw.p1 = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.p1; };

        static p2 : org.jbox2d.common.Vec2; public static p2_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.p2 == null) ProcessingDebugDraw.p2 = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.p2; };

        static p1world : org.jbox2d.common.Vec2; public static p1world_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.p1world == null) ProcessingDebugDraw.p1world = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.p1world; };

        static p2world : org.jbox2d.common.Vec2; public static p2world_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.p2world == null) ProcessingDebugDraw.p2world = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.p2world; };

        /**
         * 
         * @param {org.jbox2d.common.XForm} xf
         */
        public drawXForm(xf : org.jbox2d.common.XForm) {
            ProcessingDebugDraw.p1_$LI$().set$org_jbox2d_common_Vec2(xf.position);
            ProcessingDebugDraw.p2_$LI$().setZero();
            let k_axisScale : number = 0.4;
            this.g.beginShape(PConstants.LINES);
            this.viewportTransform.getWorldToScreen(ProcessingDebugDraw.p1_$LI$(), ProcessingDebugDraw.p1world_$LI$());
            this.g.stroke(255.0, 0.0, 0.0);
            this.g.vertex(ProcessingDebugDraw.p1world_$LI$().x, ProcessingDebugDraw.p1world_$LI$().y);
            ProcessingDebugDraw.p2_$LI$().x = (<any>Math).fround(ProcessingDebugDraw.p1_$LI$().x + (<any>Math).fround(k_axisScale * xf.R.col1.x));
            ProcessingDebugDraw.p2_$LI$().y = (<any>Math).fround(ProcessingDebugDraw.p1_$LI$().y + (<any>Math).fround(k_axisScale * xf.R.col1.y));
            this.viewportTransform.getWorldToScreen(ProcessingDebugDraw.p2_$LI$(), ProcessingDebugDraw.p2world_$LI$());
            this.g.vertex(ProcessingDebugDraw.p2world_$LI$().x, ProcessingDebugDraw.p2world_$LI$().y);
            this.g.stroke(0.0, 255.0, 0.0);
            this.g.vertex(ProcessingDebugDraw.p1world_$LI$().x, ProcessingDebugDraw.p1world_$LI$().y);
            ProcessingDebugDraw.p2_$LI$().x = (<any>Math).fround(ProcessingDebugDraw.p1_$LI$().x + (<any>Math).fround(k_axisScale * xf.R.col2.x));
            ProcessingDebugDraw.p2_$LI$().y = (<any>Math).fround(ProcessingDebugDraw.p1_$LI$().y + (<any>Math).fround(k_axisScale * xf.R.col2.y));
            this.viewportTransform.getWorldToScreen(ProcessingDebugDraw.p2_$LI$(), ProcessingDebugDraw.p2world_$LI$());
            this.g.vertex(ProcessingDebugDraw.p2world_$LI$().x, ProcessingDebugDraw.p2world_$LI$().y);
            this.g.endShape();
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         * @param {string} s
         * @param {org.jbox2d.common.Color3f} color
         */
        public drawString(x : number, y : number, s : string, color : org.jbox2d.common.Color3f) {
            if(this.firstTime) {
                this.g.textFont(this.m_font);
                if(this.pg != null && this.pg.is3D()) this.g.textMode(PConstants.SCREEN);
                this.firstTime = false;
            }
            this.g.fill(color.x, color.y, color.z);
            this.g.text(s, x, y);
        }

        static position : org.jbox2d.common.Vec2; public static position_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.position == null) ProcessingDebugDraw.position = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.position; };

        /**
         * 
         * @param {org.jbox2d.common.Vec2} argPosition
         * @param {number} f
         * @param {org.jbox2d.common.Color3f} color
         */
        public drawPoint(argPosition : org.jbox2d.common.Vec2, f : number, color : org.jbox2d.common.Color3f) {
            this.viewportTransform.getWorldToScreen(argPosition, ProcessingDebugDraw.position_$LI$());
            let k_segments : number = 5.0;
            let k_increment : number = (<any>Math).fround((<any>Math).fround(2.0 * org.jbox2d.common.MathUtils.PI_$LI$()) / k_segments);
            let k_radius : number = 3.0;
            let theta : number = 0.0;
            this.g.fill(color.x, color.y, color.z);
            this.g.noStroke();
            this.g.beginShape(PConstants.POLYGON);
            for(let i : number = 0; i < k_segments; ++i) {{
                let vx : number = (<any>Math).fround(ProcessingDebugDraw.position_$LI$().x + (<any>Math).fround(k_radius * org.jbox2d.common.MathUtils.cos(theta)));
                let vy : number = (<any>Math).fround(ProcessingDebugDraw.position_$LI$().y + (<any>Math).fround(k_radius * org.jbox2d.common.MathUtils.sin(theta)));
                this.g.vertex(vx, vy);
                theta += k_increment;
            };}
            this.g.endShape();
        }

        static localOffset : org.jbox2d.common.Vec2; public static localOffset_$LI$() : org.jbox2d.common.Vec2 { if(ProcessingDebugDraw.localOffset == null) ProcessingDebugDraw.localOffset = new org.jbox2d.common.Vec2(); return ProcessingDebugDraw.localOffset; };

        /**
         * First image is centered on position, then
         * rotation, then localOffset is applied, and
         * lastly localScale.
         * <BR><BR>
         * Thus localOffset should be specified in world
         * units before scaling is applied.
         * For instance, if you want a MxN image to have its corner
         * at body center and be scaled by S, use a localOffset
         * of (M*S/2, N*S/2) and a localScale of S.
         * <BR><BR>
         * 
         * @param {PImage} image
         * @param {org.jbox2d.common.Vec2} argPosition
         * @param {number} rotation
         * @param {number} localScale
         * @param {org.jbox2d.common.Vec2} argLocalOffset
         * @param {number} halfImageWidth
         * @param {number} halfImageHeight
         */
        public drawImage(image : PImage, argPosition : org.jbox2d.common.Vec2, rotation : number, localScale : number, argLocalOffset : org.jbox2d.common.Vec2, halfImageWidth : number, halfImageHeight : number) {
            this.viewportTransform.getWorldToScreen(argPosition, ProcessingDebugDraw.position_$LI$());
            this.viewportTransform.vectorTransform(argLocalOffset, ProcessingDebugDraw.localOffset_$LI$());
            this.g.pushMatrix();
            this.g.translate(ProcessingDebugDraw.position_$LI$().x, ProcessingDebugDraw.position_$LI$().y);
            let mat : org.jbox2d.common.Mat22 = this.transform.getTransform();
            if(this.pg.is3D()) {
                this.g.applyMatrix(mat.col1.x, mat.col2.x, 0, 0, mat.col1.y, mat.col2.y, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            } else {
                this.g.applyMatrix(mat.col1.x, mat.col2.x, 0, mat.col1.y, mat.col2.y, 0);
            }
            this.g.rotate(-rotation);
            this.g.scale(localScale);
            this.g.translate(ProcessingDebugDraw.localOffset_$LI$().x, ProcessingDebugDraw.localOffset_$LI$().y);
            this.g.image(image, -halfImageWidth, -halfImageHeight);
            this.g.popMatrix();
        }
    }
    ProcessingDebugDraw["__class"] = "org.jbox2d.testbed.ProcessingDebugDraw";

}
namespace org.jbox2d.dynamics {
    /**
     * Implement this class to provide collision filtering. In other words, you can implement
     * this class if you want finer control over contact creation.
     * @class
     */
    export interface ContactFilter {
        /**
         * Return true if contact calculations should be performed between these two shapes.
         * <BR><BR><em>Warning</em>: for performance reasons this is only called when the AABBs begin to overlap.
         * @param {org.jbox2d.collision.shapes.Shape} shape1
         * @param {org.jbox2d.collision.shapes.Shape} shape2
         * @return {boolean}
         */
        shouldCollide(shape1 : org.jbox2d.collision.shapes.Shape, shape2 : org.jbox2d.collision.shapes.Shape) : boolean;

        /**
         * Return true if the given shape should be considered for ray intersection
         * @param {*} userData
         * @param {org.jbox2d.collision.shapes.Shape} shape
         * @return {boolean}
         */
        rayCollide(userData : any, shape : org.jbox2d.collision.shapes.Shape) : boolean;
    }

    export namespace ContactFilter {

        /**
         * Default contact filter, using groupIndex, maskBits and categoryBits as detailed
         * in Box2d manual.
         */
        export let DEFAULT_FILTER : ContactFilter; export function DEFAULT_FILTER_$LI$() : ContactFilter { if(ContactFilter.DEFAULT_FILTER == null) ContactFilter.DEFAULT_FILTER = new org.jbox2d.dynamics.DefaultContactFilter(); return ContactFilter.DEFAULT_FILTER; };
    }

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A gear joint is used to connect two joints together. Either joint
     * can be a revolute or prismatic joint. You specify a gear ratio
     * to bind the motions together:
     * coordinate1 + ratio * coordinate2 = constant
     * The ratio can be negative or positive. If one joint is a revolute joint
     * and the other joint is a prismatic joint, then the ratio will have units
     * of length or units of 1/length.
     * <BR><em>Warning</em>: The revolute and prismatic joints must be attached to
     * fixed bodies (which must be body1 on those joints).
     * @param {org.jbox2d.dynamics.joints.GearJointDef} def
     * @class
     * @extends org.jbox2d.dynamics.joints.Joint
     */
    export class GearJoint extends org.jbox2d.dynamics.joints.Joint {
        public m_ground1 : org.jbox2d.dynamics.Body;

        public m_ground2 : org.jbox2d.dynamics.Body;

        public m_revolute1 : org.jbox2d.dynamics.joints.RevoluteJoint;

        public m_prismatic1 : org.jbox2d.dynamics.joints.PrismaticJoint;

        public m_revolute2 : org.jbox2d.dynamics.joints.RevoluteJoint;

        public m_prismatic2 : org.jbox2d.dynamics.joints.PrismaticJoint;

        public m_groundAnchor1 : org.jbox2d.common.Vec2;

        public m_groundAnchor2 : org.jbox2d.common.Vec2;

        public m_localAnchor1 : org.jbox2d.common.Vec2;

        public m_localAnchor2 : org.jbox2d.common.Vec2;

        public m_J : org.jbox2d.dynamics.joints.Jacobian;

        public m_constant : number;

        public m_ratio : number;

        /**
         * Effective mass
         */
        m_mass : number;

        /**
         * Force for accumulation/warm starting.
         */
        m_force : number;

        public constructor(def : org.jbox2d.dynamics.joints.GearJointDef) {
            super(def);
            if(this.m_ground1===undefined) this.m_ground1 = null;
            if(this.m_ground2===undefined) this.m_ground2 = null;
            if(this.m_revolute1===undefined) this.m_revolute1 = null;
            if(this.m_prismatic1===undefined) this.m_prismatic1 = null;
            if(this.m_revolute2===undefined) this.m_revolute2 = null;
            if(this.m_prismatic2===undefined) this.m_prismatic2 = null;
            if(this.m_groundAnchor1===undefined) this.m_groundAnchor1 = null;
            if(this.m_groundAnchor2===undefined) this.m_groundAnchor2 = null;
            if(this.m_localAnchor1===undefined) this.m_localAnchor1 = null;
            if(this.m_localAnchor2===undefined) this.m_localAnchor2 = null;
            if(this.m_J===undefined) this.m_J = null;
            if(this.m_constant===undefined) this.m_constant = 0;
            if(this.m_ratio===undefined) this.m_ratio = 0;
            if(this.m_mass===undefined) this.m_mass = 0;
            if(this.m_force===undefined) this.m_force = 0;
            this.m_J = new org.jbox2d.dynamics.joints.Jacobian();
            let type1 : org.jbox2d.dynamics.joints.JointType = def.joint1.getType();
            let type2 : org.jbox2d.dynamics.joints.JointType = def.joint2.getType();
            if(!((type1 === org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT || type1 === org.jbox2d.dynamics.joints.JointType.PRISMATIC_JOINT))) throw new Error("Assertion error line 73: assert (type1 == JointType.REVOLUTE_JOINT || type1 == JointType.PRISMATIC_JOINT);");;
            if(!((type2 === org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT || type2 === org.jbox2d.dynamics.joints.JointType.PRISMATIC_JOINT))) throw new Error("Assertion error line 74: assert (type2 == JointType.REVOLUTE_JOINT || type2 == JointType.PRISMATIC_JOINT);");;
            if(!((def.joint1.getBody1().isStatic()))) throw new Error("Assertion error line 75: assert (def.joint1.getBody1().isStatic());");;
            if(!((def.joint2.getBody1().isStatic()))) throw new Error("Assertion error line 76: assert (def.joint2.getBody1().isStatic());");;
            this.m_revolute1 = null;
            this.m_prismatic1 = null;
            this.m_revolute2 = null;
            this.m_prismatic2 = null;
            let coordinate1 : number;
            let coordinate2 : number;
            this.m_ground1 = def.joint1.getBody1();
            this.m_body1 = def.joint1.getBody2();
            if(type1 === org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT) {
                this.m_revolute1 = <org.jbox2d.dynamics.joints.RevoluteJoint>def.joint1;
                this.m_groundAnchor1 = this.m_revolute1.m_localAnchor1;
                this.m_localAnchor1 = this.m_revolute1.m_localAnchor2;
                coordinate1 = this.m_revolute1.getJointAngle();
            } else {
                this.m_prismatic1 = <org.jbox2d.dynamics.joints.PrismaticJoint>def.joint1;
                this.m_groundAnchor1 = this.m_prismatic1.m_localAnchor1;
                this.m_localAnchor1 = this.m_prismatic1.m_localAnchor2;
                coordinate1 = this.m_prismatic1.getJointTranslation();
            }
            this.m_ground2 = def.joint2.getBody1();
            this.m_body2 = def.joint2.getBody2();
            if(type2 === org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT) {
                this.m_revolute2 = <org.jbox2d.dynamics.joints.RevoluteJoint>def.joint2;
                this.m_groundAnchor2 = this.m_revolute2.m_localAnchor1;
                this.m_localAnchor2 = this.m_revolute2.m_localAnchor2;
                coordinate2 = this.m_revolute2.getJointAngle();
            } else {
                this.m_prismatic2 = <org.jbox2d.dynamics.joints.PrismaticJoint>def.joint2;
                this.m_groundAnchor2 = this.m_prismatic2.m_localAnchor1;
                this.m_localAnchor2 = this.m_prismatic2.m_localAnchor2;
                coordinate2 = this.m_prismatic2.getJointTranslation();
            }
            this.m_ratio = def.ratio;
            this.m_constant = (<any>Math).fround(coordinate1 + (<any>Math).fround(this.m_ratio * coordinate2));
            this.m_force = 0.0;
        }

        /*private*/ tlug : org.jbox2d.pooling.TLVec2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })();

        /*private*/ tlr : org.jbox2d.pooling.TLVec2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })();

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public initVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let g1 : org.jbox2d.dynamics.Body = this.m_ground1;
            let g2 : org.jbox2d.dynamics.Body = this.m_ground2;
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let ug : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(this.tlug);
            let r : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(this.tlr);
            let K : number = 0.0;
            this.m_J.setZero();
            if(this.m_revolute1 != null) {
                this.m_J.angular1 = -1.0;
                K += b1.m_invI;
            } else {
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(g1.getMemberXForm().R, this.m_prismatic1.m_localXAxis1, ug);
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.getMemberXForm().R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r);
                let crug : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r, ug);
                this.m_J.linear1.set$org_jbox2d_common_Vec2(ug);
                this.m_J.linear1.negateLocal();
                this.m_J.angular1 = -crug;
                K += (<any>Math).fround(b1.m_invMass + (<any>Math).fround((<any>Math).fround(b1.m_invI * crug) * crug));
            }
            if(this.m_revolute2 != null) {
                this.m_J.angular2 = -this.m_ratio;
                K += (<any>Math).fround((<any>Math).fround(this.m_ratio * this.m_ratio) * b2.m_invI);
            } else {
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(g2.getMemberXForm().R, this.m_prismatic2.m_localXAxis1, ug);
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.getMemberXForm().R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r);
                let crug : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r, ug);
                this.m_J.linear2.set$org_jbox2d_common_Vec2(ug);
                this.m_J.linear2.mulLocal(-this.m_ratio);
                this.m_J.angular2 = (<any>Math).fround(-this.m_ratio * crug);
                K += (<any>Math).fround((<any>Math).fround(this.m_ratio * this.m_ratio) * ((<any>Math).fround(b2.m_invMass + (<any>Math).fround((<any>Math).fround(b2.m_invI * crug) * crug))));
            }
            if(!((K > 0.0))) throw new Error("Assertion error line 155: assert (K > 0.0F);");;
            this.m_mass = (<any>Math).fround(1.0 / K);
            if(step.warmStarting) {
                let P : number = (<any>Math).fround(step.dt * this.m_force);
                b1.m_linearVelocity.x += (<any>Math).fround((<any>Math).fround(b1.m_invMass * P) * this.m_J.linear1.x);
                b1.m_linearVelocity.y += (<any>Math).fround((<any>Math).fround(b1.m_invMass * P) * this.m_J.linear1.y);
                b1.m_angularVelocity += (<any>Math).fround((<any>Math).fround(b1.m_invI * P) * this.m_J.angular1);
                b2.m_linearVelocity.x += (<any>Math).fround((<any>Math).fround(b2.m_invMass * P) * this.m_J.linear2.x);
                b2.m_linearVelocity.y += (<any>Math).fround((<any>Math).fround(b2.m_invMass * P) * this.m_J.linear2.y);
                b2.m_angularVelocity += (<any>Math).fround((<any>Math).fround(b2.m_invI * P) * this.m_J.angular2);
            } else {
                this.m_force = 0.0;
            }
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public solveVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let Cdot : number = this.m_J.compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity);
            let force : number = (<any>Math).fround((<any>Math).fround(-step.inv_dt * this.m_mass) * Cdot);
            this.m_force += force;
            let P : number = (<any>Math).fround(step.dt * force);
            b1.m_linearVelocity.x += (<any>Math).fround((<any>Math).fround(b1.m_invMass * P) * this.m_J.linear1.x);
            b1.m_linearVelocity.y += (<any>Math).fround((<any>Math).fround(b1.m_invMass * P) * this.m_J.linear1.y);
            b1.m_angularVelocity += (<any>Math).fround((<any>Math).fround(b1.m_invI * P) * this.m_J.angular1);
            b2.m_linearVelocity.x += (<any>Math).fround((<any>Math).fround(b2.m_invMass * P) * this.m_J.linear2.x);
            b2.m_linearVelocity.y += (<any>Math).fround((<any>Math).fround(b2.m_invMass * P) * this.m_J.linear2.y);
            b2.m_angularVelocity += (<any>Math).fround((<any>Math).fround(b2.m_invI * P) * this.m_J.angular2);
        }

        /**
         * 
         * @return {boolean}
         */
        public solvePositionConstraints() : boolean {
            let linearError : number = 0.0;
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let coordinate1 : number;
            let coordinate2 : number;
            if(this.m_revolute1 != null) {
                coordinate1 = this.m_revolute1.getJointAngle();
            } else {
                coordinate1 = this.m_prismatic1.getJointTranslation();
            }
            if(this.m_revolute2 != null) {
                coordinate2 = this.m_revolute2.getJointAngle();
            } else {
                coordinate2 = this.m_prismatic2.getJointTranslation();
            }
            let C : number = (<any>Math).fround(this.m_constant - ((<any>Math).fround(coordinate1 + (<any>Math).fround(this.m_ratio * coordinate2))));
            let impulse : number = (<any>Math).fround(-this.m_mass * C);
            b1.m_sweep.c.x += (<any>Math).fround((<any>Math).fround(b1.m_invMass * impulse) * this.m_J.linear1.x);
            b1.m_sweep.c.y += (<any>Math).fround((<any>Math).fround(b1.m_invMass * impulse) * this.m_J.linear1.y);
            b1.m_sweep.a += (<any>Math).fround((<any>Math).fround(b1.m_invI * impulse) * this.m_J.angular1);
            b2.m_sweep.c.x += (<any>Math).fround((<any>Math).fround(b2.m_invMass * impulse) * this.m_J.linear2.x);
            b2.m_sweep.c.y += (<any>Math).fround((<any>Math).fround(b2.m_invMass * impulse) * this.m_J.linear2.y);
            b2.m_sweep.a += (<any>Math).fround((<any>Math).fround(b2.m_invI * impulse) * this.m_J.angular2);
            b1.synchronizeTransform();
            b2.synchronizeTransform();
            return linearError < org.jbox2d.common.Settings.linearSlop_$LI$();
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor1() : org.jbox2d.common.Vec2 {
            return this.m_body1.getWorldLocation(this.m_localAnchor1);
        }

        public getAnchor1ToOut(out : org.jbox2d.common.Vec2) {
            this.m_body1.getWorldLocationToOut(this.m_localAnchor1, out);
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor2() : org.jbox2d.common.Vec2 {
            return this.m_body2.getWorldLocation(this.m_localAnchor2);
        }

        public getAnchor2ToOut(out : org.jbox2d.common.Vec2) {
            this.m_body2.getWorldLocationToOut(this.m_localAnchor2, out);
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getReactionForce() : org.jbox2d.common.Vec2 {
            return new org.jbox2d.common.Vec2((<any>Math).fround(this.m_force * this.m_J.linear2.x), (<any>Math).fround(this.m_force * this.m_J.linear2.y));
        }

        public getReactionForceToOut(out : org.jbox2d.common.Vec2) {
            out.x = (<any>Math).fround(this.m_force * this.m_J.linear2.x);
            out.y = (<any>Math).fround(this.m_force * this.m_J.linear2.y);
        }

        /**
         * 
         * @return {number}
         */
        public getReactionTorque() : number {
            let r : org.jbox2d.common.Vec2 = org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(this.m_body2.getMemberXForm().R, this.m_localAnchor2.sub(this.m_body2.getMemberLocalCenter()));
            let F : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(this.m_force * this.m_J.linear2.x), (<any>Math).fround(this.m_force * this.m_J.linear2.y));
            let T : number = (<any>Math).fround((<any>Math).fround(this.m_force * this.m_J.angular2) - org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r, F));
            return T;
        }

        public getRatio() : number {
            return this.m_ratio;
        }
    }
    GearJoint["__class"] = "org.jbox2d.dynamics.joints.GearJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Definition for a {@link ConstantVolumeJoint}, which connects a group a bodies together
     * so they maintain a constant volume within them.
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class ConstantVolumeJointDef extends org.jbox2d.dynamics.joints.JointDef {
        bodies : org.jbox2d.dynamics.Body[];

        public frequencyHz : number;

        public dampingRatio : number;

        public constructor() {
            super();
            if(this.bodies===undefined) this.bodies = null;
            if(this.frequencyHz===undefined) this.frequencyHz = 0;
            if(this.dampingRatio===undefined) this.dampingRatio = 0;
            this.type = org.jbox2d.dynamics.joints.JointType.CONSTANT_VOLUME_JOINT;
            this.bodies = [];
            this.collideConnected = false;
            this.frequencyHz = 0.0;
            this.dampingRatio = 0.0;
        }

        public addBody(b : org.jbox2d.dynamics.Body) {
            let tmp : org.jbox2d.dynamics.Body[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.bodies.length + 1);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.bodies, 0, tmp, 0, this.bodies.length);
            tmp[this.bodies.length] = b;
            this.bodies = tmp;
            if(tmp.length === 1) {
                this.body1 = b;
            }
            if(tmp.length === 2) {
                this.body2 = b;
            }
        }
    }
    ConstantVolumeJointDef["__class"] = "org.jbox2d.dynamics.joints.ConstantVolumeJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Definition for a distance joint.  A distance joint
     * keeps two points on two bodies at a constant distance
     * from each other.
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class DistanceJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The local anchor point relative to body1's origin.
         */
        public localAnchor1 : org.jbox2d.common.Vec2;

        /**
         * The local anchor point relative to body2's origin.
         */
        public localAnchor2 : org.jbox2d.common.Vec2;

        /**
         * The equilibrium length between the anchor points.
         */
        public length : number;

        public frequencyHz : number;

        public dampingRatio : number;

        public constructor() {
            super();
            if(this.localAnchor1===undefined) this.localAnchor1 = null;
            if(this.localAnchor2===undefined) this.localAnchor2 = null;
            if(this.length===undefined) this.length = 0;
            if(this.frequencyHz===undefined) this.frequencyHz = 0;
            if(this.dampingRatio===undefined) this.dampingRatio = 0;
            this.type = org.jbox2d.dynamics.joints.JointType.DISTANCE_JOINT;
            this.localAnchor1 = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.localAnchor2 = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.length = 1.0;
            this.frequencyHz = 0.0;
            this.dampingRatio = 0.0;
        }

        /**
         * Initialize the bodies, anchors, and length using the world
         * anchors.
         * @param {org.jbox2d.dynamics.Body} b1 First body
         * @param {org.jbox2d.dynamics.Body} b2 Second body
         * @param {org.jbox2d.common.Vec2} anchor1 World anchor on first body
         * @param {org.jbox2d.common.Vec2} anchor2 World anchor on second body
         */
        public initialize(b1 : org.jbox2d.dynamics.Body, b2 : org.jbox2d.dynamics.Body, anchor1 : org.jbox2d.common.Vec2, anchor2 : org.jbox2d.common.Vec2) {
            this.body1 = b1;
            this.body2 = b2;
            this.localAnchor1.set$org_jbox2d_common_Vec2(this.body1.getLocalPoint(anchor1));
            this.localAnchor2.set$org_jbox2d_common_Vec2(this.body2.getLocalPoint(anchor2));
            let d : org.jbox2d.common.Vec2 = anchor2.sub(anchor1);
            this.length = d.length();
        }
    }
    DistanceJointDef["__class"] = "org.jbox2d.dynamics.joints.DistanceJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * 
     * Gear joint definition. This definition requires two existing
     * revolute or prismatic joints (any combination will work).
     * The provided joints must attach a dynamic body to a static body.<BR><BR>
     * A gear joint is used to connect two joints together. Either joint
     * can be a revolute or prismatic joint. You specify a gear ratio
     * to bind the motions together:
     * coordinate1 + ratio * coordinate2 = constant
     * The ratio can be negative or positive. If one joint is a revolute joint
     * and the other joint is a prismatic joint, then the ratio will have units
     * of length or units of 1/length.
     * <BR><em>Warning</em>: The revolute and prismatic joints must be attached to
     * fixed bodies (which must be body1 on those joints).
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class GearJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The first revolute/prismatic joint attached to the gear joint.
         */
        public joint1 : org.jbox2d.dynamics.joints.Joint;

        /**
         * The second revolute/prismatic joint attached to the gear joint.
         */
        public joint2 : org.jbox2d.dynamics.joints.Joint;

        /**
         * The gear ratio.
         * @see org.jbox2d.dynamics.joints.GearJoint for explanation.
         */
        public ratio : number;

        public constructor() {
            super();
            if(this.joint1===undefined) this.joint1 = null;
            if(this.joint2===undefined) this.joint2 = null;
            if(this.ratio===undefined) this.ratio = 0;
            this.type = org.jbox2d.dynamics.joints.JointType.GEAR_JOINT;
            this.joint1 = null;
            this.joint2 = null;
            this.ratio = 1.0;
        }
    }
    GearJointDef["__class"] = "org.jbox2d.dynamics.joints.GearJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * This joint is used to add force to an object to accelerate to a position,
     * normally used with the mouse.
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class MouseJointDef extends org.jbox2d.dynamics.joints.JointDef {
        /**
         * The initial world target point. This is assumed
         * to coincide with the body anchor initially.
         */
        public target : org.jbox2d.common.Vec2;

        /**
         * The maximum constraint force that can be exerted
         * to move the candidate body. Usually you will express
         * as some multiple of the weight (multiplier * mass * gravity).
         */
        public maxForce : number;

        /**
         * The response speed.
         */
        public frequencyHz : number;

        /**
         * The damping ratio. 0 = no damping, 1 = critical damping.
         */
        public dampingRatio : number;

        /**
         * The time step used in the simulation.
         */
        public timeStep : number;

        public constructor() {
            super();
            if(this.target===undefined) this.target = null;
            if(this.maxForce===undefined) this.maxForce = 0;
            if(this.frequencyHz===undefined) this.frequencyHz = 0;
            if(this.dampingRatio===undefined) this.dampingRatio = 0;
            if(this.timeStep===undefined) this.timeStep = 0;
            this.type = org.jbox2d.dynamics.joints.JointType.MOUSE_JOINT;
            this.target = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.maxForce = 0.0;
            this.frequencyHz = 5.0;
            this.dampingRatio = 0.7;
            this.timeStep = (<any>Math).fround(1.0 / 60.0);
        }
    }
    MouseJointDef["__class"] = "org.jbox2d.dynamics.joints.MouseJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A prismatic joint definition. This joint provides one degree of freedom: translation
     * along an axis fixed in body1. Relative rotation is prevented. You can
     * use a joint limit to restrict the range of motion and a joint motor to
     * drive the motion or to model joint friction.
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class PrismaticJointDef extends org.jbox2d.dynamics.joints.JointDef {
        public constructor() {
            super();
            if(this.localAnchor1===undefined) this.localAnchor1 = null;
            if(this.localAnchor2===undefined) this.localAnchor2 = null;
            if(this.localAxis1===undefined) this.localAxis1 = null;
            if(this.referenceAngle===undefined) this.referenceAngle = 0;
            if(this.enableLimit===undefined) this.enableLimit = false;
            if(this.lowerTranslation===undefined) this.lowerTranslation = 0;
            if(this.upperTranslation===undefined) this.upperTranslation = 0;
            if(this.enableMotor===undefined) this.enableMotor = false;
            if(this.maxMotorForce===undefined) this.maxMotorForce = 0;
            if(this.motorSpeed===undefined) this.motorSpeed = 0;
            this.type = org.jbox2d.dynamics.joints.JointType.PRISMATIC_JOINT;
            this.localAnchor1 = new org.jbox2d.common.Vec2();
            this.localAnchor2 = new org.jbox2d.common.Vec2();
            this.localAxis1 = new org.jbox2d.common.Vec2();
            this.referenceAngle = 0.0;
            this.enableLimit = false;
            this.lowerTranslation = 0.0;
            this.upperTranslation = 0.0;
            this.enableMotor = false;
            this.maxMotorForce = 0.0;
            this.motorSpeed = 0.0;
        }

        public initialize(b1 : org.jbox2d.dynamics.Body, b2 : org.jbox2d.dynamics.Body, anchor : org.jbox2d.common.Vec2, axis : org.jbox2d.common.Vec2) {
            this.body1 = b1;
            this.body2 = b2;
            this.body1.getLocalPointToOut(anchor, this.localAnchor1);
            this.body2.getLocalPointToOut(anchor, this.localAnchor2);
            this.body1.getLocalVectorToOut(axis, this.localAxis1);
            this.referenceAngle = (<any>Math).fround(this.body2.getAngle() - this.body1.getAngle());
        }

        public localAnchor1 : org.jbox2d.common.Vec2;

        public localAnchor2 : org.jbox2d.common.Vec2;

        public localAxis1 : org.jbox2d.common.Vec2;

        public referenceAngle : number;

        public enableLimit : boolean;

        public lowerTranslation : number;

        public upperTranslation : number;

        public enableMotor : boolean;

        public maxMotorForce : number;

        public motorSpeed : number;
    }
    PrismaticJointDef["__class"] = "org.jbox2d.dynamics.joints.PrismaticJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * The pulley joint is connected to two bodies and two fixed ground points.
     * The pulley supports a ratio such that:
     * length1 + ratio * length2 = constant
     * Yes, the force transmitted is scaled by the ratio.
     * The pulley also enforces a maximum length limit on both sides. This is
     * useful to prevent one side of the pulley hitting the top.
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class PulleyJointDef extends org.jbox2d.dynamics.joints.JointDef {
        public constructor() {
            super();
            if(this.groundAnchor1===undefined) this.groundAnchor1 = null;
            if(this.groundAnchor2===undefined) this.groundAnchor2 = null;
            if(this.localAnchor1===undefined) this.localAnchor1 = null;
            if(this.localAnchor2===undefined) this.localAnchor2 = null;
            if(this.length1===undefined) this.length1 = 0;
            if(this.maxLength1===undefined) this.maxLength1 = 0;
            if(this.length2===undefined) this.length2 = 0;
            if(this.maxLength2===undefined) this.maxLength2 = 0;
            if(this.ratio===undefined) this.ratio = 0;
            this.type = org.jbox2d.dynamics.joints.JointType.PULLEY_JOINT;
            this.groundAnchor1 = new org.jbox2d.common.Vec2(-1.0, 1.0);
            this.groundAnchor2 = new org.jbox2d.common.Vec2(1.0, 1.0);
            this.localAnchor1 = new org.jbox2d.common.Vec2(-1.0, 0.0);
            this.localAnchor2 = new org.jbox2d.common.Vec2(1.0, 0.0);
            this.length1 = 0.0;
            this.maxLength1 = 0.0;
            this.length2 = 0.0;
            this.maxLength2 = 0.0;
            this.ratio = 1.0;
            this.collideConnected = true;
        }

        public initialize(b1 : org.jbox2d.dynamics.Body, b2 : org.jbox2d.dynamics.Body, ga1 : org.jbox2d.common.Vec2, ga2 : org.jbox2d.common.Vec2, anchor1 : org.jbox2d.common.Vec2, anchor2 : org.jbox2d.common.Vec2, r : number) {
            this.body1 = b1;
            this.body2 = b2;
            this.groundAnchor1 = ga1;
            this.groundAnchor2 = ga2;
            this.localAnchor1 = this.body1.getLocalPoint(anchor1);
            this.localAnchor2 = this.body2.getLocalPoint(anchor2);
            let d1 : org.jbox2d.common.Vec2 = anchor1.sub(ga1);
            this.length1 = d1.length();
            let d2 : org.jbox2d.common.Vec2 = anchor2.sub(ga2);
            this.length2 = d2.length();
            this.ratio = r;
            if(!((this.ratio > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 49: assert (ratio > Settings.EPSILON);");;
            let C : number = (<any>Math).fround(this.length1 + (<any>Math).fround(this.ratio * this.length2));
            this.maxLength1 = (<any>Math).fround(C - (<any>Math).fround(this.ratio * org.jbox2d.dynamics.joints.PulleyJoint.MIN_PULLEY_LENGTH));
            this.maxLength2 = (<any>Math).fround(((<any>Math).fround(C - org.jbox2d.dynamics.joints.PulleyJoint.MIN_PULLEY_LENGTH)) / this.ratio);
        }

        public groundAnchor1 : org.jbox2d.common.Vec2;

        public groundAnchor2 : org.jbox2d.common.Vec2;

        public localAnchor1 : org.jbox2d.common.Vec2;

        public localAnchor2 : org.jbox2d.common.Vec2;

        public length1 : number;

        public maxLength1 : number;

        public length2 : number;

        public maxLength2 : number;

        public ratio : number;
    }
    PulleyJointDef["__class"] = "org.jbox2d.dynamics.joints.PulleyJointDef";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * Revolute joint definition. This requires defining an
     * anchor point where the bodies are joined. The definition
     * uses local anchor points so that the initial configuration
     * can violate the constraint slightly. You also need to
     * specify the initial relative angle for joint limits. This
     * helps when saving and loading a game.
     * The local anchor points are measured from the body's origin
     * rather than the center of mass because:<br/>
     * <ul>
     * <li>you might not know where the center of mass will be.</li>
     * <li>if you add/remove shapes from a body and recompute the mass,
     * the joints will be broken.</li></ul>
     * @class
     * @extends org.jbox2d.dynamics.joints.JointDef
     */
    export class RevoluteJointDef extends org.jbox2d.dynamics.joints.JointDef {
        public constructor() {
            super();
            if(this.localAnchor1===undefined) this.localAnchor1 = null;
            if(this.localAnchor2===undefined) this.localAnchor2 = null;
            if(this.referenceAngle===undefined) this.referenceAngle = 0;
            if(this.enableLimit===undefined) this.enableLimit = false;
            if(this.lowerAngle===undefined) this.lowerAngle = 0;
            if(this.upperAngle===undefined) this.upperAngle = 0;
            if(this.enableMotor===undefined) this.enableMotor = false;
            if(this.motorSpeed===undefined) this.motorSpeed = 0;
            if(this.maxMotorTorque===undefined) this.maxMotorTorque = 0;
            this.type = org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT;
            this.localAnchor1 = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.localAnchor2 = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.referenceAngle = 0.0;
            this.lowerAngle = 0.0;
            this.upperAngle = 0.0;
            this.maxMotorTorque = 0.0;
            this.motorSpeed = 0.0;
            this.enableLimit = false;
            this.enableMotor = false;
        }

        public initialize(b1 : org.jbox2d.dynamics.Body, b2 : org.jbox2d.dynamics.Body, anchor : org.jbox2d.common.Vec2) {
            this.body1 = b1;
            this.body2 = b2;
            this.localAnchor1 = this.body1.getLocalPoint(anchor);
            this.localAnchor2 = this.body2.getLocalPoint(anchor);
            this.referenceAngle = (<any>Math).fround(this.body2.getAngle() - this.body1.getAngle());
        }

        /**
         * The local anchor point relative to body1's origin.
         */
        public localAnchor1 : org.jbox2d.common.Vec2;

        /**
         * The local anchor point relative to body2's origin.
         */
        public localAnchor2 : org.jbox2d.common.Vec2;

        /**
         * The body2 angle minus body1 angle in the reference state (radians).
         */
        public referenceAngle : number;

        /**
         * A flag to enable joint limits.
         */
        public enableLimit : boolean;

        /**
         * The lower angle for the joint limit (radians).
         */
        public lowerAngle : number;

        /**
         * The upper angle for the joint limit (radians).
         */
        public upperAngle : number;

        /**
         * A flag to enable the joint motor.
         */
        public enableMotor : boolean;

        /**
         * The desired motor speed. Usually in radians per second.
         */
        public motorSpeed : number;

        /**
         * The maximum motor torque used to achieve the desired motor speed.
         * Usually in N-m.
         */
        public maxMotorTorque : number;
    }
    RevoluteJointDef["__class"] = "org.jbox2d.dynamics.joints.RevoluteJointDef";

}
namespace org.jbox2d.pooling.arrays {
    export class BooleanArray extends org.jbox2d.pooling.arrays.DynamicTLArray<boolean> {
        /**
         * 
         * @param {number} argLength
         * @return {Array}
         */
        getInitializedArray(argLength : number) : boolean[] {
            let ray : boolean[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(argLength);
            for(let i : number = 0; i < argLength; i++) {{
                ray[i] = false;
            };}
            return ray;
        }
    }
    BooleanArray["__class"] = "org.jbox2d.pooling.arrays.BooleanArray";

}
namespace org.jbox2d.pooling.arrays {
    export class IntegerArray extends org.jbox2d.pooling.arrays.DynamicTLArray<number> {
        /**
         * 
         * @param {number} argLength
         * @return {Array}
         */
        getInitializedArray(argLength : number) : number[] {
            return (s => { let a=[]; while(s-->0) a.push(null); return a; })(argLength);
        }
    }
    IntegerArray["__class"] = "org.jbox2d.pooling.arrays.IntegerArray";

}
namespace org.jbox2d.pooling.arrays {
    export class Vec2Array extends org.jbox2d.pooling.arrays.DynamicTLArray<org.jbox2d.common.Vec2> {
        /**
         * 
         * @param {number} argLength
         * @return {Array}
         */
        getInitializedArray(argLength : number) : org.jbox2d.common.Vec2[] {
            let ray : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(argLength);
            for(let i : number = 0; i < ray.length; i++) {{
                ray[i] = new org.jbox2d.common.Vec2();
            };}
            return ray;
        }
    }
    Vec2Array["__class"] = "org.jbox2d.pooling.arrays.Vec2Array";

}
namespace org.jbox2d.pooling.stacks {
    export class ContactSolverStack extends org.jbox2d.pooling.stacks.DynamicTLStack<org.jbox2d.dynamics.contacts.ContactSolver> {
        /**
         * 
         * @return {org.jbox2d.dynamics.contacts.ContactSolver}
         */
        newObjectInstance() : org.jbox2d.dynamics.contacts.ContactSolver {
            return new org.jbox2d.dynamics.contacts.ContactSolver();
        }
    }
    ContactSolverStack["__class"] = "org.jbox2d.pooling.stacks.ContactSolverStack";

}
namespace org.jbox2d.pooling.stacks {
    export class IslandStack extends org.jbox2d.pooling.stacks.DynamicTLStack<org.jbox2d.dynamics.Island> {
        /**
         * 
         * @return {org.jbox2d.dynamics.Island}
         */
        newObjectInstance() : org.jbox2d.dynamics.Island {
            return new org.jbox2d.dynamics.Island();
        }
    }
    IslandStack["__class"] = "org.jbox2d.pooling.stacks.IslandStack";

}
namespace org.jbox2d.pooling.stacks {
    export class TimeStepStack extends org.jbox2d.pooling.stacks.DynamicTLStack<org.jbox2d.dynamics.TimeStep> {
        /**
         * 
         * @return {org.jbox2d.dynamics.TimeStep}
         */
        newObjectInstance() : org.jbox2d.dynamics.TimeStep {
            return new org.jbox2d.dynamics.TimeStep();
        }
    }
    TimeStepStack["__class"] = "org.jbox2d.pooling.stacks.TimeStepStack";

}
namespace org.jbox2d.collision.shapes {
    /**
     * A shape is used for collision detection. Shapes are created in World.
     * You can use shape for collision detection before they are attached to the world.
     * <BR><BR><em>Warning</em>: you cannot reuse shapes on different bodies, they must
     * be re-created or copied.
     * @param {org.jbox2d.collision.shapes.ShapeDef} def
     * @class
     */
    export abstract class Shape {
        /**
         * Unique id for shape for sorting (C++ version uses memory address)
         */
        public uid : number;

        /**
         * Used to generate uids - not initialized on applet reload,
         * but that's okay since these just have to be unique.
         */
        static uidcount : number = 0;

        public m_type : org.jbox2d.collision.shapes.ShapeType;

        public m_next : Shape;

        public m_body : org.jbox2d.dynamics.Body;

        /**
         * Sweep radius relative to the parent body's center of mass.
         */
        public m_sweepRadius : number;

        public m_density : number;

        public m_friction : number;

        public m_restitution : number;

        public m_proxyId : number;

        public m_filter : org.jbox2d.collision.FilterData;

        public m_isSensor : boolean;

        public m_userData : any;

        public constructor(def : org.jbox2d.collision.shapes.ShapeDef) {
            if(this.uid===undefined) this.uid = 0;
            if(this.m_type===undefined) this.m_type = null;
            if(this.m_next===undefined) this.m_next = null;
            if(this.m_body===undefined) this.m_body = null;
            if(this.m_sweepRadius===undefined) this.m_sweepRadius = 0;
            if(this.m_density===undefined) this.m_density = 0;
            if(this.m_friction===undefined) this.m_friction = 0;
            if(this.m_restitution===undefined) this.m_restitution = 0;
            if(this.m_proxyId===undefined) this.m_proxyId = 0;
            if(this.m_filter===undefined) this.m_filter = null;
            if(this.m_isSensor===undefined) this.m_isSensor = false;
            if(this.m_userData===undefined) this.m_userData = null;
            this.uid = Shape.uidcount++;
            this.m_userData = def.userData;
            this.m_friction = def.friction;
            this.m_restitution = def.restitution;
            this.m_density = def.density;
            this.m_body = null;
            this.m_sweepRadius = 0.0;
            this.m_next = null;
            this.m_proxyId = org.jbox2d.collision.PairManager.NULL_PROXY_$LI$();
            this.m_filter = new org.jbox2d.collision.FilterData();
            this.m_filter.categoryBits = def.filter.categoryBits;
            this.m_filter.maskBits = def.filter.maskBits;
            this.m_filter.groupIndex = def.filter.groupIndex;
            this.m_isSensor = def.isSensor;
        }

        /**
         * Get the coefficient of friction.
         * @return {number}
         */
        public getFriction() : number {
            return this.m_friction;
        }

        /**
         * Set the coefficient of friction.
         * @param {number} friction
         */
        public setFriction(friction : number) {
            this.m_friction = friction;
        }

        /**
         * Get the coefficient of restitution.
         * @return {number}
         */
        public getRestitution() : number {
            return this.m_restitution;
        }

        /**
         * Set the coefficient of restitution.
         * @param {number} restitution
         */
        public setRestitution(restitution : number) {
            this.m_restitution = restitution;
        }

        /**
         * Set the collision filtering data.
         * @param {org.jbox2d.collision.FilterData} filter
         */
        public setFilterData(filter : org.jbox2d.collision.FilterData) {
            this.m_filter.set(filter);
        }

        /**
         * Get the collision filtering data.
         * @return {org.jbox2d.collision.FilterData}
         */
        public getFilterData() : org.jbox2d.collision.FilterData {
            return this.m_filter;
        }

        /**
         * Get the type of this shape. You can use this to down cast to the concrete shape.
         * @return {org.jbox2d.collision.shapes.ShapeType} the shape type.
         */
        public getType() : org.jbox2d.collision.shapes.ShapeType {
            return this.m_type;
        }

        /**
         * Is this shape a sensor (non-solid)?
         * @return {boolean} the true if the shape is a sensor.
         */
        public isSensor() : boolean {
            return this.m_isSensor;
        }

        /**
         * Get the user data that was assigned in the shape definition. Use this to
         * store your application specific data.
         * @return {*}
         */
        public getUserData() : any {
            return this.m_userData;
        }

        /**
         * Set the user data associated with the object.
         * @param {*} o User data to set
         */
        public setUserData(o : any) {
            this.m_userData = o;
        }

        /**
         * Get the parent body of this shape. This is NULL if the shape is not attached.
         * @return {org.jbox2d.dynamics.Body} the parent body.
         */
        public getBody() : org.jbox2d.dynamics.Body {
            return this.m_body;
        }

        /**
         * Get the next shape in the parent body's shape list.
         * @return {org.jbox2d.collision.shapes.Shape} the next shape.
         */
        public getNext() : Shape {
            return this.m_next;
        }

        /**
         * Get the sweep radius of the shape.
         * @return {number} the sweep radius
         */
        public getSweepRadius() : number {
            return this.m_sweepRadius;
        }

        /**
         * Test a point for containment in this shape. This only works for convex shapes.
         * @param {org.jbox2d.common.XForm} xf the shape world transform.
         * @param {org.jbox2d.common.Vec2} p a point in world coordinates.
         * @return {boolean} true if the point is within the shape
         */
        public abstract testPoint(xf : org.jbox2d.common.XForm, p : org.jbox2d.common.Vec2) : boolean;

        /**
         * Perform a ray cast against this shape.
         * @param {org.jbox2d.common.XForm} xf the shape world transform.
         * @param {org.jbox2d.common.RaycastResult} out is where the results are placed: <ul><li>lambda returns the hit fraction, based on
         * the distance between the two points. You can use this to compute the contact point
         * p = (1 - lambda) * segment.p1 + lambda * segment.p2.</li>
         * <li>normal returns the normal at the contact point. If there is no intersection, the normal
         * is not set.</li></ul>
         * @param {org.jbox2d.collision.Segment} segment defines the begin and end point of the ray cast.
         * @param {number} maxLambda a number typically in the range [0,1].
         * @return {org.jbox2d.collision.SegmentCollide} true if there was an intersection.
         */
        public abstract testSegment(xf : org.jbox2d.common.XForm, out : org.jbox2d.common.RaycastResult, segment : org.jbox2d.collision.Segment, maxLambda : number) : org.jbox2d.collision.SegmentCollide;

        /**
         * Given a transform, compute the associated axis aligned bounding box for this shape.
         * @param {org.jbox2d.collision.AABB} aabb returns the axis aligned box.
         * @param {org.jbox2d.common.XForm} xf the world transform of the shape.
         */
        public abstract computeAABB(aabb : org.jbox2d.collision.AABB, xf : org.jbox2d.common.XForm);

        /**
         * Given two transforms, compute the associated swept axis aligned bounding box for this shape.
         * @param {org.jbox2d.collision.AABB} aabb returns the axis aligned box. (return parameter)
         * @param {org.jbox2d.common.XForm} xf1 the starting shape world transform.
         * @param {org.jbox2d.common.XForm} xf2 the ending shape world transform.
         */
        public abstract computeSweptAABB(aabb : org.jbox2d.collision.AABB, xf1 : org.jbox2d.common.XForm, xf2 : org.jbox2d.common.XForm);

        /**
         * Compute the mass properties of this shape using its dimensions and density.
         * The inertia tensor is computed about the local origin, not the centroid.
         * @param {org.jbox2d.collision.MassData} massData returns the mass data for this shape. (return parameter)
         */
        public abstract computeMass(massData : org.jbox2d.collision.MassData);

        /**
         * Internal
         * @param {org.jbox2d.common.Vec2} center
         */
        public abstract updateSweepRadius(center : org.jbox2d.common.Vec2);

        static tlAabb : org.jbox2d.pooling.TLAABB; public static tlAabb_$LI$() : org.jbox2d.pooling.TLAABB { if(Shape.tlAabb == null) Shape.tlAabb = (() => { let __o : any = new org.jbox2d.pooling.TLAABB(); __o.__delegate = new org.jbox2d.pooling.TLAABB(); return __o; })(); return Shape.tlAabb; };

        /**
         * Internal
         * @param {org.jbox2d.collision.BroadPhase} broadPhase
         * @param {org.jbox2d.common.XForm} transform1
         * @param {org.jbox2d.common.XForm} transform2
         * @return {boolean}
         */
        public synchronize(broadPhase : org.jbox2d.collision.BroadPhase, transform1 : org.jbox2d.common.XForm, transform2 : org.jbox2d.common.XForm) : boolean {
            if(this.m_proxyId === org.jbox2d.collision.PairManager.NULL_PROXY_$LI$()) {
                return false;
            }
            let aabb : org.jbox2d.collision.AABB = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(Shape.tlAabb_$LI$());
            this.computeSweptAABB(aabb, transform1, transform2);
            if(broadPhase.inRange(aabb)) {
                broadPhase.moveProxy(this.m_proxyId, aabb);
                return true;
            } else {
                return false;
            }
        }

        /**
         * Internal
         * @param {org.jbox2d.collision.BroadPhase} broadPhase
         * @param {org.jbox2d.common.XForm} transform
         */
        public refilterProxy(broadPhase : org.jbox2d.collision.BroadPhase, transform : org.jbox2d.common.XForm) {
            if(this.m_proxyId === org.jbox2d.collision.PairManager.NULL_PROXY_$LI$()) {
                return;
            }
            broadPhase.destroyProxy(this.m_proxyId);
            let aabb : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();
            this.computeAABB(aabb, transform);
            let inRange : boolean = broadPhase.inRange(aabb);
            if(inRange) {
                this.m_proxyId = broadPhase.createProxy(aabb, this);
            } else {
                this.m_proxyId = org.jbox2d.collision.PairManager.NULL_PROXY_$LI$();
            }
        }

        /**
         * Internal
         * @param {org.jbox2d.collision.shapes.ShapeDef} def
         * @return {org.jbox2d.collision.shapes.Shape}
         */
        public static create(def : org.jbox2d.collision.shapes.ShapeDef) : Shape {
            if(def.type === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                return new org.jbox2d.collision.shapes.CircleShape(def);
            } else if(def.type === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                return new org.jbox2d.collision.shapes.PolygonShape(def);
            } else if(def.type === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE) {
                return new org.jbox2d.collision.shapes.PointShape(def);
            }
            if(!(false)) throw new Error("Assertion error line 287: assert false;");;
            return null;
        }

        /**
         * Internal
         * @param {org.jbox2d.collision.shapes.Shape} s
         */
        public static destroy(s : Shape) {
            if(s.getType() === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE) {
                let edge : org.jbox2d.collision.shapes.EdgeShape = <org.jbox2d.collision.shapes.EdgeShape>s;
                if(edge.m_nextEdge != null) {
                    edge.m_nextEdge.m_prevEdge = null;
                }
                if(edge.m_prevEdge != null) {
                    edge.m_prevEdge.m_nextEdge = null;
                }
            }
            s.destructor();
        }

        /**
         * Internal
         */
        public destructor() {
            if(!((this.m_proxyId === org.jbox2d.collision.PairManager.NULL_PROXY_$LI$()))) throw new Error("Assertion error line 312: assert (m_proxyId == PairManager.NULL_PROXY);");;
        }

        /**
         * Internal
         * @param {org.jbox2d.collision.BroadPhase} broadPhase
         * @param {org.jbox2d.common.XForm} transform
         */
        public createProxy(broadPhase : org.jbox2d.collision.BroadPhase, transform : org.jbox2d.common.XForm) {
            if(!((this.m_proxyId === org.jbox2d.collision.PairManager.NULL_PROXY_$LI$()))) throw new Error("Assertion error line 321: assert (m_proxyId == PairManager.NULL_PROXY);");;
            let aabb : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();
            this.computeAABB(aabb, transform);
            let inRange : boolean = broadPhase.inRange(aabb);
            if(!((inRange))) throw new Error("Assertion error line 325: assert (inRange);");;
            if(inRange) {
                this.m_proxyId = broadPhase.createProxy(aabb, this);
            } else {
                this.m_proxyId = org.jbox2d.collision.PairManager.NULL_PROXY_$LI$();
            }
        }

        /**
         * Internal
         * @param {org.jbox2d.collision.BroadPhase} broadPhase
         */
        public destroyProxy(broadPhase : org.jbox2d.collision.BroadPhase) {
            if(this.m_proxyId !== org.jbox2d.collision.PairManager.NULL_PROXY_$LI$()) {
                broadPhase.destroyProxy(this.m_proxyId);
                this.m_proxyId = org.jbox2d.collision.PairManager.NULL_PROXY_$LI$();
            }
        }

        public computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(normal : org.jbox2d.common.Vec2, offset : number, c : org.jbox2d.common.Vec2) : number {
            return this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, this.m_body.getXForm(), c);
        }

        public computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal : org.jbox2d.common.Vec2, offset : number, form : org.jbox2d.common.XForm, c : org.jbox2d.common.Vec2) : number {
            return 0;
        }

        /**
         * @param {org.jbox2d.common.Vec2} normal
         * @param {number} offset
         * @param {org.jbox2d.common.XForm} form
         * @param {org.jbox2d.common.Vec2} c
         * @return
         * @return {number}
         */
        public computeSubmergedArea(normal? : any, offset? : any, form? : any, c? : any) : any {
            if(((normal != null && normal instanceof <any>org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((form != null && form instanceof <any>org.jbox2d.common.XForm) || form === null) && ((c != null && c instanceof <any>org.jbox2d.common.Vec2) || c === null)) {
                return <any>this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, form, c);
            } else if(((normal != null && normal instanceof <any>org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((form != null && form instanceof <any>org.jbox2d.common.Vec2) || form === null) && c === undefined) {
                return <any>this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(normal, offset, form);
            } else throw new Error('invalid overload');
        }

        /**
         * @return {number} shape density
         */
        public getDensity() : number {
            return this.m_density;
        }

        /**
         * @return {org.jbox2d.collision.shapes.Shape[]} a Set<Shape> of all shapes in contact with this one
         */
        public getShapesInContact() : Array<Shape> {
            let curr : org.jbox2d.dynamics.contacts.ContactEdge = this.m_body.getContactList();
            let touching : Array<Shape> = <any>([]);
            while((curr != null)) {{
                if(curr.contact.m_shape1 === this) {
                    /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(touching, curr.contact.m_shape2);
                } else if(curr.contact.m_shape2 === this) {
                    /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(touching, curr.contact.m_shape1);
                }
                curr = curr.next;
            }};
            return touching;
        }

        /**
         * @return {org.jbox2d.dynamics.contacts.Contact[]} a Set<Contact> of all (active) contacts involving this shape
         */
        public getContacts() : Array<org.jbox2d.dynamics.contacts.Contact> {
            let curr : org.jbox2d.dynamics.contacts.ContactEdge = this.m_body.getContactList();
            let contacts : Array<org.jbox2d.dynamics.contacts.Contact> = <any>([]);
            while((curr != null)) {{
                if(curr.contact.getManifoldCount() > 0) {
                    if(curr.contact.m_shape1 === this) {
                        /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(contacts, curr.contact);
                    } else if(curr.contact.m_shape2 === this) {
                        /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(contacts, curr.contact);
                    }
                }
                curr = curr.next;
            }};
            return contacts;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            return "shape:" + (this.m_type == null?"unknown":/* Enum.name */org.jbox2d.collision.shapes.ShapeType[this.m_type]) + "_uid=" + this.uid;
        }
    }
    Shape["__class"] = "org.jbox2d.collision.shapes.Shape";

}
namespace org.jbox2d.common {
    export class OBBViewportTransform implements org.jbox2d.common.IViewportTransform {
        box : org.jbox2d.collision.OBB = new org.jbox2d.collision.OBB();

        /*private*/ yFlip : boolean = false;

        /*private*/ yFlipMat : org.jbox2d.common.Mat22 = new org.jbox2d.common.Mat22(1, 0, 0, -1);

        /*private*/ yFlipMatInv : org.jbox2d.common.Mat22 = this.yFlipMat.invert();

        public constructor() {
            this.box.R.setIdentity();
        }

        public set(vpt : OBBViewportTransform) {
            this.box.center.set$org_jbox2d_common_Vec2(vpt.box.center);
            this.box.extents.set$org_jbox2d_common_Vec2(vpt.box.extents);
            this.box.R.set$org_jbox2d_common_Mat22(vpt.box.R);
            this.yFlip = vpt.yFlip;
        }

        /**
         * @see IViewportTransform#setCamera(float, float, float)
         * @param {number} x
         * @param {number} y
         * @param {number} scale
         */
        public setCamera(x : number, y : number, scale : number) {
            this.box.center.set$float$float(x, y);
            org.jbox2d.common.Mat22.createScaleTransform$float$org_jbox2d_common_Mat22(scale, this.box.R);
        }

        /**
         * @see IViewportTransform#getExtents()
         * @return {org.jbox2d.common.Vec2}
         */
        public getExtents() : org.jbox2d.common.Vec2 {
            return this.box.extents;
        }

        public setExtents$org_jbox2d_common_Vec2(argExtents : org.jbox2d.common.Vec2) {
            this.box.extents.set$org_jbox2d_common_Vec2(argExtents);
        }

        public setExtents$float$float(argHalfWidth : number, argHalfHeight : number) {
            this.box.extents.set$float$float(argHalfWidth, argHalfHeight);
        }

        /**
         * @see IViewportTransform#setExtents(float, float)
         * @param {number} argHalfWidth
         * @param {number} argHalfHeight
         */
        public setExtents(argHalfWidth? : any, argHalfHeight? : any) : any {
            if(((typeof argHalfWidth === 'number') || argHalfWidth === null) && ((typeof argHalfHeight === 'number') || argHalfHeight === null)) {
                return <any>this.setExtents$float$float(argHalfWidth, argHalfHeight);
            } else if(((argHalfWidth != null && argHalfWidth instanceof <any>org.jbox2d.common.Vec2) || argHalfWidth === null) && argHalfHeight === undefined) {
                return <any>this.setExtents$org_jbox2d_common_Vec2(argHalfWidth);
            } else throw new Error('invalid overload');
        }

        /**
         * @see IViewportTransform#getCenter()
         * @return {org.jbox2d.common.Vec2}
         */
        public getCenter() : org.jbox2d.common.Vec2 {
            return this.box.center;
        }

        public setCenter$org_jbox2d_common_Vec2(argPos : org.jbox2d.common.Vec2) {
            this.box.center.set$org_jbox2d_common_Vec2(argPos);
        }

        public setCenter$float$float(x : number, y : number) {
            this.box.center.set$float$float(x, y);
        }

        /**
         * @see IViewportTransform#setCenter(float, float)
         * @param {number} x
         * @param {number} y
         */
        public setCenter(x? : any, y? : any) : any {
            if(((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return <any>this.setCenter$float$float(x, y);
            } else if(((x != null && x instanceof <any>org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                return <any>this.setCenter$org_jbox2d_common_Vec2(x);
            } else throw new Error('invalid overload');
        }

        /**
         * gets the transform of the viewport, transforms around the center.
         * Not a copy.
         * @return
         * @return {org.jbox2d.common.Mat22}
         */
        public getTransform() : org.jbox2d.common.Mat22 {
            return this.box.R;
        }

        /**
         * Sets the transform of the viewport.  Transforms about the center.
         * @param {org.jbox2d.common.Mat22} transform
         */
        public setTransform(transform : org.jbox2d.common.Mat22) {
            this.box.R.set$org_jbox2d_common_Mat22(transform);
        }

        /**
         * Lerps to the given transform
         * @param {org.jbox2d.common.Mat22} transform
         * @param {number} amt
         */
        public lerpTransform(transform : org.jbox2d.common.Mat22, amt : number) {
            this.box.R.col1.x += (<any>Math).fround(((<any>Math).fround(transform.col1.x - this.box.R.col1.x)) * amt);
            this.box.R.col1.y += (<any>Math).fround(((<any>Math).fround(transform.col1.y - this.box.R.col1.y)) * amt);
            this.box.R.col2.x += (<any>Math).fround(((<any>Math).fround(transform.col2.x - this.box.R.col2.x)) * amt);
            this.box.R.col2.y += (<any>Math).fround(((<any>Math).fround(transform.col2.y - this.box.R.col2.y)) * amt);
        }

        /**
         * Multiplies the obb transform by the given transform
         * @param {org.jbox2d.common.Mat22} argTransform
         */
        public mulByTransform(argTransform : org.jbox2d.common.Mat22) {
            this.box.R.mulLocal(argTransform);
        }

        /**
         * @see IViewportTransform#isYFlip()
         * @return {boolean}
         */
        public isYFlip() : boolean {
            return this.yFlip;
        }

        /**
         * @see IViewportTransform#setYFlip(boolean)
         * @param {boolean} yFlip
         */
        public setYFlip(yFlip : boolean) {
            this.yFlip = yFlip;
        }

        static tlInv : org.jbox2d.pooling.TLMat22; public static tlInv_$LI$() : org.jbox2d.pooling.TLMat22 { if(OBBViewportTransform.tlInv == null) OBBViewportTransform.tlInv = (() => { let __o : any = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return OBBViewportTransform.tlInv; };

        /**
         * @see IViewportTransform#vectorInverseTransform(Vec2, Vec2)
         * @param {org.jbox2d.common.Vec2} argScreen
         * @param {org.jbox2d.common.Vec2} argWorld
         */
        public vectorInverseTransform(argScreen : org.jbox2d.common.Vec2, argWorld : org.jbox2d.common.Vec2) {
            let inv : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(OBBViewportTransform.tlInv_$LI$());
            inv.set$org_jbox2d_common_Mat22(this.box.R);
            inv.invertLocal();
            inv.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen, argWorld);
            if(this.yFlip) {
                this.yFlipMatInv.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld, argWorld);
            }
        }

        /**
         * @see IViewportTransform#vectorTransform(Vec2, Vec2)
         * @param {org.jbox2d.common.Vec2} argWorld
         * @param {org.jbox2d.common.Vec2} argScreen
         */
        public vectorTransform(argWorld : org.jbox2d.common.Vec2, argScreen : org.jbox2d.common.Vec2) {
            this.box.R.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld, argScreen);
            if(this.yFlip) {
                this.yFlipMat.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen, argScreen);
            }
        }

        /**
         * @see IViewportTransform#getWorldToScreen(Vec2, Vec2)
         * @param {org.jbox2d.common.Vec2} argWorld
         * @param {org.jbox2d.common.Vec2} argScreen
         */
        public getWorldToScreen(argWorld : org.jbox2d.common.Vec2, argScreen : org.jbox2d.common.Vec2) {
            argScreen.set$org_jbox2d_common_Vec2(argWorld);
            argScreen.subLocal(this.box.center);
            this.box.R.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen, argScreen);
            if(this.yFlip) {
                this.yFlipMat.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen, argScreen);
            }
            argScreen.addLocal$org_jbox2d_common_Vec2(this.box.extents);
        }

        /**
         * @see IViewportTransform#getScreenToWorld(Vec2, Vec2)
         * @param {org.jbox2d.common.Vec2} argScreen
         * @param {org.jbox2d.common.Vec2} argWorld
         */
        public getScreenToWorld(argScreen : org.jbox2d.common.Vec2, argWorld : org.jbox2d.common.Vec2) {
            argWorld.set$org_jbox2d_common_Vec2(argScreen);
            argWorld.subLocal(this.box.extents);
            let inv : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(OBBViewportTransform.tlInv_$LI$());
            this.box.R.invertToOut(inv);
            inv.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld, argWorld);
            if(this.yFlip) {
                this.yFlipMatInv.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld, argWorld);
            }
            argWorld.addLocal$org_jbox2d_common_Vec2(this.box.center);
        }
    }
    OBBViewportTransform["__class"] = "org.jbox2d.common.OBBViewportTransform";
    OBBViewportTransform["__interfaces"] = ["org.jbox2d.common.IViewportTransform"];


}
namespace org.jbox2d.collision {
    export class Segment {
        public toString() : string {
            return "p1: " + this.p1 + "; p2: " + this.p2;
        }

        /**
         * The starting point
         */
        public p1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * The ending point
         */
        public p2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        static tlR : org.jbox2d.pooling.TLVec2; public static tlR_$LI$() : org.jbox2d.pooling.TLVec2 { if(Segment.tlR == null) Segment.tlR = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return Segment.tlR; };

        static tlD : org.jbox2d.pooling.TLVec2; public static tlD_$LI$() : org.jbox2d.pooling.TLVec2 { if(Segment.tlD == null) Segment.tlD = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return Segment.tlD; };

        static tlN : org.jbox2d.pooling.TLVec2; public static tlN_$LI$() : org.jbox2d.pooling.TLVec2 { if(Segment.tlN == null) Segment.tlN = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return Segment.tlN; };

        static tlB : org.jbox2d.pooling.TLVec2; public static tlB_$LI$() : org.jbox2d.pooling.TLVec2 { if(Segment.tlB == null) Segment.tlB = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return Segment.tlB; };

        public testSegment(out : org.jbox2d.common.RaycastResult, segment : Segment, maxLambda : number) : boolean {
            let s : org.jbox2d.common.Vec2 = segment.p1;
            let r : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(Segment.tlR_$LI$()).set$org_jbox2d_common_Vec2(segment.p2);
            r.subLocal(s);
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(Segment.tlD_$LI$()).set$org_jbox2d_common_Vec2(this.p2);
            d.subLocal(this.p1);
            let n : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(Segment.tlN_$LI$());
            org.jbox2d.common.Vec2.crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(d, 1.0, n);
            let b : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(Segment.tlB_$LI$());
            let k_slop : number = (<any>Math).fround(100.0 * org.jbox2d.common.Settings.EPSILON);
            let denom : number = -org.jbox2d.common.Vec2.dot(r, n);
            if(denom > k_slop) {
                b.set$org_jbox2d_common_Vec2(s);
                b.subLocal(this.p1);
                let a : number = org.jbox2d.common.Vec2.dot(b, n);
                if(0.0 <= a && a <= (<any>Math).fround(maxLambda * denom)) {
                    let mu2 : number = (<any>Math).fround((<any>Math).fround(-r.x * b.y) + (<any>Math).fround(r.y * b.x));
                    if((<any>Math).fround(-k_slop * denom) <= mu2 && mu2 <= (<any>Math).fround(denom * ((<any>Math).fround(1.0 + k_slop)))) {
                        a /= denom;
                        n.normalize();
                        out.lambda = a;
                        out.normal.set$org_jbox2d_common_Vec2(n);
                        return true;
                    }
                }
            }
            return false;
        }
    }
    Segment["__class"] = "org.jbox2d.collision.Segment";

}
namespace org.jbox2d.dynamics {
    /**
     * Delegate of World - for internal use.
     * @class
     */
    export class ContactManager implements org.jbox2d.collision.PairCallback {
        m_world : org.jbox2d.dynamics.World;

        m_nullContact : org.jbox2d.dynamics.contacts.NullContact;

        m_destroyImmediate : boolean;

        public constructor() {
            if(this.m_world===undefined) this.m_world = null;
            if(this.m_nullContact===undefined) this.m_nullContact = null;
            if(this.m_destroyImmediate===undefined) this.m_destroyImmediate = false;
            this.m_nullContact = new org.jbox2d.dynamics.contacts.NullContact();
            this.m_destroyImmediate = false;
        }

        public pairAdded(proxyUserData1 : any, proxyUserData2 : any) : any {
            let shape1 : org.jbox2d.collision.shapes.Shape = <org.jbox2d.collision.shapes.Shape>proxyUserData1;
            let shape2 : org.jbox2d.collision.shapes.Shape = <org.jbox2d.collision.shapes.Shape>proxyUserData2;
            if(shape1 == null || shape2 == null) {
                return this.m_nullContact;
            }
            let body1 : org.jbox2d.dynamics.Body = shape1.getBody();
            let body2 : org.jbox2d.dynamics.Body = shape2.getBody();
            if(body1.isStatic() && body2.isStatic()) {
                return this.m_nullContact;
            }
            if(shape1.getBody() === shape2.getBody()) {
                return this.m_nullContact;
            }
            if(body2.isConnected(body1)) {
                return this.m_nullContact;
            }
            if(this.m_world.m_contactFilter != null && this.m_world.m_contactFilter.shouldCollide(shape1, shape2) === false) {
                return this.m_nullContact;
            }
            let c : org.jbox2d.dynamics.contacts.Contact = org.jbox2d.dynamics.contacts.Contact.createContact(shape1, shape2);
            if(c == null) {
                return this.m_nullContact;
            }
            shape1 = c.getShape1();
            shape2 = c.getShape2();
            body1 = shape1.getBody();
            body2 = shape2.getBody();
            c.m_prev = null;
            c.m_next = this.m_world.m_contactList;
            if(this.m_world.m_contactList != null) {
                this.m_world.m_contactList.m_prev = c;
            }
            this.m_world.m_contactList = c;
            c.m_node1.contact = c;
            c.m_node1.other = body2;
            c.m_node1.prev = null;
            c.m_node1.next = body1.m_contactList;
            if(body1.m_contactList != null) {
                body1.m_contactList.prev = c.m_node1;
            }
            body1.m_contactList = c.m_node1;
            c.m_node2.contact = c;
            c.m_node2.other = body1;
            c.m_node2.prev = null;
            c.m_node2.next = body2.m_contactList;
            if(body2.m_contactList != null) {
                body2.m_contactList.prev = c.m_node2;
            }
            body2.m_contactList = c.m_node2;
            ++this.m_world.m_contactCount;
            return c;
        }

        public pairRemoved(proxyUserData1 : any, proxyUserData2 : any, pairUserData : any) {
            if(pairUserData == null) {
                return;
            }
            let c : org.jbox2d.dynamics.contacts.Contact = <org.jbox2d.dynamics.contacts.Contact>pairUserData;
            if(c === this.m_nullContact) {
                return;
            }
            this.destroy(c);
        }

        static tlV1 : org.jbox2d.pooling.TLVec2; public static tlV1_$LI$() : org.jbox2d.pooling.TLVec2 { if(ContactManager.tlV1 == null) ContactManager.tlV1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return ContactManager.tlV1; };

        static tlCp : org.jbox2d.pooling.TLContactPoint; public static tlCp_$LI$() : org.jbox2d.pooling.TLContactPoint { if(ContactManager.tlCp == null) ContactManager.tlCp = (() => { let __o : any = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return ContactManager.tlCp; };

        public destroy(c : org.jbox2d.dynamics.contacts.Contact) {
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(ContactManager.tlV1_$LI$());
            let cp : org.jbox2d.dynamics.contacts.ContactPoint = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(ContactManager.tlCp_$LI$());
            let shape1 : org.jbox2d.collision.shapes.Shape = c.getShape1();
            let shape2 : org.jbox2d.collision.shapes.Shape = c.getShape2();
            let manifoldCount : number = c.getManifoldCount();
            if(manifoldCount > 0 && (this.m_world.m_contactListener != null)) {
                let b1 : org.jbox2d.dynamics.Body = shape1.getBody();
                let b2 : org.jbox2d.dynamics.Body = shape2.getBody();
                let manifolds : Array<org.jbox2d.collision.Manifold> = c.getManifolds();
                cp.shape1 = c.getShape1();
                cp.shape2 = c.getShape2();
                cp.friction = c.m_friction;
                cp.restitution = c.m_restitution;
                for(let i : number = 0; i < manifoldCount; ++i) {{
                    let manifold : org.jbox2d.collision.Manifold = /* get */manifolds[i];
                    cp.normal.set$org_jbox2d_common_Vec2(manifold.normal);
                    for(let j : number = 0; j < manifold.pointCount; ++j) {{
                        let mp : org.jbox2d.collision.ManifoldPoint = manifold.points[j];
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.separation = mp.separation;
                        cp.id.set(mp.id);
                        this.m_world.m_contactListener.remove(cp);
                    };}
                };}
            }
            if(c.m_prev != null) {
                c.m_prev.m_next = c.m_next;
            }
            if(c.m_next != null) {
                c.m_next.m_prev = c.m_prev;
            }
            if(c === this.m_world.m_contactList) {
                this.m_world.m_contactList = c.m_next;
            }
            let body1 : org.jbox2d.dynamics.Body = shape1.getBody();
            let body2 : org.jbox2d.dynamics.Body = shape2.getBody();
            if(c.m_node1.prev != null) {
                c.m_node1.prev.next = c.m_node1.next;
            }
            if(c.m_node1.next != null) {
                c.m_node1.next.prev = c.m_node1.prev;
            }
            if(c.m_node1 === body1.m_contactList) {
                body1.m_contactList = c.m_node1.next;
            }
            if(c.m_node2.prev != null) {
                c.m_node2.prev.next = c.m_node2.next;
            }
            if(c.m_node2.next != null) {
                c.m_node2.next.prev = c.m_node2.prev;
            }
            if(c.m_node2 === body2.m_contactList) {
                body2.m_contactList = c.m_node2.next;
            }
            org.jbox2d.dynamics.contacts.Contact.destroy(c);
            --this.m_world.m_contactCount;
        }

        public collide() {
            for(let c : org.jbox2d.dynamics.contacts.Contact = this.m_world.m_contactList; c != null; c = c.getNext()) {{
                let body1 : org.jbox2d.dynamics.Body = c.getShape1().getBody();
                let body2 : org.jbox2d.dynamics.Body = c.getShape2().getBody();
                if(body1.isSleeping() && body2.isSleeping()) {
                    continue;
                }
                c.update(this.m_world.m_contactListener);
            };}
        }
    }
    ContactManager["__class"] = "org.jbox2d.dynamics.ContactManager";
    ContactManager["__interfaces"] = ["org.jbox2d.collision.PairCallback"];


}
namespace org.jbox2d.dynamics.contacts {
    export class CircleContact extends org.jbox2d.dynamics.contacts.Contact implements org.jbox2d.dynamics.contacts.ContactCreateFcn {
        public m_manifold : org.jbox2d.collision.Manifold;

        public manifoldList : Array<org.jbox2d.collision.Manifold>;

        public create(shape1 : org.jbox2d.collision.shapes.Shape, shape2 : org.jbox2d.collision.shapes.Shape) : org.jbox2d.dynamics.contacts.Contact {
            return new CircleContact(shape1, shape2);
        }

        public static Destroy(contact : org.jbox2d.dynamics.contacts.Contact) {
            (<CircleContact>contact).destructor();
        }

        /**
         * 
         * @return {org.jbox2d.dynamics.contacts.CircleContact}
         */
        public clone() : CircleContact {
            return this;
        }

        public constructor(shape1? : any, shape2? : any) {
            if(((shape1 != null && shape1 instanceof <any>org.jbox2d.collision.shapes.Shape) || shape1 === null) && ((shape2 != null && shape2 instanceof <any>org.jbox2d.collision.shapes.Shape) || shape2 === null)) {
                let __args = arguments;
                super(shape1, shape2);
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                    if(!((this.m_shape1.getType() === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE))) throw new Error("Assertion error line 33: assert (m_shape1.getType() == ShapeType.CIRCLE_SHAPE);");;
                    if(!((this.m_shape2.getType() === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE))) throw new Error("Assertion error line 34: assert (m_shape2.getType() == ShapeType.CIRCLE_SHAPE);");;
                    this.m_manifold.pointCount = 0;
                    this.m_manifold.points[0].normalImpulse = 0.0;
                    this.m_manifold.points[0].tangentImpulse = 0.0;
                    this.m_manifold.points[0].localPoint1.setZero();
                    this.m_manifold.points[0].localPoint2.setZero();
                })();
            } else if(shape1 === undefined && shape2 === undefined) {
                let __args = arguments;
                super();
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    this.m_manifoldCount = 0;
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                })();
            } else throw new Error('invalid overload');
        }

        public destructor() {
        }

        static tlm0 : org.jbox2d.pooling.TLManifold; public static tlm0_$LI$() : org.jbox2d.pooling.TLManifold { if(CircleContact.tlm0 == null) CircleContact.tlm0 = (() => { let __o : any = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return CircleContact.tlm0; };

        static tlV1 : org.jbox2d.pooling.TLVec2; public static tlV1_$LI$() : org.jbox2d.pooling.TLVec2 { if(CircleContact.tlV1 == null) CircleContact.tlV1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleContact.tlV1; };

        static tlCp : org.jbox2d.pooling.TLContactPoint; public static tlCp_$LI$() : org.jbox2d.pooling.TLContactPoint { if(CircleContact.tlCp == null) CircleContact.tlCp = (() => { let __o : any = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return CircleContact.tlCp; };

        /**
         * 
         * @param {*} listener
         */
        public evaluate(listener : org.jbox2d.dynamics.ContactListener) {
            let b1 : org.jbox2d.dynamics.Body = this.m_shape1.getBody();
            let b2 : org.jbox2d.dynamics.Body = this.m_shape2.getBody();
            let m0 : org.jbox2d.collision.Manifold = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(CircleContact.tlm0_$LI$());
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(CircleContact.tlV1_$LI$());
            let cp : org.jbox2d.dynamics.contacts.ContactPoint = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(CircleContact.tlCp_$LI$());
            m0.set(this.m_manifold);
            org.jbox2d.pooling.SingletonPool.getCollideCircle().collideCircles(this.m_manifold, <org.jbox2d.collision.shapes.CircleShape>this.m_shape1, b1.m_xf, <org.jbox2d.collision.shapes.CircleShape>this.m_shape2, b2.m_xf);
            cp.shape1 = this.m_shape1;
            cp.shape2 = this.m_shape2;
            cp.friction = this.m_friction;
            cp.restitution = this.m_restitution;
            if(this.m_manifold.pointCount > 0) {
                this.m_manifoldCount = 1;
                let mp : org.jbox2d.collision.ManifoldPoint = this.m_manifold.points[0];
                if(m0.pointCount === 0) {
                    mp.normalImpulse = 0.0;
                    mp.tangentImpulse = 0.0;
                    if(listener != null) {
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                        cp.separation = mp.separation;
                        cp.id.set(mp.id);
                        listener.add(cp);
                    }
                } else {
                    let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[0];
                    mp.normalImpulse = mp0.normalImpulse;
                    mp.tangentImpulse = mp0.tangentImpulse;
                    if(listener != null) {
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                        cp.separation = mp.separation;
                        cp.id.set(mp.id);
                        listener.persist(cp);
                    }
                }
            } else {
                this.m_manifoldCount = 0;
                if(m0.pointCount > 0 && (listener != null)) {
                    let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[0];
                    b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                    b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                    b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                    cp.velocity.subLocal(v1);
                    cp.normal.set$org_jbox2d_common_Vec2(m0.normal);
                    cp.separation = mp0.separation;
                    cp.id.set(mp0.id);
                    listener.remove(cp);
                }
            }
        }

        /**
         * 
         * @return {org.jbox2d.collision.Manifold[]}
         */
        public getManifolds() : Array<org.jbox2d.collision.Manifold> {
            return this.manifoldList;
        }
    }
    CircleContact["__class"] = "org.jbox2d.dynamics.contacts.CircleContact";
    CircleContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];


}
namespace org.jbox2d.dynamics.contacts {
    export class EdgeAndCircleContact extends org.jbox2d.dynamics.contacts.Contact implements org.jbox2d.dynamics.contacts.ContactCreateFcn {
        public m_manifold : org.jbox2d.collision.Manifold;

        public manifoldList : Array<org.jbox2d.collision.Manifold>;

        public constructor(s1? : any, s2? : any) {
            if(((s1 != null && s1 instanceof <any>org.jbox2d.collision.shapes.Shape) || s1 === null) && ((s2 != null && s2 instanceof <any>org.jbox2d.collision.shapes.Shape) || s2 === null)) {
                let __args = arguments;
                super(s1, s2);
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    if(!((this.m_shape1.getType() === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE))) throw new Error("Assertion error line 15: assert (m_shape1.getType() == ShapeType.EDGE_SHAPE);");;
                    if(!((this.m_shape2.getType() === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE))) throw new Error("Assertion error line 16: assert (m_shape2.getType() == ShapeType.CIRCLE_SHAPE);");;
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                    this.m_manifoldCount = 0;
                })();
            } else if(s1 === undefined && s2 === undefined) {
                let __args = arguments;
                super();
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                    this.m_manifoldCount = 0;
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {org.jbox2d.dynamics.contacts.Contact}
         */
        public clone() : org.jbox2d.dynamics.contacts.Contact {
            if(!(false)) throw new Error("Assertion error line 40: assert false : 'Not yet implemented.';");;
            return this;
        }

        public static Destroy(contact : org.jbox2d.dynamics.contacts.Contact) {
            (<EdgeAndCircleContact>contact).destructor();
        }

        public destructor() {
        }

        static tlm0 : org.jbox2d.pooling.TLManifold; public static tlm0_$LI$() : org.jbox2d.pooling.TLManifold { if(EdgeAndCircleContact.tlm0 == null) EdgeAndCircleContact.tlm0 = (() => { let __o : any = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return EdgeAndCircleContact.tlm0; };

        static tlV1 : org.jbox2d.pooling.TLVec2; public static tlV1_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeAndCircleContact.tlV1 == null) EdgeAndCircleContact.tlV1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeAndCircleContact.tlV1; };

        static tlCp : org.jbox2d.pooling.TLContactPoint; public static tlCp_$LI$() : org.jbox2d.pooling.TLContactPoint { if(EdgeAndCircleContact.tlCp == null) EdgeAndCircleContact.tlCp = (() => { let __o : any = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return EdgeAndCircleContact.tlCp; };

        /**
         * 
         * @param {*} listener
         */
        public evaluate(listener : org.jbox2d.dynamics.ContactListener) {
            let b1 : org.jbox2d.dynamics.Body = this.m_shape1.getBody();
            let b2 : org.jbox2d.dynamics.Body = this.m_shape2.getBody();
            let m0 : org.jbox2d.collision.Manifold = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeAndCircleContact.tlm0_$LI$());
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeAndCircleContact.tlV1_$LI$());
            let cp : org.jbox2d.dynamics.contacts.ContactPoint = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeAndCircleContact.tlCp_$LI$());
            m0.set(this.m_manifold);
            org.jbox2d.pooling.SingletonPool.getCollideCircle().collideEdgeAndCircle(this.m_manifold, <org.jbox2d.collision.shapes.EdgeShape>this.m_shape1, b1.getMemberXForm(), <org.jbox2d.collision.shapes.CircleShape>this.m_shape2, b2.getMemberXForm());
            cp.shape1 = this.m_shape1;
            cp.shape2 = this.m_shape2;
            cp.friction = this.m_friction;
            cp.restitution = this.m_restitution;
            if(this.m_manifold.pointCount > 0) {
                this.m_manifoldCount = 1;
                let mp : org.jbox2d.collision.ManifoldPoint = this.m_manifold.points[0];
                if(m0.pointCount === 0) {
                    mp.normalImpulse = 0.0;
                    mp.tangentImpulse = 0.0;
                    if(listener != null) {
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                        cp.separation = mp.separation;
                        cp.id.set(mp.id);
                        listener.add(cp);
                    }
                } else {
                    let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[0];
                    mp.normalImpulse = mp0.normalImpulse;
                    mp.tangentImpulse = mp0.tangentImpulse;
                    if(listener != null) {
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                        cp.separation = mp.separation;
                        cp.id.set(mp.id);
                        listener.persist(cp);
                    }
                }
            } else {
                this.m_manifoldCount = 0;
                if(m0.pointCount > 0 && (listener != null)) {
                    let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[0];
                    b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                    b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                    b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                    cp.velocity.subLocal(v1);
                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                    cp.separation = mp0.separation;
                    cp.id.set(mp0.id);
                    listener.remove(cp);
                }
            }
        }

        /**
         * 
         * @return {org.jbox2d.collision.Manifold[]}
         */
        public getManifolds() : Array<org.jbox2d.collision.Manifold> {
            return this.manifoldList;
        }

        public create(s1 : org.jbox2d.collision.shapes.Shape, s2 : org.jbox2d.collision.shapes.Shape) : org.jbox2d.dynamics.contacts.Contact {
            return new EdgeAndCircleContact(s1, s2);
        }
    }
    EdgeAndCircleContact["__class"] = "org.jbox2d.dynamics.contacts.EdgeAndCircleContact";
    EdgeAndCircleContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];


}
namespace org.jbox2d.dynamics.contacts {
    export class PointAndCircleContact extends org.jbox2d.dynamics.contacts.Contact implements org.jbox2d.dynamics.contacts.ContactCreateFcn {
        public m_manifold : org.jbox2d.collision.Manifold;

        public manifoldList : Array<org.jbox2d.collision.Manifold>;

        public create(shape1 : org.jbox2d.collision.shapes.Shape, shape2 : org.jbox2d.collision.shapes.Shape) : org.jbox2d.dynamics.contacts.Contact {
            return new PointAndCircleContact(shape1, shape2);
        }

        public static Destroy(contact : org.jbox2d.dynamics.contacts.Contact) {
            (<PointAndCircleContact>contact).destructor();
        }

        /**
         * 
         * @return {org.jbox2d.dynamics.contacts.PointAndCircleContact}
         */
        public clone() : PointAndCircleContact {
            return this;
        }

        public constructor(shape1? : any, shape2? : any) {
            if(((shape1 != null && shape1 instanceof <any>org.jbox2d.collision.shapes.Shape) || shape1 === null) && ((shape2 != null && shape2 instanceof <any>org.jbox2d.collision.shapes.Shape) || shape2 === null)) {
                let __args = arguments;
                super(shape1, shape2);
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    if(!((this.m_shape1.getType() === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE))) throw new Error("Assertion error line 32: assert (m_shape1.getType() == ShapeType.POINT_SHAPE);");;
                    if(!((this.m_shape2.getType() === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE))) throw new Error("Assertion error line 33: assert (m_shape2.getType() == ShapeType.CIRCLE_SHAPE);");;
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                    this.m_manifold.pointCount = 0;
                    this.m_manifold.points[0].normalImpulse = 0.0;
                    this.m_manifold.points[0].tangentImpulse = 0.0;
                    this.m_manifold.points[0].localPoint1.setZero();
                    this.m_manifold.points[0].localPoint2.setZero();
                })();
            } else if(shape1 === undefined && shape2 === undefined) {
                let __args = arguments;
                super();
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                    this.m_manifoldCount = 0;
                })();
            } else throw new Error('invalid overload');
        }

        public destructor() {
        }

        static tlm0 : org.jbox2d.pooling.TLManifold; public static tlm0_$LI$() : org.jbox2d.pooling.TLManifold { if(PointAndCircleContact.tlm0 == null) PointAndCircleContact.tlm0 = (() => { let __o : any = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return PointAndCircleContact.tlm0; };

        static tlV1 : org.jbox2d.pooling.TLVec2; public static tlV1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PointAndCircleContact.tlV1 == null) PointAndCircleContact.tlV1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointAndCircleContact.tlV1; };

        static tlCp : org.jbox2d.pooling.TLContactPoint; public static tlCp_$LI$() : org.jbox2d.pooling.TLContactPoint { if(PointAndCircleContact.tlCp == null) PointAndCircleContact.tlCp = (() => { let __o : any = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return PointAndCircleContact.tlCp; };

        /**
         * 
         * @param {*} listener
         */
        public evaluate(listener : org.jbox2d.dynamics.ContactListener) {
            let b1 : org.jbox2d.dynamics.Body = this.m_shape1.getBody();
            let b2 : org.jbox2d.dynamics.Body = this.m_shape2.getBody();
            let m0 : org.jbox2d.collision.Manifold = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointAndCircleContact.tlm0_$LI$());
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointAndCircleContact.tlV1_$LI$());
            let cp : org.jbox2d.dynamics.contacts.ContactPoint = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointAndCircleContact.tlCp_$LI$());
            m0.set(this.m_manifold);
            org.jbox2d.pooling.SingletonPool.getCollideCircle().collidePointAndCircle(this.m_manifold, <org.jbox2d.collision.shapes.PointShape>this.m_shape1, b1.m_xf, <org.jbox2d.collision.shapes.CircleShape>this.m_shape2, b2.m_xf);
            cp.shape1 = this.m_shape1;
            cp.shape2 = this.m_shape2;
            cp.friction = this.m_friction;
            cp.restitution = this.m_restitution;
            if(this.m_manifold.pointCount > 0) {
                this.m_manifoldCount = 1;
                let mp : org.jbox2d.collision.ManifoldPoint = this.m_manifold.points[0];
                if(m0.pointCount === 0) {
                    mp.normalImpulse = 0.0;
                    mp.tangentImpulse = 0.0;
                    if(listener != null) {
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                        cp.separation = mp.separation;
                        cp.id.set(mp.id);
                        listener.add(cp);
                    }
                } else {
                    let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[0];
                    mp.normalImpulse = mp0.normalImpulse;
                    mp.tangentImpulse = mp0.tangentImpulse;
                    if(listener != null) {
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                        cp.separation = mp.separation;
                        cp.id.set(mp.id);
                        listener.persist(cp);
                    }
                }
            } else {
                this.m_manifoldCount = 0;
                if(m0.pointCount > 0 && (listener != null)) {
                    let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[0];
                    b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                    b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                    b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                    cp.velocity.subLocal(v1);
                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                    cp.separation = mp0.separation;
                    cp.id.set(mp0.id);
                    listener.remove(cp);
                }
            }
        }

        /**
         * 
         * @return {org.jbox2d.collision.Manifold[]}
         */
        public getManifolds() : Array<org.jbox2d.collision.Manifold> {
            return this.manifoldList;
        }
    }
    PointAndCircleContact["__class"] = "org.jbox2d.dynamics.contacts.PointAndCircleContact";
    PointAndCircleContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];


}
namespace org.jbox2d.dynamics.contacts {
    export class PolyContact extends org.jbox2d.dynamics.contacts.Contact implements org.jbox2d.dynamics.contacts.ContactCreateFcn {
        public m_manifold : org.jbox2d.collision.Manifold;

        public manifoldList : Array<org.jbox2d.collision.Manifold>;

        public constructor(s1? : any, s2? : any) {
            if(((s1 != null && s1 instanceof <any>org.jbox2d.collision.shapes.Shape) || s1 === null) && ((s2 != null && s2 instanceof <any>org.jbox2d.collision.shapes.Shape) || s2 === null)) {
                let __args = arguments;
                super(s1, s2);
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    if(!((this.m_shape1.getType() === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE))) throw new Error("Assertion error line 15: assert (m_shape1.getType() == ShapeType.POLYGON_SHAPE);");;
                    if(!((this.m_shape2.getType() === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE))) throw new Error("Assertion error line 16: assert (m_shape2.getType() == ShapeType.POLYGON_SHAPE);");;
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    this.m_manifoldCount = 0;
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                })();
            } else if(s1 === undefined && s2 === undefined) {
                let __args = arguments;
                super();
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    this.m_manifoldCount = 0;
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {org.jbox2d.dynamics.contacts.Contact}
         */
        public clone() : org.jbox2d.dynamics.contacts.Contact {
            let newC : PolyContact = new PolyContact(this.m_shape1, this.m_shape2);
            if(this.m_manifold != null) {
                newC.m_manifold.set(this.m_manifold);
            }
            newC.m_manifoldCount = this.m_manifoldCount;
            newC.m_world = this.m_world;
            newC.m_toi = this.m_toi;
            newC.m_prev = this.m_prev;
            newC.m_next = this.m_next;
            newC.m_node1.set(this.m_node1);
            newC.m_node2.set(this.m_node2);
            newC.m_friction = this.m_friction;
            newC.m_restitution = this.m_restitution;
            newC.m_flags = this.m_flags;
            return newC;
        }

        /**
         * 
         * @return {org.jbox2d.collision.Manifold[]}
         */
        public getManifolds() : Array<org.jbox2d.collision.Manifold> {
            return this.manifoldList;
        }

        public create(shape1 : org.jbox2d.collision.shapes.Shape, shape2 : org.jbox2d.collision.shapes.Shape) : org.jbox2d.dynamics.contacts.Contact {
            return new PolyContact(shape1, shape2);
        }

        public dumpManifoldPoints() {
            for(let i : number = 0; i < this.m_manifold.pointCount; ++i) {{
                let mp : org.jbox2d.collision.ManifoldPoint = this.m_manifold.points[i];
                console.info("Manifold point dump: " + mp.normalImpulse + " " + mp.tangentImpulse);
            };}
        }

        static tlm0 : org.jbox2d.pooling.TLManifold; public static tlm0_$LI$() : org.jbox2d.pooling.TLManifold { if(PolyContact.tlm0 == null) PolyContact.tlm0 = (() => { let __o : any = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return PolyContact.tlm0; };

        static tlV1 : org.jbox2d.pooling.TLVec2; public static tlV1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolyContact.tlV1 == null) PolyContact.tlV1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolyContact.tlV1; };

        static tlCp : org.jbox2d.pooling.TLContactPoint; public static tlCp_$LI$() : org.jbox2d.pooling.TLContactPoint { if(PolyContact.tlCp == null) PolyContact.tlCp = (() => { let __o : any = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return PolyContact.tlCp; };

        /**
         * 
         * @param {*} listener
         */
        public evaluate(listener : org.jbox2d.dynamics.ContactListener) {
            let b1 : org.jbox2d.dynamics.Body = this.m_shape1.getBody();
            let b2 : org.jbox2d.dynamics.Body = this.m_shape2.getBody();
            let m0 : org.jbox2d.collision.Manifold = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolyContact.tlm0_$LI$());
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolyContact.tlV1_$LI$());
            let cp : org.jbox2d.dynamics.contacts.ContactPoint = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolyContact.tlCp_$LI$());
            m0.set(this.m_manifold);
            org.jbox2d.pooling.SingletonPool.getCollidePoly().collidePolygons(this.m_manifold, <org.jbox2d.collision.shapes.PolygonShape>this.m_shape1, b1.getMemberXForm(), <org.jbox2d.collision.shapes.PolygonShape>this.m_shape2, b2.getMemberXForm());
            let persisted : boolean[] = [false, false];
            cp.shape1 = this.m_shape1;
            cp.shape2 = this.m_shape2;
            cp.friction = this.m_friction;
            cp.restitution = this.m_restitution;
            if(this.m_manifold.pointCount > 0) {
                for(let i : number = 0; i < this.m_manifold.pointCount; ++i) {{
                    let mp : org.jbox2d.collision.ManifoldPoint = this.m_manifold.points[i];
                    mp.normalImpulse = 0.0;
                    mp.tangentImpulse = 0.0;
                    let found : boolean = false;
                    let id : org.jbox2d.collision.ContactID = mp.id;
                    for(let j : number = 0; j < m0.pointCount; ++j) {{
                        if(persisted[j] === true) {
                            continue;
                        }
                        let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[j];
                        if(mp0.id.isEqual(id)) {
                            persisted[j] = true;
                            mp.normalImpulse = mp0.normalImpulse;
                            mp.tangentImpulse = mp0.tangentImpulse;
                            found = true;
                            if(listener != null) {
                                b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                cp.separation = mp.separation;
                                cp.id.set(id);
                                listener.persist(cp);
                            }
                            break;
                        }
                    };}
                    if(found === false && listener != null) {
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                        cp.separation = mp.separation;
                        cp.id.set(id);
                        listener.add(cp);
                    }
                };}
                this.m_manifoldCount = 1;
            } else {
                this.m_manifoldCount = 0;
            }
            if(listener == null) {
                return;
            }
            for(let i : number = 0; i < m0.pointCount; ++i) {{
                if(persisted[i]) {
                    continue;
                }
                let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[i];
                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                cp.velocity.subLocal(v1);
                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                cp.separation = mp0.separation;
                cp.id.set(mp0.id);
                listener.remove(cp);
            };}
        }
    }
    PolyContact["__class"] = "org.jbox2d.dynamics.contacts.PolyContact";
    PolyContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];


}
namespace org.jbox2d.dynamics.joints {
    export class DistanceJoint extends org.jbox2d.dynamics.joints.Joint {
        public m_localAnchor1 : org.jbox2d.common.Vec2;

        public m_localAnchor2 : org.jbox2d.common.Vec2;

        public m_u : org.jbox2d.common.Vec2;

        public m_impulse : number;

        public m_mass : number;

        public m_length : number;

        public m_frequencyHz : number;

        public m_dampingRatio : number;

        public m_gamma : number;

        public m_bias : number;

        public constructor(def : org.jbox2d.dynamics.joints.DistanceJointDef) {
            super(def);
            if(this.m_localAnchor1===undefined) this.m_localAnchor1 = null;
            if(this.m_localAnchor2===undefined) this.m_localAnchor2 = null;
            if(this.m_u===undefined) this.m_u = null;
            if(this.m_impulse===undefined) this.m_impulse = 0;
            if(this.m_mass===undefined) this.m_mass = 0;
            if(this.m_length===undefined) this.m_length = 0;
            if(this.m_frequencyHz===undefined) this.m_frequencyHz = 0;
            if(this.m_dampingRatio===undefined) this.m_dampingRatio = 0;
            if(this.m_gamma===undefined) this.m_gamma = 0;
            if(this.m_bias===undefined) this.m_bias = 0;
            this.m_localAnchor1 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAnchor1);
            this.m_localAnchor2 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAnchor2);
            this.m_length = def.length;
            this.m_impulse = 0.0;
            this.m_u = new org.jbox2d.common.Vec2();
            this.m_frequencyHz = def.frequencyHz;
            this.m_dampingRatio = def.dampingRatio;
            this.m_gamma = 0.0;
            this.m_bias = 0.0;
            this.m_inv_dt = 0.0;
        }

        public setFrequency(hz : number) {
            this.m_frequencyHz = hz;
        }

        public getFrequency() : number {
            return this.m_frequencyHz;
        }

        public setDampingRatio(damp : number) {
            this.m_dampingRatio = damp;
        }

        public getDampingRatio() : number {
            return this.m_dampingRatio;
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor1() : org.jbox2d.common.Vec2 {
            return this.m_body1.getWorldLocation(this.m_localAnchor1);
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor2() : org.jbox2d.common.Vec2 {
            return this.m_body2.getWorldLocation(this.m_localAnchor2);
        }

        static tlReactionForce : org.jbox2d.pooling.TLVec2; public static tlReactionForce_$LI$() : org.jbox2d.pooling.TLVec2 { if(DistanceJoint.tlReactionForce == null) DistanceJoint.tlReactionForce = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlReactionForce; };

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getReactionForce() : org.jbox2d.common.Vec2 {
            let reactionForce : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tlReactionForce_$LI$());
            reactionForce.x = (<any>Math).fround(this.m_impulse * this.m_u.x);
            reactionForce.y = (<any>Math).fround(this.m_impulse * this.m_u.y);
            return reactionForce;
        }

        /**
         * 
         * @return {number}
         */
        public getReactionTorque() : number {
            return 0.0;
        }

        static tlr1 : org.jbox2d.pooling.TLVec2; public static tlr1_$LI$() : org.jbox2d.pooling.TLVec2 { if(DistanceJoint.tlr1 == null) DistanceJoint.tlr1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlr1; };

        static tlr2 : org.jbox2d.pooling.TLVec2; public static tlr2_$LI$() : org.jbox2d.pooling.TLVec2 { if(DistanceJoint.tlr2 == null) DistanceJoint.tlr2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlr2; };

        static tlP : org.jbox2d.pooling.TLVec2; public static tlP_$LI$() : org.jbox2d.pooling.TLVec2 { if(DistanceJoint.tlP == null) DistanceJoint.tlP = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlP; };

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public initVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            this.m_inv_dt = step.inv_dt;
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tlr2_$LI$());
            let P : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tlP_$LI$());
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.getMemberXForm().R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.getMemberXForm().R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r2);
            this.m_u.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b2.m_sweep.c.x + r2.x) - b1.m_sweep.c.x) - r1.x);
            this.m_u.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b2.m_sweep.c.y + r2.y) - b1.m_sweep.c.y) - r1.y);
            let length : number = this.m_u.length();
            if(length > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                this.m_u.x *= (<any>Math).fround(1.0 / length);
                this.m_u.y *= (<any>Math).fround(1.0 / length);
            } else {
                this.m_u.set$float$float(0.0, 0.0);
            }
            let cr1u : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, this.m_u);
            let cr2u : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, this.m_u);
            let invMass : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b1.m_invMass + (<any>Math).fround((<any>Math).fround(b1.m_invI * cr1u) * cr1u)) + b2.m_invMass) + (<any>Math).fround((<any>Math).fround(b2.m_invI * cr2u) * cr2u));
            if(!((invMass > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 131: assert (invMass > Settings.EPSILON);");;
            this.m_mass = (<any>Math).fround(1.0 / invMass);
            if(this.m_frequencyHz > 0.0) {
                let C : number = (<any>Math).fround(length - this.m_length);
                let omega : number = (<any>Math).fround((<any>Math).fround(2.0 * org.jbox2d.common.MathUtils.PI_$LI$()) * this.m_frequencyHz);
                let d : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(2.0 * this.m_mass) * this.m_dampingRatio) * omega);
                let k : number = (<any>Math).fround((<any>Math).fround(this.m_mass * omega) * omega);
                this.m_gamma = (<any>Math).fround(1.0 / ((<any>Math).fround(step.dt * ((<any>Math).fround(d + (<any>Math).fround(step.dt * k))))));
                this.m_bias = (<any>Math).fround((<any>Math).fround((<any>Math).fround(C * step.dt) * k) * this.m_gamma);
                this.m_mass = (<any>Math).fround(1.0 / ((<any>Math).fround(invMass + this.m_gamma)));
            }
            if(step.warmStarting) {
                this.m_impulse *= step.dtRatio;
                P.set$org_jbox2d_common_Vec2(this.m_u);
                P.mulLocal(this.m_impulse);
                b1.m_linearVelocity.x -= (<any>Math).fround(b1.m_invMass * P.x);
                b1.m_linearVelocity.y -= (<any>Math).fround(b1.m_invMass * P.y);
                b1.m_angularVelocity -= (<any>Math).fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P));
                b2.m_linearVelocity.x += (<any>Math).fround(b2.m_invMass * P.x);
                b2.m_linearVelocity.y += (<any>Math).fround(b2.m_invMass * P.y);
                b2.m_angularVelocity += (<any>Math).fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P));
            } else {
                this.m_impulse = 0.0;
            }
        }

        static tld : org.jbox2d.pooling.TLVec2; public static tld_$LI$() : org.jbox2d.pooling.TLVec2 { if(DistanceJoint.tld == null) DistanceJoint.tld = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tld; };

        /**
         * 
         * @return {boolean}
         */
        public solvePositionConstraints() : boolean {
            if(this.m_frequencyHz > 0.0) {
                return true;
            }
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tld_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tlr2_$LI$());
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tlr1_$LI$());
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.getMemberXForm().R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.getMemberXForm().R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r2);
            d.x = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b2.m_sweep.c.x + r2.x) - b1.m_sweep.c.x) - r1.x);
            d.y = (<any>Math).fround((<any>Math).fround((<any>Math).fround(b2.m_sweep.c.y + r2.y) - b1.m_sweep.c.y) - r1.y);
            let length : number = d.normalize();
            let C : number = (<any>Math).fround(length - this.m_length);
            C = org.jbox2d.common.MathUtils.clamp$float$float$float(C, -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), org.jbox2d.common.Settings.maxLinearCorrection_$LI$());
            let impulse : number = (<any>Math).fround(-this.m_mass * C);
            this.m_u.set$org_jbox2d_common_Vec2(d);
            let Px : number = (<any>Math).fround(impulse * this.m_u.x);
            let Py : number = (<any>Math).fround(impulse * this.m_u.y);
            b1.m_sweep.c.x -= (<any>Math).fround(b1.m_invMass * Px);
            b1.m_sweep.c.y -= (<any>Math).fround(b1.m_invMass * Py);
            b1.m_sweep.a -= (<any>Math).fround(b1.m_invI * ((<any>Math).fround((<any>Math).fround(r1.x * Py) - (<any>Math).fround(r1.y * Px))));
            b2.m_sweep.c.x += (<any>Math).fround(b2.m_invMass * Px);
            b2.m_sweep.c.y += (<any>Math).fround(b2.m_invMass * Py);
            b2.m_sweep.a += (<any>Math).fround(b2.m_invI * ((<any>Math).fround((<any>Math).fround(r2.x * Py) - (<any>Math).fround(r2.y * Px))));
            b1.synchronizeTransform();
            b2.synchronizeTransform();
            return org.jbox2d.common.MathUtils.abs(C) < org.jbox2d.common.Settings.linearSlop_$LI$();
        }

        static tlv1 : org.jbox2d.pooling.TLVec2; public static tlv1_$LI$() : org.jbox2d.pooling.TLVec2 { if(DistanceJoint.tlv1 == null) DistanceJoint.tlv1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlv1; };

        static tlv2 : org.jbox2d.pooling.TLVec2; public static tlv2_$LI$() : org.jbox2d.pooling.TLVec2 { if(DistanceJoint.tlv2 == null) DistanceJoint.tlv2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlv2; };

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public solveVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tlv1_$LI$());
            let v2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tlv2_$LI$());
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(DistanceJoint.tlr2_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r2);
            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_angularVelocity, r1, v1);
            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_angularVelocity, r2, v2);
            v1.addLocal$org_jbox2d_common_Vec2(b1.m_linearVelocity);
            v2.addLocal$org_jbox2d_common_Vec2(b2.m_linearVelocity);
            let Cdot : number = org.jbox2d.common.Vec2.dot(this.m_u, v2.subLocal(v1));
            let impulse : number = (<any>Math).fround(-this.m_mass * ((<any>Math).fround((<any>Math).fround(Cdot + this.m_bias) + (<any>Math).fround(this.m_gamma * this.m_impulse))));
            this.m_impulse += impulse;
            let Px : number = (<any>Math).fround(impulse * this.m_u.x);
            let Py : number = (<any>Math).fround(impulse * this.m_u.y);
            b1.m_linearVelocity.x -= (<any>Math).fround(b1.m_invMass * Px);
            b1.m_linearVelocity.y -= (<any>Math).fround(b1.m_invMass * Py);
            b1.m_angularVelocity -= (<any>Math).fround(b1.m_invI * ((<any>Math).fround((<any>Math).fround(r1.x * Py) - (<any>Math).fround(r1.y * Px))));
            b2.m_linearVelocity.x += (<any>Math).fround(b2.m_invMass * Px);
            b2.m_linearVelocity.y += (<any>Math).fround(b2.m_invMass * Py);
            b2.m_angularVelocity += (<any>Math).fround(b2.m_invI * ((<any>Math).fround((<any>Math).fround(r2.x * Py) - (<any>Math).fround(r2.y * Px))));
        }
    }
    DistanceJoint["__class"] = "org.jbox2d.dynamics.joints.DistanceJoint";

}
namespace org.jbox2d.dynamics.joints {
    export class MouseJoint extends org.jbox2d.dynamics.joints.Joint {
        public m_localAnchor : org.jbox2d.common.Vec2;

        public m_target : org.jbox2d.common.Vec2;

        public m_force : org.jbox2d.common.Vec2;

        public m_mass : org.jbox2d.common.Mat22;

        public m_C : org.jbox2d.common.Vec2;

        public m_maxForce : number;

        public m_beta : number;

        public m_gamma : number;

        public constructor(def : org.jbox2d.dynamics.joints.MouseJointDef) {
            super(def);
            if(this.m_localAnchor===undefined) this.m_localAnchor = null;
            if(this.m_target===undefined) this.m_target = null;
            if(this.m_force===undefined) this.m_force = null;
            if(this.m_mass===undefined) this.m_mass = null;
            if(this.m_C===undefined) this.m_C = null;
            if(this.m_maxForce===undefined) this.m_maxForce = 0;
            if(this.m_beta===undefined) this.m_beta = 0;
            if(this.m_gamma===undefined) this.m_gamma = 0;
            this.m_force = new org.jbox2d.common.Vec2();
            this.m_target = new org.jbox2d.common.Vec2();
            this.m_C = new org.jbox2d.common.Vec2();
            this.m_mass = new org.jbox2d.common.Mat22();
            this.m_target.set$org_jbox2d_common_Vec2(def.target);
            this.m_localAnchor = org.jbox2d.common.XForm.mulTrans(this.m_body2.m_xf, this.m_target);
            this.m_maxForce = def.maxForce;
            let mass : number = this.m_body2.m_mass;
            let omega : number = (<any>Math).fround((<any>Math).fround(2.0 * org.jbox2d.common.Settings.pi_$LI$()) * def.frequencyHz);
            let d : number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(2.0 * mass) * def.dampingRatio) * omega);
            let k : number = (<any>Math).fround((<any>Math).fround(mass * omega) * omega);
            this.m_gamma = (<any>Math).fround(1.0 / ((<any>Math).fround(d + (<any>Math).fround(def.timeStep * k))));
            this.m_beta = (<any>Math).fround((<any>Math).fround(def.timeStep * k) / ((<any>Math).fround(d + (<any>Math).fround(def.timeStep * k))));
        }

        /**
         * Use this to update the target point.
         * @param {org.jbox2d.common.Vec2} target
         */
        public setTarget(target : org.jbox2d.common.Vec2) {
            if(this.m_body2.isSleeping()) {
                this.m_body2.wakeUp();
            }
            this.m_target.set$org_jbox2d_common_Vec2(target);
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor1() : org.jbox2d.common.Vec2 {
            return this.m_target;
        }

        static tlanchor2 : org.jbox2d.pooling.TLVec2; public static tlanchor2_$LI$() : org.jbox2d.pooling.TLVec2 { if(MouseJoint.tlanchor2 == null) MouseJoint.tlanchor2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tlanchor2; };

        /**
         * this comes from a pooled value
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor2() : org.jbox2d.common.Vec2 {
            let anchor2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(MouseJoint.tlanchor2_$LI$());
            this.m_body2.getWorldLocationToOut(this.m_localAnchor, anchor2);
            return anchor2;
        }

        static tlr : org.jbox2d.pooling.TLVec2; public static tlr_$LI$() : org.jbox2d.pooling.TLVec2 { if(MouseJoint.tlr == null) MouseJoint.tlr = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tlr; };

        static tlK1 : org.jbox2d.pooling.TLMat22; public static tlK1_$LI$() : org.jbox2d.pooling.TLMat22 { if(MouseJoint.tlK1 == null) MouseJoint.tlK1 = (() => { let __o : any = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return MouseJoint.tlK1; };

        static tlK2 : org.jbox2d.pooling.TLMat22; public static tlK2_$LI$() : org.jbox2d.pooling.TLMat22 { if(MouseJoint.tlK2 == null) MouseJoint.tlK2 = (() => { let __o : any = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return MouseJoint.tlK2; };

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public initVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let b : org.jbox2d.dynamics.Body = this.m_body2;
            let r : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(MouseJoint.tlr_$LI$());
            let K1 : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(MouseJoint.tlK1_$LI$());
            let K2 : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(MouseJoint.tlK2_$LI$());
            r.set$org_jbox2d_common_Vec2(this.m_localAnchor);
            r.subLocal(b.getMemberLocalCenter());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b.m_xf.R, r, r);
            let invMass : number = b.m_invMass;
            let invI : number = b.m_invI;
            K1.set$float$float$float$float(invMass, 0.0, 0.0, invMass);
            K2.set$float$float$float$float((<any>Math).fround((<any>Math).fround(invI * r.y) * r.y), (<any>Math).fround((<any>Math).fround(-invI * r.x) * r.y), (<any>Math).fround((<any>Math).fround(-invI * r.x) * r.y), (<any>Math).fround((<any>Math).fround(invI * r.x) * r.x));
            K1.addLocal(K2);
            K1.col1.x += this.m_gamma;
            K1.col2.y += this.m_gamma;
            K1.invertToOut(this.m_mass);
            this.m_C.set$float$float((<any>Math).fround((<any>Math).fround(b.m_sweep.c.x + r.x) - this.m_target.x), (<any>Math).fround((<any>Math).fround(b.m_sweep.c.y + r.y) - this.m_target.y));
            b.m_angularVelocity *= 0.98;
            let Px : number = (<any>Math).fround(step.dt * this.m_force.x);
            let Py : number = (<any>Math).fround(step.dt * this.m_force.y);
            b.m_linearVelocity.x += (<any>Math).fround(invMass * Px);
            b.m_linearVelocity.y += (<any>Math).fround(invMass * Py);
            b.m_angularVelocity += (<any>Math).fround(invI * ((<any>Math).fround((<any>Math).fround(r.x * Py) - (<any>Math).fround(r.y * Px))));
        }

        /**
         * 
         * @return {boolean}
         */
        public solvePositionConstraints() : boolean {
            return true;
        }

        static tlCdot : org.jbox2d.pooling.TLVec2; public static tlCdot_$LI$() : org.jbox2d.pooling.TLVec2 { if(MouseJoint.tlCdot == null) MouseJoint.tlCdot = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tlCdot; };

        static tlforce : org.jbox2d.pooling.TLVec2; public static tlforce_$LI$() : org.jbox2d.pooling.TLVec2 { if(MouseJoint.tlforce == null) MouseJoint.tlforce = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tlforce; };

        static tloldForce : org.jbox2d.pooling.TLVec2; public static tloldForce_$LI$() : org.jbox2d.pooling.TLVec2 { if(MouseJoint.tloldForce == null) MouseJoint.tloldForce = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tloldForce; };

        static tlP : org.jbox2d.pooling.TLVec2; public static tlP_$LI$() : org.jbox2d.pooling.TLVec2 { if(MouseJoint.tlP == null) MouseJoint.tlP = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tlP; };

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public solveVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let b : org.jbox2d.dynamics.Body = this.m_body2;
            let r : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(MouseJoint.tlr_$LI$());
            let Cdot : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(MouseJoint.tlCdot_$LI$());
            let force : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(MouseJoint.tlforce_$LI$());
            let oldForce : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(MouseJoint.tloldForce_$LI$());
            let P : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(MouseJoint.tlP_$LI$());
            r.set$org_jbox2d_common_Vec2(this.m_localAnchor);
            r.subLocal(b.getMemberLocalCenter());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b.m_xf.R, r, r);
            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b.m_angularVelocity, r, Cdot);
            Cdot.addLocal$org_jbox2d_common_Vec2(b.m_linearVelocity);
            force.set$float$float((<any>Math).fround((<any>Math).fround(Cdot.x + (<any>Math).fround(((<any>Math).fround(this.m_beta * step.inv_dt)) * this.m_C.x)) + (<any>Math).fround((<any>Math).fround(this.m_gamma * step.dt) * this.m_force.x)), (<any>Math).fround((<any>Math).fround(Cdot.y + (<any>Math).fround(((<any>Math).fround(this.m_beta * step.inv_dt)) * this.m_C.y)) + (<any>Math).fround((<any>Math).fround(this.m_gamma * step.dt) * this.m_force.y)));
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_mass, force, force);
            force.mulLocal(-step.inv_dt);
            oldForce.set$org_jbox2d_common_Vec2(this.m_force);
            this.m_force.addLocal$org_jbox2d_common_Vec2(force);
            let forceMagnitude : number = this.m_force.length();
            if(forceMagnitude > this.m_maxForce) {
                this.m_force.mulLocal((<any>Math).fround(this.m_maxForce / forceMagnitude));
            }
            force.set$float$float((<any>Math).fround(this.m_force.x - oldForce.x), (<any>Math).fround(this.m_force.y - oldForce.y));
            P.x = (<any>Math).fround(step.dt * force.x);
            P.y = (<any>Math).fround(step.dt * force.y);
            b.m_angularVelocity += (<any>Math).fround(b.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r, P));
            b.m_linearVelocity.addLocal$org_jbox2d_common_Vec2(P.mulLocal(b.m_invMass));
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getReactionForce() : org.jbox2d.common.Vec2 {
            return this.m_force;
        }

        /**
         * 
         * @return {number}
         */
        public getReactionTorque() : number {
            return 0.0;
        }
    }
    MouseJoint["__class"] = "org.jbox2d.dynamics.joints.MouseJoint";

}
namespace org.jbox2d.dynamics.joints {
    /**
     * A prismatic joint. This joint provides one degree of freedom: translation
     * along an axis fixed in body1. Relative rotation is prevented. You can
     * use a joint limit to restrict the range of motion and a joint motor to
     * drive the motion or to model joint friction.
     * @param {org.jbox2d.dynamics.joints.PrismaticJointDef} def
     * @class
     * @extends org.jbox2d.dynamics.joints.Joint
     */
    export class PrismaticJoint extends org.jbox2d.dynamics.joints.Joint {
        public m_localAnchor1 : org.jbox2d.common.Vec2;

        public m_localAnchor2 : org.jbox2d.common.Vec2;

        public m_localXAxis1 : org.jbox2d.common.Vec2;

        public m_localYAxis1 : org.jbox2d.common.Vec2;

        public m_refAngle : number;

        public m_linearJacobian : org.jbox2d.dynamics.joints.Jacobian;

        public m_linearMass : number;

        public m_force : number;

        public m_angularMass : number;

        public m_torque : number;

        public m_motorJacobian : org.jbox2d.dynamics.joints.Jacobian;

        public m_motorMass : number;

        public m_motorForce : number;

        public m_limitForce : number;

        public m_limitPositionImpulse : number;

        public m_lowerTranslation : number;

        public m_upperTranslation : number;

        public m_maxMotorForce : number;

        public m_motorSpeed : number;

        public m_enableLimit : boolean;

        public m_enableMotor : boolean;

        public m_limitState : org.jbox2d.dynamics.joints.LimitState;

        public constructor(def : org.jbox2d.dynamics.joints.PrismaticJointDef) {
            super(def);
            if(this.m_localAnchor1===undefined) this.m_localAnchor1 = null;
            if(this.m_localAnchor2===undefined) this.m_localAnchor2 = null;
            if(this.m_localXAxis1===undefined) this.m_localXAxis1 = null;
            if(this.m_localYAxis1===undefined) this.m_localYAxis1 = null;
            if(this.m_refAngle===undefined) this.m_refAngle = 0;
            if(this.m_linearJacobian===undefined) this.m_linearJacobian = null;
            if(this.m_linearMass===undefined) this.m_linearMass = 0;
            if(this.m_force===undefined) this.m_force = 0;
            if(this.m_angularMass===undefined) this.m_angularMass = 0;
            if(this.m_torque===undefined) this.m_torque = 0;
            if(this.m_motorJacobian===undefined) this.m_motorJacobian = null;
            if(this.m_motorMass===undefined) this.m_motorMass = 0;
            if(this.m_motorForce===undefined) this.m_motorForce = 0;
            if(this.m_limitForce===undefined) this.m_limitForce = 0;
            if(this.m_limitPositionImpulse===undefined) this.m_limitPositionImpulse = 0;
            if(this.m_lowerTranslation===undefined) this.m_lowerTranslation = 0;
            if(this.m_upperTranslation===undefined) this.m_upperTranslation = 0;
            if(this.m_maxMotorForce===undefined) this.m_maxMotorForce = 0;
            if(this.m_motorSpeed===undefined) this.m_motorSpeed = 0;
            if(this.m_enableLimit===undefined) this.m_enableLimit = false;
            if(this.m_enableMotor===undefined) this.m_enableMotor = false;
            if(this.m_limitState===undefined) this.m_limitState = null;
            if(this.m_lastWarmStartingForce===undefined) this.m_lastWarmStartingForce = 0;
            if(this.m_lastWarmStartingTorque===undefined) this.m_lastWarmStartingTorque = 0;
            this.m_localAnchor1 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAnchor1);
            this.m_localAnchor2 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAnchor2);
            this.m_localXAxis1 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAxis1);
            this.m_localYAxis1 = org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(1.0, this.m_localXAxis1);
            this.m_refAngle = def.referenceAngle;
            this.m_linearJacobian = new org.jbox2d.dynamics.joints.Jacobian();
            this.m_linearMass = 0.0;
            this.m_force = 0.0;
            this.m_angularMass = 0.0;
            this.m_torque = 0.0;
            this.m_motorJacobian = new org.jbox2d.dynamics.joints.Jacobian();
            this.m_motorMass = 0.0;
            this.m_motorForce = 0.0;
            this.m_limitForce = 0.0;
            this.m_limitPositionImpulse = 0.0;
            this.m_lowerTranslation = def.lowerTranslation;
            this.m_upperTranslation = def.upperTranslation;
            this.m_maxMotorForce = def.maxMotorForce;
            this.m_motorSpeed = def.motorSpeed;
            this.m_enableLimit = def.enableLimit;
            this.m_enableMotor = def.enableMotor;
        }

        static tlr1 : org.jbox2d.pooling.TLVec2; public static tlr1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlr1 == null) PrismaticJoint.tlr1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlr1; };

        static tlr2 : org.jbox2d.pooling.TLVec2; public static tlr2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlr2 == null) PrismaticJoint.tlr2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlr2; };

        static tlax1 : org.jbox2d.pooling.TLVec2; public static tlax1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlax1 == null) PrismaticJoint.tlax1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlax1; };

        static tlay1 : org.jbox2d.pooling.TLVec2; public static tlay1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlay1 == null) PrismaticJoint.tlay1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlay1; };

        static tle : org.jbox2d.pooling.TLVec2; public static tle_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tle == null) PrismaticJoint.tle = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tle; };

        static tlax1Neg : org.jbox2d.pooling.TLVec2; public static tlax1Neg_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlax1Neg == null) PrismaticJoint.tlax1Neg = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlax1Neg; };

        static tlay1Neg : org.jbox2d.pooling.TLVec2; public static tlay1Neg_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlay1Neg == null) PrismaticJoint.tlay1Neg = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlay1Neg; };

        static tld : org.jbox2d.pooling.TLVec2; public static tld_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tld == null) PrismaticJoint.tld = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tld; };

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public initVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlr2_$LI$());
            let ax1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlax1_$LI$());
            let ay1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlay1_$LI$());
            let e : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tle_$LI$());
            let ax1Neg : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlax1Neg_$LI$());
            let ay1Neg : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlay1Neg_$LI$());
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tld_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r2);
            let invMass1 : number = b1.m_invMass;
            let invMass2 : number = b2.m_invMass;
            let invI1 : number = b1.m_invI;
            let invI2 : number = b2.m_invI;
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localYAxis1, ay1);
            e.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
            e.addLocal$org_jbox2d_common_Vec2(r2).subLocal(b1.m_sweep.c);
            org.jbox2d.common.Vec2.negateToOut(ay1, ay1Neg);
            this.m_linearJacobian.set(ay1Neg, -org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e, ay1), ay1, org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, ay1));
            this.m_linearMass = (<any>Math).fround((<any>Math).fround((<any>Math).fround(invMass1 + (<any>Math).fround((<any>Math).fround(invI1 * this.m_linearJacobian.angular1) * this.m_linearJacobian.angular1)) + invMass2) + (<any>Math).fround((<any>Math).fround(invI2 * this.m_linearJacobian.angular2) * this.m_linearJacobian.angular2));
            if(!(this.m_linearMass > org.jbox2d.common.Settings.EPSILON)) throw new Error("Assertion error line 148: assert m_linearMass > Settings.EPSILON;");;
            this.m_linearMass = (<any>Math).fround(1.0 / this.m_linearMass);
            this.m_angularMass = (<any>Math).fround(invI1 + invI2);
            if(this.m_angularMass > org.jbox2d.common.Settings.EPSILON) {
                this.m_angularMass = (<any>Math).fround(1.0 / this.m_angularMass);
            }
            if(this.m_enableLimit || this.m_enableMotor) {
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localXAxis1, ax1);
                org.jbox2d.common.Vec2.negateToOut(ax1, ax1Neg);
                this.m_motorJacobian.set(ax1Neg, -org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e, ax1), ax1, org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, ax1));
                this.m_motorMass = (<any>Math).fround((<any>Math).fround((<any>Math).fround(invMass1 + (<any>Math).fround((<any>Math).fround(invI1 * this.m_motorJacobian.angular1) * this.m_motorJacobian.angular1)) + invMass2) + (<any>Math).fround((<any>Math).fround(invI2 * this.m_motorJacobian.angular2) * this.m_motorJacobian.angular2));
                if(!(this.m_motorMass > org.jbox2d.common.Settings.EPSILON)) throw new Error("Assertion error line 159: assert m_motorMass > Settings.EPSILON;");;
                this.m_motorMass = (<any>Math).fround(1.0 / this.m_motorMass);
                if(this.m_enableLimit) {
                    d.set$org_jbox2d_common_Vec2(e);
                    d.subLocal(r1);
                    let jointTranslation : number = org.jbox2d.common.Vec2.dot(ax1, d);
                    if(org.jbox2d.common.MathUtils.abs((<any>Math).fround(this.m_upperTranslation - this.m_lowerTranslation)) < (<any>Math).fround(2.0 * org.jbox2d.common.Settings.linearSlop_$LI$())) {
                        this.m_limitState = org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS;
                    } else if(jointTranslation <= this.m_lowerTranslation) {
                        if(this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                            this.m_limitForce = 0.0;
                        }
                        this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT;
                    } else if(jointTranslation >= this.m_upperTranslation) {
                        if(this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                            this.m_limitForce = 0.0;
                        }
                        this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT;
                    } else {
                        this.m_limitState = org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT;
                        this.m_limitForce = 0.0;
                    }
                }
            }
            if(this.m_enableMotor === false) {
                this.m_motorForce = 0.0;
            }
            if(this.m_enableLimit === false) {
                this.m_limitForce = 0.0;
            }
            if(step.warmStarting) {
                let L1 : number = (<any>Math).fround(step.dt * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_force * this.m_linearJacobian.angular1) - this.m_torque) + (<any>Math).fround(((<any>Math).fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.angular1))));
                let L2 : number = (<any>Math).fround(step.dt * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_force * this.m_linearJacobian.angular2) + this.m_torque) + (<any>Math).fround(((<any>Math).fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.angular2))));
                b1.m_linearVelocity.x += (<any>Math).fround((<any>Math).fround(invMass1 * step.dt) * ((<any>Math).fround((<any>Math).fround(this.m_force * this.m_linearJacobian.linear1.x) + (<any>Math).fround(((<any>Math).fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.linear1.x))));
                b1.m_linearVelocity.y += (<any>Math).fround((<any>Math).fround(invMass1 * step.dt) * ((<any>Math).fround((<any>Math).fround(this.m_force * this.m_linearJacobian.linear1.y) + (<any>Math).fround(((<any>Math).fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.linear1.y))));
                b1.m_angularVelocity += (<any>Math).fround(invI1 * L1);
                b2.m_linearVelocity.x += (<any>Math).fround((<any>Math).fround(invMass2 * step.dt) * ((<any>Math).fround((<any>Math).fround(this.m_force * this.m_linearJacobian.linear2.x) + (<any>Math).fround(((<any>Math).fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.linear2.x))));
                b2.m_linearVelocity.y += (<any>Math).fround((<any>Math).fround(invMass2 * step.dt) * ((<any>Math).fround((<any>Math).fround(this.m_force * this.m_linearJacobian.linear2.y) + (<any>Math).fround(((<any>Math).fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.linear2.y))));
                b2.m_angularVelocity += (<any>Math).fround(invI2 * L2);
            } else {
                this.m_force = 0.0;
                this.m_torque = 0.0;
                this.m_limitForce = 0.0;
                this.m_motorForce = 0.0;
            }
            this.m_limitPositionImpulse = 0.0;
        }

        /*private*/ m_lastWarmStartingForce : number;

        /*private*/ m_lastWarmStartingTorque : number;

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public solveVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let invMass1 : number = b1.m_invMass;
            let invMass2 : number = b2.m_invMass;
            let invI1 : number = b1.m_invI;
            let invI2 : number = b2.m_invI;
            let linearCdot : number = this.m_linearJacobian.compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity);
            let force : number = (<any>Math).fround((<any>Math).fround(-step.inv_dt * this.m_linearMass) * linearCdot);
            if(step.warmStarting) {
                this.m_force += (force);
                this.m_lastWarmStartingForce = this.m_force;
            } else {
                this.m_force = this.m_lastWarmStartingForce;
            }
            let P : number = (<any>Math).fround(step.dt * force);
            b1.m_linearVelocity.x += (<any>Math).fround(((<any>Math).fround(invMass1 * P)) * this.m_linearJacobian.linear1.x);
            b1.m_linearVelocity.y += (<any>Math).fround(((<any>Math).fround(invMass1 * P)) * this.m_linearJacobian.linear1.y);
            b1.m_angularVelocity += (<any>Math).fround((<any>Math).fround(invI1 * P) * this.m_linearJacobian.angular1);
            b2.m_linearVelocity.x += (<any>Math).fround(((<any>Math).fround(invMass2 * P)) * this.m_linearJacobian.linear2.x);
            b2.m_linearVelocity.y += (<any>Math).fround(((<any>Math).fround(invMass2 * P)) * this.m_linearJacobian.linear2.y);
            b2.m_angularVelocity += (<any>Math).fround((<any>Math).fround(invI2 * P) * this.m_linearJacobian.angular2);
            let angularCdot : number = (<any>Math).fround(b2.m_angularVelocity - b1.m_angularVelocity);
            let torque : number = (<any>Math).fround((<any>Math).fround(-step.inv_dt * this.m_angularMass) * angularCdot);
            this.m_torque += torque;
            if(step.warmStarting) {
                this.m_torque += torque;
                this.m_lastWarmStartingTorque = this.m_torque;
            } else {
                this.m_torque = this.m_lastWarmStartingTorque;
            }
            let L : number = (<any>Math).fround(step.dt * torque);
            b1.m_angularVelocity -= (<any>Math).fround(invI1 * L);
            b2.m_angularVelocity += (<any>Math).fround(invI2 * L);
            if(this.m_enableMotor && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                let motorCdot : number = (<any>Math).fround(this.m_motorJacobian.compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity) - this.m_motorSpeed);
                let motorForce : number = (<any>Math).fround((<any>Math).fround(-step.inv_dt * this.m_motorMass) * motorCdot);
                let oldMotorForce : number = this.m_motorForce;
                this.m_motorForce = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(this.m_motorForce + motorForce), -this.m_maxMotorForce, this.m_maxMotorForce);
                motorForce = (<any>Math).fround(this.m_motorForce - oldMotorForce);
                let P2 : number = (<any>Math).fround(step.dt * motorForce);
                b1.m_linearVelocity.x += (<any>Math).fround(((<any>Math).fround(invMass1 * P2)) * this.m_motorJacobian.linear1.x);
                b1.m_linearVelocity.y += (<any>Math).fround(((<any>Math).fround(invMass1 * P2)) * this.m_motorJacobian.linear1.y);
                b1.m_angularVelocity += (<any>Math).fround((<any>Math).fround(invI1 * P2) * this.m_motorJacobian.angular1);
                b2.m_linearVelocity.x += (<any>Math).fround(((<any>Math).fround(invMass2 * P2)) * this.m_motorJacobian.linear2.x);
                b2.m_linearVelocity.y += (<any>Math).fround(((<any>Math).fround(invMass2 * P2)) * this.m_motorJacobian.linear2.y);
                b2.m_angularVelocity += (<any>Math).fround((<any>Math).fround(invI2 * P2) * this.m_motorJacobian.angular2);
            }
            if(this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT) {
                let limitCdot : number = this.m_motorJacobian.compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity);
                let limitForce : number = (<any>Math).fround((<any>Math).fround(-step.inv_dt * this.m_motorMass) * limitCdot);
                if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                    this.m_limitForce += limitForce;
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                    let oldLimitForce : number = this.m_limitForce;
                    this.m_limitForce = org.jbox2d.common.MathUtils.max$float$float((<any>Math).fround(this.m_limitForce + limitForce), 0.0);
                    limitForce = (<any>Math).fround(this.m_limitForce - oldLimitForce);
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                    let oldLimitForce : number = this.m_limitForce;
                    this.m_limitForce = org.jbox2d.common.MathUtils.min((<any>Math).fround(this.m_limitForce + limitForce), 0.0);
                    limitForce = (<any>Math).fround(this.m_limitForce - oldLimitForce);
                }
                let P2 : number = (<any>Math).fround(step.dt * limitForce);
                b1.m_linearVelocity.x += (<any>Math).fround(((<any>Math).fround(invMass1 * P2)) * this.m_motorJacobian.linear1.x);
                b1.m_linearVelocity.y += (<any>Math).fround(((<any>Math).fround(invMass1 * P2)) * this.m_motorJacobian.linear1.y);
                b1.m_angularVelocity += (<any>Math).fround((<any>Math).fround(invI1 * P2) * this.m_motorJacobian.angular1);
                b2.m_linearVelocity.x += (<any>Math).fround(((<any>Math).fround(invMass2 * P2)) * this.m_motorJacobian.linear2.x);
                b2.m_linearVelocity.y += (<any>Math).fround(((<any>Math).fround(invMass2 * P2)) * this.m_motorJacobian.linear2.y);
                b2.m_angularVelocity += (<any>Math).fround((<any>Math).fround(invI2 * P2) * this.m_motorJacobian.angular2);
            }
        }

        static tltemp : org.jbox2d.pooling.TLVec2; public static tltemp_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tltemp == null) PrismaticJoint.tltemp = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tltemp; };

        static tlp1 : org.jbox2d.pooling.TLVec2; public static tlp1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlp1 == null) PrismaticJoint.tlp1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlp1; };

        static tlp2 : org.jbox2d.pooling.TLVec2; public static tlp2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlp2 == null) PrismaticJoint.tlp2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlp2; };

        static tlr1z : org.jbox2d.pooling.TLVec2; public static tlr1z_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlr1z == null) PrismaticJoint.tlr1z = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlr1z; };

        static tlr2z : org.jbox2d.pooling.TLVec2; public static tlr2z_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlr2z == null) PrismaticJoint.tlr2z = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlr2z; };

        static tlp1z : org.jbox2d.pooling.TLVec2; public static tlp1z_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlp1z == null) PrismaticJoint.tlp1z = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlp1z; };

        static tlp2z : org.jbox2d.pooling.TLVec2; public static tlp2z_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlp2z == null) PrismaticJoint.tlp2z = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlp2z; };

        static tldz : org.jbox2d.pooling.TLVec2; public static tldz_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tldz == null) PrismaticJoint.tldz = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tldz; };

        /**
         * 
         * @return {boolean}
         */
        public solvePositionConstraints() : boolean {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let temp : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tltemp_$LI$());
            let p1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlp1_$LI$());
            let p2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlp2_$LI$());
            let r1z : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlr1z_$LI$());
            let r2z : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlr2z_$LI$());
            let p1z : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlp1z_$LI$());
            let p2z : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlp2z_$LI$());
            let dz : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tldz_$LI$());
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlr2_$LI$());
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tld_$LI$());
            let ax1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlax1_$LI$());
            let ay1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlay1_$LI$());
            let invMass1 : number = b1.m_invMass;
            let invMass2 : number = b2.m_invMass;
            let invI1 : number = b1.m_invI;
            let invI2 : number = b2.m_invI;
            temp.set$org_jbox2d_common_Vec2(this.m_localAnchor1);
            temp.subLocal(b1.getMemberLocalCenter());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, temp, r1);
            temp.set$org_jbox2d_common_Vec2(this.m_localAnchor2);
            temp.subLocal(b2.getMemberLocalCenter());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, temp, r2);
            p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
            p1.addLocal$org_jbox2d_common_Vec2(r1);
            p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
            p2.addLocal$org_jbox2d_common_Vec2(r2);
            d.set$org_jbox2d_common_Vec2(p2);
            d.subLocal(p1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localYAxis1, ay1);
            let linearC : number = org.jbox2d.common.Vec2.dot(ay1, d);
            linearC = org.jbox2d.common.MathUtils.clamp$float$float$float(linearC, -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), org.jbox2d.common.Settings.maxLinearCorrection_$LI$());
            let linearImpulse : number = (<any>Math).fround(-this.m_linearMass * linearC);
            b1.m_sweep.c.x += (<any>Math).fround(((<any>Math).fround(invMass1 * linearImpulse)) * this.m_linearJacobian.linear1.x);
            b1.m_sweep.c.y += (<any>Math).fround(((<any>Math).fround(invMass1 * linearImpulse)) * this.m_linearJacobian.linear1.y);
            b1.m_sweep.a += (<any>Math).fround((<any>Math).fround(invI1 * linearImpulse) * this.m_linearJacobian.angular1);
            b2.m_sweep.c.x += (<any>Math).fround(((<any>Math).fround(invMass2 * linearImpulse)) * this.m_linearJacobian.linear2.x);
            b2.m_sweep.c.y += (<any>Math).fround(((<any>Math).fround(invMass2 * linearImpulse)) * this.m_linearJacobian.linear2.y);
            b2.m_sweep.a += (<any>Math).fround((<any>Math).fround(invI2 * linearImpulse) * this.m_linearJacobian.angular2);
            let positionError : number = org.jbox2d.common.MathUtils.abs(linearC);
            let angularC : number = (<any>Math).fround((<any>Math).fround(b2.m_sweep.a - b1.m_sweep.a) - this.m_refAngle);
            angularC = org.jbox2d.common.MathUtils.clamp$float$float$float(angularC, -org.jbox2d.common.Settings.maxAngularCorrection_$LI$(), org.jbox2d.common.Settings.maxAngularCorrection_$LI$());
            let angularImpulse : number = (<any>Math).fround(-this.m_angularMass * angularC);
            b1.m_sweep.a -= (<any>Math).fround(b1.m_invI * angularImpulse);
            b2.m_sweep.a += (<any>Math).fround(b2.m_invI * angularImpulse);
            b1.synchronizeTransform();
            b2.synchronizeTransform();
            let angularError : number = org.jbox2d.common.MathUtils.abs(angularC);
            if(this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT) {
                temp.set$org_jbox2d_common_Vec2(this.m_localAnchor1);
                temp.subLocal(b1.getMemberLocalCenter());
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, temp, r1z);
                temp.set$org_jbox2d_common_Vec2(this.m_localAnchor2);
                temp.subLocal(b2.getMemberLocalCenter());
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, temp, r2z);
                p1z.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
                p1z.addLocal$org_jbox2d_common_Vec2(r1z);
                p2z.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                p2z.addLocal$org_jbox2d_common_Vec2(r2z);
                dz.set$org_jbox2d_common_Vec2(p2z);
                dz.subLocal(p1z);
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localXAxis1, ax1);
                let translation : number = org.jbox2d.common.Vec2.dot(ax1, dz);
                let limitImpulse : number = 0.0;
                if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                    let limitC : number = org.jbox2d.common.MathUtils.clamp$float$float$float(translation, -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), org.jbox2d.common.Settings.maxLinearCorrection_$LI$());
                    limitImpulse = (<any>Math).fround(-this.m_motorMass * limitC);
                    positionError = org.jbox2d.common.MathUtils.max$float$float(positionError, org.jbox2d.common.MathUtils.abs(angularC));
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                    let limitC : number = (<any>Math).fround(translation - this.m_lowerTranslation);
                    positionError = org.jbox2d.common.MathUtils.max$float$float(positionError, -limitC);
                    limitC = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(limitC + org.jbox2d.common.Settings.linearSlop_$LI$()), -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), 0.0);
                    limitImpulse = (<any>Math).fround(-this.m_motorMass * limitC);
                    let oldLimitImpulse : number = this.m_limitPositionImpulse;
                    this.m_limitPositionImpulse = org.jbox2d.common.MathUtils.max$float$float((<any>Math).fround(this.m_limitPositionImpulse + limitImpulse), 0.0);
                    limitImpulse = (<any>Math).fround(this.m_limitPositionImpulse - oldLimitImpulse);
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                    let limitC : number = (<any>Math).fround(translation - this.m_upperTranslation);
                    positionError = org.jbox2d.common.MathUtils.max$float$float(positionError, limitC);
                    limitC = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(limitC - org.jbox2d.common.Settings.linearSlop_$LI$()), 0.0, org.jbox2d.common.Settings.maxLinearCorrection_$LI$());
                    limitImpulse = (<any>Math).fround(-this.m_motorMass * limitC);
                    let oldLimitImpulse : number = this.m_limitPositionImpulse;
                    this.m_limitPositionImpulse = org.jbox2d.common.MathUtils.min((<any>Math).fround(this.m_limitPositionImpulse + limitImpulse), 0.0);
                    limitImpulse = (<any>Math).fround(this.m_limitPositionImpulse - oldLimitImpulse);
                }
                b1.m_sweep.c.x += (<any>Math).fround(((<any>Math).fround(invMass1 * limitImpulse)) * this.m_motorJacobian.linear1.x);
                b1.m_sweep.c.y += (<any>Math).fround(((<any>Math).fround(invMass1 * limitImpulse)) * this.m_motorJacobian.linear1.y);
                b1.m_sweep.a += (<any>Math).fround((<any>Math).fround(invI1 * limitImpulse) * this.m_motorJacobian.angular1);
                b2.m_sweep.c.x += (<any>Math).fround(((<any>Math).fround(invMass2 * limitImpulse)) * this.m_motorJacobian.linear2.x);
                b2.m_sweep.c.y += (<any>Math).fround(((<any>Math).fround(invMass2 * limitImpulse)) * this.m_motorJacobian.linear2.y);
                b2.m_sweep.a += (<any>Math).fround((<any>Math).fround(invI2 * limitImpulse) * this.m_motorJacobian.angular2);
                b1.synchronizeTransform();
                b2.synchronizeTransform();
            }
            return positionError <= org.jbox2d.common.Settings.linearSlop_$LI$() && angularError <= org.jbox2d.common.Settings.angularSlop_$LI$();
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor1() : org.jbox2d.common.Vec2 {
            return this.m_body1.getWorldLocation(this.m_localAnchor1);
        }

        public getAnchor1ToOut(out : org.jbox2d.common.Vec2) {
            this.m_body1.getWorldLocationToOut(this.m_localAnchor1, out);
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor2() : org.jbox2d.common.Vec2 {
            return this.m_body2.getWorldLocation(this.m_localAnchor2);
        }

        public getAnchor2ToOut(out : org.jbox2d.common.Vec2) {
            this.m_body2.getWorldLocationToOut(this.m_localAnchor2, out);
        }

        public static tlaxis : org.jbox2d.pooling.TLVec2; public static tlaxis_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlaxis == null) PrismaticJoint.tlaxis = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlaxis; };

        public getJointTranslation() : number {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let axis : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlaxis_$LI$());
            let p1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlp1_$LI$());
            let p2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlp2_$LI$());
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tld_$LI$());
            b1.getWorldLocationToOut(this.m_localAnchor1, p1);
            b2.getWorldLocationToOut(this.m_localAnchor2, p2);
            d.set$org_jbox2d_common_Vec2(p2);
            d.subLocal(p1);
            b1.getWorldDirectionToOut(this.m_localXAxis1, axis);
            let translation : number = org.jbox2d.common.Vec2.dot(d, axis);
            return translation;
        }

        static tlw1xAxis : org.jbox2d.pooling.TLVec2; public static tlw1xAxis_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlw1xAxis == null) PrismaticJoint.tlw1xAxis = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlw1xAxis; };

        static tlv22 : org.jbox2d.pooling.TLVec2; public static tlv22_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlv22 == null) PrismaticJoint.tlv22 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlv22; };

        static tlw2xR2 : org.jbox2d.pooling.TLVec2; public static tlw2xR2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlw2xR2 == null) PrismaticJoint.tlw2xR2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlw2xR2; };

        static tlw1xR1 : org.jbox2d.pooling.TLVec2; public static tlw1xR1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlw1xR1 == null) PrismaticJoint.tlw1xR1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlw1xR1; };

        public getJointSpeed() : number {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlr2_$LI$());
            let p1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlp1_$LI$());
            let p2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlp2_$LI$());
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tld_$LI$());
            let axis : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlaxis_$LI$());
            let w1xAxis : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlw1xAxis_$LI$());
            let v22 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlv22_$LI$());
            let w2xR2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlw2xR2_$LI$());
            let w1xR1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlw1xR1_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r2);
            p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
            p1.addLocal$org_jbox2d_common_Vec2(r1);
            p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
            p2.addLocal$org_jbox2d_common_Vec2(r2);
            d.set$org_jbox2d_common_Vec2(p2);
            d.subLocal(p1);
            b1.getWorldDirectionToOut(this.m_localXAxis1, axis);
            let v1 : org.jbox2d.common.Vec2 = b1.m_linearVelocity;
            let v2 : org.jbox2d.common.Vec2 = b2.m_linearVelocity;
            let w1 : number = b1.m_angularVelocity;
            let w2 : number = b2.m_angularVelocity;
            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(w1, axis, w1xAxis);
            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(w2, r2, w2xR2);
            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(w1, r1, w1xR1);
            v22.set$org_jbox2d_common_Vec2(v2);
            let speed : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(d, w1xAxis) + org.jbox2d.common.Vec2.dot(axis, v22.addLocal$org_jbox2d_common_Vec2(w2xR2).subLocal(v1).subLocal(w1xR1)));
            return speed;
        }

        /**
         * 
         * @return {number}
         */
        public getReactionTorque() : number {
            return this.m_torque;
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getReactionForce() : org.jbox2d.common.Vec2 {
            let ax1 : org.jbox2d.common.Vec2 = org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(this.m_body1.m_xf.R, this.m_localXAxis1);
            let ay1 : org.jbox2d.common.Vec2 = org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(this.m_body1.m_xf.R, this.m_localYAxis1);
            return new org.jbox2d.common.Vec2((<any>Math).fround((<any>Math).fround(this.m_limitForce * ax1.x) + (<any>Math).fround(this.m_force * ay1.x)), (<any>Math).fround((<any>Math).fround(this.m_limitForce * ax1.y) + (<any>Math).fround(this.m_force * ay1.y)));
        }

        static tlreactionAx1 : org.jbox2d.pooling.TLVec2; public static tlreactionAx1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PrismaticJoint.tlreactionAx1 == null) PrismaticJoint.tlreactionAx1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlreactionAx1; };

        public getReactionForceToOut(out : org.jbox2d.common.Vec2) {
            let reactionAx1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PrismaticJoint.tlreactionAx1_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_body1.m_xf.R, this.m_localXAxis1, reactionAx1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_body1.m_xf.R, this.m_localYAxis1, out);
            out.x = (<any>Math).fround((<any>Math).fround(this.m_limitForce * reactionAx1.x) + (<any>Math).fround(this.m_force * out.x));
            out.y = (<any>Math).fround((<any>Math).fround(this.m_limitForce * reactionAx1.y) + (<any>Math).fround(this.m_force * out.y));
        }

        /**
         * Is the joint limit enabled?
         * @return {boolean}
         */
        public isLimitEnabled() : boolean {
            return this.m_enableLimit;
        }

        /**
         * Enable/disable the joint limit.
         * @param {boolean} flag
         */
        public enableLimit(flag : boolean) {
            this.m_enableLimit = flag;
        }

        /**
         * Get the lower joint limit, usually in meters.
         * @return {number}
         */
        public getLowerLimit() : number {
            return this.m_lowerTranslation;
        }

        /**
         * Get the upper joint limit, usually in meters.
         * @return {number}
         */
        public getUpperLimit() : number {
            return this.m_upperTranslation;
        }

        /**
         * Set the joint limits, usually in meters.
         * @param {number} lower
         * @param {number} upper
         */
        public setLimits(lower : number, upper : number) {
            if(!((lower <= upper))) throw new Error("Assertion error line 557: assert (lower <= upper);");;
            this.m_lowerTranslation = lower;
            this.m_upperTranslation = upper;
        }

        /**
         * Is the joint motor enabled?
         * @return {boolean}
         */
        public isMotorEnabled() : boolean {
            return this.m_enableMotor;
        }

        /**
         * Enable/disable the joint motor.
         * @param {boolean} flag
         */
        public enableMotor(flag : boolean) {
            this.m_enableMotor = flag;
        }

        /**
         * Set the motor speed, usually in meters per second.
         * @param {number} speed
         */
        public setMotorSpeed(speed : number) {
            this.m_motorSpeed = speed;
        }

        /**
         * Get the motor speed, usually in meters per second.
         * @return {number}
         */
        public getMotorSpeed() : number {
            return this.m_motorSpeed;
        }

        /**
         * Set the maximum motor torque, usually in N.
         * @param {number} force
         */
        public setMaxMotorForce(force : number) {
            this.m_maxMotorForce = force;
        }

        /**
         * Get the current motor torque, usually in N.
         * @return {number}
         */
        public getMotorForce() : number {
            return this.m_motorForce;
        }
    }
    PrismaticJoint["__class"] = "org.jbox2d.dynamics.joints.PrismaticJoint";

}
namespace org.jbox2d.dynamics.joints {
    export class PulleyJoint extends org.jbox2d.dynamics.joints.Joint {
        public static MIN_PULLEY_LENGTH : number = 2.0;

        public m_ground : org.jbox2d.dynamics.Body;

        public m_groundAnchor1 : org.jbox2d.common.Vec2;

        public m_groundAnchor2 : org.jbox2d.common.Vec2;

        public m_localAnchor1 : org.jbox2d.common.Vec2;

        public m_localAnchor2 : org.jbox2d.common.Vec2;

        public m_u1 : org.jbox2d.common.Vec2;

        public m_u2 : org.jbox2d.common.Vec2;

        public m_constant : number;

        public m_ratio : number;

        public m_maxLength1 : number;

        public m_maxLength2 : number;

        public m_pulleyMass : number;

        public m_limitMass1 : number;

        public m_limitMass2 : number;

        public m_force : number;

        public m_limitForce1 : number;

        public m_limitForce2 : number;

        public m_positionImpulse : number;

        public m_limitPositionImpulse1 : number;

        public m_limitPositionImpulse2 : number;

        public m_state : org.jbox2d.dynamics.joints.LimitState;

        public m_limitState1 : org.jbox2d.dynamics.joints.LimitState;

        public m_limitState2 : org.jbox2d.dynamics.joints.LimitState;

        public constructor(def : org.jbox2d.dynamics.joints.PulleyJointDef) {
            super(def);
            if(this.m_ground===undefined) this.m_ground = null;
            if(this.m_groundAnchor1===undefined) this.m_groundAnchor1 = null;
            if(this.m_groundAnchor2===undefined) this.m_groundAnchor2 = null;
            if(this.m_localAnchor1===undefined) this.m_localAnchor1 = null;
            if(this.m_localAnchor2===undefined) this.m_localAnchor2 = null;
            if(this.m_u1===undefined) this.m_u1 = null;
            if(this.m_u2===undefined) this.m_u2 = null;
            if(this.m_constant===undefined) this.m_constant = 0;
            if(this.m_ratio===undefined) this.m_ratio = 0;
            if(this.m_maxLength1===undefined) this.m_maxLength1 = 0;
            if(this.m_maxLength2===undefined) this.m_maxLength2 = 0;
            if(this.m_pulleyMass===undefined) this.m_pulleyMass = 0;
            if(this.m_limitMass1===undefined) this.m_limitMass1 = 0;
            if(this.m_limitMass2===undefined) this.m_limitMass2 = 0;
            if(this.m_force===undefined) this.m_force = 0;
            if(this.m_limitForce1===undefined) this.m_limitForce1 = 0;
            if(this.m_limitForce2===undefined) this.m_limitForce2 = 0;
            if(this.m_positionImpulse===undefined) this.m_positionImpulse = 0;
            if(this.m_limitPositionImpulse1===undefined) this.m_limitPositionImpulse1 = 0;
            if(this.m_limitPositionImpulse2===undefined) this.m_limitPositionImpulse2 = 0;
            if(this.m_state===undefined) this.m_state = null;
            if(this.m_limitState1===undefined) this.m_limitState1 = null;
            if(this.m_limitState2===undefined) this.m_limitState2 = null;
            this.m_ground = this.m_body1.m_world.getGroundBody();
            this.m_groundAnchor1 = def.groundAnchor1.sub(this.m_ground.m_xf.position);
            this.m_groundAnchor2 = def.groundAnchor2.sub(this.m_ground.m_xf.position);
            this.m_localAnchor1 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAnchor1);
            this.m_localAnchor2 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAnchor2);
            this.m_u1 = new org.jbox2d.common.Vec2();
            this.m_u2 = new org.jbox2d.common.Vec2();
            if(!((def.ratio !== 0.0))) throw new Error("Assertion error line 83: assert (def.ratio != 0.0F);");;
            this.m_ratio = def.ratio;
            this.m_constant = (<any>Math).fround(def.length1 + (<any>Math).fround(this.m_ratio * def.length2));
            this.m_maxLength1 = org.jbox2d.common.MathUtils.min(def.maxLength1, (<any>Math).fround(this.m_constant - (<any>Math).fround(this.m_ratio * PulleyJoint.MIN_PULLEY_LENGTH)));
            this.m_maxLength2 = org.jbox2d.common.MathUtils.min(def.maxLength2, (<any>Math).fround(((<any>Math).fround(this.m_constant - PulleyJoint.MIN_PULLEY_LENGTH)) / this.m_ratio));
            this.m_force = 0.0;
            this.m_limitForce1 = 0.0;
            this.m_limitForce2 = 0.0;
        }

        static tlr1 : org.jbox2d.pooling.TLVec2; public static tlr1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PulleyJoint.tlr1 == null) PulleyJoint.tlr1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlr1; };

        static tlr2 : org.jbox2d.pooling.TLVec2; public static tlr2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PulleyJoint.tlr2 == null) PulleyJoint.tlr2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlr2; };

        static tlp1 : org.jbox2d.pooling.TLVec2; public static tlp1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PulleyJoint.tlp1 == null) PulleyJoint.tlp1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlp1; };

        static tlp2 : org.jbox2d.pooling.TLVec2; public static tlp2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PulleyJoint.tlp2 == null) PulleyJoint.tlp2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlp2; };

        static tls1 : org.jbox2d.pooling.TLVec2; public static tls1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PulleyJoint.tls1 == null) PulleyJoint.tls1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tls1; };

        static tls2 : org.jbox2d.pooling.TLVec2; public static tls2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PulleyJoint.tls2 == null) PulleyJoint.tls2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tls2; };

        static tlP1 : org.jbox2d.pooling.TLVec2; public static tlP1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PulleyJoint.tlP1 == null) PulleyJoint.tlP1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlP1; };

        static tlP2 : org.jbox2d.pooling.TLVec2; public static tlP2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PulleyJoint.tlP2 == null) PulleyJoint.tlP2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlP2; };

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public initVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlr2_$LI$());
            let p1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlp1_$LI$());
            let p2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlp2_$LI$());
            let s1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tls1_$LI$());
            let s2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tls2_$LI$());
            let P1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlP1_$LI$());
            let P2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlP2_$LI$());
            r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
            r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
            r1.subLocal(this.m_localAnchor1).negateLocal();
            r2.subLocal(this.m_localAnchor2).negateLocal();
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
            p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
            p1.addLocal$org_jbox2d_common_Vec2(r1);
            p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
            p2.addLocal$org_jbox2d_common_Vec2(r2);
            s1.set$org_jbox2d_common_Vec2(this.m_ground.m_xf.position);
            s1.addLocal$org_jbox2d_common_Vec2(this.m_groundAnchor1);
            s2.set$org_jbox2d_common_Vec2(this.m_ground.m_xf.position);
            s2.addLocal$org_jbox2d_common_Vec2(this.m_groundAnchor2);
            this.m_u1.set$org_jbox2d_common_Vec2(p1);
            this.m_u1.subLocal(s1);
            this.m_u2.set$org_jbox2d_common_Vec2(p2);
            this.m_u2.subLocal(s2);
            let length1 : number = this.m_u1.length();
            let length2 : number = this.m_u2.length();
            if(length1 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                this.m_u1.mulLocal((<any>Math).fround(1.0 / length1));
            } else {
                this.m_u1.setZero();
            }
            if(length2 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                this.m_u2.mulLocal((<any>Math).fround(1.0 / length2));
            } else {
                this.m_u2.setZero();
            }
            let C : number = (<any>Math).fround((<any>Math).fround(this.m_constant - length1) - (<any>Math).fround(this.m_ratio * length2));
            if(C > 0.0) {
                this.m_state = org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT;
                this.m_force = 0.0;
            } else {
                this.m_state = org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT;
                this.m_positionImpulse = 0.0;
            }
            if(length1 < this.m_maxLength1) {
                this.m_limitState1 = org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT;
                this.m_limitForce1 = 0.0;
            } else {
                this.m_limitState1 = org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT;
                this.m_limitPositionImpulse1 = 0.0;
            }
            if(length2 < this.m_maxLength2) {
                this.m_limitState2 = org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT;
                this.m_limitForce2 = 0.0;
            } else {
                this.m_limitState2 = org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT;
                this.m_limitPositionImpulse2 = 0.0;
            }
            let cr1u1 : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, this.m_u1);
            let cr2u2 : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, this.m_u2);
            this.m_limitMass1 = (<any>Math).fround(b1.m_invMass + (<any>Math).fround((<any>Math).fround(b1.m_invI * cr1u1) * cr1u1));
            this.m_limitMass2 = (<any>Math).fround(b2.m_invMass + (<any>Math).fround((<any>Math).fround(b2.m_invI * cr2u2) * cr2u2));
            this.m_pulleyMass = (<any>Math).fround(this.m_limitMass1 + (<any>Math).fround((<any>Math).fround(this.m_ratio * this.m_ratio) * this.m_limitMass2));
            if(!((this.m_limitMass1 > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 181: assert (m_limitMass1 > Settings.EPSILON);");;
            if(!((this.m_limitMass2 > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 182: assert (m_limitMass2 > Settings.EPSILON);");;
            if(!((this.m_pulleyMass > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 183: assert (m_pulleyMass > Settings.EPSILON);");;
            this.m_limitMass1 = (<any>Math).fround(1.0 / this.m_limitMass1);
            this.m_limitMass2 = (<any>Math).fround(1.0 / this.m_limitMass2);
            this.m_pulleyMass = (<any>Math).fround(1.0 / this.m_pulleyMass);
            if(step.warmStarting) {
                P1.set$org_jbox2d_common_Vec2(this.m_u1);
                P1.mulLocal((<any>Math).fround(step.dt * ((<any>Math).fround(-this.m_force - this.m_limitForce1))));
                P2.set$org_jbox2d_common_Vec2(this.m_u2);
                P2.mulLocal((<any>Math).fround(step.dt * ((<any>Math).fround((<any>Math).fround(-this.m_ratio * this.m_force) - this.m_limitForce2))));
                b1.m_angularVelocity += (<any>Math).fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P1));
                b2.m_angularVelocity += (<any>Math).fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P2));
                b1.m_linearVelocity.addLocal$org_jbox2d_common_Vec2(P1.mulLocal(b1.m_invMass));
                b2.m_linearVelocity.addLocal$org_jbox2d_common_Vec2(P2.mulLocal(b2.m_invMass));
            } else {
                this.m_force = 0.0;
                this.m_limitForce1 = 0.0;
                this.m_limitForce2 = 0.0;
            }
        }

        static tlv1 : org.jbox2d.pooling.TLVec2; public static tlv1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PulleyJoint.tlv1 == null) PulleyJoint.tlv1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlv1; };

        static tlv2 : org.jbox2d.pooling.TLVec2; public static tlv2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PulleyJoint.tlv2 == null) PulleyJoint.tlv2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlv2; };

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public solveVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlv1_$LI$());
            let v2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlv2_$LI$());
            let P1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlP1_$LI$());
            let P2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlP2_$LI$());
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlr2_$LI$());
            r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
            r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
            r1.subLocal(this.m_localAnchor1).negateLocal();
            r2.subLocal(this.m_localAnchor2).negateLocal();
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
            if(this.m_state === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_angularVelocity, r1, v1);
                org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_angularVelocity, r2, v2);
                v1.add(b1.m_linearVelocity);
                v2.add(b2.m_linearVelocity);
                let Cdot : number = (<any>Math).fround(-org.jbox2d.common.Vec2.dot(this.m_u1, v1) - (<any>Math).fround(this.m_ratio * org.jbox2d.common.Vec2.dot(this.m_u2, v2)));
                let force : number = (<any>Math).fround((<any>Math).fround(-step.inv_dt * this.m_pulleyMass) * Cdot);
                let oldForce : number = this.m_force;
                this.m_force = org.jbox2d.common.MathUtils.max$float$float(0.0, (<any>Math).fround(this.m_force + force));
                force = (<any>Math).fround(this.m_force - oldForce);
                P1.set$org_jbox2d_common_Vec2(this.m_u1);
                P1.mulLocal((<any>Math).fround(-step.dt * force));
                P2.set$org_jbox2d_common_Vec2(this.m_u2);
                P2.mulLocal((<any>Math).fround((<any>Math).fround(-step.dt * this.m_ratio) * force));
                b1.m_linearVelocity.x += (<any>Math).fround(b1.m_invMass * P1.x);
                b1.m_linearVelocity.y += (<any>Math).fround(b1.m_invMass * P1.y);
                b1.m_angularVelocity += (<any>Math).fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P1));
                b2.m_linearVelocity.x += (<any>Math).fround(b2.m_invMass * P2.x);
                b2.m_linearVelocity.y += (<any>Math).fround(b2.m_invMass * P2.y);
                b2.m_angularVelocity += (<any>Math).fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P2));
            }
            if(this.m_limitState1 === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_angularVelocity, r1, v1);
                v1.addLocal$org_jbox2d_common_Vec2(b1.m_linearVelocity);
                let Cdot : number = -org.jbox2d.common.Vec2.dot(this.m_u1, v1);
                let force : number = (<any>Math).fround((<any>Math).fround(-step.inv_dt * this.m_limitMass1) * Cdot);
                let oldForce : number = this.m_limitForce1;
                this.m_limitForce1 = org.jbox2d.common.MathUtils.max$float$float(0.0, (<any>Math).fround(this.m_limitForce1 + force));
                force = (<any>Math).fround(this.m_limitForce1 - oldForce);
                P1.set$org_jbox2d_common_Vec2(this.m_u1);
                P1.mulLocal((<any>Math).fround(-step.dt * force));
                b1.m_linearVelocity.x += (<any>Math).fround(b1.m_invMass * P1.x);
                b1.m_linearVelocity.y += (<any>Math).fround(b1.m_invMass * P1.y);
                b1.m_angularVelocity += (<any>Math).fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P1));
            }
            if(this.m_limitState2 === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_angularVelocity, r2, v2);
                v2.addLocal$org_jbox2d_common_Vec2(b2.m_linearVelocity);
                let Cdot : number = -org.jbox2d.common.Vec2.dot(this.m_u2, v2);
                let force : number = (<any>Math).fround((<any>Math).fround(-step.inv_dt * this.m_limitMass2) * Cdot);
                let oldForce : number = this.m_limitForce2;
                this.m_limitForce2 = org.jbox2d.common.MathUtils.max$float$float(0.0, (<any>Math).fround(this.m_limitForce2 + force));
                force = (<any>Math).fround(this.m_limitForce2 - oldForce);
                P2.set$org_jbox2d_common_Vec2(this.m_u2);
                P2.mulLocal((<any>Math).fround(-step.dt * force));
                b2.m_linearVelocity.x += (<any>Math).fround(b2.m_invMass * P2.x);
                b2.m_linearVelocity.y += (<any>Math).fround(b2.m_invMass * P2.y);
                b2.m_angularVelocity += (<any>Math).fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P2));
            }
        }

        /**
         * 
         * @return {boolean}
         */
        public solvePositionConstraints() : boolean {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlr2_$LI$());
            let p1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlp1_$LI$());
            let p2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlp2_$LI$());
            let s1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tls1_$LI$());
            let s2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tls2_$LI$());
            let P1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlP1_$LI$());
            let P2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PulleyJoint.tlP2_$LI$());
            s1.set$org_jbox2d_common_Vec2(this.m_ground.m_xf.position);
            s1.addLocal$org_jbox2d_common_Vec2(this.m_groundAnchor1);
            s2.set$org_jbox2d_common_Vec2(this.m_ground.m_xf.position);
            s2.addLocal$org_jbox2d_common_Vec2(this.m_groundAnchor2);
            let linearError : number = 0.0;
            if(this.m_state === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
                r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
                r1.subLocal(this.m_localAnchor1).negateLocal();
                r2.subLocal(this.m_localAnchor2).negateLocal();
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
                p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
                p1.addLocal$org_jbox2d_common_Vec2(r1);
                p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                p2.addLocal$org_jbox2d_common_Vec2(r2);
                this.m_u1.set$float$float((<any>Math).fround(p1.x - s1.x), (<any>Math).fround(p1.y - s1.y));
                this.m_u2.set$float$float((<any>Math).fround(p2.x - s2.x), (<any>Math).fround(p2.y - s2.y));
                let length1 : number = this.m_u1.length();
                let length2 : number = this.m_u2.length();
                if(length1 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                    this.m_u1.mulLocal((<any>Math).fround(1.0 / length1));
                } else {
                    this.m_u1.setZero();
                }
                if(length2 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                    this.m_u2.mulLocal((<any>Math).fround(1.0 / length2));
                } else {
                    this.m_u2.setZero();
                }
                let C : number = (<any>Math).fround((<any>Math).fround(this.m_constant - length1) - (<any>Math).fround(this.m_ratio * length2));
                linearError = org.jbox2d.common.MathUtils.max$float$float(linearError, -C);
                C = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(C + org.jbox2d.common.Settings.linearSlop_$LI$()), -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), 0.0);
                let impulse : number = (<any>Math).fround(-this.m_pulleyMass * C);
                let oldImpulse : number = this.m_positionImpulse;
                this.m_positionImpulse = org.jbox2d.common.MathUtils.max$float$float(0.0, (<any>Math).fround(this.m_positionImpulse + impulse));
                impulse = (<any>Math).fround(this.m_positionImpulse - oldImpulse);
                P1.set$org_jbox2d_common_Vec2(this.m_u1);
                P1.mulLocal(-impulse);
                P2.set$org_jbox2d_common_Vec2(this.m_u2);
                P2.mulLocal((<any>Math).fround(-this.m_ratio * impulse));
                b1.m_sweep.c.x += (<any>Math).fround(b1.m_invMass * P1.x);
                b1.m_sweep.c.y += (<any>Math).fround(b1.m_invMass * P1.y);
                b1.m_sweep.a += (<any>Math).fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P1));
                b2.m_sweep.c.x += (<any>Math).fround(b2.m_invMass * P2.x);
                b2.m_sweep.c.y += (<any>Math).fround(b2.m_invMass * P2.y);
                b2.m_sweep.a += (<any>Math).fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P2));
                b1.synchronizeTransform();
                b2.synchronizeTransform();
            }
            if(this.m_limitState1 === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
                r1.subLocal(this.m_localAnchor1).negateLocal();
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
                p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
                p1.addLocal$org_jbox2d_common_Vec2(r1);
                this.m_u1.set$float$float((<any>Math).fround(p1.x - s1.x), (<any>Math).fround(p1.y - s1.y));
                let length1 : number = this.m_u1.length();
                if(length1 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                    this.m_u1.mulLocal((<any>Math).fround(1.0 / length1));
                } else {
                    this.m_u1.setZero();
                }
                let C : number = (<any>Math).fround(this.m_maxLength1 - length1);
                linearError = org.jbox2d.common.MathUtils.max$float$float(linearError, -C);
                C = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(C + org.jbox2d.common.Settings.linearSlop_$LI$()), -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), 0.0);
                let impulse : number = (<any>Math).fround(-this.m_limitMass1 * C);
                let oldLimitPositionImpulse : number = this.m_limitPositionImpulse1;
                this.m_limitPositionImpulse1 = org.jbox2d.common.MathUtils.max$float$float(0.0, (<any>Math).fround(this.m_limitPositionImpulse1 + impulse));
                impulse = (<any>Math).fround(this.m_limitPositionImpulse1 - oldLimitPositionImpulse);
                P1.set$org_jbox2d_common_Vec2(this.m_u1);
                P1.mulLocal(-impulse);
                b1.m_sweep.c.x += (<any>Math).fround(b1.m_invMass * P1.x);
                b1.m_sweep.c.y += (<any>Math).fround(b1.m_invMass * P1.y);
                b1.m_sweep.a += (<any>Math).fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P1));
                b1.synchronizeTransform();
            }
            if(this.m_limitState2 === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
                r2.subLocal(this.m_localAnchor2).negateLocal();
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
                p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                p2.addLocal$org_jbox2d_common_Vec2(r2);
                this.m_u2.set$float$float((<any>Math).fround(p2.x - s2.x), (<any>Math).fround(p2.y - s2.y));
                let length2 : number = this.m_u2.length();
                if(length2 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                    this.m_u2.mulLocal((<any>Math).fround(1.0 / length2));
                } else {
                    this.m_u2.setZero();
                }
                let C : number = (<any>Math).fround(this.m_maxLength2 - length2);
                linearError = org.jbox2d.common.MathUtils.max$float$float(linearError, -C);
                C = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(C + org.jbox2d.common.Settings.linearSlop_$LI$()), -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), 0.0);
                let impulse : number = (<any>Math).fround(-this.m_limitMass2 * C);
                let oldLimitPositionImpulse : number = this.m_limitPositionImpulse2;
                this.m_limitPositionImpulse2 = org.jbox2d.common.MathUtils.max$float$float(0.0, (<any>Math).fround(this.m_limitPositionImpulse2 + impulse));
                impulse = (<any>Math).fround(this.m_limitPositionImpulse2 - oldLimitPositionImpulse);
                P2.set$org_jbox2d_common_Vec2(this.m_u2);
                P2.mulLocal(-impulse);
                b2.m_sweep.c.x += (<any>Math).fround(b2.m_invMass * P2.x);
                b2.m_sweep.c.y += (<any>Math).fround(b2.m_invMass * P2.y);
                b2.m_sweep.a += (<any>Math).fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P2));
                b2.synchronizeTransform();
            }
            return linearError < org.jbox2d.common.Settings.linearSlop_$LI$();
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor1() : org.jbox2d.common.Vec2 {
            return this.m_body1.getWorldLocation(this.m_localAnchor1);
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor2() : org.jbox2d.common.Vec2 {
            return this.m_body2.getWorldLocation(this.m_localAnchor2);
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getReactionForce() : org.jbox2d.common.Vec2 {
            let F : org.jbox2d.common.Vec2 = this.m_u2.mul(this.m_force);
            return F;
        }

        /**
         * 
         * @return {number}
         */
        public getReactionTorque() : number {
            return 0.0;
        }

        public getGroundAnchor1() : org.jbox2d.common.Vec2 {
            return this.m_ground.m_xf.position.add(this.m_groundAnchor1);
        }

        public getGroundAnchor2() : org.jbox2d.common.Vec2 {
            return this.m_ground.m_xf.position.add(this.m_groundAnchor2);
        }

        public getLength1() : number {
            let p : org.jbox2d.common.Vec2 = this.m_body1.getWorldLocation(this.m_localAnchor1);
            let s : org.jbox2d.common.Vec2 = this.m_ground.m_xf.position.add(this.m_groundAnchor1);
            let d : org.jbox2d.common.Vec2 = p.subLocal(s);
            return d.length();
        }

        public getLength2() : number {
            let p : org.jbox2d.common.Vec2 = this.m_body2.getWorldLocation(this.m_localAnchor2);
            let s : org.jbox2d.common.Vec2 = this.m_ground.m_xf.position.add(this.m_groundAnchor2);
            let d : org.jbox2d.common.Vec2 = p.subLocal(s);
            return d.length();
        }

        public getRatio() : number {
            return this.m_ratio;
        }
    }
    PulleyJoint["__class"] = "org.jbox2d.dynamics.joints.PulleyJoint";

}
namespace org.jbox2d.dynamics.joints {
    export class RevoluteJoint extends org.jbox2d.dynamics.joints.Joint {
        public m_localAnchor1 : org.jbox2d.common.Vec2;

        public m_localAnchor2 : org.jbox2d.common.Vec2;

        public m_pivotForce : org.jbox2d.common.Vec2;

        public m_motorForce : number;

        public m_limitForce : number;

        public m_limitPositionImpulse : number;

        public m_pivotMass : org.jbox2d.common.Mat22;

        public m_motorMass : number;

        public m_enableMotor : boolean;

        public m_maxMotorTorque : number;

        public m_motorSpeed : number;

        public m_enableLimit : boolean;

        public m_referenceAngle : number;

        public m_lowerAngle : number;

        public m_upperAngle : number;

        public m_limitState : org.jbox2d.dynamics.joints.LimitState;

        public constructor(def : org.jbox2d.dynamics.joints.RevoluteJointDef) {
            super(def);
            if(this.m_localAnchor1===undefined) this.m_localAnchor1 = null;
            if(this.m_localAnchor2===undefined) this.m_localAnchor2 = null;
            if(this.m_pivotForce===undefined) this.m_pivotForce = null;
            if(this.m_motorForce===undefined) this.m_motorForce = 0;
            if(this.m_limitForce===undefined) this.m_limitForce = 0;
            if(this.m_limitPositionImpulse===undefined) this.m_limitPositionImpulse = 0;
            if(this.m_pivotMass===undefined) this.m_pivotMass = null;
            if(this.m_motorMass===undefined) this.m_motorMass = 0;
            if(this.m_enableMotor===undefined) this.m_enableMotor = false;
            if(this.m_maxMotorTorque===undefined) this.m_maxMotorTorque = 0;
            if(this.m_motorSpeed===undefined) this.m_motorSpeed = 0;
            if(this.m_enableLimit===undefined) this.m_enableLimit = false;
            if(this.m_referenceAngle===undefined) this.m_referenceAngle = 0;
            if(this.m_lowerAngle===undefined) this.m_lowerAngle = 0;
            if(this.m_upperAngle===undefined) this.m_upperAngle = 0;
            if(this.m_limitState===undefined) this.m_limitState = null;
            this.m_localAnchor1 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAnchor1);
            this.m_localAnchor2 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(def.localAnchor2);
            this.m_referenceAngle = def.referenceAngle;
            this.m_pivotForce = new org.jbox2d.common.Vec2(0.0, 0.0);
            this.m_motorForce = 0.0;
            this.m_limitForce = 0.0;
            this.m_limitPositionImpulse = 0.0;
            this.m_pivotMass = new org.jbox2d.common.Mat22();
            this.m_lowerAngle = def.lowerAngle;
            this.m_upperAngle = def.upperAngle;
            this.m_maxMotorTorque = def.maxMotorTorque;
            this.m_motorSpeed = def.motorSpeed;
            this.m_enableLimit = def.enableLimit;
            this.m_enableMotor = def.enableMotor;
        }

        static tlr1 : org.jbox2d.pooling.TLVec2; public static tlr1_$LI$() : org.jbox2d.pooling.TLVec2 { if(RevoluteJoint.tlr1 == null) RevoluteJoint.tlr1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlr1; };

        static tlr2 : org.jbox2d.pooling.TLVec2; public static tlr2_$LI$() : org.jbox2d.pooling.TLVec2 { if(RevoluteJoint.tlr2 == null) RevoluteJoint.tlr2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlr2; };

        static tlK1 : org.jbox2d.pooling.TLMat22; public static tlK1_$LI$() : org.jbox2d.pooling.TLMat22 { if(RevoluteJoint.tlK1 == null) RevoluteJoint.tlK1 = (() => { let __o : any = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return RevoluteJoint.tlK1; };

        static tlK2 : org.jbox2d.pooling.TLMat22; public static tlK2_$LI$() : org.jbox2d.pooling.TLMat22 { if(RevoluteJoint.tlK2 == null) RevoluteJoint.tlK2 = (() => { let __o : any = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return RevoluteJoint.tlK2; };

        static tlK3 : org.jbox2d.pooling.TLMat22; public static tlK3_$LI$() : org.jbox2d.pooling.TLMat22 { if(RevoluteJoint.tlK3 == null) RevoluteJoint.tlK3 = (() => { let __o : any = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return RevoluteJoint.tlK3; };

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public initVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlr2_$LI$());
            let K1 : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlK1_$LI$());
            let K2 : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlK2_$LI$());
            let K3 : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlK3_$LI$());
            r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
            r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
            r1.subLocal(this.m_localAnchor1).negateLocal();
            r2.subLocal(this.m_localAnchor2).negateLocal();
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
            let invMass1 : number = b1.m_invMass;
            let invMass2 : number = b2.m_invMass;
            let invI1 : number = b1.m_invI;
            let invI2 : number = b2.m_invI;
            K1.col1.x = (<any>Math).fround(invMass1 + invMass2);
            K1.col2.x = 0.0;
            K1.col1.y = 0.0;
            K1.col2.y = (<any>Math).fround(invMass1 + invMass2);
            K2.col1.x = (<any>Math).fround((<any>Math).fround(invI1 * r1.y) * r1.y);
            K2.col2.x = (<any>Math).fround((<any>Math).fround(-invI1 * r1.x) * r1.y);
            K2.col1.y = (<any>Math).fround((<any>Math).fround(-invI1 * r1.x) * r1.y);
            K2.col2.y = (<any>Math).fround((<any>Math).fround(invI1 * r1.x) * r1.x);
            K3.col1.x = (<any>Math).fround((<any>Math).fround(invI2 * r2.y) * r2.y);
            K3.col2.x = (<any>Math).fround((<any>Math).fround(-invI2 * r2.x) * r2.y);
            K3.col1.y = (<any>Math).fround((<any>Math).fround(-invI2 * r2.x) * r2.y);
            K3.col2.y = (<any>Math).fround((<any>Math).fround(invI2 * r2.x) * r2.x);
            K1.addLocal(K2).addLocal(K3);
            K1.invertToOut(this.m_pivotMass);
            this.m_motorMass = (<any>Math).fround(1.0 / ((<any>Math).fround(invI1 + invI2)));
            if(this.m_enableMotor === false) {
                this.m_motorForce = 0.0;
            }
            if(this.m_enableLimit) {
                let jointAngle : number = (<any>Math).fround((<any>Math).fround(b2.m_sweep.a - b1.m_sweep.a) - this.m_referenceAngle);
                if(org.jbox2d.common.MathUtils.abs((<any>Math).fround(this.m_upperAngle - this.m_lowerAngle)) < (<any>Math).fround(2.0 * org.jbox2d.common.Settings.angularSlop_$LI$())) {
                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS;
                } else if(jointAngle <= this.m_lowerAngle) {
                    if(this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                        this.m_limitForce = 0.0;
                    }
                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT;
                } else if(jointAngle >= this.m_upperAngle) {
                    if(this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                        this.m_limitForce = 0.0;
                    }
                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT;
                } else {
                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT;
                    this.m_limitForce = 0.0;
                }
            } else {
                this.m_limitForce = 0.0;
            }
            if(step.warmStarting) {
                b1.m_linearVelocity.x -= (<any>Math).fround((<any>Math).fround(step.dt * invMass1) * this.m_pivotForce.x);
                b1.m_linearVelocity.y -= (<any>Math).fround((<any>Math).fround(step.dt * invMass1) * this.m_pivotForce.y);
                b1.m_angularVelocity -= (<any>Math).fround((<any>Math).fround(step.dt * invI1) * ((<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, this.m_pivotForce) + this.m_motorForce) + this.m_limitForce)));
                b2.m_linearVelocity.x += (<any>Math).fround((<any>Math).fround(step.dt * invMass2) * this.m_pivotForce.x);
                b2.m_linearVelocity.y += (<any>Math).fround((<any>Math).fround(step.dt * invMass2) * this.m_pivotForce.y);
                b2.m_angularVelocity += (<any>Math).fround((<any>Math).fround(step.dt * invI2) * ((<any>Math).fround((<any>Math).fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, this.m_pivotForce) + this.m_motorForce) + this.m_limitForce)));
            } else {
                this.m_pivotForce.setZero();
                this.m_motorForce = 0.0;
                this.m_limitForce = 0.0;
            }
            this.m_limitPositionImpulse = 0.0;
        }

        m_lastWarmStartingPivotForce : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(0.0, 0.0);

        static tltemp : org.jbox2d.pooling.TLVec2; public static tltemp_$LI$() : org.jbox2d.pooling.TLVec2 { if(RevoluteJoint.tltemp == null) RevoluteJoint.tltemp = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tltemp; };

        static tlpivotCdot : org.jbox2d.pooling.TLVec2; public static tlpivotCdot_$LI$() : org.jbox2d.pooling.TLVec2 { if(RevoluteJoint.tlpivotCdot == null) RevoluteJoint.tlpivotCdot = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlpivotCdot; };

        static tlpivotForce : org.jbox2d.pooling.TLVec2; public static tlpivotForce_$LI$() : org.jbox2d.pooling.TLVec2 { if(RevoluteJoint.tlpivotForce == null) RevoluteJoint.tlpivotForce = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlpivotForce; };

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public solveVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let temp : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tltemp_$LI$());
            let pivotCdot : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlpivotCdot_$LI$());
            let pivotForce : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlpivotForce_$LI$());
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlr2_$LI$());
            r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
            r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
            r1.subLocal(this.m_localAnchor1).negateLocal();
            r2.subLocal(this.m_localAnchor2).negateLocal();
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_angularVelocity, r1, temp);
            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_angularVelocity, r2, pivotCdot);
            pivotCdot.subLocal(b1.m_linearVelocity).subLocal(temp).addLocal$org_jbox2d_common_Vec2(b2.m_linearVelocity);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_pivotMass, pivotCdot, pivotForce);
            pivotForce.mulLocal(-step.inv_dt);
            if(step.warmStarting) {
                this.m_pivotForce.addLocal$org_jbox2d_common_Vec2(pivotForce);
                this.m_lastWarmStartingPivotForce.set$org_jbox2d_common_Vec2(this.m_pivotForce);
            } else {
                this.m_pivotForce.set$org_jbox2d_common_Vec2(this.m_lastWarmStartingPivotForce);
            }
            let P : org.jbox2d.common.Vec2 = pivotForce.mulLocal(step.dt);
            b1.m_linearVelocity.x -= (<any>Math).fround(b1.m_invMass * P.x);
            b1.m_linearVelocity.y -= (<any>Math).fround(b1.m_invMass * P.y);
            b1.m_angularVelocity -= (<any>Math).fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P));
            b2.m_linearVelocity.x += (<any>Math).fround(b2.m_invMass * P.x);
            b2.m_linearVelocity.y += (<any>Math).fround(b2.m_invMass * P.y);
            b2.m_angularVelocity += (<any>Math).fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P));
            if(this.m_enableMotor && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                let motorCdot : number = (<any>Math).fround((<any>Math).fround(b2.m_angularVelocity - b1.m_angularVelocity) - this.m_motorSpeed);
                let motorForce : number = (<any>Math).fround((<any>Math).fround(-step.inv_dt * this.m_motorMass) * motorCdot);
                let oldMotorForce : number = this.m_motorForce;
                this.m_motorForce = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(this.m_motorForce + motorForce), -this.m_maxMotorTorque, this.m_maxMotorTorque);
                motorForce = (<any>Math).fround(this.m_motorForce - oldMotorForce);
                if(!step.warmStarting) {
                    this.m_motorForce = oldMotorForce;
                }
                let P2 : number = (<any>Math).fround(step.dt * motorForce);
                b1.m_angularVelocity -= (<any>Math).fround(b1.m_invI * P2);
                b2.m_angularVelocity += (<any>Math).fround(b2.m_invI * P2);
            }
            if(this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT) {
                let limitCdot : number = (<any>Math).fround(b2.m_angularVelocity - b1.m_angularVelocity);
                let limitForce : number = (<any>Math).fround((<any>Math).fround(-step.inv_dt * this.m_motorMass) * limitCdot);
                if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                    this.m_limitForce += limitForce;
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                    let oldLimitForce : number = this.m_limitForce;
                    this.m_limitForce = org.jbox2d.common.MathUtils.max$float$float((<any>Math).fround(this.m_limitForce + limitForce), 0.0);
                    limitForce = (<any>Math).fround(this.m_limitForce - oldLimitForce);
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                    let oldLimitForce : number = this.m_limitForce;
                    this.m_limitForce = org.jbox2d.common.MathUtils.min((<any>Math).fround(this.m_limitForce + limitForce), 0.0);
                    limitForce = (<any>Math).fround(this.m_limitForce - oldLimitForce);
                }
                let P2 : number = (<any>Math).fround(step.dt * limitForce);
                b1.m_angularVelocity -= (<any>Math).fround(b1.m_invI * P2);
                b2.m_angularVelocity += (<any>Math).fround(b2.m_invI * P2);
            }
        }

        static tlp1 : org.jbox2d.pooling.TLVec2; public static tlp1_$LI$() : org.jbox2d.pooling.TLVec2 { if(RevoluteJoint.tlp1 == null) RevoluteJoint.tlp1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlp1; };

        static tlp2 : org.jbox2d.pooling.TLVec2; public static tlp2_$LI$() : org.jbox2d.pooling.TLVec2 { if(RevoluteJoint.tlp2 == null) RevoluteJoint.tlp2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlp2; };

        static tlptpC : org.jbox2d.pooling.TLVec2; public static tlptpC_$LI$() : org.jbox2d.pooling.TLVec2 { if(RevoluteJoint.tlptpC == null) RevoluteJoint.tlptpC = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlptpC; };

        static tlimpulse : org.jbox2d.pooling.TLVec2; public static tlimpulse_$LI$() : org.jbox2d.pooling.TLVec2 { if(RevoluteJoint.tlimpulse == null) RevoluteJoint.tlimpulse = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlimpulse; };

        /**
         * 
         * @return {boolean}
         */
        public solvePositionConstraints() : boolean {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            let p1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlp1_$LI$());
            let p2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlp2_$LI$());
            let ptpC : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlptpC_$LI$());
            let impulse : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlimpulse_$LI$());
            let r1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlr1_$LI$());
            let r2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlr2_$LI$());
            let K1 : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlK1_$LI$());
            let K2 : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlK2_$LI$());
            let K3 : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(RevoluteJoint.tlK3_$LI$());
            let positionError : number = 0.0;
            r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
            r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
            r1.subLocal(this.m_localAnchor1).negateLocal();
            r2.subLocal(this.m_localAnchor2).negateLocal();
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
            p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
            p1.addLocal$org_jbox2d_common_Vec2(r1);
            p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
            p2.addLocal$org_jbox2d_common_Vec2(r2);
            ptpC.set$org_jbox2d_common_Vec2(p2);
            ptpC.subLocal(p1);
            positionError = ptpC.length();
            let invMass1 : number = b1.m_invMass;
            let invMass2 : number = b2.m_invMass;
            let invI1 : number = b1.m_invI;
            let invI2 : number = b2.m_invI;
            K1.col1.x = (<any>Math).fround(invMass1 + invMass2);
            K1.col2.x = 0.0;
            K1.col1.y = 0.0;
            K1.col2.y = (<any>Math).fround(invMass1 + invMass2);
            K2.col1.x = (<any>Math).fround((<any>Math).fround(invI1 * r1.y) * r1.y);
            K2.col2.x = (<any>Math).fround((<any>Math).fround(-invI1 * r1.x) * r1.y);
            K2.col1.y = (<any>Math).fround((<any>Math).fround(-invI1 * r1.x) * r1.y);
            K2.col2.y = (<any>Math).fround((<any>Math).fround(invI1 * r1.x) * r1.x);
            K3.col1.x = (<any>Math).fround((<any>Math).fround(invI2 * r2.y) * r2.y);
            K3.col2.x = (<any>Math).fround((<any>Math).fround(-invI2 * r2.x) * r2.y);
            K3.col1.y = (<any>Math).fround((<any>Math).fround(-invI2 * r2.x) * r2.y);
            K3.col2.y = (<any>Math).fround((<any>Math).fround(invI2 * r2.x) * r2.x);
            let K : org.jbox2d.common.Mat22 = K1.addLocal(K2).addLocal(K3);
            K.solveToOut(ptpC.negateLocal(), impulse);
            b1.m_sweep.c.x -= (<any>Math).fround(b1.m_invMass * impulse.x);
            b1.m_sweep.c.y -= (<any>Math).fround(b1.m_invMass * impulse.y);
            b1.m_sweep.a -= (<any>Math).fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, impulse));
            b2.m_sweep.c.x += (<any>Math).fround(b2.m_invMass * impulse.x);
            b2.m_sweep.c.y += (<any>Math).fround(b2.m_invMass * impulse.y);
            b2.m_sweep.a += (<any>Math).fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, impulse));
            b1.synchronizeTransform();
            b2.synchronizeTransform();
            let angularError : number = 0.0;
            if(this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT) {
                let angle : number = (<any>Math).fround((<any>Math).fround(b2.m_sweep.a - b1.m_sweep.a) - this.m_referenceAngle);
                let limitImpulse : number = 0.0;
                if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                    let limitC : number = org.jbox2d.common.MathUtils.clamp$float$float$float(angle, -org.jbox2d.common.Settings.maxAngularCorrection_$LI$(), org.jbox2d.common.Settings.maxAngularCorrection_$LI$());
                    limitImpulse = (<any>Math).fround(-this.m_motorMass * limitC);
                    angularError = org.jbox2d.common.MathUtils.abs(limitC);
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                    let limitC : number = (<any>Math).fround(angle - this.m_lowerAngle);
                    angularError = org.jbox2d.common.MathUtils.max$float$float(0.0, -limitC);
                    limitC = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(limitC + org.jbox2d.common.Settings.angularSlop_$LI$()), -org.jbox2d.common.Settings.maxAngularCorrection_$LI$(), 0.0);
                    limitImpulse = (<any>Math).fround(-this.m_motorMass * limitC);
                    let oldLimitImpulse : number = this.m_limitPositionImpulse;
                    this.m_limitPositionImpulse = org.jbox2d.common.MathUtils.max$float$float((<any>Math).fround(this.m_limitPositionImpulse + limitImpulse), 0.0);
                    limitImpulse = (<any>Math).fround(this.m_limitPositionImpulse - oldLimitImpulse);
                } else if(this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                    let limitC : number = (<any>Math).fround(angle - this.m_upperAngle);
                    angularError = org.jbox2d.common.MathUtils.max$float$float(0.0, limitC);
                    limitC = org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(limitC - org.jbox2d.common.Settings.angularSlop_$LI$()), 0.0, org.jbox2d.common.Settings.maxAngularCorrection_$LI$());
                    limitImpulse = (<any>Math).fround(-this.m_motorMass * limitC);
                    let oldLimitImpulse : number = this.m_limitPositionImpulse;
                    this.m_limitPositionImpulse = org.jbox2d.common.MathUtils.min((<any>Math).fround(this.m_limitPositionImpulse + limitImpulse), 0.0);
                    limitImpulse = (<any>Math).fround(this.m_limitPositionImpulse - oldLimitImpulse);
                }
                b1.m_sweep.a -= (<any>Math).fround(b1.m_invI * limitImpulse);
                b2.m_sweep.a += (<any>Math).fround(b2.m_invI * limitImpulse);
                b1.synchronizeTransform();
                b2.synchronizeTransform();
            }
            return positionError <= org.jbox2d.common.Settings.linearSlop_$LI$() && angularError <= org.jbox2d.common.Settings.angularSlop_$LI$();
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor1() : org.jbox2d.common.Vec2 {
            return this.m_body1.getWorldLocation(this.m_localAnchor1);
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor2() : org.jbox2d.common.Vec2 {
            return this.m_body2.getWorldLocation(this.m_localAnchor2);
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getReactionForce() : org.jbox2d.common.Vec2 {
            return this.m_pivotForce;
        }

        /**
         * 
         * @return {number}
         */
        public getReactionTorque() : number {
            return this.m_limitForce;
        }

        public getJointAngle() : number {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            return (<any>Math).fround((<any>Math).fround(b2.m_sweep.a - b1.m_sweep.a) - this.m_referenceAngle);
        }

        public getJointSpeed() : number {
            let b1 : org.jbox2d.dynamics.Body = this.m_body1;
            let b2 : org.jbox2d.dynamics.Body = this.m_body2;
            return (<any>Math).fround(b2.m_angularVelocity - b1.m_angularVelocity);
        }

        public isMotorEnabled() : boolean {
            return this.m_enableMotor;
        }

        public enableMotor(flag : boolean) {
            this.m_enableMotor = flag;
        }

        public getMotorTorque() : number {
            return this.m_motorForce;
        }

        public setMotorSpeed(speed : number) {
            this.m_motorSpeed = speed;
        }

        public setMaxMotorTorque(torque : number) {
            this.m_maxMotorTorque = torque;
        }

        public isLimitEnabled() : boolean {
            return this.m_enableLimit;
        }

        public enableLimit(flag : boolean) {
            this.m_enableLimit = flag;
        }

        public getLowerLimit() : number {
            return this.m_lowerAngle;
        }

        public getUpperLimit() : number {
            return this.m_upperAngle;
        }

        public setLimits(lower : number, upper : number) {
            if(!((lower <= upper))) throw new Error("Assertion error line 410: assert (lower <= upper);");;
            this.m_lowerAngle = lower;
            this.m_upperAngle = upper;
        }
    }
    RevoluteJoint["__class"] = "org.jbox2d.dynamics.joints.RevoluteJoint";

}
namespace org.jbox2d.collision {
    /**
     * Handles conservative advancement to compute time of impact between shapes.
     * @class
     */
    export class TOI {
        static tlxf1 : org.jbox2d.pooling.TLXForm; public static tlxf1_$LI$() : org.jbox2d.pooling.TLXForm { if(TOI.tlxf1 == null) TOI.tlxf1 = (() => { let __o : any = new org.jbox2d.pooling.TLXForm(); __o.__delegate = new org.jbox2d.pooling.TLXForm(); return __o; })(); return TOI.tlxf1; };

        static tlxf2 : org.jbox2d.pooling.TLXForm; public static tlxf2_$LI$() : org.jbox2d.pooling.TLXForm { if(TOI.tlxf2 == null) TOI.tlxf2 = (() => { let __o : any = new org.jbox2d.pooling.TLXForm(); __o.__delegate = new org.jbox2d.pooling.TLXForm(); return __o; })(); return TOI.tlxf2; };

        static tlP1 : org.jbox2d.pooling.TLVec2; public static tlP1_$LI$() : org.jbox2d.pooling.TLVec2 { if(TOI.tlP1 == null) TOI.tlP1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return TOI.tlP1; };

        static tlP2 : org.jbox2d.pooling.TLVec2; public static tlP2_$LI$() : org.jbox2d.pooling.TLVec2 { if(TOI.tlP2 == null) TOI.tlP2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return TOI.tlP2; };

        /**
         * Compute the time when two shapes begin to touch or touch at a closer distance.
         * <BR><BR><em>Warning</em>: the sweeps must have the same time interval.
         * @return {number} the fraction between [0,1] in which the shapes first touch.
         * fraction=0 means the shapes begin touching/overlapped, and fraction=1 means the shapes don't touch.
         * @param {org.jbox2d.collision.shapes.Shape} shape1
         * @param {org.jbox2d.common.Sweep} sweep1
         * @param {org.jbox2d.collision.shapes.Shape} shape2
         * @param {org.jbox2d.common.Sweep} sweep2
         */
        public static timeOfImpact(shape1 : org.jbox2d.collision.shapes.Shape, sweep1 : org.jbox2d.common.Sweep, shape2 : org.jbox2d.collision.shapes.Shape, sweep2 : org.jbox2d.common.Sweep) : number {
            let xf1 : org.jbox2d.common.XForm = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(TOI.tlxf1_$LI$());
            let xf2 : org.jbox2d.common.XForm = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(TOI.tlxf2_$LI$());
            let p1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(TOI.tlP1_$LI$());
            let p2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(TOI.tlP2_$LI$());
            let r1 : number = shape1.getSweepRadius();
            let r2 : number = shape2.getSweepRadius();
            if(!((sweep1.t0 === sweep2.t0))) throw new Error("Assertion error line 32: assert (sweep1.t0 == sweep2.t0);");;
            if(!(((<any>Math).fround(1.0 - sweep1.t0) > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 33: assert (1.0F - sweep1.t0 > Settings.EPSILON);");;
            let t0 : number = sweep1.t0;
            let vx : number = (<any>Math).fround(((<any>Math).fround(sweep1.c.x - sweep1.c0.x)) - ((<any>Math).fround(sweep2.c.x - sweep2.c0.x)));
            let vy : number = (<any>Math).fround(((<any>Math).fround(sweep1.c.y - sweep1.c0.y)) - ((<any>Math).fround(sweep2.c.y - sweep2.c0.y)));
            let omega1 : number = (<any>Math).fround(sweep1.a - sweep1.a0);
            let omega2 : number = (<any>Math).fround(sweep2.a - sweep2.a0);
            let alpha : number = 0.0;
            let k_maxIterations : number = 20;
            let iter : number = 0;
            let distance : number = 0.0;
            let targetDistance : number = 0.0;
            while((true)) {{
                let t : number = (<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - alpha)) * t0) + alpha);
                sweep1.getXForm(xf1, t);
                sweep2.getXForm(xf2, t);
                distance = org.jbox2d.pooling.SingletonPool.getDistance().distance(p1, p2, shape1, xf1, shape2, xf2);
                if(iter === 0) {
                    if(distance > (<any>Math).fround(2.0 * org.jbox2d.common.Settings.toiSlop_$LI$())) {
                        targetDistance = (<any>Math).fround(1.5 * org.jbox2d.common.Settings.toiSlop_$LI$());
                    } else {
                        targetDistance = org.jbox2d.common.MathUtils.max$float$float((<any>Math).fround(0.05 * org.jbox2d.common.Settings.toiSlop_$LI$()), (<any>Math).fround(distance - (<any>Math).fround(0.5 * org.jbox2d.common.Settings.toiSlop_$LI$())));
                    }
                }
                if((<any>Math).fround(distance - targetDistance) < (<any>Math).fround(0.05 * org.jbox2d.common.Settings.toiSlop_$LI$()) || iter === k_maxIterations) {
                    break;
                }
                let normalx : number = (<any>Math).fround(p2.x - p1.x);
                let normaly : number = (<any>Math).fround(p2.y - p1.y);
                let lenSqrd : number = (<any>Math).fround((<any>Math).fround(normalx * normalx) + (<any>Math).fround(normaly * normaly));
                if(lenSqrd >= (<any>Math).fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON)) {
                    let length : number = org.jbox2d.common.MathUtils.sqrt(lenSqrd);
                    let invLength : number = (<any>Math).fround(1.0 / length);
                    normalx *= invLength;
                    normaly *= invLength;
                }
                let approachVelocityBound : number = (<any>Math).fround((<any>Math).fround(((<any>Math).fround((<any>Math).fround(normalx * vx) + (<any>Math).fround(normaly * vy))) + (<any>Math).fround(org.jbox2d.common.MathUtils.abs(omega1) * r1)) + (<any>Math).fround(org.jbox2d.common.MathUtils.abs(omega2) * r2));
                if(org.jbox2d.common.MathUtils.abs(approachVelocityBound) < org.jbox2d.common.Settings.EPSILON) {
                    alpha = 1.0;
                    break;
                }
                let dAlpha : number = (<any>Math).fround(((<any>Math).fround(distance - targetDistance)) / approachVelocityBound);
                let newAlpha : number = (<any>Math).fround(alpha + dAlpha);
                if(newAlpha < 0.0 || 1.0 < newAlpha) {
                    alpha = 1.0;
                    break;
                }
                if(newAlpha < (<any>Math).fround(((<any>Math).fround(1.0 + (<any>Math).fround(100.0 * org.jbox2d.common.Settings.EPSILON))) * alpha)) {
                    break;
                }
                alpha = newAlpha;
                ++iter;
            }};
            return alpha;
        }
    }
    TOI["__class"] = "org.jbox2d.collision.TOI";

}
namespace org.jbox2d.dynamics {
    /**
     * Should not be called by user, as it will not
     * be properly added to the world.  Instead,
     * create a BodyDef object and pass it
     * to World.createDynamicBody or World.createStaticBody.
     * 
     * @param {org.jbox2d.dynamics.BodyDef} bd Body definition
     * @param {org.jbox2d.dynamics.World} world World to create body in
     * @class
     */
    export class Body {
        static nextID : number = 0;

        static idLock : any; public static idLock_$LI$() : any { if(Body.idLock == null) Body.idLock = <any>new Object(); return Body.idLock; };

        /*private*/ m_uniqueID : number;

        public static e_frozenFlag : number = 2;

        public static e_islandFlag : number = 4;

        public static e_sleepFlag : number = 8;

        public static e_allowSleepFlag : number = 16;

        public static e_bulletFlag : number = 32;

        public static e_fixedRotationFlag : number = 64;

        public m_flags : number;

        public static e_staticType : number = 0;

        public static e_dynamicType : number = 1;

        public static e_maxTypes : number = 2;

        public m_type : number;

        public m_controllerList : org.jbox2d.dynamics.controllers.ControllerEdge;

        /**
         * The body origin transform
         */
        public m_xf : org.jbox2d.common.XForm;

        /**
         * The swept motion for CCD
         */
        public m_sweep : org.jbox2d.common.Sweep;

        public m_linearVelocity : org.jbox2d.common.Vec2;

        public m_angularVelocity : number;

        public m_force : org.jbox2d.common.Vec2;

        public m_torque : number;

        public m_world : org.jbox2d.dynamics.World;

        public m_prev : Body;

        public m_next : Body;

        public m_shapeList : org.jbox2d.collision.shapes.Shape;

        public m_shapeCount : number;

        public m_jointList : org.jbox2d.dynamics.joints.JointEdge;

        public m_contactList : org.jbox2d.dynamics.contacts.ContactEdge;

        public m_mass : number;

        public m_invMass : number;

        public m_I : number;

        public m_invI : number;

        public m_linearDamping : number;

        public m_angularDamping : number;

        public m_sleepTime : number;

        /**
         * A holder to attach external data to a body.
         * Useful to keep track of what game entity
         * each body represents. This is copied from
         * the BodyDef used to create the body, so may
         * be set there instead.
         */
        public m_userData : any;

        public constructor(bd? : any, world? : any) {
            if(((bd != null && bd instanceof <any>org.jbox2d.dynamics.BodyDef) || bd === null) && ((world != null && world instanceof <any>org.jbox2d.dynamics.World) || world === null)) {
                let __args = arguments;
                if(this.m_uniqueID===undefined) this.m_uniqueID = 0;
                if(this.m_flags===undefined) this.m_flags = 0;
                if(this.m_type===undefined) this.m_type = 0;
                if(this.m_controllerList===undefined) this.m_controllerList = null;
                if(this.m_xf===undefined) this.m_xf = null;
                if(this.m_sweep===undefined) this.m_sweep = null;
                if(this.m_linearVelocity===undefined) this.m_linearVelocity = null;
                if(this.m_angularVelocity===undefined) this.m_angularVelocity = 0;
                if(this.m_force===undefined) this.m_force = null;
                if(this.m_torque===undefined) this.m_torque = 0;
                if(this.m_world===undefined) this.m_world = null;
                if(this.m_prev===undefined) this.m_prev = null;
                if(this.m_next===undefined) this.m_next = null;
                if(this.m_shapeList===undefined) this.m_shapeList = null;
                if(this.m_shapeCount===undefined) this.m_shapeCount = 0;
                if(this.m_jointList===undefined) this.m_jointList = null;
                if(this.m_contactList===undefined) this.m_contactList = null;
                if(this.m_mass===undefined) this.m_mass = 0;
                if(this.m_invMass===undefined) this.m_invMass = 0;
                if(this.m_I===undefined) this.m_I = 0;
                if(this.m_invI===undefined) this.m_invI = 0;
                if(this.m_linearDamping===undefined) this.m_linearDamping = 0;
                if(this.m_angularDamping===undefined) this.m_angularDamping = 0;
                if(this.m_sleepTime===undefined) this.m_sleepTime = 0;
                if(this.m_userData===undefined) this.m_userData = null;
                if(this.m_uniqueID===undefined) this.m_uniqueID = 0;
                if(this.m_flags===undefined) this.m_flags = 0;
                if(this.m_type===undefined) this.m_type = 0;
                if(this.m_controllerList===undefined) this.m_controllerList = null;
                if(this.m_xf===undefined) this.m_xf = null;
                if(this.m_sweep===undefined) this.m_sweep = null;
                if(this.m_linearVelocity===undefined) this.m_linearVelocity = null;
                if(this.m_angularVelocity===undefined) this.m_angularVelocity = 0;
                if(this.m_force===undefined) this.m_force = null;
                if(this.m_torque===undefined) this.m_torque = 0;
                if(this.m_world===undefined) this.m_world = null;
                if(this.m_prev===undefined) this.m_prev = null;
                if(this.m_next===undefined) this.m_next = null;
                if(this.m_shapeList===undefined) this.m_shapeList = null;
                if(this.m_shapeCount===undefined) this.m_shapeCount = 0;
                if(this.m_jointList===undefined) this.m_jointList = null;
                if(this.m_contactList===undefined) this.m_contactList = null;
                if(this.m_mass===undefined) this.m_mass = 0;
                if(this.m_invMass===undefined) this.m_invMass = 0;
                if(this.m_I===undefined) this.m_I = 0;
                if(this.m_invI===undefined) this.m_invI = 0;
                if(this.m_linearDamping===undefined) this.m_linearDamping = 0;
                if(this.m_angularDamping===undefined) this.m_angularDamping = 0;
                if(this.m_sleepTime===undefined) this.m_sleepTime = 0;
                if(this.m_userData===undefined) this.m_userData = null;
                (() => {
                    if(!((world.m_lock === false))) throw new Error("Assertion error line 152: assert (world.m_lock == false);");;
                    {
                        this.m_uniqueID = Body.nextID++;
                    };
                    this.m_flags = 0;
                    if(bd.isBullet) {
                        this.m_flags |= Body.e_bulletFlag;
                    }
                    if(bd.fixedRotation) {
                        this.m_flags |= Body.e_fixedRotationFlag;
                    }
                    if(bd.allowSleep) {
                        this.m_flags |= Body.e_allowSleepFlag;
                    }
                    if(bd.isSleeping) {
                        this.m_flags |= Body.e_sleepFlag;
                    }
                    this.m_world = world;
                    this.m_xf = new org.jbox2d.common.XForm();
                    this.m_xf.position.set$org_jbox2d_common_Vec2(bd.position);
                    this.m_xf.R.set$float(bd.angle);
                    this.m_sweep = new org.jbox2d.common.Sweep();
                    this.m_sweep.localCenter.set$org_jbox2d_common_Vec2(bd.massData.center);
                    this.m_sweep.t0 = 1.0;
                    this.m_sweep.a0 = this.m_sweep.a = bd.angle;
                    this.m_sweep.c.set$org_jbox2d_common_Vec2(org.jbox2d.common.XForm.mul(this.m_xf, this.m_sweep.localCenter));
                    this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
                    this.m_jointList = null;
                    this.m_contactList = null;
                    this.m_prev = null;
                    this.m_next = null;
                    this.m_linearDamping = bd.linearDamping;
                    this.m_angularDamping = bd.angularDamping;
                    this.m_force = new org.jbox2d.common.Vec2(0.0, 0.0);
                    this.m_torque = 0.0;
                    this.m_linearVelocity = new org.jbox2d.common.Vec2(0.0, 0.0);
                    this.m_angularVelocity = 0.0;
                    this.m_sleepTime = 0.0;
                    this.m_invMass = 0.0;
                    this.m_I = 0.0;
                    this.m_invI = 0.0;
                    this.m_mass = bd.massData.mass;
                    if(this.m_mass > 0.0) {
                        this.m_invMass = (<any>Math).fround(1.0 / this.m_mass);
                    }
                    if((this.m_flags & Body.e_fixedRotationFlag) === 0) {
                        this.m_I = bd.massData.I;
                    }
                    if(this.m_I > 0.0) {
                        this.m_invI = (<any>Math).fround(1.0 / this.m_I);
                    }
                    if(this.m_invMass === 0.0 && this.m_invI === 0.0) {
                        this.m_type = Body.e_staticType;
                    } else {
                        this.m_type = Body.e_dynamicType;
                    }
                    this.m_userData = bd.userData;
                    this.m_shapeList = null;
                    this.m_shapeCount = 0;
                })();
            } else if(bd === undefined && world === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let bd : any = new org.jbox2d.dynamics.BodyDef();
                    let world : any = null;
                    if(this.m_uniqueID===undefined) this.m_uniqueID = 0;
                    if(this.m_flags===undefined) this.m_flags = 0;
                    if(this.m_type===undefined) this.m_type = 0;
                    if(this.m_controllerList===undefined) this.m_controllerList = null;
                    if(this.m_xf===undefined) this.m_xf = null;
                    if(this.m_sweep===undefined) this.m_sweep = null;
                    if(this.m_linearVelocity===undefined) this.m_linearVelocity = null;
                    if(this.m_angularVelocity===undefined) this.m_angularVelocity = 0;
                    if(this.m_force===undefined) this.m_force = null;
                    if(this.m_torque===undefined) this.m_torque = 0;
                    if(this.m_world===undefined) this.m_world = null;
                    if(this.m_prev===undefined) this.m_prev = null;
                    if(this.m_next===undefined) this.m_next = null;
                    if(this.m_shapeList===undefined) this.m_shapeList = null;
                    if(this.m_shapeCount===undefined) this.m_shapeCount = 0;
                    if(this.m_jointList===undefined) this.m_jointList = null;
                    if(this.m_contactList===undefined) this.m_contactList = null;
                    if(this.m_mass===undefined) this.m_mass = 0;
                    if(this.m_invMass===undefined) this.m_invMass = 0;
                    if(this.m_I===undefined) this.m_I = 0;
                    if(this.m_invI===undefined) this.m_invI = 0;
                    if(this.m_linearDamping===undefined) this.m_linearDamping = 0;
                    if(this.m_angularDamping===undefined) this.m_angularDamping = 0;
                    if(this.m_sleepTime===undefined) this.m_sleepTime = 0;
                    if(this.m_userData===undefined) this.m_userData = null;
                    if(this.m_uniqueID===undefined) this.m_uniqueID = 0;
                    if(this.m_flags===undefined) this.m_flags = 0;
                    if(this.m_type===undefined) this.m_type = 0;
                    if(this.m_controllerList===undefined) this.m_controllerList = null;
                    if(this.m_xf===undefined) this.m_xf = null;
                    if(this.m_sweep===undefined) this.m_sweep = null;
                    if(this.m_linearVelocity===undefined) this.m_linearVelocity = null;
                    if(this.m_angularVelocity===undefined) this.m_angularVelocity = 0;
                    if(this.m_force===undefined) this.m_force = null;
                    if(this.m_torque===undefined) this.m_torque = 0;
                    if(this.m_world===undefined) this.m_world = null;
                    if(this.m_prev===undefined) this.m_prev = null;
                    if(this.m_next===undefined) this.m_next = null;
                    if(this.m_shapeList===undefined) this.m_shapeList = null;
                    if(this.m_shapeCount===undefined) this.m_shapeCount = 0;
                    if(this.m_jointList===undefined) this.m_jointList = null;
                    if(this.m_contactList===undefined) this.m_contactList = null;
                    if(this.m_mass===undefined) this.m_mass = 0;
                    if(this.m_invMass===undefined) this.m_invMass = 0;
                    if(this.m_I===undefined) this.m_I = 0;
                    if(this.m_invI===undefined) this.m_invI = 0;
                    if(this.m_linearDamping===undefined) this.m_linearDamping = 0;
                    if(this.m_angularDamping===undefined) this.m_angularDamping = 0;
                    if(this.m_sleepTime===undefined) this.m_sleepTime = 0;
                    if(this.m_userData===undefined) this.m_userData = null;
                    (() => {
                        if(!((world.m_lock === false))) throw new Error("Assertion error line 269: assert (world.m_lock == false);");;
                        {
                            this.m_uniqueID = Body.nextID++;
                        };
                        this.m_flags = 0;
                        if(bd.isBullet) {
                            this.m_flags |= Body.e_bulletFlag;
                        }
                        if(bd.fixedRotation) {
                            this.m_flags |= Body.e_fixedRotationFlag;
                        }
                        if(bd.allowSleep) {
                            this.m_flags |= Body.e_allowSleepFlag;
                        }
                        if(bd.isSleeping) {
                            this.m_flags |= Body.e_sleepFlag;
                        }
                        this.m_world = world;
                        this.m_xf = new org.jbox2d.common.XForm();
                        this.m_xf.position.set$org_jbox2d_common_Vec2(bd.position);
                        this.m_xf.R.set$float(bd.angle);
                        this.m_sweep = new org.jbox2d.common.Sweep();
                        this.m_sweep.localCenter.set$org_jbox2d_common_Vec2(bd.massData.center);
                        this.m_sweep.t0 = 1.0;
                        this.m_sweep.a0 = this.m_sweep.a = bd.angle;
                        this.m_sweep.c.set$org_jbox2d_common_Vec2(org.jbox2d.common.XForm.mul(this.m_xf, this.m_sweep.localCenter));
                        this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
                        this.m_jointList = null;
                        this.m_contactList = null;
                        this.m_prev = null;
                        this.m_next = null;
                        this.m_linearDamping = bd.linearDamping;
                        this.m_angularDamping = bd.angularDamping;
                        this.m_force = new org.jbox2d.common.Vec2(0.0, 0.0);
                        this.m_torque = 0.0;
                        this.m_linearVelocity = new org.jbox2d.common.Vec2(0.0, 0.0);
                        this.m_angularVelocity = 0.0;
                        this.m_sleepTime = 0.0;
                        this.m_invMass = 0.0;
                        this.m_I = 0.0;
                        this.m_invI = 0.0;
                        this.m_mass = bd.massData.mass;
                        if(this.m_mass > 0.0) {
                            this.m_invMass = (<any>Math).fround(1.0 / this.m_mass);
                        }
                        if((this.m_flags & Body.e_fixedRotationFlag) === 0) {
                            this.m_I = bd.massData.I;
                        }
                        if(this.m_I > 0.0) {
                            this.m_invI = (<any>Math).fround(1.0 / this.m_I);
                        }
                        if(this.m_invMass === 0.0 && this.m_invI === 0.0) {
                            this.m_type = Body.e_staticType;
                        } else {
                            this.m_type = Body.e_dynamicType;
                        }
                        this.m_userData = bd.userData;
                        this.m_shapeList = null;
                        this.m_shapeCount = 0;
                    })();
                }
            } else throw new Error('invalid overload');
        }

        /*private*/ connectEdges(s1 : org.jbox2d.collision.shapes.EdgeShape, s2 : org.jbox2d.collision.shapes.EdgeShape, angle1 : number) : number {
            let angle2 : number = (<any>Math).fround(Math.atan2(s2.getDirectionVector().y, s2.getDirectionVector().x));
            let core : org.jbox2d.common.Vec2 = s2.getDirectionVector().mul((<any>Math).fround(Math.tan((<any>Math).fround(((<any>Math).fround(angle2 - angle1)) * 0.5))));
            (core.subLocal(s2.getNormalVector())).mulLocal(org.jbox2d.common.Settings.toiSlop_$LI$()).addLocal$org_jbox2d_common_Vec2(s2.getVertex1());
            let cornerDir : org.jbox2d.common.Vec2 = s1.getDirectionVector().add(s2.getDirectionVector());
            cornerDir.normalize();
            let convex : boolean = org.jbox2d.common.Vec2.dot(s1.getDirectionVector(), s2.getNormalVector()) > 0.0;
            s1.setNextEdge(s2, core, cornerDir, convex);
            s2.setPrevEdge(s1, core, cornerDir, convex);
            return angle2;
        }

        /**
         * Creates a shape and attach it to this body.
         * <BR><em>Warning</em>: This function is locked during callbacks.
         * @param {org.jbox2d.collision.shapes.ShapeDef} def the shape definition.
         * @return {org.jbox2d.collision.shapes.Shape}
         */
        public createShape(def : org.jbox2d.collision.shapes.ShapeDef) : org.jbox2d.collision.shapes.Shape {
            if(!((this.m_world.m_lock === false))) throw new Error("Assertion error line 352: assert (m_world.m_lock == false);");;
            if(def.type === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE) {
                let edgeDef : org.jbox2d.collision.shapes.EdgeChainDef = <org.jbox2d.collision.shapes.EdgeChainDef>def;
                let v1 : org.jbox2d.common.Vec2;
                let v2 : org.jbox2d.common.Vec2;
                let i : number = 0;
                if(edgeDef.isLoop()) {
                    v1 = /* get */edgeDef.getVertices()[edgeDef.getVertexCount() - 1];
                    i = 0;
                } else {
                    v1 = /* get */edgeDef.getVertices()[0];
                    i = 1;
                }
                let s0 : org.jbox2d.collision.shapes.EdgeShape = null;
                let s1 : org.jbox2d.collision.shapes.EdgeShape = null;
                let s2 : org.jbox2d.collision.shapes.EdgeShape = null;
                let angle : number = 0.0;
                for(; i < edgeDef.getVertexCount(); i++) {{
                    v2 = /* get */edgeDef.getVertices()[i];
                    s2 = new org.jbox2d.collision.shapes.EdgeShape(v1, v2, def);
                    s2.m_next = this.m_shapeList;
                    this.m_shapeList = s2;
                    ++this.m_shapeCount;
                    s2.m_body = this;
                    s2.createProxy(this.m_world.m_broadPhase, this.m_xf);
                    s2.updateSweepRadius(this.m_sweep.localCenter);
                    if(s1 == null) {
                        s0 = s2;
                        angle = (<any>Math).fround(Math.atan2(s2.getDirectionVector().y, s2.getDirectionVector().x));
                    } else {
                        angle = this.connectEdges(s1, s2, angle);
                    }
                    s1 = s2;
                    v1 = v2;
                };}
                if(edgeDef.isLoop()) {
                    this.connectEdges(s1, s0, angle);
                }
                return s0;
            }
            let s : org.jbox2d.collision.shapes.Shape = org.jbox2d.collision.shapes.Shape.create(def);
            s.m_next = this.m_shapeList;
            this.m_shapeList = s;
            ++this.m_shapeCount;
            s.m_body = this;
            s.createProxy(this.m_world.m_broadPhase, this.m_xf);
            s.updateSweepRadius(this.m_sweep.localCenter);
            return s;
        }

        /**
         * Destroy a shape. This removes the shape from the broad-phase and
         * therefore destroys any contacts associated with this shape. All shapes
         * attached to a body are implicitly destroyed when the body is destroyed.
         * <BR><em>Warning</em>: This function is locked during callbacks.
         * @param {org.jbox2d.collision.shapes.Shape} s the shape to be removed.
         */
        public destroyShape(s : org.jbox2d.collision.shapes.Shape) {
            if(!((this.m_world.m_lock === false))) throw new Error("Assertion error line 410: assert (m_world.m_lock == false);");;
            if(!((s.getBody() === this))) throw new Error("Assertion error line 411: assert (s.getBody() == this);");;
            s.destroyProxy(this.m_world.m_broadPhase);
            if(!((this.m_shapeCount > 0))) throw new Error("Assertion error line 413: assert (m_shapeCount > 0);");;
            let node : org.jbox2d.collision.shapes.Shape = this.m_shapeList;
            let prevNode : org.jbox2d.collision.shapes.Shape = null;
            let found : boolean = false;
            while((node != null)) {{
                if(node === s) {
                    if(prevNode == null) {
                        this.m_shapeList = s.m_next;
                        found = true;
                        break;
                    } else {
                        prevNode.m_next = s.m_next;
                        found = true;
                        break;
                    }
                }
                prevNode = node;
                node = node.m_next;
            }};
            if(!((found))) throw new Error("Assertion error line 432: assert (found);");;
            s.m_body = null;
            s.m_next = null;
            --this.m_shapeCount;
            org.jbox2d.collision.shapes.Shape.destroy(s);
        }

        /**
         * Set the mass properties. Note that this changes the center of mass position.
         * If you are not sure how to compute mass properties, use setMassFromShapes().
         * The inertia tensor is assumed to be relative to the center of mass.
         * @param {org.jbox2d.collision.MassData} massData the mass properties.
         */
        public setMass(massData : org.jbox2d.collision.MassData) {
            if(!((this.m_world.m_lock === false))) throw new Error("Assertion error line 446: assert (m_world.m_lock == false);");;
            this.m_invMass = 0.0;
            this.m_I = 0.0;
            this.m_invI = 0.0;
            this.m_mass = massData.mass;
            if(this.m_mass > 0.0) {
                this.m_invMass = (<any>Math).fround(1.0 / this.m_mass);
            }
            if((this.m_flags & Body.e_fixedRotationFlag) === 0) {
                this.m_I = massData.I;
            }
            if(this.m_I > 0.0) {
                this.m_invI = (<any>Math).fround(1.0 / this.m_I);
            }
            this.m_sweep.localCenter.set$org_jbox2d_common_Vec2(massData.center);
            org.jbox2d.common.XForm.mulToOut(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
            this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
            for(let s : org.jbox2d.collision.shapes.Shape = this.m_shapeList; s != null; s = s.m_next) {{
                s.updateSweepRadius(this.m_sweep.localCenter);
            };}
            let oldType : number = this.m_type;
            if(this.m_invMass === 0.0 && this.m_invI === 0.0) {
                this.m_type = Body.e_staticType;
            } else {
                this.m_type = Body.e_dynamicType;
            }
            if(oldType !== this.m_type) {
                for(let s : org.jbox2d.collision.shapes.Shape = this.m_shapeList; s != null; s = s.m_next) {{
                    s.refilterProxy(this.m_world.m_broadPhase, this.m_xf);
                };}
            }
        }

        static tlCenter : org.jbox2d.pooling.TLVec2; public static tlCenter_$LI$() : org.jbox2d.pooling.TLVec2 { if(Body.tlCenter == null) Body.tlCenter = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return Body.tlCenter; };

        /**
         * Compute the mass properties from the attached shapes. You typically call this
         * after adding all the shapes. If you add or remove shapes later, you may want
         * to call this again. Note that this changes the center of mass position.
         */
        public setMassFromShapes() {
            if(!((this.m_world.m_lock === false))) throw new Error("Assertion error line 487: assert (m_world.m_lock == false);");;
            this.m_mass = 0.0;
            this.m_invMass = 0.0;
            this.m_I = 0.0;
            this.m_invI = 0.0;
            let center : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(Body.tlCenter_$LI$());
            center.setZero();
            for(let s : org.jbox2d.collision.shapes.Shape = this.m_shapeList; s != null; s = s.m_next) {{
                let massData : org.jbox2d.collision.MassData = new org.jbox2d.collision.MassData();
                s.computeMass(massData);
                this.m_mass += massData.mass;
                center.x += (<any>Math).fround(massData.mass * massData.center.x);
                center.y += (<any>Math).fround(massData.mass * massData.center.y);
                this.m_I += massData.I;
            };}
            if(this.m_mass > 0.0) {
                this.m_invMass = (<any>Math).fround(1.0 / this.m_mass);
                center.x *= this.m_invMass;
                center.y *= this.m_invMass;
            }
            if(this.m_I > 0.0 && (this.m_flags & Body.e_fixedRotationFlag) === 0) {
                this.m_I -= (<any>Math).fround(this.m_mass * org.jbox2d.common.Vec2.dot(center, center));
                if(!((this.m_I > 0.0))) throw new Error("Assertion error line 509: assert (m_I > 0.0F);");;
                this.m_invI = (<any>Math).fround(1.0 / this.m_I);
            } else {
                this.m_I = 0.0;
                this.m_invI = 0.0;
            }
            this.m_sweep.localCenter.set$org_jbox2d_common_Vec2(center);
            org.jbox2d.common.XForm.mulToOut(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
            this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
            for(let s : org.jbox2d.collision.shapes.Shape = this.m_shapeList; s != null; s = s.m_next) {{
                s.updateSweepRadius(this.m_sweep.localCenter);
            };}
            let oldType : number = this.m_type;
            if(this.m_invMass === 0.0 && this.m_invI === 0.0) {
                this.m_type = Body.e_staticType;
            } else {
                this.m_type = Body.e_dynamicType;
            }
            if(oldType !== this.m_type) {
                for(let s : org.jbox2d.collision.shapes.Shape = this.m_shapeList; s != null; s = s.m_next) {{
                    s.refilterProxy(this.m_world.m_broadPhase, this.m_xf);
                };}
            }
        }

        /**
         * Set the position of the body's origin and rotation (radians).
         * This breaks any contacts and wakes the other bodies.
         * @param {org.jbox2d.common.Vec2} position the new world position of the body's origin (not necessarily
         * the center of mass).
         * @param {number} angle the new world rotation angle of the body in radians.
         * @return {boolean} false if the movement put a shape outside the world. In this case the
         * body is automatically frozen.
         */
        public setXForm(position : org.jbox2d.common.Vec2, angle : number) : boolean {
            if(!((this.m_world.m_lock === false))) throw new Error("Assertion error line 544: assert (m_world.m_lock == false);");;
            if(this.isFrozen()) {
                return false;
            }
            this.m_xf.R.set$float(angle);
            this.m_xf.position.set$org_jbox2d_common_Vec2(position);
            org.jbox2d.common.XForm.mulToOut(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
            this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
            this.m_sweep.a0 = this.m_sweep.a = angle;
            let freeze : boolean = false;
            for(let s : org.jbox2d.collision.shapes.Shape = this.m_shapeList; s != null; s = s.m_next) {{
                let inRange : boolean = s.synchronize(this.m_world.m_broadPhase, this.m_xf, this.m_xf);
                if(inRange === false) {
                    freeze = true;
                    break;
                }
            };}
            if(freeze === true) {
                this.m_flags |= Body.e_frozenFlag;
                this.m_linearVelocity.setZero();
                this.m_angularVelocity = 0.0;
                for(let s : org.jbox2d.collision.shapes.Shape = this.m_shapeList; s != null; s = s.m_next) {{
                    s.destroyProxy(this.m_world.m_broadPhase);
                };}
                return false;
            }
            this.m_world.m_broadPhase.commit();
            return true;
        }

        /**
         * Get a copy of the body transform for the body's origin.
         * @return {org.jbox2d.common.XForm} the world transform of the body's origin.
         */
        public getXForm() : org.jbox2d.common.XForm {
            let xf : org.jbox2d.common.XForm = new org.jbox2d.common.XForm();
            xf.set(this.m_xf);
            return xf;
        }

        /**
         * More for internal use.  It isn't copied,
         * so don't modify it.  instead try to use {@link #setXForm(Vec2, float)}.
         * Otherwise, this also gives you direct access to the body's XForm, if you
         * really need to change something (careful!).
         * @see #getXForm()
         * @see #setXForm(Vec2, float)
         * @return {org.jbox2d.common.XForm} an uncopied version of this body's XForm
         */
        public getMemberXForm() : org.jbox2d.common.XForm {
            return this.m_xf;
        }

        /**
         * You probably don't want to use this
         * function.  What you really want is getWorldCenter(),
         * which returns the center of mass (which actually has
         * some physical significance).
         * <p>
         * Just in case you do want to use this,
         * Get a copy of the world body origin position.  This
         * is not necessarily the same as the center of mass.
         * In fact, it's not anything in particular.  Just a
         * point.
         * <p>
         * @return {org.jbox2d.common.Vec2} a copy of the world position of the body's origin.
         */
        public getPosition() : org.jbox2d.common.Vec2 {
            return /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this.m_xf.position);
        }

        /**
         * This is more for internal use.  It isn't copied, so don't
         * modify it.  This is the position of the body's XForm
         * ({@link #getXForm()}), and if you want to change that I would
         * suggest using {@link #setXForm(Vec2, float)}.  Modifying this
         * will not do what you want.
         * @see #getPosition()
         * @return {org.jbox2d.common.Vec2} the body's world position of the body's origin.
         */
        public getMemberPosition() : org.jbox2d.common.Vec2 {
            return this.m_xf.position;
        }

        /**
         * Get the angle in radians.
         * @return {number} the current world rotation angle in radians.
         */
        public getAngle() : number {
            return this.m_sweep.a;
        }

        /**
         * Get a copy of the world position of the center of mass.
         * @return {org.jbox2d.common.Vec2} a copy of the world position
         */
        public getWorldCenter() : org.jbox2d.common.Vec2 {
            return /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this.m_sweep.c);
        }

        /**
         * More for internal use. It isn't copied, so don't
         * modify it.  Modifying this will not do what you want,
         * instead use {@link #setXForm(Vec2, float)}
         * @see #getWorldCenter()
         * @return {org.jbox2d.common.Vec2} the world position
         */
        public getMemberWorldCenter() : org.jbox2d.common.Vec2 {
            return this.m_sweep.c;
        }

        /**
         * Get local position of the center of mass.
         * @return {org.jbox2d.common.Vec2} a copy of the local position of the center of mass
         */
        public getLocalCenter() : org.jbox2d.common.Vec2 {
            return /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this.m_sweep.localCenter);
        }

        /**
         * More for internal use. It isn't a copy, so don't
         * modify it.
         * @return {org.jbox2d.common.Vec2} the local position of the center of mass
         */
        public getMemberLocalCenter() : org.jbox2d.common.Vec2 {
            return this.m_sweep.localCenter;
        }

        /**
         * Set the linear velocity of the center of mass.
         * @param {org.jbox2d.common.Vec2} v the new linear velocity of the center of mass.
         */
        public setLinearVelocity(v : org.jbox2d.common.Vec2) {
            this.m_linearVelocity.set$org_jbox2d_common_Vec2(v);
        }

        /**
         * Get the linear velocity of the center of mass. This isn't a copy,
         * so modifying this will change the linear velocity.
         * @return {org.jbox2d.common.Vec2} a the linear velocity of the center of mass.
         */
        public getLinearVelocity() : org.jbox2d.common.Vec2 {
            return this.m_linearVelocity;
        }

        /**
         * Set the angular velocity.
         * @param {number} omega the new angular velocity in radians/second.
         */
        public setAngularVelocity(omega : number) {
            this.m_angularVelocity = omega;
        }

        /**
         * Get the angular velocity.
         * @return {number} the angular velocity in radians/second.
         */
        public getAngularVelocity() : number {
            return this.m_angularVelocity;
        }

        /**
         * Apply a force at a world point. If the force is not
         * applied at the center of mass, it will generate a torque and
         * affect the angular velocity. This wakes up the body.
         * @param {org.jbox2d.common.Vec2} force the world force vector, usually in Newtons (N).
         * @param {org.jbox2d.common.Vec2} point the world position of the point of application.
         */
        public applyForce(force : org.jbox2d.common.Vec2, point : org.jbox2d.common.Vec2) {
            if(this.isSleeping()) {
                this.wakeUp();
            }
            this.m_force.addLocal$org_jbox2d_common_Vec2(force);
            this.m_torque += (<any>Math).fround((<any>Math).fround(((<any>Math).fround(point.x - this.m_sweep.c.x)) * force.y) - (<any>Math).fround(((<any>Math).fround(point.y - this.m_sweep.c.y)) * force.x));
        }

        /**
         * Apply a torque. This affects the angular velocity
         * without affecting the linear velocity of the center of mass.
         * This wakes up the body.
         * @param {number} torque about the z-axis (out of the screen), usually in N-m.
         */
        public applyTorque(torque : number) {
            if(this.isSleeping()) {
                this.wakeUp();
            }
            this.m_torque += torque;
        }

        /**
         * Apply an impulse at a point. This immediately modifies the velocity.
         * It also modifies the angular velocity if the point of application
         * is not at the center of mass. This wakes up the body.
         * @param {org.jbox2d.common.Vec2} impulse the world impulse vector, usually in N-seconds or kg-m/s.
         * @param {org.jbox2d.common.Vec2} point the world position of the point of application.
         */
        public applyImpulse(impulse : org.jbox2d.common.Vec2, point : org.jbox2d.common.Vec2) {
            if(this.isSleeping()) {
                this.wakeUp();
            }
            this.m_linearVelocity.x += (<any>Math).fround(this.m_invMass * impulse.x);
            this.m_linearVelocity.y += (<any>Math).fround(this.m_invMass * impulse.y);
            this.m_angularVelocity += (<any>Math).fround(this.m_invI * ((<any>Math).fround((<any>Math).fround(((<any>Math).fround(point.x - this.m_sweep.c.x)) * impulse.y) - (<any>Math).fround(((<any>Math).fround(point.y - this.m_sweep.c.y)) * impulse.x))));
        }

        /**
         * Get the total mass of the body.
         * @return {number} the mass, usually in kilograms (kg).
         */
        public getMass() : number {
            return this.m_mass;
        }

        /**
         * Get the central rotational inertia of the body.
         * @return {number} the rotational inertia, usually in kg-m^2.
         */
        public getInertia() : number {
            return this.m_I;
        }

        /**
         * Get the world coordinates of a point given the local coordinates.
         * @param {org.jbox2d.common.Vec2} localPoint a point on the body measured relative the the body's origin.
         * @return {org.jbox2d.common.Vec2} the same point expressed in world coordinates.
         */
        public getWorldLocation(localPoint : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return org.jbox2d.common.XForm.mul(this.m_xf, localPoint);
        }

        /**
         * Get the world coordinates of a point given the local coordinates.
         * @param {org.jbox2d.common.Vec2} localPoint a point on the body measured relative the the body's origin.
         * @param {org.jbox2d.common.Vec2} out where to put the same point expressed in world coordinates.
         */
        public getWorldLocationToOut(localPoint : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.XForm.mulToOut(this.m_xf, localPoint, out);
        }

        /**
         * Get the world coordinates of a point given the local coordinates.
         * @param {org.jbox2d.common.Vec2} localPoint a point on the body measured relative the the body's origin.
         * @return {org.jbox2d.common.Vec2} the same point expressed in world coordinates.
         * @deprecated Use getWorldLocation instead (clearer naming convention)
         */
        public getWorldPoint(localPoint : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return this.getWorldLocation(localPoint);
        }

        /**
         * Get the world coordinates of a vector given the local coordinates.
         * @param {org.jbox2d.common.Vec2} localVector a vector fixed in the body.
         * @return {org.jbox2d.common.Vec2} the same vector expressed in world coordinates.
         * @deprecated Use getWorldDirection instead (clearer naming convention)
         */
        public getWorldVector(localVector : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return this.getWorldDirection(localVector);
        }

        /**
         * Get the world coordinates of a direction given the local direction.
         * @param {org.jbox2d.common.Vec2} localDirection a vector fixed in the body.
         * @return {org.jbox2d.common.Vec2} the same vector expressed in world coordinates.
         */
        public getWorldDirection(localDirection : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(this.m_xf.R, localDirection);
        }

        /**
         * Get the world coordinates of a direction given the local direction.
         * @param {org.jbox2d.common.Vec2} localDirection a vector fixed in the body.
         * @param {org.jbox2d.common.Vec2} out where to put the same vector expressed in world coordinates.
         */
        public getWorldDirectionToOut(localDirection : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf.R, localDirection, out);
        }

        /**
         * Gets a local point relative to the body's origin given a world point.
         * @param {org.jbox2d.common.Vec2} worldPoint a point in world coordinates.
         * @return {org.jbox2d.common.Vec2} the corresponding local point relative to the body's origin.
         */
        public getLocalPoint(worldPoint : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return org.jbox2d.common.XForm.mulTrans(this.m_xf, worldPoint);
        }

        /**
         * Gets a local point relative to the body's origin given a world point.
         * @param {org.jbox2d.common.Vec2} worldPoint a point in world coordinates.
         * @param {org.jbox2d.common.Vec2} out where to put the the corresponding local point relative to the body's origin.
         */
        public getLocalPointToOut(worldPoint : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.XForm.mulTransToOut(this.m_xf, worldPoint, out);
        }

        /**
         * Gets a local vector given a world vector.
         * @param {org.jbox2d.common.Vec2} worldVector a vector in world coordinates.
         * @return {org.jbox2d.common.Vec2} the corresponding local vector.
         */
        public getLocalVector(worldVector : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            return org.jbox2d.common.Mat22.mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(this.m_xf.R, worldVector);
        }

        /**
         * Gets a local vector given a world vector.
         * @param {org.jbox2d.common.Vec2} worldVector a vector in world coordinates.
         * @param {org.jbox2d.common.Vec2} out where to put the corresponding local vector.
         */
        public getLocalVectorToOut(worldVector : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf.R, worldVector, out);
        }

        /**
         * Is this body treated like a bullet for continuous collision detection?
         * @return {boolean}
         */
        public isBullet() : boolean {
            return (this.m_flags & Body.e_bulletFlag) === Body.e_bulletFlag;
        }

        /**
         * Should this body be treated like a bullet for continuous collision detection?
         * Use sparingly, as continuous collision detection can be expensive.
         * @param {boolean} flag
         */
        public setBullet(flag : boolean) {
            if(flag) {
                this.m_flags |= Body.e_bulletFlag;
            } else {
                this.m_flags &= ~Body.e_bulletFlag;
            }
        }

        /**
         * Is this body static (immovable)?
         * @return {boolean}
         */
        public isStatic() : boolean {
            return this.m_type === Body.e_staticType;
        }

        /**
         * Is this body dynamic (movable)?
         * @return {boolean}
         */
        public isDynamic() : boolean {
            return this.m_type === Body.e_dynamicType;
        }

        /**
         * Is this body frozen?
         * @return {boolean}
         */
        public isFrozen() : boolean {
            return (this.m_flags & Body.e_frozenFlag) === Body.e_frozenFlag;
        }

        /**
         * Is this body sleeping (not simulating).
         * @return {boolean}
         */
        public isSleeping() : boolean {
            return (this.m_flags & Body.e_sleepFlag) === Body.e_sleepFlag;
        }

        /**
         * Set to false to prevent this body from sleeping due to inactivity.
         * @param {boolean} flag
         */
        public allowSleeping(flag : boolean) {
            if(flag) {
                this.m_flags |= Body.e_allowSleepFlag;
            } else {
                this.m_flags &= ~Body.e_allowSleepFlag;
                this.wakeUp();
            }
        }

        /**
         * Wake up this body so it will begin simulating.
         */
        public wakeUp() {
            this.m_flags &= ~Body.e_sleepFlag;
            this.m_sleepTime = 0.0;
        }

        /**
         * Get the linked list of all shapes attached to this body.
         * @return {org.jbox2d.collision.shapes.Shape} first Shape in linked list
         */
        public getShapeList() : org.jbox2d.collision.shapes.Shape {
            return this.m_shapeList;
        }

        /**
         * Get the linked list of all joints attached to this body.
         * @return {org.jbox2d.dynamics.joints.JointEdge} first JointEdge in linked list
         */
        public getJointList() : org.jbox2d.dynamics.joints.JointEdge {
            return this.m_jointList;
        }

        /**
         * Get the next body in the world's body list.
         * @return {org.jbox2d.dynamics.Body}
         */
        public getNext() : Body {
            return this.m_next;
        }

        /**
         * Get the user data Object reference that was provided in the body definition.
         * @return {*}
         */
        public getUserData() : any {
            return this.m_userData;
        }

        /**
         * For internal use only.
         */
        public computeMass() {
        }

        static tlXf1 : org.jbox2d.pooling.TLXForm; public static tlXf1_$LI$() : org.jbox2d.pooling.TLXForm { if(Body.tlXf1 == null) Body.tlXf1 = (() => { let __o : any = new org.jbox2d.pooling.TLXForm(); __o.__delegate = new org.jbox2d.pooling.TLXForm(); return __o; })(); return Body.tlXf1; };

        /**
         * For internal use only.
         * @return {boolean}
         */
        public synchronizeShapes() : boolean {
            let xf1 : org.jbox2d.common.XForm = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(Body.tlXf1_$LI$());
            xf1.R.set$float(this.m_sweep.a0);
            let R : org.jbox2d.common.Mat22 = xf1.R;
            let v : org.jbox2d.common.Vec2 = this.m_sweep.localCenter;
            xf1.position.set$float$float((<any>Math).fround(this.m_sweep.c0.x - ((<any>Math).fround((<any>Math).fround(R.col1.x * v.x) + (<any>Math).fround(R.col2.x * v.y)))), (<any>Math).fround(this.m_sweep.c0.y - ((<any>Math).fround((<any>Math).fround(R.col1.y * v.x) + (<any>Math).fround(R.col2.y * v.y)))));
            let inRange : boolean = true;
            for(let s : org.jbox2d.collision.shapes.Shape = this.m_shapeList; s != null; s = s.m_next) {{
                inRange = s.synchronize(this.m_world.m_broadPhase, xf1, this.m_xf);
                if(inRange === false) {
                    break;
                }
            };}
            if(inRange === false) {
                this.m_flags |= Body.e_frozenFlag;
                this.m_linearVelocity.setZero();
                this.m_angularVelocity = 0.0;
                for(let s : org.jbox2d.collision.shapes.Shape = this.m_shapeList; s != null; s = s.m_next) {{
                    s.destroyProxy(this.m_world.m_broadPhase);
                };}
                return false;
            }
            return true;
        }

        /**
         * For internal use only.
         */
        public synchronizeTransform() {
            this.m_xf.R.set$float(this.m_sweep.a);
            let v1 : org.jbox2d.common.Vec2 = this.m_sweep.localCenter;
            this.m_xf.position.x = (<any>Math).fround(this.m_sweep.c.x - ((<any>Math).fround((<any>Math).fround(this.m_xf.R.col1.x * v1.x) + (<any>Math).fround(this.m_xf.R.col2.x * v1.y))));
            this.m_xf.position.y = (<any>Math).fround(this.m_sweep.c.y - ((<any>Math).fround((<any>Math).fround(this.m_xf.R.col1.y * v1.x) + (<any>Math).fround(this.m_xf.R.col2.y * v1.y))));
        }

        /**
         * This is used to prevent connected bodies from colliding.
         * It may lie, depending on the collideConnected flag, so
         * it won't be very useful external to the engine.
         * @param {org.jbox2d.dynamics.Body} other
         * @return {boolean}
         */
        public isConnected(other : Body) : boolean {
            for(let jn : org.jbox2d.dynamics.joints.JointEdge = this.m_jointList; jn != null; jn = jn.next) {{
                if(jn.other === other) {
                    return (jn.joint.m_collideConnected === false);
                }
            };}
            return false;
        }

        /**
         * For internal use only.
         * @param {number} t
         */
        public advance(t : number) {
            this.m_sweep.advance(t);
            this.m_sweep.c.set$org_jbox2d_common_Vec2(this.m_sweep.c0);
            this.m_sweep.a = this.m_sweep.a0;
            this.synchronizeTransform();
        }

        /**
         * Get the world linear velocity of a world point attached to this body.
         * @param {org.jbox2d.common.Vec2} worldPoint a point in world coordinates.
         * @return {org.jbox2d.common.Vec2} the world velocity of a point.
         */
        public getLinearVelocityFromWorldPoint(worldPoint : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let ax : number = (<any>Math).fround(worldPoint.x - this.m_sweep.c.x);
            let ay : number = (<any>Math).fround(worldPoint.y - this.m_sweep.c.y);
            let vx : number = (<any>Math).fround(-this.m_angularVelocity * ay);
            let vy : number = (<any>Math).fround(this.m_angularVelocity * ax);
            return new org.jbox2d.common.Vec2((<any>Math).fround(this.m_linearVelocity.x + vx), (<any>Math).fround(this.m_linearVelocity.y + vy));
        }

        /**
         * Get the world linear velocity of a world point attached to this body.
         * @param {org.jbox2d.common.Vec2} worldPoint a point in world coordinates.
         * @param {org.jbox2d.common.Vec2} out where to put the world velocity of a point.
         */
        public getLinearVelocityFromWorldPointToOut(worldPoint : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            let ax : number = (<any>Math).fround(worldPoint.x - this.m_sweep.c.x);
            let ay : number = (<any>Math).fround(worldPoint.y - this.m_sweep.c.y);
            let vx : number = (<any>Math).fround(-this.m_angularVelocity * ay);
            let vy : number = (<any>Math).fround(this.m_angularVelocity * ax);
            out.set$float$float((<any>Math).fround(this.m_linearVelocity.x + vx), (<any>Math).fround(this.m_linearVelocity.y + vy));
        }

        /**
         * Get the world velocity of a local point.
         * @param {org.jbox2d.common.Vec2} localPoint a point in local coordinates.
         * @return {org.jbox2d.common.Vec2} the world velocity of a point.
         */
        public getLinearVelocityFromLocalPoint(localPoint : org.jbox2d.common.Vec2) : org.jbox2d.common.Vec2 {
            let out : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            this.getWorldLocationToOut(localPoint, out);
            let ax : number = (<any>Math).fround(out.x - this.m_sweep.c.x);
            let ay : number = (<any>Math).fround(out.y - this.m_sweep.c.y);
            let vx : number = (<any>Math).fround(-this.m_angularVelocity * ay);
            let vy : number = (<any>Math).fround(this.m_angularVelocity * ax);
            out.x = (<any>Math).fround(this.m_linearVelocity.x + vx);
            out.y = (<any>Math).fround(this.m_linearVelocity.y + vy);
            return out;
        }

        /**
         * Get the world velocity of a local point.
         * @param {org.jbox2d.common.Vec2} localPoint a point in local coordinates.
         * @param {org.jbox2d.common.Vec2} out where to put the world velocity of a point.
         */
        public getLinearVelocityFromLocalPointToOut(localPoint : org.jbox2d.common.Vec2, out : org.jbox2d.common.Vec2) {
            this.getWorldLocationToOut(localPoint, out);
            let ax : number = (<any>Math).fround(out.x - this.m_sweep.c.x);
            let ay : number = (<any>Math).fround(out.y - this.m_sweep.c.y);
            let vx : number = (<any>Math).fround(-this.m_angularVelocity * ay);
            let vy : number = (<any>Math).fround(this.m_angularVelocity * ax);
            out.x = (<any>Math).fround(this.m_linearVelocity.x + vx);
            out.y = (<any>Math).fround(this.m_linearVelocity.y + vy);
        }

        /**
         * Put this body to sleep so it will stop simulating.
         * This also sets the velocity to zero.
         */
        public putToSleep() {
            this.m_flags |= Body.e_sleepFlag;
            this.m_sleepTime = 0.0;
            this.m_linearVelocity.setZero();
            this.m_angularVelocity = 0.0;
            this.m_force.setZero();
            this.m_torque = 0.0;
        }

        public setUserData(data : any) {
            this.m_userData = data;
        }

        public getWorld() : org.jbox2d.dynamics.World {
            return this.m_world;
        }

        /**
         * Get the contact list, represented as a linked list of ContactEdges. Will
         * return null if no contacts are present.
         * 
         * @return {org.jbox2d.dynamics.contacts.ContactEdge} the head of the linked list of contacts
         */
        public getContactList() : org.jbox2d.dynamics.contacts.ContactEdge {
            return this.m_contactList;
        }

        /**
         * Get the set of bodies in contact with this body.
         * 
         * @return {org.jbox2d.dynamics.Body[]} all bodies touching this one
         */
        public getBodiesInContact() : Array<Body> {
            let mySet : Array<Body> = <any>([]);
            let edge : org.jbox2d.dynamics.contacts.ContactEdge = this.getContactList();
            while((edge != null)) {{
                if(edge.contact.getManifoldCount() > 0) {
                    /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(mySet, edge.other);
                }
                edge = edge.next;
            }};
            return mySet;
        }

        /**
         * Get the set of bodies connected to this one by a joint.
         * Note: this does not return the entire island of connected bodies,
         * only those directly connected to this one.
         * @return {org.jbox2d.dynamics.Body[]} all bodies connected directly to this body by a joint
         */
        public getConnectedBodies() : Array<Body> {
            let mySet : Array<Body> = <any>([]);
            let edge : org.jbox2d.dynamics.joints.JointEdge = this.getJointList();
            while((edge != null)) {{
                /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(mySet, edge.other);
                edge = edge.next;
            }};
            return mySet;
        }

        /**
         * Get the set of dynamic bodies connected to this one by a joint.
         * Note: this does not return the entire island of connected bodies,
         * only those directly connected to this one.
         * @return {org.jbox2d.dynamics.Body[]} all bodies connected directly to this body by a joint
         */
        public getConnectedDynamicBodies() : Array<Body> {
            let mySet : Array<Body> = <any>([]);
            let edge : org.jbox2d.dynamics.joints.JointEdge = this.getJointList();
            while((edge != null)) {{
                if(edge.other.isDynamic()) /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(mySet, edge.other);
                edge = edge.next;
            }};
            return mySet;
        }

        /**
         * Get the island of connected bodies, including the current body.
         * <em>Warning</em>: will continue walking the joint tree past static bodies,
         * which may lead to unwanted results esp. if bodies are connected to the ground
         * body.
         * @return {org.jbox2d.dynamics.Body[]} Set<Body> of all bodies accessible from this one by walking the joint tree
         */
        public getConnectedBodyIsland() : Array<Body> {
            let result : Array<Body> = <any>([]);
            /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(result, this);
            return this.getConnectedBodyIsland_impl(this, result);
        }

        /*private*/ getConnectedBodyIsland_impl(parent : Body, parentResult : Array<Body>) : Array<Body> {
            let connected : Array<Body> = this.getConnectedBodies();
            for(let index155=0; index155 < connected.length; index155++) {
                let b = connected[index155];
                {
                    if(b === parent || /* contains */(parentResult.indexOf(<any>(b)) >= 0)) continue;
                    /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(parentResult, b);
                    /* addAll */((l1, l2) => l1.push.apply(l1, l2))(parentResult, b.getConnectedBodyIsland_impl(b, parentResult));
                }
            }
            return parentResult;
        }

        /**
         * Get the island of joint-connected dynamic bodies, including the current body.
         * Stops walking tree if it encounters a static body.
         * @see Body#getConnectedBodyIsland()
         * @return {org.jbox2d.dynamics.Body[]} Set<Body> of all bodies accessible from this one by walking the joint tree
         */
        public getConnectedDynamicBodyIsland() : Array<Body> {
            let result : Array<Body> = <any>([]);
            if(!this.isDynamic()) return result;
            /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(result, this);
            return this.getConnectedDynamicBodyIsland_impl(this, result);
        }

        /*private*/ getConnectedDynamicBodyIsland_impl(parent : Body, parentResult : Array<Body>) : Array<Body> {
            let connected : Array<Body> = this.getConnectedBodies();
            for(let index156=0; index156 < connected.length; index156++) {
                let b = connected[index156];
                {
                    if(b === parent || !b.isDynamic() || /* contains */(parentResult.indexOf(<any>(b)) >= 0)) continue;
                    /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(parentResult, b);
                    /* addAll */((l1, l2) => l1.push.apply(l1, l2))(parentResult, b.getConnectedDynamicBodyIsland_impl(b, parentResult));
                }
            }
            return parentResult;
        }

        /**
         * Get the island of bodies in contact, including the current body.
         * <em>Warning</em>: will continue walking the contact tree past static bodies,
         * which may lead to unwanted results esp. if bodies are touching the ground
         * body.
         * @return {org.jbox2d.dynamics.Body[]} Set<Body> of all bodies accessible from this one by walking the contact tree
         */
        public getTouchingBodyIsland() : Array<Body> {
            let result : Array<Body> = <any>([]);
            /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(result, this);
            return this.getTouchingBodyIsland_impl(this, result);
        }

        /*private*/ getTouchingBodyIsland_impl(parent : Body, parentResult : Array<Body>) : Array<Body> {
            let touching : Array<Body> = this.getBodiesInContact();
            for(let index157=0; index157 < touching.length; index157++) {
                let b = touching[index157];
                {
                    if(b === parent || /* contains */(parentResult.indexOf(<any>(b)) >= 0)) continue;
                    /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(parentResult, b);
                    /* addAll */((l1, l2) => l1.push.apply(l1, l2))(parentResult, b.getTouchingBodyIsland_impl(b, parentResult));
                }
            }
            return parentResult;
        }

        /**
         * Get the island of dynamic bodies in contact, including the current body.
         * Stops walking tree if it encounters a static body.
         * @return {org.jbox2d.dynamics.Body[]} Set<Body> of all bodies accessible from this one by walking the contact tree
         */
        public getTouchingDynamicBodyIsland() : Array<Body> {
            let result : Array<Body> = <any>([]);
            /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(result, this);
            return this.getTouchingDynamicBodyIsland_impl(this, result);
        }

        /*private*/ getTouchingDynamicBodyIsland_impl(parent : Body, parentResult : Array<Body>) : Array<Body> {
            let touching : Array<Body> = this.getBodiesInContact();
            for(let index158=0; index158 < touching.length; index158++) {
                let b = touching[index158];
                {
                    if(b === parent || !b.isDynamic() || /* contains */(parentResult.indexOf(<any>(b)) >= 0)) continue;
                    /* add */((s, e) => { if(s.indexOf(e)==-1) { s.push(e); return true; } else { return false; } })(parentResult, b);
                    /* addAll */((l1, l2) => l1.push.apply(l1, l2))(parentResult, b.getTouchingDynamicBodyIsland_impl(b, parentResult));
                }
            }
            return parentResult;
        }

        /**
         * @return {boolean} true if this Body is currently in contact with the passed body
         * @param {org.jbox2d.dynamics.Body} other
         */
        public isTouching(other : Body) : boolean {
            let edge : org.jbox2d.dynamics.contacts.ContactEdge = this.getContactList();
            while((edge != null)) {{
                if(edge.other === other && edge.contact.getManifoldCount() > 0) return true;
                edge = edge.next;
            }};
            return false;
        }

        public setLinearDamping(damping : number) {
            this.m_linearDamping = damping;
        }

        public getLinearDamping() : number {
            return this.m_linearDamping;
        }

        public setAngularDamping(damping : number) {
            this.m_angularDamping = damping;
        }

        public getAngularDamping() : number {
            return this.m_angularDamping;
        }
    }
    Body["__class"] = "org.jbox2d.dynamics.Body";

}
namespace org.jbox2d.util.blob {
    /**
     * Simple non-reinforced square lattice.
     * Easy to collapse, but simple.
     * @class
     * @extends org.jbox2d.util.blob.BlobStructure
     */
    export class SquareLatticeStructure extends org.jbox2d.util.blob.BlobStructure {
        public constructor() {
            super();
            let toAdd : org.jbox2d.util.blob.BlobPoint = new org.jbox2d.util.blob.BlobPoint(0.5, 0.5);
            let center : number = this.addPoint(toAdd);
            this.addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(center, center, BlobStructure.Region.UP_RIGHT);
            this.addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(center, center, BlobStructure.Region.RIGHT);
            this.addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(center, center, BlobStructure.Region.DOWN_RIGHT);
            this.addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(center, center, BlobStructure.Region.DOWN);
        }
    }
    SquareLatticeStructure["__class"] = "org.jbox2d.util.blob.SquareLatticeStructure";

}
namespace org.jbox2d.util.sph {
    export class SmoothParticle extends org.jbox2d.util.sph.Particle {
        public ID : number;

        pressure : number;

        density : number;

        h : number;

        c : number;

        ChangeDensity : number;

        ChangeVelocity : org.jbox2d.common.Vec2;

        shapeID : number;

        numNeighbors : number;

        minDensity : number;

        maxDensity : number;

        public constructor(p? : any, v? : any, m? : any, d? : any, pr? : any, len? : any, speedSnd? : any) {
            if(((p != null && p instanceof <any>org.jbox2d.common.Vec2) || p === null) && ((v != null && v instanceof <any>org.jbox2d.common.Vec2) || v === null) && ((typeof m === 'number') || m === null) && ((typeof d === 'number') || d === null) && ((typeof pr === 'number') || pr === null) && ((typeof len === 'number') || len === null) && ((typeof speedSnd === 'number') || speedSnd === null)) {
                let __args = arguments;
                super(p, v, m);
                if(this.ID===undefined) this.ID = 0;
                if(this.pressure===undefined) this.pressure = 0;
                if(this.density===undefined) this.density = 0;
                if(this.h===undefined) this.h = 0;
                if(this.c===undefined) this.c = 0;
                if(this.ChangeDensity===undefined) this.ChangeDensity = 0;
                if(this.ChangeVelocity===undefined) this.ChangeVelocity = null;
                if(this.shapeID===undefined) this.shapeID = 0;
                if(this.numNeighbors===undefined) this.numNeighbors = 0;
                if(this.minDensity===undefined) this.minDensity = 0;
                if(this.maxDensity===undefined) this.maxDensity = 0;
                if(this.ID===undefined) this.ID = 0;
                if(this.pressure===undefined) this.pressure = 0;
                if(this.density===undefined) this.density = 0;
                if(this.h===undefined) this.h = 0;
                if(this.c===undefined) this.c = 0;
                if(this.ChangeDensity===undefined) this.ChangeDensity = 0;
                if(this.ChangeVelocity===undefined) this.ChangeVelocity = null;
                if(this.shapeID===undefined) this.shapeID = 0;
                if(this.numNeighbors===undefined) this.numNeighbors = 0;
                if(this.minDensity===undefined) this.minDensity = 0;
                if(this.maxDensity===undefined) this.maxDensity = 0;
                (() => {
                    this.pressure = pr;
                    this.density = d;
                    this.h = len;
                    this.c = speedSnd;
                    this.ChangeDensity = 0.0;
                    this.ChangeVelocity = new org.jbox2d.common.Vec2(0.0, 0.0);
                    this.shapeID = -1;
                    this.ID = 0;
                    this.minDensity = 999999.0;
                    this.maxDensity = -999999.0;
                    this.numNeighbors = 0;
                })();
            } else if(((p != null && p instanceof <any>org.jbox2d.util.sph.SmoothParticle) || p === null) && v === undefined && m === undefined && d === undefined && pr === undefined && len === undefined && speedSnd === undefined) {
                let __args = arguments;
                let SP : any = __args[0];
                super();
                if(this.ID===undefined) this.ID = 0;
                if(this.pressure===undefined) this.pressure = 0;
                if(this.density===undefined) this.density = 0;
                if(this.h===undefined) this.h = 0;
                if(this.c===undefined) this.c = 0;
                if(this.ChangeDensity===undefined) this.ChangeDensity = 0;
                if(this.ChangeVelocity===undefined) this.ChangeVelocity = null;
                if(this.shapeID===undefined) this.shapeID = 0;
                if(this.numNeighbors===undefined) this.numNeighbors = 0;
                if(this.minDensity===undefined) this.minDensity = 0;
                if(this.maxDensity===undefined) this.maxDensity = 0;
                if(this.ID===undefined) this.ID = 0;
                if(this.pressure===undefined) this.pressure = 0;
                if(this.density===undefined) this.density = 0;
                if(this.h===undefined) this.h = 0;
                if(this.c===undefined) this.c = 0;
                if(this.ChangeDensity===undefined) this.ChangeDensity = 0;
                if(this.ChangeVelocity===undefined) this.ChangeVelocity = null;
                if(this.shapeID===undefined) this.shapeID = 0;
                if(this.numNeighbors===undefined) this.numNeighbors = 0;
                if(this.minDensity===undefined) this.minDensity = 0;
                if(this.maxDensity===undefined) this.maxDensity = 0;
                (() => {
                    this.pos = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(SP.pos);
                    this.vel = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(SP.vel);
                    this.mass = SP.mass;
                    this.density = SP.getDensity();
                    this.pressure = SP.getPressure();
                    this.h = SP.getSmoothingLength();
                    this.c = SP.getSpeedSound();
                    this.minDensity = SP.getMinDensity();
                    this.maxDensity = SP.getMaxDensity();
                    this.ChangeVelocity = SP.getChangeVelocity();
                    this.ChangeDensity = SP.getChangeDensity();
                    this.deleted = SP.deleted;
                    this.ID = SP.ID;
                    this.shapeID = SP.shapeID;
                    this.numNeighbors = SP.numNeighbors;
                })();
            } else if(p === undefined && v === undefined && m === undefined && d === undefined && pr === undefined && len === undefined && speedSnd === undefined) {
                let __args = arguments;
                super();
                if(this.ID===undefined) this.ID = 0;
                if(this.pressure===undefined) this.pressure = 0;
                if(this.density===undefined) this.density = 0;
                if(this.h===undefined) this.h = 0;
                if(this.c===undefined) this.c = 0;
                if(this.ChangeDensity===undefined) this.ChangeDensity = 0;
                if(this.ChangeVelocity===undefined) this.ChangeVelocity = null;
                if(this.shapeID===undefined) this.shapeID = 0;
                if(this.numNeighbors===undefined) this.numNeighbors = 0;
                if(this.minDensity===undefined) this.minDensity = 0;
                if(this.maxDensity===undefined) this.maxDensity = 0;
                if(this.ID===undefined) this.ID = 0;
                if(this.pressure===undefined) this.pressure = 0;
                if(this.density===undefined) this.density = 0;
                if(this.h===undefined) this.h = 0;
                if(this.c===undefined) this.c = 0;
                if(this.ChangeDensity===undefined) this.ChangeDensity = 0;
                if(this.ChangeVelocity===undefined) this.ChangeVelocity = null;
                if(this.shapeID===undefined) this.shapeID = 0;
                if(this.numNeighbors===undefined) this.numNeighbors = 0;
                if(this.minDensity===undefined) this.minDensity = 0;
                if(this.maxDensity===undefined) this.maxDensity = 0;
                (() => {
                    this.pressure = 0.0;
                    this.density = 0.0;
                    this.h = 0.0;
                    this.c = 0.0;
                    this.ChangeDensity = 0.0;
                    this.ChangeVelocity = new org.jbox2d.common.Vec2(0.0, 0.0);
                    this.ID = 0;
                    this.shapeID = -1;
                    this.minDensity = 999999.0;
                    this.maxDensity = -999999.0;
                    this.numNeighbors = 0;
                })();
            } else throw new Error('invalid overload');
        }

        public setPressure(p : number) {
            this.pressure = p;
        }

        public setDensity(den : number) {
            this.density = den;
        }

        public setSmoothingLength(len : number) {
            this.h = len;
        }

        public setSpeedSound(spSnd : number) {
            this.c = spSnd;
        }

        public setChangeVelocity(ChangeV : org.jbox2d.common.Vec2) {
            this.ChangeVelocity.set$org_jbox2d_common_Vec2(ChangeV);
        }

        public setChangeDensity(cd : number) {
            this.ChangeDensity = cd;
        }

        public setMinDensity(m : number) {
            this.minDensity = m;
        }

        public setMaxDensity(m : number) {
            this.maxDensity = m;
        }

        public setShapeID(id : number) {
            this.shapeID = id;
        }

        public setNumNeighbors(n : number) {
            this.numNeighbors = n;
        }

        public getPressure() : number {
            return this.pressure;
        }

        public getSmoothingLength() : number {
            return this.h;
        }

        public getDensity() : number {
            return this.density;
        }

        public getSpeedSound() : number {
            return this.c;
        }

        public getChangeDensity() : number {
            return this.ChangeDensity;
        }

        public getChangeVelocity() : org.jbox2d.common.Vec2 {
            return this.ChangeVelocity;
        }

        public getChangeVelocityX() : number {
            return this.ChangeVelocity.x;
        }

        public getChangeVelocityY() : number {
            return this.ChangeVelocity.y;
        }

        public getShapeID() : number {
            return this.shapeID;
        }

        public getMinDensity() : number {
            return this.minDensity;
        }

        public getMaxDensity() : number {
            return this.maxDensity;
        }

        public getNumNeighbors() : number {
            return this.numNeighbors;
        }

        /**
         * Calculates the pressure for this SPH particle.
         * The state equation comes from **** and is used to model water.
         * @param {org.jbox2d.util.sph.Parameter} p
         */
        public calcPressure(p : org.jbox2d.util.sph.Parameter) {
            this.pressure = p.c * p.c * this.density;
        }

        /**
         * Zeroes out the delta values. The reason is because the delta
         * values come from summing up contributions from all neighbors and
         * we don't want to add to the last time steps value.
         */
        public zeroSPHVars() {
            this.ChangeDensity = 0.0;
            this.ChangeVelocity.set$float$float(0.0, 0.0);
            this.numNeighbors = 0;
        }

        /**
         * Adds the contributions of the change in density from the neighbor
         * "sp".
         * @param {org.jbox2d.util.sph.SmoothParticle} sp
         * @param {org.jbox2d.common.Vec2} v_ij
         */
        public calcChangeDensity(sp : SmoothParticle, v_ij : org.jbox2d.common.Vec2) {
            this.ChangeDensity += sp.mass * (v_ij.x * this.gradientKernelX(sp) + v_ij.y * this.gradientKernelY(sp));
        }

        /**
         * Add the contribution of the acceleration due to the free
         * particle "sp".
         * @param {org.jbox2d.util.sph.SmoothParticle} sp
         * @param {org.jbox2d.common.Vec2} v_ij
         * @param {org.jbox2d.util.sph.Parameter} param
         */
        public calcChangeVelocity(sp : SmoothParticle, v_ij : org.jbox2d.common.Vec2, param : org.jbox2d.util.sph.Parameter) {
            let pressTerm : number = this.pressureTerm(sp);
            let artVisc : number = this.artificialViscosity(sp, param);
            let oldChngVelX : number = this.ChangeVelocity.x;
            let oldChngVelY : number = this.ChangeVelocity.y;
            this.ChangeVelocity.x = (<any>Math).fround((oldChngVelX + sp.mass * (pressTerm * this.gradientKernelX(sp) + v_ij.x * artVisc)));
            this.ChangeVelocity.y = (<any>Math).fround((oldChngVelY + sp.mass * (pressTerm * this.gradientKernelY(sp) + v_ij.y * artVisc)));
        }

        /**
         * Add the body force in the x direction.
         * @param {org.jbox2d.util.sph.Parameter} param
         */
        public addForceX(param : org.jbox2d.util.sph.Parameter) {
            this.ChangeVelocity.x = (<any>Math).fround((this.ChangeVelocity.x + param.bodyFX));
        }

        /**
         * Add the body force in the y direction.
         * @param {org.jbox2d.util.sph.Parameter} param
         */
        public addForceY(param : org.jbox2d.util.sph.Parameter) {
            this.ChangeVelocity.x = (<any>Math).fround((this.ChangeVelocity.y + param.bodyFY));
        }

        /**
         * Calculate the pressure gradient due to the free particle "sp".
         * @param {org.jbox2d.util.sph.SmoothParticle} sp
         * @return {number}
         * @private
         */
        /*private*/ pressureTerm(sp : SmoothParticle) : number {
            return (-1.0 * (this.pressure / (this.density * this.density) + sp.getPressure() / (sp.getDensity() * sp.getDensity())));
        }

        /**
         * This is used to simulate viscous fluids.
         * @param {org.jbox2d.util.sph.SmoothParticle} sp
         * @param {org.jbox2d.util.sph.Parameter} param
         * @return {number}
         */
        artificialViscosity(sp : SmoothParticle, param : org.jbox2d.util.sph.Parameter) : number {
            let distance : number = Math.sqrt((<any>Math).fround((<any>Math).fround(((<any>Math).fround(this.pos.x - sp.pos.x)) * ((<any>Math).fround(this.pos.x - sp.pos.x))) + (<any>Math).fround(((<any>Math).fround(this.pos.y - sp.pos.y)) * ((<any>Math).fround(this.pos.y - sp.pos.y)))));
            let r_ij : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(((<any>Math).fround(this.pos.x - sp.pos.x)), ((<any>Math).fround(this.pos.y - sp.pos.y)));
            return (param.nu * (this.density + sp.getDensity()) * (r_ij.x * this.gradientKernelX(sp) + r_ij.y * this.gradientKernelY(sp))) / ((this.density * sp.getDensity()) * (distance * distance + 0.01 * this.h * this.h));
        }

        /**
         * SPH smoothing kernel
         * @param {org.jbox2d.util.sph.SmoothParticle} sp
         * @return {number}
         */
        kernel(sp : SmoothParticle) : number {
            let distance : number = 0;
            let normalization : number = 10.0 / (7.0 * Math.PI * this.h * this.h);
            let dist1 : number = (<any>Math).fround(this.pos.x - sp.pos.x);
            let dist2 : number = (<any>Math).fround(this.pos.y - sp.pos.y);
            distance = Math.sqrt(dist1 * dist1 + dist2 * dist2);
            if(distance < this.h) return (normalization) * (1.0 - 1.5 * distance * distance / (this.h * this.h) + 0.75 * distance * distance * distance / (this.h * this.h * this.h)); else if(distance < 2.0 * this.h) return normalization * (2.0 - 3.0 * distance / this.h + 1.5 * distance * distance / (this.h * this.h) - 0.25 * distance * distance * distance / (this.h * this.h * this.h)); else return 0.0;
        }

        /**
         * X component of gradient of SPH smoothing kernel
         * @param {org.jbox2d.util.sph.SmoothParticle} sp
         * @return {number}
         */
        gradientKernelX(sp : SmoothParticle) : number {
            let distance : number = 0.0;
            let diffX : number = 0.0;
            let diffY : number = 0.0;
            let normalization : number = 10.0 / (7.0 * Math.PI * this.h * this.h);
            diffX = (<any>Math).fround(this.pos.x - sp.pos.x);
            diffY = (<any>Math).fround(this.pos.y - sp.pos.y);
            distance = Math.sqrt(diffX * diffX + diffY * diffY);
            if(distance < this.h) return normalization * (-3.0 / (this.h * this.h) + 9.0 * distance / (4.0 * this.h * this.h * this.h)) * diffX; else if(distance < 2.0 * this.h) return normalization * (-3.0 / (this.h * distance) + 3.0 / (this.h * this.h) - 3.0 * distance / (4.0 * this.h * this.h * this.h)) * diffX; else return 0.0;
        }

        /**
         * Y component of gradient of SPH smoothing kernel
         * @param {org.jbox2d.util.sph.SmoothParticle} sp
         * @return {number}
         */
        gradientKernelY(sp : SmoothParticle) : number {
            let distance : number = 0.0;
            let diffX : number = 0.0;
            let diffY : number = 0.0;
            let normalization : number = 10.0 / (7.0 * Math.PI * this.h * this.h);
            diffX = (<any>Math).fround(this.pos.x - sp.pos.x);
            diffY = (<any>Math).fround(this.pos.y - sp.pos.y);
            distance = Math.sqrt(diffX * diffX + diffY * diffY);
            if(distance < this.h) return normalization * (-3.0 / (this.h * this.h) + 9.0 * distance / (4.0 * this.h * this.h * this.h)) * diffY; else if(distance < 2.0 * this.h) return normalization * (-3.0 / (this.h * distance) + 3.0 / (this.h * this.h) - 3.0 * distance / (4.0 * this.h * this.h * this.h)) * diffY; else {
                return 0.0;
            }
        }

        /**
         * Keeps track of our particle's min and max density
         */
        public setMinMaxDensity() {
            if(this.density > this.maxDensity) this.maxDensity = this.density; else if(this.density < this.minDensity) this.minDensity = this.density;
        }

        /**
         * Used to keep a total of the number of neighbors within 2*h of
         * this smooth particle.  Used for debugging.
         * @param {org.jbox2d.util.sph.SmoothParticle} sp
         */
        updateNumNeighbors(sp : SmoothParticle) {
            let distance : number = Math.sqrt((<any>Math).fround((<any>Math).fround(((<any>Math).fround(this.pos.x - sp.pos.x)) * ((<any>Math).fround(this.pos.x - sp.pos.x))) + (<any>Math).fround(((<any>Math).fround(this.pos.y - sp.pos.y)) * ((<any>Math).fround(this.pos.y - sp.pos.y)))));
            if(distance < 2 * this.h) this.numNeighbors++;
        }
    }
    SmoothParticle["__class"] = "org.jbox2d.util.sph.SmoothParticle";

}
namespace org.jbox2d.dynamics.contacts {
    export class PointAndPolyContact extends org.jbox2d.dynamics.contacts.Contact implements org.jbox2d.dynamics.contacts.ContactCreateFcn {
        public m_manifold : org.jbox2d.collision.Manifold;

        public manifoldList : Array<org.jbox2d.collision.Manifold>;

        public constructor(s1? : any, s2? : any) {
            if(((s1 != null && s1 instanceof <any>org.jbox2d.collision.shapes.Shape) || s1 === null) && ((s2 != null && s2 instanceof <any>org.jbox2d.collision.shapes.Shape) || s2 === null)) {
                let __args = arguments;
                super(s1, s2);
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    if(!((this.m_shape1.getType() === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE))) throw new Error("Assertion error line 15: assert (m_shape1.getType() == ShapeType.POLYGON_SHAPE);");;
                    if(!((this.m_shape2.getType() === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE))) throw new Error("Assertion error line 16: assert (m_shape2.getType() == ShapeType.POINT_SHAPE);");;
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                    this.m_manifoldCount = 0;
                    this.m_manifold.points[0].normalImpulse = 0.0;
                    this.m_manifold.points[0].tangentImpulse = 0.0;
                })();
            } else if(s1 === undefined && s2 === undefined) {
                let __args = arguments;
                super();
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                    this.m_manifoldCount = 0;
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {org.jbox2d.dynamics.contacts.Contact}
         */
        public clone() : org.jbox2d.dynamics.contacts.Contact {
            let newC : PointAndPolyContact = new PointAndPolyContact(this.m_shape1, this.m_shape2);
            newC.m_manifold.set(this.m_manifold);
            newC.m_manifoldCount = this.m_manifoldCount;
            newC.m_world = this.m_world;
            newC.m_prev = this.m_prev;
            newC.m_next = this.m_next;
            newC.m_node1.set(this.m_node1);
            newC.m_node2.set(this.m_node2);
            newC.m_friction = this.m_friction;
            newC.m_restitution = this.m_restitution;
            newC.m_flags = this.m_flags;
            return newC;
        }

        public create(shape1 : org.jbox2d.collision.shapes.Shape, shape2 : org.jbox2d.collision.shapes.Shape) : org.jbox2d.dynamics.contacts.Contact {
            return new PointAndPolyContact(shape1, shape2);
        }

        /**
         * 
         * @return {org.jbox2d.collision.Manifold[]}
         */
        public getManifolds() : Array<org.jbox2d.collision.Manifold> {
            let ret : Array<org.jbox2d.collision.Manifold> = <any>([]);
            if(this.m_manifold != null) {
                /* add */(ret.push(this.m_manifold)>0);
            }
            return ret;
        }

        public getFirstManifold() : org.jbox2d.collision.Manifold {
            return this.m_manifold;
        }

        static tlm0 : org.jbox2d.pooling.TLManifold; public static tlm0_$LI$() : org.jbox2d.pooling.TLManifold { if(PointAndPolyContact.tlm0 == null) PointAndPolyContact.tlm0 = (() => { let __o : any = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return PointAndPolyContact.tlm0; };

        static tlV1 : org.jbox2d.pooling.TLVec2; public static tlV1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PointAndPolyContact.tlV1 == null) PointAndPolyContact.tlV1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointAndPolyContact.tlV1; };

        static tlCp : org.jbox2d.pooling.TLContactPoint; public static tlCp_$LI$() : org.jbox2d.pooling.TLContactPoint { if(PointAndPolyContact.tlCp == null) PointAndPolyContact.tlCp = (() => { let __o : any = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return PointAndPolyContact.tlCp; };

        static tlPersisted : org.jbox2d.pooling.arrays.BooleanArray; public static tlPersisted_$LI$() : org.jbox2d.pooling.arrays.BooleanArray { if(PointAndPolyContact.tlPersisted == null) PointAndPolyContact.tlPersisted = new org.jbox2d.pooling.arrays.BooleanArray(); return PointAndPolyContact.tlPersisted; };

        /**
         * 
         * @param {*} listener
         */
        public evaluate(listener : org.jbox2d.dynamics.ContactListener) {
            let b1 : org.jbox2d.dynamics.Body = this.m_shape1.getBody();
            let b2 : org.jbox2d.dynamics.Body = this.m_shape2.getBody();
            let m0 : org.jbox2d.collision.Manifold = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointAndPolyContact.tlm0_$LI$());
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointAndPolyContact.tlV1_$LI$());
            let cp : org.jbox2d.dynamics.contacts.ContactPoint = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointAndPolyContact.tlCp_$LI$());
            m0.set(this.m_manifold);
            org.jbox2d.pooling.SingletonPool.getCollidePoly().collidePolygonAndPoint(this.m_manifold, <org.jbox2d.collision.shapes.PolygonShape>this.m_shape1, b1.getMemberXForm(), <org.jbox2d.collision.shapes.PointShape>this.m_shape2, b2.getMemberXForm());
            let persisted : boolean[] = PointAndPolyContact.tlPersisted_$LI$().get(2);
            persisted[0] = false;
            persisted[1] = false;
            cp.shape1 = this.m_shape1;
            cp.shape2 = this.m_shape2;
            cp.friction = this.m_friction;
            cp.restitution = this.m_restitution;
            if(this.m_manifold.pointCount > 0) {
                for(let i : number = 0; i < this.m_manifold.pointCount; ++i) {{
                    let mp : org.jbox2d.collision.ManifoldPoint = this.m_manifold.points[i];
                    mp.normalImpulse = 0.0;
                    mp.tangentImpulse = 0.0;
                    let found : boolean = false;
                    cp.id.set(mp.id);
                    for(let j : number = 0; j < m0.pointCount; ++j) {{
                        if(persisted[j] === true) {
                            continue;
                        }
                        let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[j];
                        if(mp0.id.isEqual(cp.id)) {
                            persisted[j] = true;
                            mp.normalImpulse = mp0.normalImpulse;
                            mp.tangentImpulse = mp0.tangentImpulse;
                            found = true;
                            if(listener != null) {
                                b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                cp.separation = mp.separation;
                                listener.persist(cp);
                            }
                            break;
                        }
                    };}
                    if(found === false && listener != null) {
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                        cp.separation = mp.separation;
                        listener.add(cp);
                    }
                };}
                this.m_manifoldCount = 1;
            } else {
                this.m_manifoldCount = 0;
            }
            if(listener == null) {
                return;
            }
            for(let i : number = 0; i < m0.pointCount; ++i) {{
                if(persisted[i]) {
                    continue;
                }
                let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[i];
                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                cp.velocity.subLocal(v1);
                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                cp.separation = mp0.separation;
                cp.id.set(mp0.id);
                listener.remove(cp);
            };}
        }
    }
    PointAndPolyContact["__class"] = "org.jbox2d.dynamics.contacts.PointAndPolyContact";
    PointAndPolyContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];


}
namespace org.jbox2d.dynamics.contacts {
    export class PolyAndCircleContact extends org.jbox2d.dynamics.contacts.Contact implements org.jbox2d.dynamics.contacts.ContactCreateFcn {
        public m_manifold : org.jbox2d.collision.Manifold;

        public manifoldList : Array<org.jbox2d.collision.Manifold>;

        public constructor(s1? : any, s2? : any) {
            if(((s1 != null && s1 instanceof <any>org.jbox2d.collision.shapes.Shape) || s1 === null) && ((s2 != null && s2 instanceof <any>org.jbox2d.collision.shapes.Shape) || s2 === null)) {
                let __args = arguments;
                super(s1, s2);
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    if(!((this.m_shape1.getType() === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE))) throw new Error("Assertion error line 15: assert (m_shape1.getType() == ShapeType.POLYGON_SHAPE);");;
                    if(!((this.m_shape2.getType() === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE))) throw new Error("Assertion error line 16: assert (m_shape2.getType() == ShapeType.CIRCLE_SHAPE);");;
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                    this.m_manifoldCount = 0;
                })();
            } else if(s1 === undefined && s2 === undefined) {
                let __args = arguments;
                super();
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    this.m_manifoldCount = 0;
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {org.jbox2d.dynamics.contacts.Contact}
         */
        public clone() : org.jbox2d.dynamics.contacts.Contact {
            let newC : PolyAndCircleContact = new PolyAndCircleContact(this.m_shape1, this.m_shape2);
            newC.m_manifold.set(this.m_manifold);
            newC.m_manifoldCount = this.m_manifoldCount;
            newC.m_world = this.m_world;
            newC.m_prev = this.m_prev;
            newC.m_next = this.m_next;
            newC.m_node1.set(this.m_node1);
            newC.m_node2.set(this.m_node2);
            newC.m_friction = this.m_friction;
            newC.m_restitution = this.m_restitution;
            newC.m_flags = this.m_flags;
            return newC;
        }

        public create(shape1 : org.jbox2d.collision.shapes.Shape, shape2 : org.jbox2d.collision.shapes.Shape) : org.jbox2d.dynamics.contacts.Contact {
            return new PolyAndCircleContact(shape1, shape2);
        }

        /**
         * 
         * @return {org.jbox2d.collision.Manifold[]}
         */
        public getManifolds() : Array<org.jbox2d.collision.Manifold> {
            return this.manifoldList;
        }

        static tlm0 : org.jbox2d.pooling.TLManifold; public static tlm0_$LI$() : org.jbox2d.pooling.TLManifold { if(PolyAndCircleContact.tlm0 == null) PolyAndCircleContact.tlm0 = (() => { let __o : any = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return PolyAndCircleContact.tlm0; };

        static tlV1 : org.jbox2d.pooling.TLVec2; public static tlV1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolyAndCircleContact.tlV1 == null) PolyAndCircleContact.tlV1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolyAndCircleContact.tlV1; };

        static tlCp : org.jbox2d.pooling.TLContactPoint; public static tlCp_$LI$() : org.jbox2d.pooling.TLContactPoint { if(PolyAndCircleContact.tlCp == null) PolyAndCircleContact.tlCp = (() => { let __o : any = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return PolyAndCircleContact.tlCp; };

        static tlPersisted : org.jbox2d.pooling.arrays.BooleanArray; public static tlPersisted_$LI$() : org.jbox2d.pooling.arrays.BooleanArray { if(PolyAndCircleContact.tlPersisted == null) PolyAndCircleContact.tlPersisted = new org.jbox2d.pooling.arrays.BooleanArray(); return PolyAndCircleContact.tlPersisted; };

        /**
         * 
         * @param {*} listener
         */
        public evaluate(listener : org.jbox2d.dynamics.ContactListener) {
            let b1 : org.jbox2d.dynamics.Body = this.m_shape1.getBody();
            let b2 : org.jbox2d.dynamics.Body = this.m_shape2.getBody();
            let m0 : org.jbox2d.collision.Manifold = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolyAndCircleContact.tlm0_$LI$());
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolyAndCircleContact.tlV1_$LI$());
            let cp : org.jbox2d.dynamics.contacts.ContactPoint = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolyAndCircleContact.tlCp_$LI$());
            m0.set(this.m_manifold);
            org.jbox2d.pooling.SingletonPool.getCollideCircle().collidePolygonAndCircle(this.m_manifold, <org.jbox2d.collision.shapes.PolygonShape>this.m_shape1, b1.getMemberXForm(), <org.jbox2d.collision.shapes.CircleShape>this.m_shape2, b2.getMemberXForm());
            let persisted : boolean[] = PolyAndCircleContact.tlPersisted_$LI$().get(2);
            persisted[0] = false;
            persisted[1] = false;
            cp.shape1 = this.m_shape1;
            cp.shape2 = this.m_shape2;
            cp.friction = this.m_friction;
            cp.restitution = this.m_restitution;
            if(this.m_manifold.pointCount > 0) {
                for(let i : number = 0; i < this.m_manifold.pointCount; ++i) {{
                    let mp : org.jbox2d.collision.ManifoldPoint = this.m_manifold.points[i];
                    mp.normalImpulse = 0.0;
                    mp.tangentImpulse = 0.0;
                    let found : boolean = false;
                    let id : org.jbox2d.collision.ContactID = mp.id;
                    for(let j : number = 0; j < m0.pointCount; ++j) {{
                        if(persisted[j] === true) {
                            continue;
                        }
                        let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[j];
                        if(mp0.id.isEqual(id)) {
                            persisted[j] = true;
                            mp.normalImpulse = mp0.normalImpulse;
                            mp.tangentImpulse = mp0.tangentImpulse;
                            found = true;
                            if(listener != null) {
                                b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                cp.separation = mp.separation;
                                cp.id.set(id);
                                listener.persist(cp);
                            }
                            break;
                        }
                    };}
                    if(found === false && listener != null) {
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                        cp.separation = mp.separation;
                        cp.id.set(id);
                        listener.add(cp);
                    }
                };}
                this.m_manifoldCount = 1;
            } else {
                this.m_manifoldCount = 0;
            }
            if(listener == null) {
                return;
            }
            for(let i : number = 0; i < m0.pointCount; ++i) {{
                if(persisted[i]) {
                    continue;
                }
                let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[i];
                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                cp.velocity.subLocal(v1);
                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                cp.separation = mp0.separation;
                cp.id.set(mp0.id);
                listener.remove(cp);
            };}
        }
    }
    PolyAndCircleContact["__class"] = "org.jbox2d.dynamics.contacts.PolyAndCircleContact";
    PolyAndCircleContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];


}
namespace org.jbox2d.dynamics.contacts {
    export class PolyAndEdgeContact extends org.jbox2d.dynamics.contacts.Contact implements org.jbox2d.dynamics.contacts.ContactCreateFcn {
        public m_manifold : org.jbox2d.collision.Manifold;

        public manifoldList : Array<org.jbox2d.collision.Manifold>;

        public create(s1 : org.jbox2d.collision.shapes.Shape, s2 : org.jbox2d.collision.shapes.Shape) : org.jbox2d.dynamics.contacts.Contact {
            return new PolyAndEdgeContact(s1, s2);
        }

        public constructor(shape1? : any, shape2? : any) {
            if(((shape1 != null && shape1 instanceof <any>org.jbox2d.collision.shapes.Shape) || shape1 === null) && ((shape2 != null && shape2 instanceof <any>org.jbox2d.collision.shapes.Shape) || shape2 === null)) {
                let __args = arguments;
                super(shape1, shape2);
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    if(!((this.m_shape1.getType() === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE))) throw new Error("Assertion error line 19: assert (m_shape1.getType() == ShapeType.POLYGON_SHAPE);");;
                    if(!((this.m_shape2.getType() === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE))) throw new Error("Assertion error line 20: assert (m_shape2.getType() == ShapeType.EDGE_SHAPE);");;
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    this.m_manifoldCount = 0;
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                })();
            } else if(shape1 === undefined && shape2 === undefined) {
                let __args = arguments;
                super();
                if(this.m_manifold===undefined) this.m_manifold = null;
                this.manifoldList = <any>([]);
                if(this.m_manifold===undefined) this.m_manifold = null;
                (() => {
                    this.m_manifold = new org.jbox2d.collision.Manifold();
                    /* add */(this.manifoldList.push(this.m_manifold)>0);
                    this.m_manifoldCount = 0;
                })();
            } else throw new Error('invalid overload');
        }

        public static Destroy(contact : org.jbox2d.dynamics.contacts.Contact) {
            (<PolyAndEdgeContact>contact).destructor();
        }

        public destructor() {
        }

        /**
         * 
         * @return {org.jbox2d.dynamics.contacts.Contact}
         */
        public clone() : org.jbox2d.dynamics.contacts.Contact {
            if(!(false)) throw new Error("Assertion error line 51: assert false : 'Not yet implemented.';");;
            return this;
        }

        static tlm0 : org.jbox2d.pooling.TLManifold; public static tlm0_$LI$() : org.jbox2d.pooling.TLManifold { if(PolyAndEdgeContact.tlm0 == null) PolyAndEdgeContact.tlm0 = (() => { let __o : any = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return PolyAndEdgeContact.tlm0; };

        static tlV1 : org.jbox2d.pooling.TLVec2; public static tlV1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolyAndEdgeContact.tlV1 == null) PolyAndEdgeContact.tlV1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolyAndEdgeContact.tlV1; };

        static tlCp : org.jbox2d.pooling.TLContactPoint; public static tlCp_$LI$() : org.jbox2d.pooling.TLContactPoint { if(PolyAndEdgeContact.tlCp == null) PolyAndEdgeContact.tlCp = (() => { let __o : any = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return PolyAndEdgeContact.tlCp; };

        static tlPersisted : org.jbox2d.pooling.arrays.BooleanArray; public static tlPersisted_$LI$() : org.jbox2d.pooling.arrays.BooleanArray { if(PolyAndEdgeContact.tlPersisted == null) PolyAndEdgeContact.tlPersisted = new org.jbox2d.pooling.arrays.BooleanArray(); return PolyAndEdgeContact.tlPersisted; };

        /**
         * 
         * @param {*} listener
         */
        public evaluate(listener : org.jbox2d.dynamics.ContactListener) {
            let b1 : org.jbox2d.dynamics.Body = this.m_shape1.getBody();
            let b2 : org.jbox2d.dynamics.Body = this.m_shape2.getBody();
            let m0 : org.jbox2d.collision.Manifold = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolyAndEdgeContact.tlm0_$LI$());
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolyAndEdgeContact.tlV1_$LI$());
            let cp : org.jbox2d.dynamics.contacts.ContactPoint = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolyAndEdgeContact.tlCp_$LI$());
            m0.set(this.m_manifold);
            org.jbox2d.pooling.SingletonPool.getCollidePoly().collidePolyAndEdge(this.m_manifold, <org.jbox2d.collision.shapes.PolygonShape>this.m_shape1, b1.getMemberXForm(), <org.jbox2d.collision.shapes.EdgeShape>this.m_shape2, b2.getMemberXForm());
            let persisted : boolean[] = PolyAndEdgeContact.tlPersisted_$LI$().get(2);
            persisted[0] = false;
            persisted[1] = false;
            cp.shape1 = this.m_shape1;
            cp.shape2 = this.m_shape2;
            cp.friction = this.m_friction;
            cp.restitution = this.m_restitution;
            if(this.m_manifold.pointCount > 0) {
                for(let i : number = 0; i < this.m_manifold.pointCount; ++i) {{
                    let mp : org.jbox2d.collision.ManifoldPoint = this.m_manifold.points[i];
                    mp.normalImpulse = 0.0;
                    mp.tangentImpulse = 0.0;
                    let found : boolean = false;
                    let id : org.jbox2d.collision.ContactID = mp.id;
                    for(let j : number = 0; j < m0.pointCount; ++j) {{
                        if(persisted[j] === true) {
                            continue;
                        }
                        let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[j];
                        if(mp0.id.isEqual(id)) {
                            persisted[j] = true;
                            mp.normalImpulse = mp0.normalImpulse;
                            mp.tangentImpulse = mp0.tangentImpulse;
                            found = true;
                            if(listener != null) {
                                b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                cp.separation = mp.separation;
                                cp.id.set(id);
                                listener.persist(cp);
                            }
                            break;
                        }
                    };}
                    if(found === false && listener != null) {
                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                        cp.velocity.subLocal(v1);
                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                        cp.separation = mp.separation;
                        cp.id.set(id);
                        listener.add(cp);
                    }
                };}
                this.m_manifoldCount = 1;
            } else {
                this.m_manifoldCount = 0;
            }
            if(listener == null) {
                return;
            }
            for(let i : number = 0; i < m0.pointCount; ++i) {{
                if(persisted[i]) {
                    continue;
                }
                let mp0 : org.jbox2d.collision.ManifoldPoint = m0.points[i];
                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                cp.velocity.subLocal(v1);
                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                cp.separation = mp0.separation;
                cp.id.set(mp0.id);
                listener.remove(cp);
            };}
        }

        /**
         * 
         * @return {org.jbox2d.collision.Manifold[]}
         */
        public getManifolds() : Array<org.jbox2d.collision.Manifold> {
            return this.manifoldList;
        }
    }
    PolyAndEdgeContact["__class"] = "org.jbox2d.dynamics.contacts.PolyAndEdgeContact";
    PolyAndEdgeContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];


}
namespace org.jbox2d.collision {
    /**
     * This broad phase uses the Sweep and Prune algorithm as described in:
     * Collision Detection in Interactive 3D Environments by Gino van den Bergen
     * Also, some ideas, such as using integral values for fast compares comes from
     * Bullet (http:/www.bulletphysics.com).<br/>
     * <br/>
     * 
     * Notes:<br/>
     * - we use bound arrays instead of linked lists for cache coherence.<br/>
     * - we use quantized integral values for fast compares.<br/>
     * - we use short indices rather than pointers to save memory.<br/>
     * - we use a stabbing count for fast overlap queries (less than order N).<br/>
     * - we also use a time stamp on each proxy to speed up the registration of
     * overlap query results.<br/>
     * - where possible, we compare bound indices instead of values to reduce cache
     * misses (TODO_ERIN).<br/>
     * - no broadphase is perfect and neither is this one: it is not great for huge
     * worlds (use a multi-SAP instead), it is not great for large objects.
     * @param {org.jbox2d.collision.AABB} worldAABB
     * @param {*} callback
     * @class
     */
    export class BroadPhase {
        public static INVALID : number; public static INVALID_$LI$() : number { if(BroadPhase.INVALID == null) BroadPhase.INVALID = 2147483647; return BroadPhase.INVALID; };

        public static NULL_EDGE : number; public static NULL_EDGE_$LI$() : number { if(BroadPhase.NULL_EDGE == null) BroadPhase.NULL_EDGE = 2147483647; return BroadPhase.NULL_EDGE; };

        public m_pairManager : org.jbox2d.collision.PairManager;

        public m_proxyPool : org.jbox2d.collision.Proxy[];

        m_freeProxy : number;

        pairBuffer : org.jbox2d.collision.BufferedPair[];

        m_pairBufferCount : number;

        public m_bounds : org.jbox2d.collision.Bound[][];

        m_queryResults : number[];

        m_querySortKeys : number[];

        m_queryResultCount : number;

        public m_worldAABB : org.jbox2d.collision.AABB;

        public m_quantizationFactor : org.jbox2d.common.Vec2;

        public m_proxyCount : number;

        m_timeStamp : number;

        public static debugPrint : boolean = false;

        public static s_validate : boolean = false;

        /*private*/ dump() {
            console.info("*****DUMP START");
            for(let i : number = 0; i < 100; i++) {{
                console.info("bounds[ " + i + " ] = " + this.m_bounds[0][i].value + ", " + this.m_bounds[1][i].value + " \n");
            };}
            for(let i : number = 0; i < this.m_proxyPool.length; i++) {{
                let p : org.jbox2d.collision.Proxy = this.m_proxyPool[i];
                if(p != null) {
                    console.info("proxy#" + i + ": valid=" + p.isValid() + " userData= upperBounds=" + /* implicit toString */ (a => a?'['+a.join(', ')+']':'null')(/* asList */p.upperBounds.slice(0)) + " lowerBounds=" + /* implicit toString */ (a => a?'['+a.join(', ')+']':'null')(/* asList */p.lowerBounds.slice(0)) + " timeStamp=" + p.timeStamp + " overlapCount=" + p.overlapCount + " next=" + p.getNext());
                }
            };}
            console.info("*****DUMP END");
        }

        public constructor(worldAABB : org.jbox2d.collision.AABB, callback : org.jbox2d.collision.PairCallback) {
            if(this.m_pairManager===undefined) this.m_pairManager = null;
            if(this.m_proxyPool===undefined) this.m_proxyPool = null;
            if(this.m_freeProxy===undefined) this.m_freeProxy = 0;
            if(this.pairBuffer===undefined) this.pairBuffer = null;
            if(this.m_pairBufferCount===undefined) this.m_pairBufferCount = 0;
            if(this.m_bounds===undefined) this.m_bounds = null;
            if(this.m_queryResults===undefined) this.m_queryResults = null;
            if(this.m_querySortKeys===undefined) this.m_querySortKeys = null;
            if(this.m_queryResultCount===undefined) this.m_queryResultCount = 0;
            if(this.m_worldAABB===undefined) this.m_worldAABB = null;
            if(this.m_quantizationFactor===undefined) this.m_quantizationFactor = null;
            if(this.m_proxyCount===undefined) this.m_proxyCount = 0;
            if(this.m_timeStamp===undefined) this.m_timeStamp = 0;
            if(BroadPhase.debugPrint) {
                console.info("BroadPhase()");
            }
            this.m_querySortKeys = (s => { let a=[]; while(s-->0) a.push(0); return a; })(org.jbox2d.common.Settings.maxProxies);
            this.m_proxyPool = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxProxies);
            this.pairBuffer = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxPairs_$LI$());
            this.m_bounds = <any> (function(dims) { let allocate = function(dims) { if(dims.length==0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([2, 2 * org.jbox2d.common.Settings.maxProxies]);
            this.m_queryResults = (s => { let a=[]; while(s-->0) a.push(0); return a; })(org.jbox2d.common.Settings.maxProxies);
            for(let i : number = 0; i < 2 * org.jbox2d.common.Settings.maxProxies; i++) {{
                this.m_bounds[0][i] = new org.jbox2d.collision.Bound();
                this.m_bounds[1][i] = new org.jbox2d.collision.Bound();
            };}
            for(let i : number = 0; i < org.jbox2d.common.Settings.maxProxies; i++) {{
                this.pairBuffer[i] = new org.jbox2d.collision.BufferedPair();
            };}
            this.m_pairManager = new org.jbox2d.collision.PairManager();
            this.m_pairManager.initialize(this, callback);
            if(!(worldAABB.isValid())) throw new Error("Assertion error line 104: assert worldAABB.isValid();");;
            this.m_worldAABB = new org.jbox2d.collision.AABB(worldAABB);
            this.m_proxyCount = 0;
            let d : org.jbox2d.common.Vec2 = worldAABB.upperBound.sub(worldAABB.lowerBound);
            this.m_quantizationFactor = new org.jbox2d.common.Vec2((<any>Math).fround(2147483647 / d.x), (<any>Math).fround(2147483647 / d.y));
            if(BroadPhase.debugPrint) {
                console.info("BroadPhase: m_quantizationFactor=" + this.m_quantizationFactor);
            }
            for(let i : number = 0; i < org.jbox2d.common.Settings.maxProxies - 1; ++i) {{
                this.m_proxyPool[i] = new org.jbox2d.collision.Proxy();
                this.m_proxyPool[i].setNext(i + 1);
                this.m_proxyPool[i].timeStamp = 0;
                this.m_proxyPool[i].overlapCount = BroadPhase.INVALID_$LI$();
                this.m_proxyPool[i].userData = null;
            };}
            this.m_proxyPool[org.jbox2d.common.Settings.maxProxies - 1] = new org.jbox2d.collision.Proxy();
            this.m_proxyPool[org.jbox2d.common.Settings.maxProxies - 1].setNext(org.jbox2d.collision.PairManager.NULL_PROXY_$LI$());
            this.m_proxyPool[org.jbox2d.common.Settings.maxProxies - 1].timeStamp = 0;
            this.m_proxyPool[org.jbox2d.common.Settings.maxProxies - 1].overlapCount = BroadPhase.INVALID_$LI$();
            this.m_proxyPool[org.jbox2d.common.Settings.maxProxies - 1].userData = null;
            this.m_freeProxy = 0;
            this.m_timeStamp = 1;
            this.m_queryResultCount = 0;
        }

        public testOverlap$org_jbox2d_collision_Proxy$org_jbox2d_collision_Proxy(p1 : org.jbox2d.collision.Proxy, p2 : org.jbox2d.collision.Proxy) : boolean {
            for(let axis : number = 0; axis < 2; ++axis) {{
                let bounds : org.jbox2d.collision.Bound[] = this.m_bounds[axis];
                if(!((p1.lowerBounds[axis] < 2 * this.m_proxyCount))) throw new Error("Assertion error line 132: assert (p1.lowerBounds[axis] < 2 * m_proxyCount);");;
                if(!((p1.upperBounds[axis] < 2 * this.m_proxyCount))) throw new Error("Assertion error line 133: assert (p1.upperBounds[axis] < 2 * m_proxyCount);");;
                if(!((p2.lowerBounds[axis] < 2 * this.m_proxyCount))) throw new Error("Assertion error line 134: assert (p2.lowerBounds[axis] < 2 * m_proxyCount);");;
                if(!((p2.upperBounds[axis] < 2 * this.m_proxyCount))) throw new Error("Assertion error line 135: assert (p2.upperBounds[axis] < 2 * m_proxyCount);");;
                if(bounds[p1.lowerBounds[axis]].value > bounds[p2.upperBounds[axis]].value) {
                    return false;
                }
                if(bounds[p1.upperBounds[axis]].value < bounds[p2.lowerBounds[axis]].value) {
                    return false;
                }
            };}
            return true;
        }

        public testOverlap(p1? : any, p2? : any) : any {
            if(((p1 != null && p1 instanceof <any>org.jbox2d.collision.Proxy) || p1 === null) && ((p2 != null && p2 instanceof <any>org.jbox2d.collision.Proxy) || p2 === null)) {
                return <any>this.testOverlap$org_jbox2d_collision_Proxy$org_jbox2d_collision_Proxy(p1, p2);
            } else if(((p1 != null && p1 instanceof <any>org.jbox2d.collision.BoundValues) || p1 === null) && ((p2 != null && p2 instanceof <any>org.jbox2d.collision.Proxy) || p2 === null)) {
                return <any>this.testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(p1, p2);
            } else throw new Error('invalid overload');
        }

        /*private*/ testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(b : org.jbox2d.collision.BoundValues, p : org.jbox2d.collision.Proxy) : boolean {
            for(let axis : number = 0; axis < 2; ++axis) {{
                let bounds : org.jbox2d.collision.Bound[] = this.m_bounds[axis];
                if(!((p.lowerBounds[axis] < 2 * this.m_proxyCount))) throw new Error("Assertion error line 157: assert (p.lowerBounds[axis] < 2 * m_proxyCount);");;
                if(!((p.upperBounds[axis] < 2 * this.m_proxyCount))) throw new Error("Assertion error line 158: assert (p.upperBounds[axis] < 2 * m_proxyCount);");;
                if(bounds[p.upperBounds[axis]] != null && b.lowerValues[axis] > bounds[p.upperBounds[axis]].value) {
                    return false;
                }
                if(bounds[p.lowerBounds[axis]] != null && b.upperValues[axis] < bounds[p.lowerBounds[axis]].value) {
                    return false;
                }
            };}
            return true;
        }

        public getProxy(proxyId : number) : org.jbox2d.collision.Proxy {
            if(proxyId === org.jbox2d.collision.PairManager.NULL_PROXY_$LI$() || (this.m_proxyPool[proxyId].isValid() === false)) {
                return null;
            } else {
                return this.m_proxyPool[proxyId];
            }
        }

        static tlLowerValues : org.jbox2d.pooling.arrays.IntegerArray; public static tlLowerValues_$LI$() : org.jbox2d.pooling.arrays.IntegerArray { if(BroadPhase.tlLowerValues == null) BroadPhase.tlLowerValues = new org.jbox2d.pooling.arrays.IntegerArray(); return BroadPhase.tlLowerValues; };

        static tlUpperValues : org.jbox2d.pooling.arrays.IntegerArray; public static tlUpperValues_$LI$() : org.jbox2d.pooling.arrays.IntegerArray { if(BroadPhase.tlUpperValues == null) BroadPhase.tlUpperValues = new org.jbox2d.pooling.arrays.IntegerArray(); return BroadPhase.tlUpperValues; };

        static tlIndexes : org.jbox2d.pooling.arrays.IntegerArray; public static tlIndexes_$LI$() : org.jbox2d.pooling.arrays.IntegerArray { if(BroadPhase.tlIndexes == null) BroadPhase.tlIndexes = new org.jbox2d.pooling.arrays.IntegerArray(); return BroadPhase.tlIndexes; };

        /**
         * internal
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {*} userData
         * @return {number}
         */
        public createProxy(aabb : org.jbox2d.collision.AABB, userData : any) : number {
            if(!((this.m_proxyCount < org.jbox2d.common.Settings.maxProxies))) throw new Error("Assertion error line 190: assert (m_proxyCount < Settings.maxProxies);");;
            if(!((this.m_freeProxy !== org.jbox2d.collision.PairManager.NULL_PROXY_$LI$()))) throw new Error("Assertion error line 191: assert (m_freeProxy != PairManager.NULL_PROXY);");;
            let proxyId : number = this.m_freeProxy;
            let proxy : org.jbox2d.collision.Proxy = this.m_proxyPool[proxyId];
            this.m_freeProxy = proxy.getNext();
            if(BroadPhase.debugPrint) {
                console.info("CreateProxy() bbox=" + aabb + " proxyId=" + proxyId + "/" + this.m_proxyCount + " m_freeProxy=" + this.m_freeProxy);
            }
            proxy.overlapCount = 0;
            proxy.userData = userData;
            let boundCount : number = 2 * this.m_proxyCount;
            let lowerValues : number[] = BroadPhase.tlLowerValues_$LI$().get(2);
            let upperValues : number[] = BroadPhase.tlUpperValues_$LI$().get(2);
            let indexes : number[] = BroadPhase.tlIndexes_$LI$().get(2);
            this.computeBounds(lowerValues, upperValues, aabb);
            for(let axis : number = 0; axis < 2; ++axis) {{
                let bounds : org.jbox2d.collision.Bound[] = this.m_bounds[axis];
                this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(indexes, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
                let lowerIndex : number = indexes[0];
                let upperIndex : number = indexes[1];
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.m_bounds[axis], upperIndex, this.m_bounds[axis], upperIndex + 2, boundCount - upperIndex);
                for(let i : number = 0; i < boundCount - upperIndex; i++) {{
                    this.m_bounds[axis][upperIndex + 2 + i] = new org.jbox2d.collision.Bound(this.m_bounds[axis][upperIndex + 2 + i]);
                };}
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.m_bounds[axis], lowerIndex, this.m_bounds[axis], lowerIndex + 1, upperIndex - lowerIndex);
                for(let i : number = 0; i < upperIndex - lowerIndex; i++) {{
                    this.m_bounds[axis][lowerIndex + 1 + i] = new org.jbox2d.collision.Bound(this.m_bounds[axis][lowerIndex + 1 + i]);
                };}
                ++upperIndex;
                if(!((bounds[lowerIndex] != null))) throw new Error("Assertion error line 219: assert (bounds[lowerIndex] != null) : 'Null pointer (lower)';");;
                if(!((bounds[upperIndex] != null))) throw new Error("Assertion error line 220: assert (bounds[upperIndex] != null) : 'Null pointer (upper)';");;
                bounds[lowerIndex].setValueInternal(lowerValues[axis]);
                bounds[lowerIndex].proxyId = proxyId;
                bounds[upperIndex].setValueInternal(upperValues[axis]);
                bounds[upperIndex].proxyId = proxyId;
                bounds[lowerIndex].stabbingCount = lowerIndex === 0?0:bounds[lowerIndex - 1].stabbingCount;
                bounds[upperIndex].stabbingCount = bounds[upperIndex - 1].stabbingCount;
                for(let index : number = lowerIndex; index < upperIndex; ++index) {{
                    ++bounds[index].stabbingCount;
                };}
                for(let index : number = lowerIndex; index < boundCount + 2; ++index) {{
                    let proxyn : org.jbox2d.collision.Proxy = this.m_proxyPool[bounds[index].proxyId];
                    if(bounds[index].isLower()) {
                        proxyn.lowerBounds[axis] = index;
                    } else {
                        proxyn.upperBounds[axis] = index;
                    }
                };}
            };}
            ++this.m_proxyCount;
            if(!(this.m_queryResultCount < org.jbox2d.common.Settings.maxProxies)) throw new Error("Assertion error line 240: assert m_queryResultCount < Settings.maxProxies;");;
            for(let i : number = 0; i < this.m_queryResultCount; ++i) {{
                if(!((this.m_queryResults[i] < org.jbox2d.common.Settings.maxProxies))) throw new Error("Assertion error line 242: assert (m_queryResults[i] < Settings.maxProxies);");;
                if(!((this.m_proxyPool[this.m_queryResults[i]].isValid()))) throw new Error("Assertion error line 243: assert (m_proxyPool[m_queryResults[i]].isValid());");;
                this.m_pairManager.addBufferedPair(proxyId, this.m_queryResults[i]);
            };}
            this.m_pairManager.commit();
            if(BroadPhase.s_validate) {
                this.validate();
            }
            this.m_queryResultCount = 0;
            this.incrementTimeStamp();
            return proxyId;
        }

        static tlIgnored : org.jbox2d.pooling.arrays.IntegerArray; public static tlIgnored_$LI$() : org.jbox2d.pooling.arrays.IntegerArray { if(BroadPhase.tlIgnored == null) BroadPhase.tlIgnored = new org.jbox2d.pooling.arrays.IntegerArray(); return BroadPhase.tlIgnored; };

        public destroyProxy(proxyId : number) {
            if(!((0 < this.m_proxyCount && this.m_proxyCount <= org.jbox2d.common.Settings.maxProxies))) throw new Error("Assertion error line 258: assert (0 < m_proxyCount && m_proxyCount <= Settings.maxProxies);");;
            if(BroadPhase.debugPrint) {
                console.info("destroyProxy(" + proxyId + ")");
                this.dump();
            }
            let proxy : org.jbox2d.collision.Proxy = this.m_proxyPool[proxyId];
            if(!((proxy.isValid()))) throw new Error("Assertion error line 264: assert (proxy.isValid());");;
            let boundCount : number = 2 * this.m_proxyCount;
            let ignored : number[] = BroadPhase.tlIgnored_$LI$().get(2);
            for(let axis : number = 0; axis < 2; ++axis) {{
                let bounds : org.jbox2d.collision.Bound[] = this.m_bounds[axis];
                let lowerIndex : number = proxy.lowerBounds[axis];
                let upperIndex : number = proxy.upperBounds[axis];
                let lowerValue : number = bounds[lowerIndex].value;
                let upperValue : number = bounds[upperIndex].value;
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.m_bounds[axis], lowerIndex + 1, this.m_bounds[axis], lowerIndex, upperIndex - lowerIndex - 1);
                for(let i : number = 0; i < upperIndex - lowerIndex - 1; i++) {{
                    this.m_bounds[axis][lowerIndex + i] = new org.jbox2d.collision.Bound(this.m_bounds[axis][lowerIndex + i]);
                };}
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(this.m_bounds[axis], upperIndex + 1, this.m_bounds[axis], upperIndex - 1, boundCount - upperIndex - 1);
                for(let i : number = 0; i < boundCount - upperIndex - 1; i++) {{
                    this.m_bounds[axis][upperIndex - 1 + i] = new org.jbox2d.collision.Bound(this.m_bounds[axis][upperIndex - 1 + i]);
                };}
                for(let index : number = lowerIndex; index < boundCount - 2; ++index) {{
                    let proxyn : org.jbox2d.collision.Proxy = this.m_proxyPool[bounds[index].proxyId];
                    if(bounds[index].isLower()) {
                        proxyn.lowerBounds[axis] = index;
                    } else {
                        proxyn.upperBounds[axis] = index;
                    }
                };}
                for(let index : number = lowerIndex; index < upperIndex - 1; ++index) {{
                    --bounds[index].stabbingCount;
                };}
                this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(ignored, lowerValue, upperValue, bounds, boundCount - 2, axis);
            };}
            if(!((this.m_queryResultCount < org.jbox2d.common.Settings.maxProxies))) throw new Error("Assertion error line 294: assert (m_queryResultCount < Settings.maxProxies);");;
            for(let i : number = 0; i < this.m_queryResultCount; ++i) {{
                if(!((this.m_proxyPool[this.m_queryResults[i]].isValid()))) throw new Error("Assertion error line 296: assert (m_proxyPool[m_queryResults[i]].isValid());");;
                this.m_pairManager.removeBufferedPair(proxyId, this.m_queryResults[i]);
            };}
            this.m_pairManager.commit();
            this.m_queryResultCount = 0;
            this.incrementTimeStamp();
            proxy.userData = null;
            proxy.overlapCount = BroadPhase.INVALID_$LI$();
            proxy.lowerBounds[0] = BroadPhase.INVALID_$LI$();
            proxy.lowerBounds[1] = BroadPhase.INVALID_$LI$();
            proxy.upperBounds[0] = BroadPhase.INVALID_$LI$();
            proxy.upperBounds[1] = BroadPhase.INVALID_$LI$();
            proxy.setNext(this.m_freeProxy);
            this.m_freeProxy = proxyId;
            --this.m_proxyCount;
            if(BroadPhase.s_validate) {
                this.validate();
            }
        }

        static tlNewValues : org.jbox2d.pooling.TLBoundValues; public static tlNewValues_$LI$() : org.jbox2d.pooling.TLBoundValues { if(BroadPhase.tlNewValues == null) BroadPhase.tlNewValues = (() => { let __o : any = new org.jbox2d.pooling.TLBoundValues(); __o.__delegate = new org.jbox2d.pooling.TLBoundValues(); return __o; })(); return BroadPhase.tlNewValues; };

        static tlOldValues : org.jbox2d.pooling.TLBoundValues; public static tlOldValues_$LI$() : org.jbox2d.pooling.TLBoundValues { if(BroadPhase.tlOldValues == null) BroadPhase.tlOldValues = (() => { let __o : any = new org.jbox2d.pooling.TLBoundValues(); __o.__delegate = new org.jbox2d.pooling.TLBoundValues(); return __o; })(); return BroadPhase.tlOldValues; };

        /**
         * internal
         * @param {number} proxyId
         * @param {org.jbox2d.collision.AABB} aabb
         */
        public moveProxy(proxyId : number, aabb : org.jbox2d.collision.AABB) {
            if(BroadPhase.debugPrint) {
                console.info("MoveProxy(" + proxyId + "/" + this.m_proxyCount + ")");
            }
            let newValues : org.jbox2d.collision.BoundValues = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(BroadPhase.tlNewValues_$LI$());
            let oldValues : org.jbox2d.collision.BoundValues = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(BroadPhase.tlOldValues_$LI$());
            if(proxyId === org.jbox2d.collision.PairManager.NULL_PROXY_$LI$() || org.jbox2d.common.Settings.maxProxies <= proxyId) {
                return;
            }
            if(!((aabb.isValid()))) throw new Error("Assertion error line 334: assert (aabb.isValid()) : 'invalid AABB';");;
            let boundCount : number = 2 * this.m_proxyCount;
            let proxy : org.jbox2d.collision.Proxy = this.m_proxyPool[proxyId];
            this.computeBounds(newValues.lowerValues, newValues.upperValues, aabb);
            for(let axis : number = 0; axis < 2; ++axis) {{
                if(this.m_bounds[axis][proxy.lowerBounds[axis]] != null) {
                    oldValues.lowerValues[axis] = this.m_bounds[axis][proxy.lowerBounds[axis]].value;
                }
                if(this.m_bounds[axis][proxy.lowerBounds[axis]] != null) {
                    oldValues.upperValues[axis] = this.m_bounds[axis][proxy.upperBounds[axis]].value;
                }
            };}
            for(let axis : number = 0; axis < 2; ++axis) {{
                let bounds : org.jbox2d.collision.Bound[] = this.m_bounds[axis];
                let lowerIndex : number = proxy.lowerBounds[axis];
                let upperIndex : number = proxy.upperBounds[axis];
                let lowerValue : number = newValues.lowerValues[axis];
                let upperValue : number = newValues.upperValues[axis];
                let deltaLower : number = bounds[lowerIndex] == null?0:lowerValue - bounds[lowerIndex].value;
                let deltaUpper : number = bounds[upperIndex] == null?0:upperValue - bounds[upperIndex].value;
                bounds[lowerIndex].setValueInternal(lowerValue);
                bounds[upperIndex].setValueInternal(upperValue);
                if(deltaLower < 0) {
                    let index : number = lowerIndex;
                    while((index > 0 && lowerValue < bounds[index - 1].value)) {{
                        let bound : org.jbox2d.collision.Bound = bounds[index];
                        let prevBound : org.jbox2d.collision.Bound = bounds[index - 1];
                        if(bound != null && prevBound != null) {
                            let prevProxyId : number = prevBound.proxyId;
                            let prevProxy : org.jbox2d.collision.Proxy = this.m_proxyPool[prevBound.proxyId];
                            ++prevBound.stabbingCount;
                            if(prevBound.isUpper() === true) {
                                if(this.testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(newValues, prevProxy)) {
                                    this.m_pairManager.addBufferedPair(proxyId, prevProxyId);
                                }
                                ++prevProxy.upperBounds[axis];
                                ++bound.stabbingCount;
                            } else {
                                ++prevProxy.lowerBounds[axis];
                                --bound.stabbingCount;
                            }
                            --proxy.lowerBounds[axis];
                            bound.swap(prevBound);
                        }
                        --index;
                    }};
                }
                if(deltaUpper > 0) {
                    let index : number = upperIndex;
                    while((index < boundCount - 1 && bounds[index + 1].value <= upperValue)) {{
                        let bound : org.jbox2d.collision.Bound = bounds[index];
                        let nextBound : org.jbox2d.collision.Bound = bounds[index + 1];
                        if(bound != null && nextBound != null) {
                            let nextProxyId : number = nextBound.proxyId;
                            let nextProxy : org.jbox2d.collision.Proxy = this.m_proxyPool[nextProxyId];
                            ++nextBound.stabbingCount;
                            if(nextBound.isLower() === true) {
                                if(this.testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(newValues, nextProxy)) {
                                    this.m_pairManager.addBufferedPair(proxyId, nextProxyId);
                                }
                                --nextProxy.lowerBounds[axis];
                                ++bound.stabbingCount;
                            } else {
                                --nextProxy.upperBounds[axis];
                                --bound.stabbingCount;
                            }
                            ++proxy.upperBounds[axis];
                            bound.swap(nextBound);
                        }
                        ++index;
                    }};
                }
                if(deltaLower > 0) {
                    let index : number = lowerIndex;
                    while((index < boundCount - 1 && bounds[index + 1].value <= lowerValue)) {{
                        let bound : org.jbox2d.collision.Bound = bounds[index];
                        let nextBound : org.jbox2d.collision.Bound = bounds[index + 1];
                        if(bound != null && nextBound != null) {
                            let nextProxyId : number = nextBound.proxyId;
                            let nextProxy : org.jbox2d.collision.Proxy = this.m_proxyPool[nextProxyId];
                            --nextBound.stabbingCount;
                            if(nextBound.isUpper()) {
                                if(this.testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(oldValues, nextProxy)) {
                                    this.m_pairManager.removeBufferedPair(proxyId, nextProxyId);
                                }
                                --nextProxy.upperBounds[axis];
                                --bound.stabbingCount;
                            } else {
                                --nextProxy.lowerBounds[axis];
                                ++bound.stabbingCount;
                            }
                            ++proxy.lowerBounds[axis];
                            bound.swap(nextBound);
                        }
                        ++index;
                    }};
                }
                if(deltaUpper < 0) {
                    let index : number = upperIndex;
                    while((index > 0 && upperValue < bounds[index - 1].value)) {{
                        let bound : org.jbox2d.collision.Bound = bounds[index];
                        let prevBound : org.jbox2d.collision.Bound = bounds[index - 1];
                        if(bound != null && prevBound != null) {
                            let prevProxyId : number = prevBound.proxyId;
                            let prevProxy : org.jbox2d.collision.Proxy = this.m_proxyPool[prevProxyId];
                            --prevBound.stabbingCount;
                            if(prevBound.isLower() === true) {
                                if(this.testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(oldValues, prevProxy)) {
                                    this.m_pairManager.removeBufferedPair(proxyId, prevProxyId);
                                }
                                ++prevProxy.lowerBounds[axis];
                                --bound.stabbingCount;
                            } else {
                                ++prevProxy.upperBounds[axis];
                                ++bound.stabbingCount;
                            }
                            --proxy.upperBounds[axis];
                            bound.swap(prevBound);
                        }
                        --index;
                    }};
                }
            };}
            if(BroadPhase.s_validate) {
                this.validate();
            }
        }

        public commit() {
            this.m_pairManager.commit();
        }

        public query$org_jbox2d_collision_AABB$int(aabb : org.jbox2d.collision.AABB, maxCount : number) : any[] {
            if(BroadPhase.debugPrint) {
                console.info("Query(2 args)");
            }
            let lowerValues : number[] = BroadPhase.tlUpperValues_$LI$().get(2);
            let upperValues : number[] = BroadPhase.tlLowerValues_$LI$().get(2);
            this.computeBounds(lowerValues, upperValues, aabb);
            let indexes : number[] = BroadPhase.tlIndexes_$LI$().get(2);
            this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(indexes, lowerValues[0], upperValues[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
            this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(indexes, lowerValues[1], upperValues[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
            if(!(this.m_queryResultCount < org.jbox2d.common.Settings.maxProxies)) throw new Error("Assertion error line 476: assert m_queryResultCount < Settings.maxProxies;");;
            let results : any[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(maxCount);
            let count : number = 0;
            for(let i : number = 0; i < this.m_queryResultCount && count < maxCount; ++i, ++count) {{
                if(!(this.m_queryResults[i] < org.jbox2d.common.Settings.maxProxies)) throw new Error("Assertion error line 480: assert m_queryResults[i] < Settings.maxProxies;");;
                let proxy : org.jbox2d.collision.Proxy = this.m_proxyPool[this.m_queryResults[i]];
                proxy.isValid();
                results[i] = proxy.userData;
            };}
            let copy : any[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(count);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(results, 0, copy, 0, count);
            this.m_queryResultCount = 0;
            this.incrementTimeStamp();
            return copy;
        }

        public validate() {
            if(BroadPhase.debugPrint) {
                console.info("Validate()");
            }
            for(let axis : number = 0; axis < 2; ++axis) {{
                let bounds : org.jbox2d.collision.Bound[] = this.m_bounds[axis];
                let boundCount : number = 2 * this.m_proxyCount;
                let stabbingCount : number = 0;
                for(let i : number = 0; i < boundCount; ++i) {{
                    let bound : org.jbox2d.collision.Bound = bounds[i];
                    if(!((i === 0 || bounds[i - 1].value <= bound.value))) throw new Error("Assertion error line 502: assert (i == 0 || bounds[i - 1].value <= bound.value);");;
                    if(!((bound.proxyId !== org.jbox2d.collision.PairManager.NULL_PROXY_$LI$()))) throw new Error("Assertion error line 503: assert (bound.proxyId != PairManager.NULL_PROXY);");;
                    if(!((this.m_proxyPool[bound.proxyId].isValid()))) throw new Error("Assertion error line 504: assert (m_proxyPool[bound.proxyId].isValid());");;
                    if(bound.isLower() === true) {
                        if(!((this.m_proxyPool[bound.proxyId].lowerBounds[axis] === i))) throw new Error("Assertion error line 506: assert (m_proxyPool[bound.proxyId].lowerBounds[axis] == i) : (m_proxyPool[bound.proxyId].lowerBounds[axis] + ' not ' + i);");;
                        ++stabbingCount;
                    } else {
                        if(!((this.m_proxyPool[bound.proxyId].upperBounds[axis] === i))) throw new Error("Assertion error line 509: assert (m_proxyPool[bound.proxyId].upperBounds[axis] == i);");;
                        --stabbingCount;
                    }
                    if(!((bound.stabbingCount === stabbingCount))) throw new Error("Assertion error line 512: assert (bound.stabbingCount == stabbingCount);");;
                };}
            };}
        }

        /*private*/ computeBounds(lowerValues : number[], upperValues : number[], aabb : org.jbox2d.collision.AABB) {
            if(BroadPhase.debugPrint) {
                console.info("ComputeBounds()");
            }
            if(!((aabb.upperBound.x >= aabb.lowerBound.x))) throw new Error("Assertion error line 521: assert (aabb.upperBound.x >= aabb.lowerBound.x);");;
            if(!((aabb.upperBound.y >= aabb.lowerBound.y))) throw new Error("Assertion error line 522: assert (aabb.upperBound.y >= aabb.lowerBound.y);");;
            let bx : number = aabb.lowerBound.x < this.m_worldAABB.upperBound.x?aabb.lowerBound.x:this.m_worldAABB.upperBound.x;
            let by : number = aabb.lowerBound.y < this.m_worldAABB.upperBound.y?aabb.lowerBound.y:this.m_worldAABB.upperBound.y;
            let minVertexX : number = this.m_worldAABB.lowerBound.x > bx?this.m_worldAABB.lowerBound.x:bx;
            let minVertexY : number = this.m_worldAABB.lowerBound.y > by?this.m_worldAABB.lowerBound.y:by;
            let b1x : number = aabb.upperBound.x < this.m_worldAABB.upperBound.x?aabb.upperBound.x:this.m_worldAABB.upperBound.x;
            let b1y : number = aabb.upperBound.y < this.m_worldAABB.upperBound.y?aabb.upperBound.y:this.m_worldAABB.upperBound.y;
            let maxVertexX : number = this.m_worldAABB.lowerBound.x > b1x?this.m_worldAABB.lowerBound.x:b1x;
            let maxVertexY : number = this.m_worldAABB.lowerBound.y > b1y?this.m_worldAABB.lowerBound.y:b1y;
            lowerValues[0] = (<number>((<any>Math).fround(this.m_quantizationFactor.x * ((<any>Math).fround(minVertexX - this.m_worldAABB.lowerBound.x))))|0) & (2147483647 - 1);
            upperValues[0] = (<number>((<any>Math).fround(this.m_quantizationFactor.x * ((<any>Math).fround(maxVertexX - this.m_worldAABB.lowerBound.x))))|0) | 1;
            lowerValues[1] = (<number>((<any>Math).fround(this.m_quantizationFactor.y * ((<any>Math).fround(minVertexY - this.m_worldAABB.lowerBound.y))))|0) & (2147483647 - 1);
            upperValues[1] = (<number>((<any>Math).fround(this.m_quantizationFactor.y * ((<any>Math).fround(maxVertexY - this.m_worldAABB.lowerBound.y))))|0) | 1;
            if(upperValues[0] < 0) {
                upperValues[0] = 2147483647;
            }
            if(upperValues[1] < 0) {
                upperValues[1] = 2147483647;
            }
            if(BroadPhase.debugPrint) {
                console.info("ComputeBounds() vals: lowerValues[0]=" + lowerValues[0] + " upperValues[0]=" + upperValues[0] + " lowerValues[1]=" + lowerValues[1] + " upperValues[1]=" + upperValues[1] + " test=" + ((<number>((<any>Math).fround(this.m_quantizationFactor.x * ((<any>Math).fround(minVertexX - this.m_worldAABB.lowerBound.x))))|0)));
            }
        }

        public query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(indexes : number[], lowerValue : number, upperValue : number, bounds : org.jbox2d.collision.Bound[], boundCount : number, axis : number) {
            if(BroadPhase.debugPrint) {
                console.info("Query(6 args)");
            }
            let lowerQuery : number = BroadPhase.binarySearch(bounds, boundCount, lowerValue);
            let upperQuery : number = BroadPhase.binarySearch(bounds, boundCount, upperValue);
            for(let i : number = lowerQuery; i < upperQuery; ++i) {{
                if(bounds[i] != null && bounds[i].isLower()) {
                    this.incrementOverlapCount(bounds[i].proxyId);
                }
            };}
            if(lowerQuery > 0) {
                let i : number = lowerQuery - 1;
                if(bounds[i] != null) {
                    let s : number = bounds[i].stabbingCount;
                    while((s !== 0)) {{
                        if(!((i >= 0))) throw new Error("Assertion error line 562: assert (i >= 0) : ('i = ' + i + '; s = ' + s);");;
                        if(bounds[i] != null && bounds[i].isLower()) {
                            let proxy : org.jbox2d.collision.Proxy = this.m_proxyPool[bounds[i].proxyId];
                            if(lowerQuery <= proxy.upperBounds[axis]) {
                                this.incrementOverlapCount(bounds[i].proxyId);
                                --s;
                            }
                        }
                        --i;
                        if(i < 0) {
                            break;
                        }
                    }};
                }
            }
            indexes[0] = lowerQuery;
            indexes[1] = upperQuery;
        }

        /**
         * @param {Array} indexes
         * out variable
         * @param {number} lowerValue
         * @param {number} upperValue
         * @param {Array} bounds
         * @param {number} boundCount
         * @param {number} axis
         * @private
         */
        public query(indexes? : any, lowerValue? : any, upperValue? : any, bounds? : any, boundCount? : any, axis? : any) : any {
            if(((indexes != null && indexes instanceof <any>Array && (indexes.length==0 || indexes[0] == null ||(typeof indexes[0] === 'number'))) || indexes === null) && ((typeof lowerValue === 'number') || lowerValue === null) && ((typeof upperValue === 'number') || upperValue === null) && ((bounds != null && bounds instanceof <any>Array && (bounds.length==0 || bounds[0] == null ||(bounds[0] != null && bounds[0] instanceof <any>org.jbox2d.collision.Bound))) || bounds === null) && ((typeof boundCount === 'number') || boundCount === null) && ((typeof axis === 'number') || axis === null)) {
                return <any>this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(indexes, lowerValue, upperValue, bounds, boundCount, axis);
            } else if(((indexes != null && indexes instanceof <any>org.jbox2d.collision.AABB) || indexes === null) && ((typeof lowerValue === 'number') || lowerValue === null) && upperValue === undefined && bounds === undefined && boundCount === undefined && axis === undefined) {
                return <any>this.query$org_jbox2d_collision_AABB$int(indexes, lowerValue);
            } else throw new Error('invalid overload');
        }

        /*private*/ incrementOverlapCount(proxyId : number) {
            if(BroadPhase.debugPrint) {
                console.info("IncrementOverlapCount()");
            }
            let proxy : org.jbox2d.collision.Proxy = this.m_proxyPool[proxyId];
            if(proxy.timeStamp < this.m_timeStamp) {
                proxy.timeStamp = this.m_timeStamp;
                proxy.overlapCount = 1;
            } else {
                proxy.overlapCount = 2;
                if(!(this.m_queryResultCount < org.jbox2d.common.Settings.maxProxies)) throw new Error("Assertion error line 609: assert m_queryResultCount < Settings.maxProxies;");;
                this.m_queryResults[this.m_queryResultCount] = proxyId;
                ++this.m_queryResultCount;
            }
        }

        /*private*/ incrementTimeStamp() {
            if(BroadPhase.debugPrint) {
                console.info("IncrementTimeStamp()");
            }
            if(this.m_timeStamp === 2147483647) {
                for(let i : number = 0; i < org.jbox2d.common.Settings.maxProxies; ++i) {{
                    this.m_proxyPool[i].timeStamp = 0;
                };}
                this.m_timeStamp = 1;
            } else {
                ++this.m_timeStamp;
            }
        }

        static binarySearch(bounds : org.jbox2d.collision.Bound[], count : number, value : number) : number {
            if(BroadPhase.debugPrint) {
                console.info("BinarySearch()");
            }
            let low : number = 0;
            let high : number = count - 1;
            while((low <= high)) {{
                let mid : number = (low + high) >> 1;
                if(bounds[mid].value > value) {
                    high = mid - 1;
                } else if(bounds[mid].value < value) {
                    low = mid + 1;
                } else {
                    return mid;
                }
            }};
            return low;
        }

        public inRange(aabb : org.jbox2d.collision.AABB) : boolean {
            let ax : number = (<any>Math).fround(aabb.lowerBound.x - this.m_worldAABB.upperBound.x);
            let ay : number = (<any>Math).fround(aabb.lowerBound.y - this.m_worldAABB.upperBound.y);
            let bx : number = (<any>Math).fround(this.m_worldAABB.lowerBound.x - aabb.upperBound.x);
            let by : number = (<any>Math).fround(this.m_worldAABB.lowerBound.y - aabb.upperBound.y);
            let dx : number = org.jbox2d.common.MathUtils.max$float$float(ax, bx);
            let dy : number = org.jbox2d.common.MathUtils.max$float$float(ay, by);
            let inRange : boolean = (org.jbox2d.common.MathUtils.max$float$float(dx, dy) < 0.0);
            if(BroadPhase.debugPrint) {
                console.info("inRange (" + inRange + "): aabb=" + aabb + " // world[" + this.m_worldAABB + "] => dx=" + dx + " dy=" + dy);
            }
            return inRange;
        }

        static tlResults : org.jbox2d.pooling.arrays.IntegerArray; public static tlResults_$LI$() : org.jbox2d.pooling.arrays.IntegerArray { if(BroadPhase.tlResults == null) BroadPhase.tlResults = new org.jbox2d.pooling.arrays.IntegerArray(); return BroadPhase.tlResults; };

        public querySegment(segment : org.jbox2d.collision.Segment, userData : any[], maxCount : number, sortKey : org.jbox2d.collision.SortKeyFunc) : number {
            let maxLambda : number = 1;
            let dx : number = (<any>Math).fround(((<any>Math).fround(segment.p2.x - segment.p1.x)) * this.m_quantizationFactor.x);
            let dy : number = (<any>Math).fround(((<any>Math).fround(segment.p2.y - segment.p1.y)) * this.m_quantizationFactor.y);
            let sx : number = dx < -org.jbox2d.common.Settings.EPSILON?-1:(dx > org.jbox2d.common.Settings.EPSILON?1:0);
            let sy : number = dy < -org.jbox2d.common.Settings.EPSILON?-1:(dy > org.jbox2d.common.Settings.EPSILON?1:0);
            if(!((sx !== 0 || sy !== 0))) throw new Error("Assertion error line 670: assert (sx != 0 || sy != 0);");;
            let p1x : number = (<any>Math).fround(((<any>Math).fround(segment.p1.x - this.m_worldAABB.lowerBound.x)) * this.m_quantizationFactor.x);
            let p1y : number = (<any>Math).fround(((<any>Math).fround(segment.p1.y - this.m_worldAABB.lowerBound.y)) * this.m_quantizationFactor.y);
            let startValues : number[] = [0, 0];
            let startValues2 : number[] = [0, 0];
            let xIndex : number;
            let yIndex : number;
            let proxyId : number;
            let proxy : org.jbox2d.collision.Proxy = null;
            startValues[0] = (<number>(p1x)|0) & (2147483647 - 1);
            startValues2[0] = (<number>(p1x)|0) | 1;
            startValues[1] = (<number>(p1y)|0) & (2147483647 - 1);
            startValues2[1] = (<number>(p1y)|0) | 1;
            let results : number[] = BroadPhase.tlResults_$LI$().get(2);
            this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(results, startValues[0], startValues2[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
            if(sx >= 0) xIndex = results[1] - 1; else xIndex = results[0];
            this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(results, startValues[1], startValues2[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
            if(sy >= 0) yIndex = results[1] - 1; else yIndex = results[0];
            if(sortKey != null) {
                for(let i : number = 0; i < this.m_queryResultCount; i++) {{
                    this.m_querySortKeys[i] = sortKey.apply(this.m_proxyPool[this.m_queryResults[i]].userData);
                };}
                let i : number = 0;
                while((i < this.m_queryResultCount - 1)) {{
                    let a : number = this.m_querySortKeys[i];
                    let b : number = this.m_querySortKeys[i + 1];
                    if((a < 0)?(b >= 0):(a > b && b >= 0)) {
                        this.m_querySortKeys[i + 1] = a;
                        this.m_querySortKeys[i] = b;
                        let tempValue : number = this.m_queryResults[i + 1];
                        this.m_queryResults[i + 1] = this.m_queryResults[i];
                        this.m_queryResults[i] = tempValue;
                        i--;
                        if(i === -1) i = 1;
                    } else {
                        i++;
                    }
                }};
                while((this.m_queryResultCount > 0 && this.m_querySortKeys[this.m_queryResultCount - 1] < 0)) {this.m_queryResultCount--};
            }
            for(; ; ) {{
                let xProgress : number = 0;
                let yProgress : number = 0;
                xIndex += sx >= 0?1:-1;
                if(xIndex < 0 || xIndex >= this.m_proxyCount * 2) break;
                if(sx !== 0) xProgress = (<any>Math).fround(((<any>Math).fround(<number>this.m_bounds[0][xIndex].value - p1x)) / dx);
                yIndex += sy >= 0?1:-1;
                if(yIndex < 0 || yIndex >= this.m_proxyCount * 2) break;
                if(sy !== 0) yProgress = (<any>Math).fround(((<any>Math).fround(<number>this.m_bounds[1][yIndex].value - p1y)) / dy);
                for(; ; ) {{
                    if(sy === 0 || (sx !== 0 && xProgress < yProgress)) {
                        if(xProgress > maxLambda) break;
                        if(sx > 0?this.m_bounds[0][xIndex].isLower():this.m_bounds[0][xIndex].isUpper()) {
                            proxyId = this.m_bounds[0][xIndex].proxyId;
                            proxy = this.m_proxyPool[proxyId];
                            if(sy >= 0) {
                                if(proxy.lowerBounds[1] <= yIndex - 1 && proxy.upperBounds[1] >= yIndex) {
                                    if(sortKey != null) {
                                        this.addProxyResult(proxyId, proxy, maxCount, sortKey);
                                    } else {
                                        this.m_queryResults[this.m_queryResultCount] = proxyId;
                                        ++this.m_queryResultCount;
                                    }
                                }
                            } else {
                                if(proxy.lowerBounds[1] <= yIndex && proxy.upperBounds[1] >= yIndex + 1) {
                                    if(sortKey != null) {
                                        this.addProxyResult(proxyId, proxy, maxCount, sortKey);
                                    } else {
                                        this.m_queryResults[this.m_queryResultCount] = proxyId;
                                        ++this.m_queryResultCount;
                                    }
                                }
                            }
                        }
                        if(sortKey != null && this.m_queryResultCount === maxCount && this.m_queryResultCount > 0 && xProgress > this.m_querySortKeys[this.m_queryResultCount - 1]) break;
                        if(sx > 0) {
                            xIndex++;
                            if(xIndex === this.m_proxyCount * 2) break;
                        } else {
                            xIndex--;
                            if(xIndex < 0) break;
                        }
                        xProgress = (<any>Math).fround(((<any>Math).fround(<number>this.m_bounds[0][xIndex].value - p1x)) / dx);
                    } else {
                        if(yProgress > maxLambda) break;
                        if(sy > 0?this.m_bounds[1][yIndex].isLower():this.m_bounds[1][yIndex].isUpper()) {
                            proxyId = this.m_bounds[1][yIndex].proxyId;
                            proxy = this.m_proxyPool[proxyId];
                            if(sx >= 0) {
                                if(proxy.lowerBounds[0] <= xIndex - 1 && proxy.upperBounds[0] >= xIndex) {
                                    if(sortKey != null) {
                                        this.addProxyResult(proxyId, proxy, maxCount, sortKey);
                                    } else {
                                        this.m_queryResults[this.m_queryResultCount] = proxyId;
                                        ++this.m_queryResultCount;
                                    }
                                }
                            } else {
                                if(proxy.lowerBounds[0] <= xIndex && proxy.upperBounds[0] >= xIndex + 1) {
                                    if(sortKey != null) {
                                        this.addProxyResult(proxyId, proxy, maxCount, sortKey);
                                    } else {
                                        this.m_queryResults[this.m_queryResultCount] = proxyId;
                                        ++this.m_queryResultCount;
                                    }
                                }
                            }
                        }
                        if(sortKey != null && this.m_queryResultCount === maxCount && this.m_queryResultCount > 0 && yProgress > this.m_querySortKeys[this.m_queryResultCount - 1]) break;
                        if(sy > 0) {
                            yIndex++;
                            if(yIndex === this.m_proxyCount * 2) break;
                        } else {
                            yIndex--;
                            if(yIndex < 0) break;
                        }
                        yProgress = (<any>Math).fround(((<any>Math).fround(<number>this.m_bounds[1][yIndex].value - p1y)) / dy);
                    }
                };}
                break;
            };}
            let count : number = 0;
            for(let i : number = 0; i < this.m_queryResultCount && count < maxCount; ++i, ++count) {{
                if(!((this.m_queryResults[i] < org.jbox2d.common.Settings.maxProxies))) throw new Error("Assertion error line 794: assert (m_queryResults[i] < Settings.maxProxies);");;
                let proxya : org.jbox2d.collision.Proxy = this.m_proxyPool[this.m_queryResults[i]];
                if(!((proxya.isValid()))) throw new Error("Assertion error line 796: assert (proxya.isValid());");;
                userData[i] = proxya.userData;
            };}
            this.m_queryResultCount = 0;
            this.incrementTimeStamp();
            return count;
        }

        /*private*/ addProxyResult(proxyId : number, proxy : org.jbox2d.collision.Proxy, maxCount : number, sortKey : org.jbox2d.collision.SortKeyFunc) {
            let key : number = sortKey.apply(proxy.userData);
            if(key < 0) return;
            let i : number = 0;
            while((i < this.m_queryResultCount && this.m_querySortKeys[i] < key)) {++i};
            if(maxCount === this.m_queryResultCount && i === this.m_queryResultCount) return;
            if(maxCount === this.m_queryResultCount) this.m_queryResultCount--;
            for(let j : number = this.m_queryResultCount + 1; j > i; --j) {{
                this.m_querySortKeys[j] = this.m_querySortKeys[j - 1];
                this.m_queryResults[j] = this.m_queryResults[j - 1];
            };}
            this.m_querySortKeys[i] = key;
            this.m_queryResults[i] = proxyId;
            this.m_queryResultCount++;
        }
    }
    BroadPhase["__class"] = "org.jbox2d.collision.BroadPhase";

}
namespace org.jbox2d.dynamics.joints {
    export class ConstantVolumeJoint extends org.jbox2d.dynamics.joints.Joint {
        bodies : org.jbox2d.dynamics.Body[];

        targetLengths : number[];

        targetVolume : number;

        world : org.jbox2d.dynamics.World;

        normals : org.jbox2d.common.Vec2[];

        m_step : org.jbox2d.dynamics.TimeStep;

        /*private*/ m_impulse : number = 0.0;

        distanceJoints : org.jbox2d.dynamics.joints.DistanceJoint[];

        public getBodies() : org.jbox2d.dynamics.Body[] {
            return this.bodies;
        }

        public inflate(factor : number) {
            this.targetVolume *= factor;
        }

        public constructor(def : org.jbox2d.dynamics.joints.ConstantVolumeJointDef) {
            super(def);
            if(this.bodies===undefined) this.bodies = null;
            if(this.targetLengths===undefined) this.targetLengths = null;
            if(this.targetVolume===undefined) this.targetVolume = 0;
            if(this.world===undefined) this.world = null;
            if(this.normals===undefined) this.normals = null;
            if(this.m_step===undefined) this.m_step = null;
            if(this.distanceJoints===undefined) this.distanceJoints = null;
            if(def.bodies.length <= 2) {
                throw Object.defineProperty(new Error("You cannot create a constant volume joint with less than three bodies."), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
            }
            this.world = def.bodies[0].getWorld();
            this.bodies = def.bodies;
            this.targetLengths = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.bodies.length);
            for(let i : number = 0; i < this.targetLengths.length; ++i) {{
                let next : number = (i === this.targetLengths.length - 1)?0:i + 1;
                let dist : number = this.bodies[i].getMemberWorldCenter().sub(this.bodies[next].getMemberWorldCenter()).length();
                this.targetLengths[i] = dist;
            };}
            this.targetVolume = this.getArea();
            this.distanceJoints = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.bodies.length);
            for(let i : number = 0; i < this.targetLengths.length; ++i) {{
                let next : number = (i === this.targetLengths.length - 1)?0:i + 1;
                let djd : org.jbox2d.dynamics.joints.DistanceJointDef = new org.jbox2d.dynamics.joints.DistanceJointDef();
                djd.frequencyHz = def.frequencyHz;
                djd.dampingRatio = def.dampingRatio;
                djd.initialize(this.bodies[i], this.bodies[next], this.bodies[i].getMemberWorldCenter(), this.bodies[next].getMemberWorldCenter());
                this.distanceJoints[i] = <org.jbox2d.dynamics.joints.DistanceJoint>this.world.createJoint(djd);
            };}
            this.normals = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.bodies.length);
            for(let i : number = 0; i < this.normals.length; ++i) {{
                this.normals[i] = new org.jbox2d.common.Vec2();
            };}
            this.m_body1 = this.bodies[0];
            this.m_body2 = this.bodies[1];
            this.m_collideConnected = false;
        }

        /**
         * 
         */
        public destructor() {
            for(let i : number = 0; i < this.distanceJoints.length; ++i) {{
                this.world.destroyJoint(this.distanceJoints[i]);
            };}
        }

        /*private*/ getArea() : number {
            let area : number = 0.0;
            area += (<any>Math).fround((<any>Math).fround(this.bodies[this.bodies.length - 1].getMemberWorldCenter().x * this.bodies[0].getMemberWorldCenter().y) - (<any>Math).fround(this.bodies[0].getMemberWorldCenter().x * this.bodies[this.bodies.length - 1].getMemberWorldCenter().y));
            for(let i : number = 0; i < this.bodies.length - 1; ++i) {{
                area += (<any>Math).fround((<any>Math).fround(this.bodies[i].getMemberWorldCenter().x * this.bodies[i + 1].getMemberWorldCenter().y) - (<any>Math).fround(this.bodies[i + 1].getMemberWorldCenter().x * this.bodies[i].getMemberWorldCenter().y));
            };}
            area *= 0.5;
            return area;
        }

        /**
         * Apply the position correction to the particles.
         * @param {org.jbox2d.dynamics.TimeStep} step
         * @return {boolean}
         */
        public constrainEdges(step : org.jbox2d.dynamics.TimeStep) : boolean {
            let perimeter : number = 0.0;
            for(let i : number = 0; i < this.bodies.length; ++i) {{
                let next : number = (i === this.bodies.length - 1)?0:i + 1;
                let dx : number = (<any>Math).fround(this.bodies[next].getMemberWorldCenter().x - this.bodies[i].getMemberWorldCenter().x);
                let dy : number = (<any>Math).fround(this.bodies[next].getMemberWorldCenter().y - this.bodies[i].getMemberWorldCenter().y);
                let dist : number = org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy)));
                if(dist < org.jbox2d.common.Settings.EPSILON) {
                    dist = 1.0;
                }
                this.normals[i].x = (<any>Math).fround(dy / dist);
                this.normals[i].y = (<any>Math).fround(-dx / dist);
                perimeter += dist;
            };}
            let deltaArea : number = (<any>Math).fround(this.targetVolume - this.getArea());
            let toExtrude : number = (<any>Math).fround((<any>Math).fround(0.5 * deltaArea) / perimeter);
            let done : boolean = true;
            for(let i : number = 0; i < this.bodies.length; ++i) {{
                let next : number = (i === this.bodies.length - 1)?0:i + 1;
                let delta : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2((<any>Math).fround(toExtrude * ((<any>Math).fround(this.normals[i].x + this.normals[next].x))), (<any>Math).fround(toExtrude * ((<any>Math).fround(this.normals[i].y + this.normals[next].y))));
                let norm : number = delta.length();
                if(norm > org.jbox2d.common.Settings.maxLinearCorrection_$LI$()) {
                    delta.mulLocal((<any>Math).fround(org.jbox2d.common.Settings.maxLinearCorrection_$LI$() / norm));
                }
                if(norm > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                    done = false;
                }
                this.bodies[next].m_sweep.c.x += delta.x;
                this.bodies[next].m_sweep.c.y += delta.y;
                this.bodies[next].synchronizeTransform();
            };}
            return done;
        }

        static tlD : org.jbox2d.pooling.arrays.Vec2Array; public static tlD_$LI$() : org.jbox2d.pooling.arrays.Vec2Array { if(ConstantVolumeJoint.tlD == null) ConstantVolumeJoint.tlD = new org.jbox2d.pooling.arrays.Vec2Array(); return ConstantVolumeJoint.tlD; };

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public initVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            this.m_step = step;
            let d : org.jbox2d.common.Vec2[] = ConstantVolumeJoint.tlD_$LI$().get(this.bodies.length);
            for(let i : number = 0; i < this.bodies.length; ++i) {{
                let prev : number = (i === 0)?this.bodies.length - 1:i - 1;
                let next : number = (i === this.bodies.length - 1)?0:i + 1;
                d[i].set$org_jbox2d_common_Vec2(this.bodies[next].getMemberWorldCenter());
                d[i].subLocal(this.bodies[prev].getMemberWorldCenter());
            };}
            if(step.warmStarting) {
                this.m_impulse *= step.dtRatio;
                for(let i : number = 0; i < this.bodies.length; ++i) {{
                    this.bodies[i].m_linearVelocity.x += (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.bodies[i].m_invMass * d[i].y) * 0.5) * this.m_impulse);
                    this.bodies[i].m_linearVelocity.y += (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.bodies[i].m_invMass * -d[i].x) * 0.5) * this.m_impulse);
                };}
            } else {
                this.m_impulse = 0.0;
            }
        }

        /**
         * 
         * @return {boolean}
         */
        public solvePositionConstraints() : boolean {
            return this.constrainEdges(this.m_step);
        }

        /**
         * 
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public solveVelocityConstraints(step : org.jbox2d.dynamics.TimeStep) {
            let crossMassSum : number = 0.0;
            let dotMassSum : number = 0.0;
            let d : org.jbox2d.common.Vec2[] = ConstantVolumeJoint.tlD_$LI$().get(this.bodies.length);
            for(let i : number = 0; i < this.bodies.length; ++i) {{
                let prev : number = (i === 0)?this.bodies.length - 1:i - 1;
                let next : number = (i === this.bodies.length - 1)?0:i + 1;
                d[i].set$org_jbox2d_common_Vec2(this.bodies[next].getMemberWorldCenter());
                d[i].subLocal(this.bodies[prev].getMemberWorldCenter());
                dotMassSum += (<any>Math).fround((d[i].lengthSquared()) / this.bodies[i].getMass());
                crossMassSum += org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.bodies[i].getLinearVelocity(), d[i]);
            };}
            let lambda : number = (<any>Math).fround((<any>Math).fround(-2.0 * crossMassSum) / dotMassSum);
            this.m_impulse += lambda;
            for(let i : number = 0; i < this.bodies.length; ++i) {{
                this.bodies[i].m_linearVelocity.x += (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.bodies[i].m_invMass * d[i].y) * 0.5) * lambda);
                this.bodies[i].m_linearVelocity.y += (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.bodies[i].m_invMass * -d[i].x) * 0.5) * lambda);
            };}
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor1() : org.jbox2d.common.Vec2 {
            return null;
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getAnchor2() : org.jbox2d.common.Vec2 {
            return null;
        }

        /**
         * 
         * @return {org.jbox2d.common.Vec2}
         */
        public getReactionForce() : org.jbox2d.common.Vec2 {
            return null;
        }

        /**
         * 
         * @return {number}
         */
        public getReactionTorque() : number {
            return 0;
        }
    }
    ConstantVolumeJoint["__class"] = "org.jbox2d.dynamics.joints.ConstantVolumeJoint";

}
namespace org.jbox2d.dynamics {
    /**
     * TODO djm: make this so it isn't created every time step
     * @class
     */
    export class Island {
        public m_bodies : org.jbox2d.dynamics.Body[];

        public m_contacts : org.jbox2d.dynamics.contacts.Contact[];

        public m_joints : org.jbox2d.dynamics.joints.Joint[];

        public m_bodyCount : number;

        public m_jointCount : number;

        public m_contactCount : number;

        public m_bodyCapacity : number;

        public m_contactCapacity : number;

        public m_jointCapacity : number;

        public static m_positionIterationCount : number = 0;

        public m_positionError : number;

        public m_listener : org.jbox2d.dynamics.ContactListener;

        public clear() {
            this.m_bodyCount = 0;
            this.m_contactCount = 0;
            this.m_jointCount = 0;
        }

        public add$org_jbox2d_dynamics_Body(body : org.jbox2d.dynamics.Body) {
            if(!(this.m_bodyCount < this.m_bodyCapacity)) throw new Error("Assertion error line 38: assert m_bodyCount < m_bodyCapacity;");;
            this.m_bodies[this.m_bodyCount++] = body;
        }

        public add(body? : any) : any {
            if(((body != null && body instanceof <any>org.jbox2d.dynamics.Body) || body === null)) {
                return <any>this.add$org_jbox2d_dynamics_Body(body);
            } else if(((body != null && body instanceof <any>org.jbox2d.dynamics.contacts.Contact) || body === null)) {
                return <any>this.add$org_jbox2d_dynamics_contacts_Contact(body);
            } else if(((body != null && body instanceof <any>org.jbox2d.dynamics.joints.Joint) || body === null)) {
                return <any>this.add$org_jbox2d_dynamics_joints_Joint(body);
            } else throw new Error('invalid overload');
        }

        add$org_jbox2d_dynamics_contacts_Contact(contact : org.jbox2d.dynamics.contacts.Contact) {
            if(!((this.m_contactCount < this.m_contactCapacity))) throw new Error("Assertion error line 53: assert (m_contactCount < m_contactCapacity);");;
            this.m_contacts[this.m_contactCount++] = contact;
        }

        add$org_jbox2d_dynamics_joints_Joint(joint : org.jbox2d.dynamics.joints.Joint) {
            if(!((this.m_jointCount < this.m_jointCapacity))) throw new Error("Assertion error line 58: assert (m_jointCount < m_jointCapacity);");;
            this.m_joints[this.m_jointCount++] = joint;
        }

        public constructor() {
            if(this.m_bodies===undefined) this.m_bodies = null;
            if(this.m_contacts===undefined) this.m_contacts = null;
            if(this.m_joints===undefined) this.m_joints = null;
            if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
            if(this.m_jointCount===undefined) this.m_jointCount = 0;
            if(this.m_contactCount===undefined) this.m_contactCount = 0;
            if(this.m_bodyCapacity===undefined) this.m_bodyCapacity = 0;
            if(this.m_contactCapacity===undefined) this.m_contactCapacity = 0;
            if(this.m_jointCapacity===undefined) this.m_jointCapacity = 0;
            if(this.m_positionError===undefined) this.m_positionError = 0;
            if(this.m_listener===undefined) this.m_listener = null;
        }

        public init(bodyCapacity : number, contactCapacity : number, jointCapacity : number, listener : org.jbox2d.dynamics.ContactListener) {
            this.m_bodyCapacity = bodyCapacity;
            this.m_contactCapacity = contactCapacity;
            this.m_jointCapacity = jointCapacity;
            this.m_bodyCount = 0;
            this.m_contactCount = 0;
            this.m_jointCount = 0;
            this.m_listener = listener;
            this.m_bodies = (s => { let a=[]; while(s-->0) a.push(null); return a; })(bodyCapacity);
            this.m_contacts = (s => { let a=[]; while(s-->0) a.push(null); return a; })(contactCapacity);
            this.m_joints = (s => { let a=[]; while(s-->0) a.push(null); return a; })(jointCapacity);
            Island.m_positionIterationCount = 0;
        }

        static contactSolvers : org.jbox2d.pooling.stacks.ContactSolverStack; public static contactSolvers_$LI$() : org.jbox2d.pooling.stacks.ContactSolverStack { if(Island.contactSolvers == null) Island.contactSolvers = new org.jbox2d.pooling.stacks.ContactSolverStack(); return Island.contactSolvers; };

        public solve(step : org.jbox2d.dynamics.TimeStep, gravity : org.jbox2d.common.Vec2, correctPositions : boolean, allowSleep : boolean) {
            for(let i : number = 0; i < this.m_bodyCount; ++i) {{
                let b : org.jbox2d.dynamics.Body = this.m_bodies[i];
                if(b.isStatic()) {
                    continue;
                }
                b.m_linearVelocity.x += (<any>Math).fround(step.dt * ((<any>Math).fround(gravity.x + (<any>Math).fround(b.m_invMass * b.m_force.x))));
                b.m_linearVelocity.y += (<any>Math).fround(step.dt * ((<any>Math).fround(gravity.y + (<any>Math).fround(b.m_invMass * b.m_force.y))));
                b.m_angularVelocity += (<any>Math).fround((<any>Math).fround(step.dt * b.m_invI) * b.m_torque);
                b.m_force.set$float$float(0.0, 0.0);
                b.m_torque = 0.0;
                b.m_linearVelocity.mulLocal(org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(1.0 - (<any>Math).fround(step.dt * b.m_linearDamping)), 0.0, 1.0));
                b.m_angularVelocity *= org.jbox2d.common.MathUtils.clamp$float$float$float((<any>Math).fround(1.0 - (<any>Math).fround(step.dt * b.m_angularDamping)), 0.0, 1.0);
                if(org.jbox2d.common.Vec2.dot(b.m_linearVelocity, b.m_linearVelocity) > org.jbox2d.common.Settings.maxLinearVelocitySquared_$LI$()) {
                    b.m_linearVelocity.normalize();
                    b.m_linearVelocity.mulLocal(org.jbox2d.common.Settings.maxLinearVelocity);
                }
                if((<any>Math).fround(b.m_angularVelocity * b.m_angularVelocity) > org.jbox2d.common.Settings.maxAngularVelocitySquared_$LI$()) {
                    if(b.m_angularVelocity < 0.0) {
                        b.m_angularVelocity = -org.jbox2d.common.Settings.maxAngularVelocity;
                    } else {
                        b.m_angularVelocity = org.jbox2d.common.Settings.maxAngularVelocity;
                    }
                }
            };}
            let contactSolver : org.jbox2d.dynamics.contacts.ContactSolver = Island.contactSolvers_$LI$().get();
            contactSolver.init(step, this.m_contacts, this.m_contactCount);
            contactSolver.initVelocityConstraints(step);
            for(let i : number = 0; i < this.m_jointCount; ++i) {{
                this.m_joints[i].initVelocityConstraints(step);
            };}
            for(let i : number = 0; i < step.maxIterations; ++i) {{
                contactSolver.solveVelocityConstraints();
                for(let j : number = 0; j < this.m_jointCount; ++j) {{
                    this.m_joints[j].solveVelocityConstraints(step);
                };}
            };}
            contactSolver.finalizeVelocityConstraints();
            for(let i : number = 0; i < this.m_bodyCount; ++i) {{
                let b : org.jbox2d.dynamics.Body = this.m_bodies[i];
                if(b.isStatic()) {
                    continue;
                }
                b.m_sweep.c0.set$org_jbox2d_common_Vec2(b.m_sweep.c);
                b.m_sweep.a0 = b.m_sweep.a;
                b.m_sweep.c.x += (<any>Math).fround(step.dt * b.m_linearVelocity.x);
                b.m_sweep.c.y += (<any>Math).fround(step.dt * b.m_linearVelocity.y);
                b.m_sweep.a += (<any>Math).fround(step.dt * b.m_angularVelocity);
                b.synchronizeTransform();
            };}
            if(correctPositions) {
                for(let i : number = 0; i < this.m_jointCount; ++i) {{
                    this.m_joints[i].initPositionConstraints();
                };}
                for(Island.m_positionIterationCount = 0; Island.m_positionIterationCount < step.maxIterations; ++Island.m_positionIterationCount) {{
                    let contactsOkay : boolean = contactSolver.solvePositionConstraints(org.jbox2d.common.Settings.contactBaumgarte);
                    let jointsOkay : boolean = true;
                    for(let i : number = 0; i < this.m_jointCount; ++i) {{
                        let jointOkay : boolean = this.m_joints[i].solvePositionConstraints();
                        jointsOkay = jointsOkay && jointOkay;
                    };}
                    if(contactsOkay && jointsOkay) {
                        break;
                    }
                };}
            }
            this.report$org_jbox2d_dynamics_contacts_ContactConstraint_A(contactSolver.m_constraints);
            if(allowSleep) {
                let minSleepTime : number = 3.4028235E38;
                let linTolSqr : number = (<any>Math).fround(org.jbox2d.common.Settings.linearSleepTolerance_$LI$() * org.jbox2d.common.Settings.linearSleepTolerance_$LI$());
                let angTolSqr : number = (<any>Math).fround(org.jbox2d.common.Settings.angularSleepTolerance_$LI$() * org.jbox2d.common.Settings.angularSleepTolerance_$LI$());
                for(let i : number = 0; i < this.m_bodyCount; ++i) {{
                    let b : org.jbox2d.dynamics.Body = this.m_bodies[i];
                    if(b.m_invMass === 0.0) {
                        continue;
                    }
                    if((b.m_flags & org.jbox2d.dynamics.Body.e_allowSleepFlag) === 0 || (<any>Math).fround(b.m_angularVelocity * b.m_angularVelocity) > angTolSqr || org.jbox2d.common.Vec2.dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                        b.m_sleepTime = 0.0;
                        minSleepTime = 0.0;
                    } else {
                        b.m_sleepTime += step.dt;
                        minSleepTime = org.jbox2d.common.MathUtils.min(minSleepTime, b.m_sleepTime);
                    }
                };}
                if(minSleepTime >= org.jbox2d.common.Settings.timeToSleep_$LI$()) {
                    for(let i : number = 0; i < this.m_bodyCount; ++i) {{
                        let b : org.jbox2d.dynamics.Body = this.m_bodies[i];
                        b.m_flags |= org.jbox2d.dynamics.Body.e_sleepFlag;
                        b.m_linearVelocity.setZero();
                        b.m_angularVelocity = 0.0;
                    };}
                }
            }
            Island.contactSolvers_$LI$().recycle(contactSolver);
        }

        public solveTOI(subStep : org.jbox2d.dynamics.TimeStep) {
            let contactSolver : org.jbox2d.dynamics.contacts.ContactSolver = Island.contactSolvers_$LI$().get();
            contactSolver.init(subStep, this.m_contacts, this.m_contactCount);
            if(org.jbox2d.common.Settings.maxTOIJointsPerIsland > 0) {
                subStep.warmStarting = true;
                for(let i : number = this.m_jointCount - 1; i >= 0; --i) {{
                    this.m_joints[i].initVelocityConstraints(subStep);
                };}
                subStep.warmStarting = false;
            }
            for(let i : number = 0; i < subStep.maxIterations; ++i) {{
                contactSolver.solveVelocityConstraints();
                for(let j : number = this.m_jointCount - 1; j >= 0; --j) {{
                    this.m_joints[j].solveVelocityConstraints(subStep);
                };}
            };}
            for(let i : number = 0; i < this.m_bodyCount; ++i) {{
                let b : org.jbox2d.dynamics.Body = this.m_bodies[i];
                if(b.isStatic()) {
                    continue;
                }
                b.m_sweep.c0.set$org_jbox2d_common_Vec2(b.m_sweep.c);
                b.m_sweep.a0 = b.m_sweep.a;
                b.m_sweep.c.x += (<any>Math).fround(subStep.dt * b.m_linearVelocity.x);
                b.m_sweep.c.y += (<any>Math).fround(subStep.dt * b.m_linearVelocity.y);
                b.m_sweep.a += (<any>Math).fround(subStep.dt * b.m_angularVelocity);
                b.synchronizeTransform();
            };}
            let k_toiBaumgarte : number = 0.75;
            for(let i : number = 0; i < subStep.maxIterations; ++i) {{
                let contactsOkay : boolean = contactSolver.solvePositionConstraints(k_toiBaumgarte);
                let jointsOkay : boolean = true;
                for(let j : number = this.m_jointCount - 1; j >= 0; --j) {{
                    let jointOkay : boolean = this.m_joints[j].solvePositionConstraints();
                    jointsOkay = jointsOkay && jointOkay;
                };}
                if(contactsOkay && jointsOkay) {
                    break;
                }
            };}
            this.report$org_jbox2d_dynamics_contacts_ContactConstraint_A(contactSolver.m_constraints);
            Island.contactSolvers_$LI$().recycle(contactSolver);
        }

        public report$java_util_List(constraints : Array<org.jbox2d.dynamics.contacts.ContactConstraint>) {
            let cc : org.jbox2d.dynamics.contacts.ContactConstraint[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(/* size */(<number>constraints.length));
            for(let i : number = 0; i < cc.length; ++i) {{
                cc[i] = /* get */constraints[i];
            };}
            this.report$org_jbox2d_dynamics_contacts_ContactConstraint_A(cc);
        }

        public report(constraints? : any) : any {
            if(((constraints != null && (constraints instanceof Array)) || constraints === null)) {
                return <any>this.report$java_util_List(constraints);
            } else if(((constraints != null && constraints instanceof <any>Array && (constraints.length==0 || constraints[0] == null ||(constraints[0] != null && constraints[0] instanceof <any>org.jbox2d.dynamics.contacts.ContactConstraint))) || constraints === null)) {
                return <any>this.report$org_jbox2d_dynamics_contacts_ContactConstraint_A(constraints);
            } else throw new Error('invalid overload');
        }

        public report$org_jbox2d_dynamics_contacts_ContactConstraint_A(constraints : org.jbox2d.dynamics.contacts.ContactConstraint[]) {
            if(this.m_listener == null) {
                return;
            }
            for(let i : number = 0; i < this.m_contactCount; ++i) {{
                let c : org.jbox2d.dynamics.contacts.Contact = this.m_contacts[i];
                let cc : org.jbox2d.dynamics.contacts.ContactConstraint = constraints[i];
                let cr : org.jbox2d.dynamics.contacts.ContactResult = new org.jbox2d.dynamics.contacts.ContactResult();
                cr.shape1 = c.getShape1();
                cr.shape2 = c.getShape2();
                let b1 : org.jbox2d.dynamics.Body = cr.shape1.getBody();
                let manifoldCount : number = c.getManifoldCount();
                let manifolds : Array<org.jbox2d.collision.Manifold> = c.getManifolds();
                for(let j : number = 0; j < manifoldCount; ++j) {{
                    let manifold : org.jbox2d.collision.Manifold = /* get */manifolds[j];
                    cr.normal.set$org_jbox2d_common_Vec2(manifold.normal);
                    for(let k : number = 0; k < manifold.pointCount; ++k) {{
                        let point : org.jbox2d.collision.ManifoldPoint = manifold.points[k];
                        let ccp : org.jbox2d.dynamics.contacts.ContactConstraintPoint = cc.points[k];
                        org.jbox2d.common.XForm.mulToOut(b1.getMemberXForm(), point.localPoint1, cr.position);
                        cr.normalImpulse = ccp.normalImpulse;
                        cr.tangentImpulse = ccp.tangentImpulse;
                        cr.id.set(point.id);
                        this.m_listener.result(cr);
                    };}
                };}
            };}
        }
    }
    Island["__class"] = "org.jbox2d.dynamics.Island";

}
namespace org.jbox2d.dynamics {
    /**
     * Construct a world object.
     * @param {org.jbox2d.collision.AABB} worldAABB a bounding box that completely encompasses all your shapes.
     * @param {org.jbox2d.common.Vec2} gravity the world gravity vector.
     * @param {boolean} doSleep improve performance by not simulating inactive bodies.
     * @class
     */
    export class World {
        m_lock : boolean;

        m_broadPhase : org.jbox2d.collision.BroadPhase;

        m_contactManager : org.jbox2d.dynamics.ContactManager;

        m_bodyList : org.jbox2d.dynamics.Body;

        /**
         * Do not access, won't be useful!
         */
        m_contactList : org.jbox2d.dynamics.contacts.Contact;

        m_jointList : org.jbox2d.dynamics.joints.Joint;

        m_controllerList : org.jbox2d.dynamics.controllers.Controller;

        m_controllerCount : number;

        m_bodyCount : number;

        m_contactCount : number;

        m_jointCount : number;

        m_gravity : org.jbox2d.common.Vec2;

        m_allowSleep : boolean;

        m_groundBody : org.jbox2d.dynamics.Body;

        m_positionIterationCount : number;

        /**
         * Should we apply position correction?
         */
        m_positionCorrection : boolean;

        /**
         * Should we use warm-starting?  Improves stability in stacking scenarios.
         */
        m_warmStarting : boolean;

        /**
         * Should we enable continuous collision detection?
         */
        m_continuousPhysics : boolean;

        m_destructionListener : org.jbox2d.dynamics.DestructionListener;

        m_boundaryListener : org.jbox2d.dynamics.BoundaryListener;

        m_contactFilter : org.jbox2d.dynamics.ContactFilter;

        m_contactListener : org.jbox2d.dynamics.ContactListener;

        m_debugDraw : org.jbox2d.dynamics.DebugDraw;

        m_drawDebugData : boolean;

        /*private*/ m_inv_dt0 : number;

        /*private*/ postStepList : Array<org.jbox2d.dynamics.Steppable>;

        /*private*/ autoDebugDraw : boolean = true;

        /**
         * @return {boolean} the autoDebugDraw
         */
        public isAutoDebugDraw() : boolean {
            return this.autoDebugDraw;
        }

        /**
         * @param {boolean} autoDebugDraw the autoDebugDraw to set
         */
        public setAutoDebugDraw(autoDebugDraw : boolean) {
            this.autoDebugDraw = autoDebugDraw;
        }

        public setDrawDebugData(tf : boolean) {
            this.m_drawDebugData = tf;
        }

        public isDrawingDebugData() : boolean {
            return this.m_drawDebugData;
        }

        /**
         * Get the number of bodies.
         * @return {number}
         */
        public getBodyCount() : number {
            return this.m_bodyCount;
        }

        /**
         * Get the number of joints.
         * @return {number}
         */
        public getJointCount() : number {
            return this.m_jointCount;
        }

        /**
         * Get the number of contacts (each may have 0 or more contact points).
         * @return {number}
         */
        public getContactCount() : number {
            return this.m_contactCount;
        }

        /**
         * Change the global gravity vector.
         * @param {org.jbox2d.common.Vec2} gravity
         */
        public setGravity(gravity : org.jbox2d.common.Vec2) {
            this.m_gravity = gravity;
        }

        /**
         * Get a clone of the global gravity vector.
         * @return {org.jbox2d.common.Vec2} Clone of gravity vector
         */
        public getGravity() : org.jbox2d.common.Vec2 {
            return /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this.m_gravity);
        }

        /**
         * The world provides a single static ground body with no collision shapes.
         * You can use this to simplify the creation of joints and static shapes.
         * @return {org.jbox2d.dynamics.Body}
         */
        public getGroundBody() : org.jbox2d.dynamics.Body {
            return this.m_groundBody;
        }

        /**
         * Get the world body list. With the returned body, use Body.getNext() to get
         * the next body in the world list. A NULL body indicates the end of the list.
         * @return {org.jbox2d.dynamics.Body} the head of the world body list.
         */
        public getBodyList() : org.jbox2d.dynamics.Body {
            return this.m_bodyList;
        }

        /**
         * Get the world joint list. With the returned joint, use Joint.getNext() to get
         * the next joint in the world list. A NULL joint indicates the end of the list.
         * @return {org.jbox2d.dynamics.joints.Joint} the head of the world joint list.
         */
        public getJointList() : org.jbox2d.dynamics.joints.Joint {
            return this.m_jointList;
        }

        public constructor(worldAABB : org.jbox2d.collision.AABB, gravity : org.jbox2d.common.Vec2, doSleep : boolean) {
            if(this.m_lock===undefined) this.m_lock = false;
            if(this.m_broadPhase===undefined) this.m_broadPhase = null;
            if(this.m_contactManager===undefined) this.m_contactManager = null;
            if(this.m_bodyList===undefined) this.m_bodyList = null;
            if(this.m_contactList===undefined) this.m_contactList = null;
            if(this.m_jointList===undefined) this.m_jointList = null;
            if(this.m_controllerList===undefined) this.m_controllerList = null;
            if(this.m_controllerCount===undefined) this.m_controllerCount = 0;
            if(this.m_bodyCount===undefined) this.m_bodyCount = 0;
            if(this.m_contactCount===undefined) this.m_contactCount = 0;
            if(this.m_jointCount===undefined) this.m_jointCount = 0;
            if(this.m_gravity===undefined) this.m_gravity = null;
            if(this.m_allowSleep===undefined) this.m_allowSleep = false;
            if(this.m_groundBody===undefined) this.m_groundBody = null;
            if(this.m_positionIterationCount===undefined) this.m_positionIterationCount = 0;
            if(this.m_positionCorrection===undefined) this.m_positionCorrection = false;
            if(this.m_warmStarting===undefined) this.m_warmStarting = false;
            if(this.m_continuousPhysics===undefined) this.m_continuousPhysics = false;
            if(this.m_destructionListener===undefined) this.m_destructionListener = null;
            if(this.m_boundaryListener===undefined) this.m_boundaryListener = null;
            if(this.m_contactFilter===undefined) this.m_contactFilter = null;
            if(this.m_contactListener===undefined) this.m_contactListener = null;
            if(this.m_debugDraw===undefined) this.m_debugDraw = null;
            if(this.m_drawDebugData===undefined) this.m_drawDebugData = false;
            if(this.m_inv_dt0===undefined) this.m_inv_dt0 = 0;
            if(this.postStepList===undefined) this.postStepList = null;
            if(this.m_raycastSegment===undefined) this.m_raycastSegment = null;
            if(this.m_raycastNormal===undefined) this.m_raycastNormal = null;
            if(this.m_raycastUserData===undefined) this.m_raycastUserData = null;
            if(this.m_raycastSolidShape===undefined) this.m_raycastSolidShape = false;
            this.m_positionCorrection = true;
            this.m_warmStarting = true;
            this.m_continuousPhysics = true;
            this.m_destructionListener = null;
            this.m_boundaryListener = null;
            this.m_contactFilter = org.jbox2d.dynamics.ContactFilter.DEFAULT_FILTER_$LI$();
            this.m_contactListener = null;
            this.m_debugDraw = null;
            this.m_inv_dt0 = 0.0;
            this.m_bodyList = null;
            this.m_contactList = null;
            this.m_jointList = null;
            this.m_controllerList = null;
            this.m_bodyCount = 0;
            this.m_contactCount = 0;
            this.m_jointCount = 0;
            this.m_controllerCount = 0;
            this.m_lock = false;
            this.m_allowSleep = doSleep;
            this.m_gravity = gravity;
            this.m_contactManager = new org.jbox2d.dynamics.ContactManager();
            this.m_contactManager.m_world = this;
            this.m_broadPhase = new org.jbox2d.collision.BroadPhase(worldAABB, this.m_contactManager);
            let bd : org.jbox2d.dynamics.BodyDef = new org.jbox2d.dynamics.BodyDef();
            this.m_groundBody = this.createBody(bd);
            this.postStepList = <any>([]);
            this.setDrawDebugData(true);
        }

        /**
         * Register a destruction listener.
         * @param {*} listener
         */
        public setDestructionListener(listener : org.jbox2d.dynamics.DestructionListener) {
            this.m_destructionListener = listener;
        }

        /**
         * Register a broad-phase boundary listener.
         * @param {*} listener
         */
        public setBoundaryListener(listener : org.jbox2d.dynamics.BoundaryListener) {
            this.m_boundaryListener = listener;
        }

        /**
         * Register a contact event listener
         * @param {*} listener
         */
        public setContactListener(listener : org.jbox2d.dynamics.ContactListener) {
            this.m_contactListener = listener;
        }

        /**
         * Register a contact filter to provide specific control over collision.
         * Otherwise the default filter is used (b2_defaultFilter).
         * @param {*} filter
         */
        public setContactFilter(filter : org.jbox2d.dynamics.ContactFilter) {
            this.m_contactFilter = filter;
        }

        /**
         * Register a routine for debug drawing. The debug draw functions are called
         * inside the World.step() method, so make sure your renderer is ready to
         * consume draw commands when you call step().
         * @param {org.jbox2d.dynamics.DebugDraw} debugDraw
         */
        public setDebugDraw(debugDraw : org.jbox2d.dynamics.DebugDraw) {
            this.m_debugDraw = debugDraw;
        }

        public getDebugDraw() : org.jbox2d.dynamics.DebugDraw {
            return this.m_debugDraw;
        }

        /**
         * Create a body given a definition. No reference to the definition
         * is retained.  Body will be static unless mass is nonzero.
         * <BR><em>Warning</em>: This function is locked during callbacks.
         * @param {org.jbox2d.dynamics.BodyDef} def
         * @return {org.jbox2d.dynamics.Body}
         */
        public createBody(def : org.jbox2d.dynamics.BodyDef) : org.jbox2d.dynamics.Body {
            if(!((this.m_lock === false))) throw new Error("Assertion error line 280: assert (m_lock == false);");;
            let b : org.jbox2d.dynamics.Body = new org.jbox2d.dynamics.Body(def, this);
            b.m_prev = null;
            b.m_next = this.m_bodyList;
            if(this.m_bodyList != null) {
                this.m_bodyList.m_prev = b;
            }
            this.m_bodyList = b;
            ++this.m_bodyCount;
            return b;
        }

        /**
         * Destroy a rigid body given a definition. No reference to the definition
         * is retained. This function is locked during callbacks.
         * <BR><em>Warning</em>: This automatically deletes all associated shapes and joints.
         * <BR><em>Warning</em>: This function is locked during callbacks.
         * @param {org.jbox2d.dynamics.Body} b
         */
        public destroyBody(b : org.jbox2d.dynamics.Body) {
            if(!((this.m_bodyCount > 0))) throw new Error("Assertion error line 300: assert (m_bodyCount > 0);");;
            if(!((this.m_lock === false))) throw new Error("Assertion error line 301: assert (m_lock == false);");;
            let jn : org.jbox2d.dynamics.joints.JointEdge = b.m_jointList;
            while((jn != null)) {{
                let jn0 : org.jbox2d.dynamics.joints.JointEdge = jn;
                jn = jn.next;
                if(this.m_destructionListener != null) {
                    this.m_destructionListener['sayGoodbye$org_jbox2d_dynamics_joints_Joint'](jn0.joint);
                }
                this.destroyJoint(jn0.joint);
            }};
            let ce : org.jbox2d.dynamics.controllers.ControllerEdge = b.m_controllerList;
            while((ce != null)) {{
                let ce0 : org.jbox2d.dynamics.controllers.ControllerEdge = ce;
                ce = ce.nextController;
                ce0.controller.removeBody(b);
            }};
            let s : org.jbox2d.collision.shapes.Shape = b.m_shapeList;
            while((s != null)) {{
                let s0 : org.jbox2d.collision.shapes.Shape = s;
                s = s.m_next;
                if(this.m_destructionListener != null) {
                    this.m_destructionListener['sayGoodbye$org_jbox2d_collision_shapes_Shape'](s0);
                }
                s0.destroyProxy(this.m_broadPhase);
                org.jbox2d.collision.shapes.Shape.destroy(s0);
            }};
            if(b.m_prev != null) {
                b.m_prev.m_next = b.m_next;
            }
            if(b.m_next != null) {
                b.m_next.m_prev = b.m_prev;
            }
            if(b === this.m_bodyList) {
                this.m_bodyList = b.m_next;
            }
            --this.m_bodyCount;
        }

        /**
         * Create a joint to constrain bodies together. No reference to the definition
         * is retained. This may cause the connected bodies to cease colliding.
         * <BR><em>Warning</em> This function is locked during callbacks.
         * @param {org.jbox2d.dynamics.joints.JointDef} def
         * @return {org.jbox2d.dynamics.joints.Joint}
         */
        public createJoint(def : org.jbox2d.dynamics.joints.JointDef) : org.jbox2d.dynamics.joints.Joint {
            if(!((this.m_lock === false))) throw new Error("Assertion error line 347: assert (m_lock == false);");;
            let j : org.jbox2d.dynamics.joints.Joint = org.jbox2d.dynamics.joints.Joint.create(def);
            j.m_prev = null;
            j.m_next = this.m_jointList;
            if(this.m_jointList != null) {
                this.m_jointList.m_prev = j;
            }
            this.m_jointList = j;
            ++this.m_jointCount;
            j.m_node1.joint = j;
            j.m_node1.other = j.m_body2;
            j.m_node1.prev = null;
            j.m_node1.next = j.m_body1.m_jointList;
            if(j.m_body1.m_jointList != null) {
                j.m_body1.m_jointList.prev = j.m_node1;
            }
            j.m_body1.m_jointList = j.m_node1;
            j.m_node2.joint = j;
            j.m_node2.other = j.m_body1;
            j.m_node2.prev = null;
            j.m_node2.next = j.m_body2.m_jointList;
            if(j.m_body2.m_jointList != null) {
                j.m_body2.m_jointList.prev = j.m_node2;
            }
            j.m_body2.m_jointList = j.m_node2;
            if(def.collideConnected === false) {
                let b : org.jbox2d.dynamics.Body = def.body1.m_shapeCount < def.body2.m_shapeCount?def.body1:def.body2;
                for(let s : org.jbox2d.collision.shapes.Shape = b.m_shapeList; s != null; s = s.m_next) {{
                    s.refilterProxy(this.m_broadPhase, b.getMemberXForm());
                };}
            }
            return j;
        }

        /**
         * Destroy a joint. This may cause the connected bodies to begin colliding.
         * <BR><em>Warning</em>: This function is locked during callbacks.
         * @param {org.jbox2d.dynamics.joints.Joint} j
         */
        public destroyJoint(j : org.jbox2d.dynamics.joints.Joint) {
            if(!((this.m_lock === false))) throw new Error("Assertion error line 387: assert (m_lock == false);");;
            let collideConnected : boolean = j.m_collideConnected;
            if(j.m_prev != null) {
                j.m_prev.m_next = j.m_next;
            }
            if(j.m_next != null) {
                j.m_next.m_prev = j.m_prev;
            }
            if(j === this.m_jointList) {
                this.m_jointList = j.m_next;
            }
            let body1 : org.jbox2d.dynamics.Body = j.m_body1;
            let body2 : org.jbox2d.dynamics.Body = j.m_body2;
            body1.wakeUp();
            body2.wakeUp();
            if(j.m_node1.prev != null) {
                j.m_node1.prev.next = j.m_node1.next;
            }
            if(j.m_node1.next != null) {
                j.m_node1.next.prev = j.m_node1.prev;
            }
            if(j.m_node1 === body1.m_jointList) {
                body1.m_jointList = j.m_node1.next;
            }
            j.m_node1.prev = null;
            j.m_node1.next = null;
            if(j.m_node2.prev != null) {
                j.m_node2.prev.next = j.m_node2.next;
            }
            if(j.m_node2.next != null) {
                j.m_node2.next.prev = j.m_node2.prev;
            }
            if(j.m_node2 === body2.m_jointList) {
                body2.m_jointList = j.m_node2.next;
            }
            j.m_node2.prev = null;
            j.m_node2.next = null;
            org.jbox2d.dynamics.joints.Joint.destroy(j);
            if(!(this.m_jointCount > 0)) throw new Error("Assertion error line 425: assert m_jointCount > 0;");;
            --this.m_jointCount;
            if(collideConnected === false) {
                let b : org.jbox2d.dynamics.Body = body1.m_shapeCount < body2.m_shapeCount?body1:body2;
                for(let s : org.jbox2d.collision.shapes.Shape = b.m_shapeList; s != null; s = s.m_next) {{
                    s.refilterProxy(this.m_broadPhase, b.getMemberXForm());
                };}
            }
        }

        public createController(def : org.jbox2d.dynamics.controllers.ControllerDef) : org.jbox2d.dynamics.controllers.Controller {
            let controller : org.jbox2d.dynamics.controllers.Controller = def.create();
            controller.m_next = this.m_controllerList;
            controller.m_prev = null;
            if(this.m_controllerList != null) {
                this.m_controllerList.m_prev = controller;
            }
            this.m_controllerList = controller;
            ++this.m_controllerCount;
            controller.m_world = this;
            return controller;
        }

        public destroyController(controller : org.jbox2d.dynamics.controllers.Controller) {
            if(!((this.m_controllerCount > 0))) throw new Error("Assertion error line 449: assert (m_controllerCount > 0);");;
            if(controller.m_next != null) {
                controller.m_next.m_prev = controller.m_prev;
            }
            if(controller.m_prev != null) {
                controller.m_prev.m_next = controller.m_next;
            }
            if(controller === this.m_controllerList) {
                this.m_controllerList = controller.m_next;
            }
            --this.m_controllerCount;
        }

        static tlStep : org.jbox2d.pooling.TLTimeStep; public static tlStep_$LI$() : org.jbox2d.pooling.TLTimeStep { if(World.tlStep == null) World.tlStep = (() => { let __o : any = new org.jbox2d.pooling.TLTimeStep(); __o.__delegate = new org.jbox2d.pooling.TLTimeStep(); return __o; })(); return World.tlStep; };

        /**
         * Take a time step. This performs collision detection, integration,
         * and constraint solution.
         * @param {number} dt the amount of time to simulate, this should not vary.
         * @param {number} iterations the number of iterations to be used by the constraint solver.
         */
        public step(dt : number, iterations : number) {
            this.m_lock = true;
            let step : org.jbox2d.dynamics.TimeStep = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(World.tlStep_$LI$());
            step.dt = dt;
            step.maxIterations = iterations;
            if(dt > 0.0) {
                step.inv_dt = (<any>Math).fround(1.0 / dt);
            } else {
                step.inv_dt = 0.0;
            }
            step.dtRatio = (<any>Math).fround(this.m_inv_dt0 * dt);
            step.positionCorrection = this.m_positionCorrection;
            step.warmStarting = this.m_warmStarting;
            this.m_contactManager.collide();
            if(step.dt > 0.0) {
                this.solve(step);
            }
            if(this.m_continuousPhysics && step.dt > 0.0) {
                this.solveTOI(step);
            }
            if(this.autoDebugDraw) {
                this.drawDebugData();
            }
            this.m_inv_dt0 = step.inv_dt;
            this.m_lock = false;
            this.postStep(dt, iterations);
        }

        /**
         * Goes through the registered postStep functions and calls them.
         * @param {number} dt
         * @param {number} iterations
         * @private
         */
        /*private*/ postStep(dt : number, iterations : number) {
            for(let index159=0; index159 < this.postStepList.length; index159++) {
                let s = this.postStepList[index159];
                {
                    s.step(dt, iterations);
                }
            }
        }

        /**
         * Registers a Steppable object to be stepped
         * immediately following the physics step, once
         * the locks are lifted.
         * @param {*} s
         */
        public registerPostStep(s : org.jbox2d.dynamics.Steppable) {
            /* add */(this.postStepList.push(s)>0);
        }

        /**
         * Unregisters a method from post-stepping.
         * Fails silently if method is not found.
         * @param {*} s
         */
        public unregisterPostStep(s : org.jbox2d.dynamics.Steppable) {
            if(this.postStepList != null) {
                /* remove */(a => { let index = a.indexOf(s); if(index>=0) { a.splice(index, 1); return true; } else { return false; }})(this.postStepList);
            }
        }

        /**
         * Re-filter a shape. This re-runs contact filtering on a shape.
         * @param {org.jbox2d.collision.shapes.Shape} shape
         */
        public refilter(shape : org.jbox2d.collision.shapes.Shape) {
            shape.refilterProxy(this.m_broadPhase, shape.getBody().getMemberXForm());
        }

        /**
         * Query the world for all shapes that potentially overlap the
         * provided AABB up to max count.
         * The number of shapes found is returned.
         * @param {org.jbox2d.collision.AABB} aabb the query box.
         * @param {number} maxCount the capacity of the shapes array.
         * @return {Array} array of shapes overlapped, up to maxCount in length
         */
        public query(aabb : org.jbox2d.collision.AABB, maxCount : number) : org.jbox2d.collision.shapes.Shape[] {
            let objs : any[] = this.m_broadPhase.query$org_jbox2d_collision_AABB$int(aabb, maxCount);
            let ret : org.jbox2d.collision.shapes.Shape[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(objs.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(objs, 0, ret, 0, objs.length);
            return ret;
        }

        static islands : org.jbox2d.pooling.stacks.IslandStack; public static islands_$LI$() : org.jbox2d.pooling.stacks.IslandStack { if(World.islands == null) World.islands = new org.jbox2d.pooling.stacks.IslandStack(); return World.islands; };

        /**
         * For internal use
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public solve(step : org.jbox2d.dynamics.TimeStep) {
            this.m_positionIterationCount = 0;
            for(let controller : org.jbox2d.dynamics.controllers.Controller = this.m_controllerList; controller != null; controller = controller.m_next) {{
                controller.step(step);
            };}
            let island : org.jbox2d.dynamics.Island = World.islands_$LI$().get();
            island.init(this.m_bodyCount, this.m_contactCount, this.m_jointCount, this.m_contactListener);
            for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.m_next) {{
                b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
            };}
            for(let c : org.jbox2d.dynamics.contacts.Contact = this.m_contactList; c != null; c = c.m_next) {{
                c.m_flags &= ~org.jbox2d.dynamics.contacts.Contact.e_islandFlag;
            };}
            for(let j : org.jbox2d.dynamics.joints.Joint = this.m_jointList; j != null; j = j.m_next) {{
                j.m_islandFlag = false;
            };}
            let stackSize : number = this.m_bodyCount;
            let stack : org.jbox2d.dynamics.Body[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(stackSize);
            for(let seed : org.jbox2d.dynamics.Body = this.m_bodyList; seed != null; seed = seed.m_next) {{
                if((seed.m_flags & (org.jbox2d.dynamics.Body.e_islandFlag | org.jbox2d.dynamics.Body.e_sleepFlag | org.jbox2d.dynamics.Body.e_frozenFlag)) > 0) {
                    continue;
                }
                if(seed.isStatic()) {
                    continue;
                }
                island.clear();
                let stackCount : number = 0;
                stack[stackCount++] = seed;
                seed.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                while((stackCount > 0)) {{
                    let b : org.jbox2d.dynamics.Body = stack[--stackCount];
                    island.add$org_jbox2d_dynamics_Body(b);
                    b.m_flags &= ~org.jbox2d.dynamics.Body.e_sleepFlag;
                    if(b.isStatic()) {
                        continue;
                    }
                    for(let cn : org.jbox2d.dynamics.contacts.ContactEdge = b.m_contactList; cn != null; cn = cn.next) {{
                        if((cn.contact.m_flags & (org.jbox2d.dynamics.contacts.Contact.e_islandFlag | org.jbox2d.dynamics.contacts.Contact.e_nonSolidFlag)) > 0) {
                            continue;
                        }
                        if(cn.contact.getManifoldCount() === 0) {
                            continue;
                        }
                        island.add$org_jbox2d_dynamics_contacts_Contact(cn.contact);
                        cn.contact.m_flags |= org.jbox2d.dynamics.contacts.Contact.e_islandFlag;
                        let other : org.jbox2d.dynamics.Body = cn.other;
                        if((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) > 0) {
                            continue;
                        }
                        if(!(stackCount < stackSize)) throw new Error("Assertion error line 612: assert stackCount < stackSize;");;
                        stack[stackCount++] = other;
                        other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                    };}
                    for(let jn : org.jbox2d.dynamics.joints.JointEdge = b.m_jointList; jn != null; jn = jn.next) {{
                        if(jn.joint.m_islandFlag === true) {
                            continue;
                        }
                        island.add$org_jbox2d_dynamics_joints_Joint(jn.joint);
                        jn.joint.m_islandFlag = true;
                        let other : org.jbox2d.dynamics.Body = jn.other;
                        if((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) > 0) {
                            continue;
                        }
                        if(!((stackCount < stackSize))) throw new Error("Assertion error line 626: assert (stackCount < stackSize);");;
                        stack[stackCount++] = other;
                        other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                    };}
                }};
                island.solve(step, this.m_gravity, this.m_positionCorrection, this.m_allowSleep);
                this.m_positionIterationCount = org.jbox2d.common.MathUtils.max$int$int(this.m_positionIterationCount, org.jbox2d.dynamics.Island.m_positionIterationCount);
                for(let i : number = 0; i < island.m_bodyCount; ++i) {{
                    let b : org.jbox2d.dynamics.Body = island.m_bodies[i];
                    if(b.isStatic()) {
                        b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
                    }
                };}
            };}
            for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.getNext()) {{
                if((b.m_flags & (org.jbox2d.dynamics.Body.e_sleepFlag | org.jbox2d.dynamics.Body.e_frozenFlag)) !== 0) {
                    continue;
                }
                if(b.isStatic()) {
                    continue;
                }
                let inRange : boolean = b.synchronizeShapes();
                if(inRange === false && this.m_boundaryListener != null) {
                    this.m_boundaryListener.violation(b);
                }
            };}
            this.m_broadPhase.commit();
            World.islands_$LI$().recycle(island);
        }

        static steps : org.jbox2d.pooling.stacks.TimeStepStack; public static steps_$LI$() : org.jbox2d.pooling.stacks.TimeStepStack { if(World.steps == null) World.steps = new org.jbox2d.pooling.stacks.TimeStepStack(); return World.steps; };

        /**
         * For internal use: find TOI contacts and solve them.
         * @param {org.jbox2d.dynamics.TimeStep} step
         */
        public solveTOI(step : org.jbox2d.dynamics.TimeStep) {
            let island : org.jbox2d.dynamics.Island = World.islands_$LI$().get();
            island.init(this.m_bodyCount, org.jbox2d.common.Settings.maxTOIContactsPerIsland, org.jbox2d.common.Settings.maxTOIJointsPerIsland, this.m_contactListener);
            let queueCapacity : number = this.m_bodyCount;
            let queue : org.jbox2d.dynamics.Body[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(queueCapacity);
            for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.m_next) {{
                b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
                b.m_sweep.t0 = 0.0;
            };}
            for(let c : org.jbox2d.dynamics.contacts.Contact = this.m_contactList; c != null; c = c.m_next) {{
                c.m_flags &= ~(org.jbox2d.dynamics.contacts.Contact.e_toiFlag | org.jbox2d.dynamics.contacts.Contact.e_islandFlag);
            };}
            for(let j : org.jbox2d.dynamics.joints.Joint = this.m_jointList; j != null; j = j.m_next) {{
                j.m_islandFlag = false;
            };}
            while((true)) {{
                let minContact : org.jbox2d.dynamics.contacts.Contact = null;
                let minTOI : number = 1.0;
                for(let c : org.jbox2d.dynamics.contacts.Contact = this.m_contactList; c != null; c = c.m_next) {{
                    if((c.m_flags & (org.jbox2d.dynamics.contacts.Contact.e_slowFlag | org.jbox2d.dynamics.contacts.Contact.e_nonSolidFlag)) !== 0) {
                        continue;
                    }
                    let toi : number = 1.0;
                    if((c.m_flags & org.jbox2d.dynamics.contacts.Contact.e_toiFlag) !== 0) {
                        toi = c.m_toi;
                    } else {
                        let s1 : org.jbox2d.collision.shapes.Shape = c.getShape1();
                        let s2 : org.jbox2d.collision.shapes.Shape = c.getShape2();
                        let b1 : org.jbox2d.dynamics.Body = s1.getBody();
                        let b2 : org.jbox2d.dynamics.Body = s2.getBody();
                        if((b1.isStatic() || b1.isSleeping()) && (b2.isStatic() || b2.isSleeping())) {
                            continue;
                        }
                        let t0 : number = b1.m_sweep.t0;
                        if(b1.m_sweep.t0 < b2.m_sweep.t0) {
                            t0 = b2.m_sweep.t0;
                            b1.m_sweep.advance(t0);
                        } else if(b2.m_sweep.t0 < b1.m_sweep.t0) {
                            t0 = b1.m_sweep.t0;
                            b2.m_sweep.advance(t0);
                        }
                        if(!((t0 < 1.0))) throw new Error("Assertion error line 703: assert (t0 < 1.0F);");;
                        toi = org.jbox2d.collision.TOI.timeOfImpact(c.m_shape1, b1.m_sweep, c.m_shape2, b2.m_sweep);
                        if(!((0.0 <= toi && toi <= 1.0))) throw new Error("Assertion error line 705: assert (0.0F <= toi && toi <= 1.0F);");;
                        if(toi > 0.0 && toi < 1.0) {
                            toi = org.jbox2d.common.MathUtils.min((<any>Math).fround((<any>Math).fround(((<any>Math).fround(1.0 - toi)) * t0) + toi), 1.0);
                        }
                        c.m_toi = toi;
                        c.m_flags |= org.jbox2d.dynamics.contacts.Contact.e_toiFlag;
                    }
                    if(org.jbox2d.common.Settings.EPSILON < toi && toi < minTOI) {
                        minContact = c;
                        minTOI = toi;
                    }
                };}
                if(minContact == null || (<any>Math).fround(1.0 - (<any>Math).fround(100.0 * org.jbox2d.common.Settings.EPSILON)) < minTOI) {
                    break;
                }
                let s1 : org.jbox2d.collision.shapes.Shape = minContact.getShape1();
                let s2 : org.jbox2d.collision.shapes.Shape = minContact.getShape2();
                let b1 : org.jbox2d.dynamics.Body = s1.getBody();
                let b2 : org.jbox2d.dynamics.Body = s2.getBody();
                b1.advance(minTOI);
                b2.advance(minTOI);
                minContact.update(this.m_contactListener);
                minContact.m_flags &= ~org.jbox2d.dynamics.contacts.Contact.e_toiFlag;
                if(minContact.getManifoldCount() === 0) {
                    continue;
                }
                let seed : org.jbox2d.dynamics.Body = b1;
                if(seed.isStatic()) {
                    seed = b2;
                }
                island.clear();
                let queueStart : number = 0;
                let queueSize : number = 0;
                queue[queueStart + queueSize++] = seed;
                seed.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                while((queueSize > 0)) {{
                    let b : org.jbox2d.dynamics.Body = queue[queueStart++];
                    --queueSize;
                    island.add$org_jbox2d_dynamics_Body(b);
                    b.m_flags &= ~org.jbox2d.dynamics.Body.e_sleepFlag;
                    if(b.isStatic()) {
                        continue;
                    }
                    for(let cn : org.jbox2d.dynamics.contacts.ContactEdge = b.m_contactList; cn != null; cn = cn.next) {{
                        if(island.m_contactCount === island.m_contactCapacity) {
                            continue;
                        }
                        if((cn.contact.m_flags & (org.jbox2d.dynamics.contacts.Contact.e_islandFlag | org.jbox2d.dynamics.contacts.Contact.e_slowFlag | org.jbox2d.dynamics.contacts.Contact.e_nonSolidFlag)) !== 0) {
                            continue;
                        }
                        if(cn.contact.getManifoldCount() === 0) {
                            continue;
                        }
                        island.add$org_jbox2d_dynamics_contacts_Contact(cn.contact);
                        cn.contact.m_flags |= org.jbox2d.dynamics.contacts.Contact.e_islandFlag;
                        let other : org.jbox2d.dynamics.Body = cn.other;
                        if((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) !== 0) {
                            continue;
                        }
                        if(other.isStatic() === false) {
                            other.advance(minTOI);
                            other.wakeUp();
                        }
                        if(!((queueSize < queueCapacity))) throw new Error("Assertion error line 768: assert (queueSize < queueCapacity);");;
                        queue[queueStart + queueSize++] = other;
                        other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                    };}
                    for(let jn : org.jbox2d.dynamics.joints.JointEdge = b.m_jointList; jn != null; jn = jn.next) {{
                        if(island.m_jointCount === island.m_jointCapacity) {
                            continue;
                        }
                        if(jn.joint.m_islandFlag === true) {
                            continue;
                        }
                        island.add$org_jbox2d_dynamics_joints_Joint(jn.joint);
                        jn.joint.m_islandFlag = true;
                        let other : org.jbox2d.dynamics.Body = jn.other;
                        if((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) > 0) {
                            continue;
                        }
                        if(other.isStatic() === false) {
                            other.advance(minTOI);
                            other.wakeUp();
                        }
                        if(!((queueSize < queueCapacity))) throw new Error("Assertion error line 789: assert (queueSize < queueCapacity);");;
                        queue[queueStart + queueSize++] = other;
                        other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                    };}
                }};
                let subStep : org.jbox2d.dynamics.TimeStep = World.steps_$LI$().get();
                subStep.warmStarting = false;
                subStep.dt = (<any>Math).fround(((<any>Math).fround(1.0 - minTOI)) * step.dt);
                if(!((subStep.dt > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 797: assert (subStep.dt > Settings.EPSILON);");;
                subStep.inv_dt = (<any>Math).fround(1.0 / subStep.dt);
                subStep.maxIterations = step.maxIterations;
                island.solveTOI(subStep);
                World.steps_$LI$().recycle(subStep);
                for(let i : number = 0; i < island.m_bodyCount; ++i) {{
                    let b : org.jbox2d.dynamics.Body = island.m_bodies[i];
                    b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
                    if((b.m_flags & (org.jbox2d.dynamics.Body.e_sleepFlag | org.jbox2d.dynamics.Body.e_frozenFlag)) !== 0) {
                        continue;
                    }
                    if(b.isStatic()) {
                        continue;
                    }
                    let inRange : boolean = b.synchronizeShapes();
                    if(inRange === false && this.m_boundaryListener != null) {
                        this.m_boundaryListener.violation(b);
                    }
                    for(let cn : org.jbox2d.dynamics.contacts.ContactEdge = b.m_contactList; cn != null; cn = cn.next) {{
                        cn.contact.m_flags &= ~org.jbox2d.dynamics.contacts.Contact.e_toiFlag;
                    };}
                };}
                for(let i : number = 0; i < island.m_contactCount; ++i) {{
                    let c : org.jbox2d.dynamics.contacts.Contact = island.m_contacts[i];
                    c.m_flags &= ~(org.jbox2d.dynamics.contacts.Contact.e_toiFlag | org.jbox2d.dynamics.contacts.Contact.e_islandFlag);
                };}
                for(let i : number = 0; i < island.m_jointCount; ++i) {{
                    let j : org.jbox2d.dynamics.joints.Joint = island.m_joints[i];
                    j.m_islandFlag = false;
                };}
                this.m_broadPhase.commit();
            }};
            World.islands_$LI$().recycle(island);
        }

        static LIQUID_INT : number; public static LIQUID_INT_$LI$() : number { if(World.LIQUID_INT == null) World.LIQUID_INT = new Number(12345).valueOf(); return World.LIQUID_INT; };

        /*private*/ liquidLength : number = 0.12;

        /*private*/ averageLinearVel : number = -1;

        /*private*/ coreColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f((<any>Math).fround(255.0 * 0.9), (<any>Math).fround(255.0 * 0.6), (<any>Math).fround(255.0 * 0.6));

        /*private*/ drawingCenter : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ liquidOffset : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ circCenterMoved : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ liquidColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f(80.0, 80.0, 255.0);

        /*private*/ segLeft : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ segRight : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /**
         * For internal use
         * @param {org.jbox2d.collision.shapes.Shape} shape
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.Color3f} color
         * @param {boolean} core
         */
        public drawShape(shape : org.jbox2d.collision.shapes.Shape, xf : org.jbox2d.common.XForm, color : org.jbox2d.common.Color3f, core : boolean) {
            if(shape.getType() === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                let circle : org.jbox2d.collision.shapes.CircleShape = <org.jbox2d.collision.shapes.CircleShape>shape;
                org.jbox2d.common.XForm.mulToOut(xf, circle.getMemberLocalPosition(), this.drawingCenter);
                let radius : number = circle.getRadius();
                let axis : org.jbox2d.common.Vec2 = xf.R.col1;
                if(circle.getUserData() != null && /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(circle.getUserData(),World.LIQUID_INT_$LI$()))) {
                    let b : org.jbox2d.dynamics.Body = circle.getBody();
                    this.liquidOffset.set$org_jbox2d_common_Vec2(b.m_linearVelocity);
                    let linVelLength : number = b.m_linearVelocity.length();
                    if(this.averageLinearVel === -1) {
                        this.averageLinearVel = linVelLength;
                    } else {
                        this.averageLinearVel = (<any>Math).fround((<any>Math).fround(0.98 * this.averageLinearVel) + (<any>Math).fround(0.02 * linVelLength));
                    }
                    this.liquidOffset.mulLocal((<any>Math).fround((<any>Math).fround(this.liquidLength / this.averageLinearVel) / 2));
                    this.circCenterMoved.set$org_jbox2d_common_Vec2(this.drawingCenter).addLocal$org_jbox2d_common_Vec2(this.liquidOffset);
                    this.drawingCenter.subLocal(this.liquidOffset);
                    this.m_debugDraw.drawSegment(this.drawingCenter, this.circCenterMoved, this.liquidColor);
                    return;
                }
                this.m_debugDraw.drawSolidCircle(this.drawingCenter, radius, axis, color);
                if(core) {
                    this.m_debugDraw.drawCircle(this.drawingCenter, (<any>Math).fround(radius - org.jbox2d.common.Settings.toiSlop_$LI$()), this.coreColor);
                }
            } else if(shape.getType() === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE) {
                let point : org.jbox2d.collision.shapes.PointShape = <org.jbox2d.collision.shapes.PointShape>shape;
                org.jbox2d.common.XForm.mulToOut(xf, point.getMemberLocalPosition(), this.drawingCenter);
                this.m_debugDraw.drawPoint(this.drawingCenter, 0.0, color);
            } else if(shape.getType() === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                let poly : org.jbox2d.collision.shapes.PolygonShape = <org.jbox2d.collision.shapes.PolygonShape>shape;
                let vertexCount : number = poly.getVertexCount();
                let localVertices : org.jbox2d.common.Vec2[] = poly.getVertices();
                if(!((vertexCount <= org.jbox2d.common.Settings.maxPolygonVertices))) throw new Error("Assertion error line 892: assert (vertexCount <= Settings.maxPolygonVertices);");;
                let vertices : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(vertexCount);
                for(let i : number = 0; i < vertexCount; ++i) {{
                    vertices[i] = org.jbox2d.common.XForm.mul(xf, localVertices[i]);
                };}
                this.m_debugDraw.drawSolidPolygon(vertices, vertexCount, color);
                if(core) {
                    let localCoreVertices : org.jbox2d.common.Vec2[] = poly.getCoreVertices();
                    for(let i : number = 0; i < vertexCount; ++i) {{
                        vertices[i] = org.jbox2d.common.XForm.mul(xf, localCoreVertices[i]);
                    };}
                    this.m_debugDraw.drawPolygon(vertices, vertexCount, this.coreColor);
                }
            } else if(shape.getType() === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE) {
                let edge : org.jbox2d.collision.shapes.EdgeShape = <org.jbox2d.collision.shapes.EdgeShape>shape;
                org.jbox2d.common.XForm.mulToOut(xf, edge.getVertex1(), this.segLeft);
                org.jbox2d.common.XForm.mulToOut(xf, edge.getVertex2(), this.segRight);
                this.m_debugDraw.drawSegment(this.segLeft, this.segRight, color);
                if(core) {
                    org.jbox2d.common.XForm.mulToOut(xf, edge.getCoreVertex1(), this.segLeft);
                    org.jbox2d.common.XForm.mulToOut(xf, edge.getCoreVertex2(), this.segRight);
                    this.m_debugDraw.drawSegment(this.segLeft, this.segRight, this.coreColor);
                }
            }
        }

        /*private*/ jointColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f((<any>Math).fround(255.0 * 0.5), (<any>Math).fround(255.0 * 0.8), (<any>Math).fround(255.0 * 0.8));

        /**
         * For internal use
         * @param {org.jbox2d.dynamics.joints.Joint} joint
         */
        public drawJoint(joint : org.jbox2d.dynamics.joints.Joint) {
            let b1 : org.jbox2d.dynamics.Body = joint.getBody1();
            let b2 : org.jbox2d.dynamics.Body = joint.getBody2();
            let xf1 : org.jbox2d.common.XForm = b1.getMemberXForm();
            let xf2 : org.jbox2d.common.XForm = b2.getMemberXForm();
            let x1 : org.jbox2d.common.Vec2 = xf1.position;
            let x2 : org.jbox2d.common.Vec2 = xf2.position;
            let p1 : org.jbox2d.common.Vec2 = joint.getAnchor1();
            let p2 : org.jbox2d.common.Vec2 = joint.getAnchor2();
            let type : org.jbox2d.dynamics.joints.JointType = joint.getType();
            if(type === org.jbox2d.dynamics.joints.JointType.DISTANCE_JOINT) {
                this.m_debugDraw.drawSegment(p1, p2, this.jointColor);
            } else if(type === org.jbox2d.dynamics.joints.JointType.PULLEY_JOINT) {
                let pulley : org.jbox2d.dynamics.joints.PulleyJoint = <org.jbox2d.dynamics.joints.PulleyJoint>joint;
                let s1 : org.jbox2d.common.Vec2 = pulley.getGroundAnchor1();
                let s2 : org.jbox2d.common.Vec2 = pulley.getGroundAnchor2();
                this.m_debugDraw.drawSegment(s1, p1, this.jointColor);
                this.m_debugDraw.drawSegment(s2, p2, this.jointColor);
                this.m_debugDraw.drawSegment(s1, s2, this.jointColor);
            } else if(type === org.jbox2d.dynamics.joints.JointType.MOUSE_JOINT) {
            } else if(type === org.jbox2d.dynamics.joints.JointType.CONSTANT_VOLUME_JOINT) {
                let cvj : org.jbox2d.dynamics.joints.ConstantVolumeJoint = <org.jbox2d.dynamics.joints.ConstantVolumeJoint>joint;
                let bodies : org.jbox2d.dynamics.Body[] = cvj.getBodies();
                for(let i : number = 0; i < bodies.length; ++i) {{
                    let next : number = (i === bodies.length - 1)?0:i + 1;
                    let first : org.jbox2d.common.Vec2 = bodies[i].getMemberWorldCenter();
                    let nextV : org.jbox2d.common.Vec2 = bodies[next].getMemberWorldCenter();
                    this.m_debugDraw.drawSegment(first, nextV, this.jointColor);
                };}
            } else {
                this.m_debugDraw.drawSegment(x1, p1, this.jointColor);
                this.m_debugDraw.drawSegment(p1, p2, this.jointColor);
                this.m_debugDraw.drawSegment(x2, p2, this.jointColor);
            }
        }

        /*private*/ staticColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f((<any>Math).fround(255.0 * 0.5), (<any>Math).fround(255.0 * 0.9), (<any>Math).fround(255.0 * 0.5));

        /*private*/ sleepingColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f((<any>Math).fround(255.0 * 0.5), (<any>Math).fround(255.0 * 0.5), (<any>Math).fround(255.0 * 0.9));

        /*private*/ activeColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f((<any>Math).fround(255.0 * 0.9), (<any>Math).fround(255.0 * 0.9), (<any>Math).fround(255.0 * 0.9));

        /*private*/ pairColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f((<any>Math).fround(255.0 * 0.9), (<any>Math).fround(255.0 * 0.9), (<any>Math).fround(255.0 * 0.3));

        /*private*/ aabbColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f((<any>Math).fround(255.0 * 0.9), (<any>Math).fround(255.0 * 0.3), (<any>Math).fround(255.0 * 0.9));

        /*private*/ obbColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f(0.5, 0.3, 0.5);

        /*private*/ worldColor : org.jbox2d.common.Color3f = new org.jbox2d.common.Color3f((<any>Math).fround(255.0 * 0.3), (<any>Math).fround(255.0 * 0.9), (<any>Math).fround(255.0 * 0.9));

        /*private*/ pairB1 : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ pairB2 : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ pairX1 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ pairX2 : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();

        /*private*/ aabbB : org.jbox2d.collision.AABB = new org.jbox2d.collision.AABB();

        /*private*/ cornerVecs : org.jbox2d.common.Vec2[] = [new org.jbox2d.common.Vec2(), new org.jbox2d.common.Vec2(), new org.jbox2d.common.Vec2(), new org.jbox2d.common.Vec2()];

        /**
         * For internal use
         */
        public drawDebugData() {
            if(this.m_debugDraw == null || this.m_drawDebugData === false) {
                return;
            }
            let flags : number = this.m_debugDraw.getFlags();
            if((flags & org.jbox2d.dynamics.DebugDraw.e_shapeBit) !== 0) {
                let core : boolean = (flags & org.jbox2d.dynamics.DebugDraw.e_coreShapeBit) === org.jbox2d.dynamics.DebugDraw.e_coreShapeBit;
                for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.getNext()) {{
                    let xf : org.jbox2d.common.XForm = b.getMemberXForm();
                    for(let s : org.jbox2d.collision.shapes.Shape = b.getShapeList(); s != null; s = s.getNext()) {{
                        if(b.isStatic()) {
                            this.drawShape(s, xf, this.staticColor, core);
                        } else if(b.isSleeping()) {
                            this.drawShape(s, xf, this.sleepingColor, core);
                        } else {
                            this.drawShape(s, xf, this.activeColor, core);
                        }
                    };}
                };}
            }
            if((flags & org.jbox2d.dynamics.DebugDraw.e_jointBit) !== 0) {
                for(let j : org.jbox2d.dynamics.joints.Joint = this.m_jointList; j != null; j = j.getNext()) {{
                    if(j.getType() !== org.jbox2d.dynamics.joints.JointType.MOUSE_JOINT) {
                        this.drawJoint(j);
                    }
                };}
            }
            if((flags & org.jbox2d.dynamics.DebugDraw.e_pairBit) !== 0) {
                let bp : org.jbox2d.collision.BroadPhase = this.m_broadPhase;
                let invQ : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2(0.0, 0.0);
                invQ.set$float$float((<any>Math).fround(1.0 / bp.m_quantizationFactor.x), (<any>Math).fround(1.0 / bp.m_quantizationFactor.y));
                for(let i : number = 0; i < org.jbox2d.collision.PairManager.TABLE_CAPACITY_$LI$(); ++i) {{
                    let index : number = bp.m_pairManager.m_hashTable[i];
                    while((index !== org.jbox2d.collision.PairManager.NULL_PAIR_$LI$())) {{
                        let pair : org.jbox2d.collision.Pair = bp.m_pairManager.m_pairs[index];
                        let p1 : org.jbox2d.collision.Proxy = bp.m_proxyPool[pair.proxyId1];
                        let p2 : org.jbox2d.collision.Proxy = bp.m_proxyPool[pair.proxyId2];
                        this.pairB1.lowerBound.x = (<any>Math).fround(bp.m_worldAABB.lowerBound.x + (<any>Math).fround(invQ.x * bp.m_bounds[0][p1.lowerBounds[0]].value));
                        this.pairB1.lowerBound.y = (<any>Math).fround(bp.m_worldAABB.lowerBound.y + (<any>Math).fround(invQ.y * bp.m_bounds[1][p1.lowerBounds[1]].value));
                        this.pairB1.upperBound.x = (<any>Math).fround(bp.m_worldAABB.lowerBound.x + (<any>Math).fround(invQ.x * bp.m_bounds[0][p1.upperBounds[0]].value));
                        this.pairB1.upperBound.y = (<any>Math).fround(bp.m_worldAABB.lowerBound.y + (<any>Math).fround(invQ.y * bp.m_bounds[1][p1.upperBounds[1]].value));
                        this.pairB2.lowerBound.x = (<any>Math).fround(bp.m_worldAABB.lowerBound.x + (<any>Math).fround(invQ.x * bp.m_bounds[0][p2.lowerBounds[0]].value));
                        this.pairB2.lowerBound.y = (<any>Math).fround(bp.m_worldAABB.lowerBound.y + (<any>Math).fround(invQ.y * bp.m_bounds[1][p2.lowerBounds[1]].value));
                        this.pairB2.upperBound.x = (<any>Math).fround(bp.m_worldAABB.lowerBound.x + (<any>Math).fround(invQ.x * bp.m_bounds[0][p2.upperBounds[0]].value));
                        this.pairB2.upperBound.y = (<any>Math).fround(bp.m_worldAABB.lowerBound.y + (<any>Math).fround(invQ.y * bp.m_bounds[1][p2.upperBounds[1]].value));
                        this.pairX1.x = (<any>Math).fround(0.5 * ((<any>Math).fround(this.pairB1.lowerBound.x + this.pairB1.upperBound.x)));
                        this.pairX1.y = (<any>Math).fround(0.5 * ((<any>Math).fround(this.pairB1.lowerBound.y + this.pairB1.upperBound.y)));
                        this.pairX2.x = (<any>Math).fround(0.5 * ((<any>Math).fround(this.pairB2.lowerBound.x + this.pairB2.upperBound.x)));
                        this.pairX2.y = (<any>Math).fround(0.5 * ((<any>Math).fround(this.pairB2.lowerBound.y + this.pairB2.upperBound.y)));
                        this.m_debugDraw.drawSegment(this.pairX1, this.pairX1, this.pairColor);
                        index = pair.next;
                    }};
                };}
            }
            if((flags & org.jbox2d.dynamics.DebugDraw.e_controllerBit) !== 0) {
                for(let c : org.jbox2d.dynamics.controllers.Controller = this.m_controllerList; c != null; c = c.getNext()) {{
                    c.draw(this.m_debugDraw);
                };}
            }
            let bp : org.jbox2d.collision.BroadPhase = this.m_broadPhase;
            let worldLower : org.jbox2d.common.Vec2 = bp.m_worldAABB.lowerBound;
            let worldUpper : org.jbox2d.common.Vec2 = bp.m_worldAABB.upperBound;
            if((flags & org.jbox2d.dynamics.DebugDraw.e_aabbBit) !== 0) {
                let invQ : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
                invQ.set$float$float((<any>Math).fround(1.0 / bp.m_quantizationFactor.x), (<any>Math).fround(1.0 / bp.m_quantizationFactor.y));
                for(let i : number = 0; i < org.jbox2d.common.Settings.maxProxies; ++i) {{
                    let p : org.jbox2d.collision.Proxy = bp.m_proxyPool[i];
                    if(p.isValid() === false) {
                        continue;
                    }
                    this.aabbB.lowerBound.x = (<any>Math).fround(worldLower.x + (<any>Math).fround(invQ.x * bp.m_bounds[0][p.lowerBounds[0]].value));
                    this.aabbB.lowerBound.y = (<any>Math).fround(worldLower.y + (<any>Math).fround(invQ.y * bp.m_bounds[1][p.lowerBounds[1]].value));
                    this.aabbB.upperBound.x = (<any>Math).fround(worldLower.x + (<any>Math).fround(invQ.x * bp.m_bounds[0][p.upperBounds[0]].value));
                    this.aabbB.upperBound.y = (<any>Math).fround(worldLower.y + (<any>Math).fround(invQ.y * bp.m_bounds[1][p.upperBounds[1]].value));
                    this.cornerVecs[0].set$float$float(this.aabbB.lowerBound.x, this.aabbB.lowerBound.y);
                    this.cornerVecs[1].set$float$float(this.aabbB.upperBound.x, this.aabbB.lowerBound.y);
                    this.cornerVecs[2].set$float$float(this.aabbB.upperBound.x, this.aabbB.upperBound.y);
                    this.cornerVecs[3].set$float$float(this.aabbB.lowerBound.x, this.aabbB.upperBound.y);
                    this.m_debugDraw.drawPolygon(this.cornerVecs, 4, this.aabbColor);
                };}
            }
            this.cornerVecs[0].set$float$float(worldLower.x, worldLower.y);
            this.cornerVecs[1].set$float$float(worldUpper.x, worldLower.y);
            this.cornerVecs[2].set$float$float(worldUpper.x, worldUpper.y);
            this.cornerVecs[3].set$float$float(worldLower.x, worldUpper.y);
            this.m_debugDraw.drawPolygon(this.cornerVecs, 4, this.worldColor);
            if((flags & org.jbox2d.dynamics.DebugDraw.e_obbBit) !== 0) {
                for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.getNext()) {{
                    let xf : org.jbox2d.common.XForm = b.getMemberXForm();
                    for(let s : org.jbox2d.collision.shapes.Shape = b.getShapeList(); s != null; s = s.getNext()) {{
                        if(s.getType() !== org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                            continue;
                        }
                        let poly : org.jbox2d.collision.shapes.PolygonShape = <org.jbox2d.collision.shapes.PolygonShape>s;
                        let obb : org.jbox2d.collision.OBB = poly.getOBB();
                        let h : org.jbox2d.common.Vec2 = obb.extents;
                        this.cornerVecs[0].set$float$float(-h.x, -h.y);
                        this.cornerVecs[1].set$float$float(h.x, -h.y);
                        this.cornerVecs[2].set$float$float(h.x, h.y);
                        this.cornerVecs[3].set$float$float(-h.x, h.y);
                        for(let i : number = 0; i < this.cornerVecs.length; ++i) {{
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(obb.R, this.cornerVecs[i], this.cornerVecs[i]);
                            org.jbox2d.common.XForm.mulToOut(xf, this.cornerVecs[i], this.cornerVecs[i]);
                        };}
                        this.m_debugDraw.drawPolygon(this.cornerVecs, 4, this.obbColor);
                    };}
                };}
            }
            if((flags & org.jbox2d.dynamics.DebugDraw.e_centerOfMassBit) !== 0) {
                for(let b : org.jbox2d.dynamics.Body = this.m_bodyList; b != null; b = b.getNext()) {{
                    let xf : org.jbox2d.common.XForm = b.getMemberXForm();
                    xf.position = b.getMemberWorldCenter();
                    this.m_debugDraw.drawXForm(xf);
                };}
            }
        }

        /**
         * Enable/disable warm starting. For testing.
         * @param {boolean} flag
         */
        public setWarmStarting(flag : boolean) {
            this.m_warmStarting = flag;
        }

        /**
         * Enable/disable position correction. For testing.
         * @param {boolean} flag
         */
        public setPositionCorrection(flag : boolean) {
            this.m_positionCorrection = flag;
        }

        /**
         * Enable/disable continuous physics. For testing.
         * @param {boolean} flag
         */
        public setContinuousPhysics(flag : boolean) {
            this.m_continuousPhysics = flag;
        }

        /**
         * Perform validation of internal data structures.
         */
        public validate() {
            this.m_broadPhase.validate();
        }

        /**
         * Get the number of broad-phase proxies.
         * @return {number}
         */
        public getProxyCount() : number {
            return this.m_broadPhase.m_proxyCount;
        }

        /**
         * Get the number of broad-phase pairs.
         * @return {number}
         */
        public getPairCount() : number {
            return this.m_broadPhase.m_pairManager.m_pairCount;
        }

        /**
         * Get the world bounding box.
         * @return {org.jbox2d.collision.AABB}
         */
        public getWorldAABB() : org.jbox2d.collision.AABB {
            return this.m_broadPhase.m_worldAABB;
        }

        /**
         * Return true if the bounding box is within range of the world AABB.
         * @param {org.jbox2d.collision.AABB} aabb
         * @return {boolean}
         */
        public inRange(aabb : org.jbox2d.collision.AABB) : boolean {
            return this.m_broadPhase.inRange(aabb);
        }

        m_raycastSegment : org.jbox2d.collision.Segment;

        m_raycastNormal : org.jbox2d.common.Vec2;

        m_raycastUserData : any;

        m_raycastSolidShape : boolean;

        /**
         * 
         * Query the world for all fixtures that intersect a given segment. You provide a shape
         * pointer buffer of specified size. The number of shapes found is returned, and the buffer
         * is filled in order of intersection
         * @param {org.jbox2d.collision.Segment} segment defines the begin and end point of the ray cast, from p1 to p2.
         * @param {Array} shapes a user allocated shape pointer array of size maxCount (or greater).
         * @param {number} maxCount the capacity of the shapes array
         * @param {boolean} solidShapes determines if shapes that the ray starts in are counted as hits.
         * @param {*} userData passed through the worlds contact filter, with method RayCollide. This can be used to filter valid shapes
         * @return {number} the number of shapes found
         */
        public raycast(segment : org.jbox2d.collision.Segment, shapes : org.jbox2d.collision.shapes.Shape[], maxCount : number, solidShapes : boolean, userData : any) : number {
            this.m_raycastSegment = segment;
            this.m_raycastUserData = userData;
            this.m_raycastSolidShape = solidShapes;
            let results : any[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(maxCount);
            let count : number = this.m_broadPhase.querySegment(segment, results, maxCount, this.raycastSortKey);
            for(let i : number = 0; i < count; ++i) {{
                shapes[i] = <org.jbox2d.collision.shapes.Shape>results[i];
            };}
            return count;
        }

        /**
         * 
         * Performs a ray-cast as with {@link #raycast(Segment, Shape[], int, boolean, Object)}, finding the first intersecting shape
         * @param {org.jbox2d.collision.Segment} segment defines the begin and end point of the ray cast, from p1 to p2
         * @param lambda returns the hit fraction. You can use this to compute the contact point
         * p = (1 - lambda) * segment.p1 + lambda * segment.p2.
         * @param normal returns the normal at the contact point. If there is no intersection, the normal
         * is not set.
         * @param {boolean} solidShapes determines if shapes that the ray starts in are counted as hits.
         * @returns the colliding shape shape, or null if not found
         * @see #raycast(Segment, Shape[], int, boolean, Object)
         * @param {org.jbox2d.common.RaycastResult} result
         * @param {*} userData
         * @return {org.jbox2d.collision.shapes.Shape}
         */
        public raycastOne(segment : org.jbox2d.collision.Segment, result : org.jbox2d.common.RaycastResult, solidShapes : boolean, userData : any) : org.jbox2d.collision.shapes.Shape {
            let maxCount : number = 1;
            let shapes : org.jbox2d.collision.shapes.Shape[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(maxCount);
            let count : number = this.raycast(segment, shapes, maxCount, solidShapes, userData);
            if(count === 0) return null;
            if(!((count === 1))) throw new Error("Assertion error line 1222: assert (count == 1);");;
            shapes[0].testSegment(shapes[0].getBody().getMemberXForm(), result, segment, 1.0);
            return shapes[0];
        }

        /*private*/ raycastSortKey : org.jbox2d.collision.SortKeyFunc = new World.World$0(this);

        /*private*/ raycastSortKeyFunc(data : any) : number {
            let shape : org.jbox2d.collision.shapes.Shape = <org.jbox2d.collision.shapes.Shape>data;
            let body : org.jbox2d.dynamics.Body = shape.getBody();
            let world : World = body.getWorld();
            if(world.m_contactFilter != null && !world.m_contactFilter.rayCollide(world.m_raycastUserData, shape)) {
                return -1;
            }
            let result : org.jbox2d.common.RaycastResult = new org.jbox2d.common.RaycastResult();
            let collide : org.jbox2d.collision.SegmentCollide = shape.testSegment(body.getMemberXForm(), result, world.m_raycastSegment, 1.0);
            let lambda : number = result.lambda;
            if(world.m_raycastSolidShape && collide === org.jbox2d.collision.SegmentCollide.MISS_COLLIDE) {
                return -1;
            }
            if(!world.m_raycastSolidShape && collide !== org.jbox2d.collision.SegmentCollide.HIT_COLLIDE) {
                return -1;
            }
            return lambda;
        }
    }
    World["__class"] = "org.jbox2d.dynamics.World";


    export namespace World {

        export class World$0 implements org.jbox2d.collision.SortKeyFunc {
            public __parent: any;
            public apply(shape : any) : number {
                return this.__parent.raycastSortKeyFunc(shape);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }
        World$0["__interfaces"] = ["org.jbox2d.collision.SortKeyFunc"];


    }

}
namespace org.jbox2d.collision.shapes {
    /**
     * this is used internally, instead use {@link Body#createShape(ShapeDef)}
     * with a {@link CircleDef}
     * 
     * @see Body#createShape(ShapeDef)
     * @see CircleDef
     * @param {org.jbox2d.collision.shapes.ShapeDef} def
     * @class
     * @extends org.jbox2d.collision.shapes.Shape
     */
    export class CircleShape extends org.jbox2d.collision.shapes.Shape {
        public m_radius : number;

        public m_localPosition : org.jbox2d.common.Vec2;

        public constructor(def : org.jbox2d.collision.shapes.ShapeDef) {
            super(def);
            if(this.m_radius===undefined) this.m_radius = 0;
            if(this.m_localPosition===undefined) this.m_localPosition = null;
            if(!((def.type === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE))) throw new Error("Assertion error line 21: assert (def.type == ShapeType.CIRCLE_SHAPE);");;
            let circleDef : org.jbox2d.collision.shapes.CircleDef = <org.jbox2d.collision.shapes.CircleDef>def;
            this.m_type = org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE;
            this.m_localPosition = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(circleDef.localPosition);
            this.m_radius = circleDef.radius;
        }

        /**
         * @see Shape#updateSweepRadius(Vec2)
         * @param {org.jbox2d.common.Vec2} center
         */
        public updateSweepRadius(center : org.jbox2d.common.Vec2) {
            let dx : number = (<any>Math).fround(this.m_localPosition.x - center.x);
            let dy : number = (<any>Math).fround(this.m_localPosition.y - center.y);
            this.m_sweepRadius = (<any>Math).fround((<any>Math).fround(org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy))) + this.m_radius) - org.jbox2d.common.Settings.toiSlop_$LI$());
        }

        static tlCenter : org.jbox2d.pooling.TLVec2; public static tlCenter_$LI$() : org.jbox2d.pooling.TLVec2 { if(CircleShape.tlCenter == null) CircleShape.tlCenter = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleShape.tlCenter; };

        /**
         * checks to see if the point is in this shape.
         * 
         * @see Shape#testPoint(XForm, Vec2)
         * @param {org.jbox2d.common.XForm} transform
         * @param {org.jbox2d.common.Vec2} p
         * @return {boolean}
         */
        public testPoint(transform : org.jbox2d.common.XForm, p : org.jbox2d.common.Vec2) : boolean {
            let center : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(CircleShape.tlCenter_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform.R, this.m_localPosition, center);
            center.addLocal$org_jbox2d_common_Vec2(transform.position);
            let d : org.jbox2d.common.Vec2 = center.subLocal(p).negateLocal();
            let ret : boolean = org.jbox2d.common.Vec2.dot(d, d) <= (<any>Math).fround(this.m_radius * this.m_radius);
            return ret;
        }

        static tlS : org.jbox2d.pooling.TLVec2; public static tlS_$LI$() : org.jbox2d.pooling.TLVec2 { if(CircleShape.tlS == null) CircleShape.tlS = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleShape.tlS; };

        static tlPosition : org.jbox2d.pooling.TLVec2; public static tlPosition_$LI$() : org.jbox2d.pooling.TLVec2 { if(CircleShape.tlPosition == null) CircleShape.tlPosition = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleShape.tlPosition; };

        static tlR : org.jbox2d.pooling.TLVec2; public static tlR_$LI$() : org.jbox2d.pooling.TLVec2 { if(CircleShape.tlR == null) CircleShape.tlR = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleShape.tlR; };

        /**
         * @see Shape#testSegment(XForm, RaycastResult, Segment, float)
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.RaycastResult} out
         * @param {org.jbox2d.collision.Segment} segment
         * @param {number} maxLambda
         * @return {org.jbox2d.collision.SegmentCollide}
         */
        public testSegment(xf : org.jbox2d.common.XForm, out : org.jbox2d.common.RaycastResult, segment : org.jbox2d.collision.Segment, maxLambda : number) : org.jbox2d.collision.SegmentCollide {
            let position : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(CircleShape.tlPosition_$LI$());
            let s : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(CircleShape.tlS_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, this.m_localPosition, position);
            position.addLocal$org_jbox2d_common_Vec2(xf.position);
            s.set$org_jbox2d_common_Vec2(segment.p1);
            s.subLocal(position);
            let b : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(s, s) - (<any>Math).fround(this.m_radius * this.m_radius));
            if(b < 0.0) {
                return org.jbox2d.collision.SegmentCollide.STARTS_INSIDE_COLLIDE;
            }
            let r : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(CircleShape.tlR_$LI$());
            r.set$org_jbox2d_common_Vec2(segment.p2).subLocal(segment.p1);
            let c : number = org.jbox2d.common.Vec2.dot(s, r);
            let rr : number = org.jbox2d.common.Vec2.dot(r, r);
            let sigma : number = (<any>Math).fround((<any>Math).fround(c * c) - (<any>Math).fround(rr * b));
            if(sigma < 0.0 || rr < org.jbox2d.common.Settings.EPSILON) {
                return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
            }
            let a : number = -((<any>Math).fround(c + org.jbox2d.common.MathUtils.sqrt(sigma)));
            if(0.0 <= a && a <= (<any>Math).fround(maxLambda * rr)) {
                a /= rr;
                out.lambda = a;
                out.normal.set$org_jbox2d_common_Vec2(r).mulLocal(a).addLocal$org_jbox2d_common_Vec2(s);
                out.normal.normalize();
                return org.jbox2d.collision.SegmentCollide.HIT_COLLIDE;
            }
            return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
        }

        static tlP : org.jbox2d.pooling.TLVec2; public static tlP_$LI$() : org.jbox2d.pooling.TLVec2 { if(CircleShape.tlP == null) CircleShape.tlP = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleShape.tlP; };

        /**
         * @see Shape#computeAABB(AABB, XForm)
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.XForm} transform
         */
        public computeAABB(aabb : org.jbox2d.collision.AABB, transform : org.jbox2d.common.XForm) {
            let p : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(CircleShape.tlP_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform.R, this.m_localPosition, p);
            p.addLocal$org_jbox2d_common_Vec2(transform.position);
            aabb.lowerBound.x = (<any>Math).fround(p.x - this.m_radius);
            aabb.lowerBound.y = (<any>Math).fround(p.y - this.m_radius);
            aabb.upperBound.x = (<any>Math).fround(p.x + this.m_radius);
            aabb.upperBound.y = (<any>Math).fround(p.y + this.m_radius);
        }

        /**
         * @see Shape#computeSweptAABB(AABB, XForm, XForm)
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.XForm} transform1
         * @param {org.jbox2d.common.XForm} transform2
         */
        public computeSweptAABB(aabb : org.jbox2d.collision.AABB, transform1 : org.jbox2d.common.XForm, transform2 : org.jbox2d.common.XForm) {
            let p1x : number = (<any>Math).fround((<any>Math).fround(transform1.position.x + (<any>Math).fround(transform1.R.col1.x * this.m_localPosition.x)) + (<any>Math).fround(transform1.R.col2.x * this.m_localPosition.y));
            let p1y : number = (<any>Math).fround((<any>Math).fround(transform1.position.y + (<any>Math).fround(transform1.R.col1.y * this.m_localPosition.x)) + (<any>Math).fround(transform1.R.col2.y * this.m_localPosition.y));
            let p2x : number = (<any>Math).fround((<any>Math).fround(transform2.position.x + (<any>Math).fround(transform2.R.col1.x * this.m_localPosition.x)) + (<any>Math).fround(transform2.R.col2.x * this.m_localPosition.y));
            let p2y : number = (<any>Math).fround((<any>Math).fround(transform2.position.y + (<any>Math).fround(transform2.R.col1.y * this.m_localPosition.x)) + (<any>Math).fround(transform2.R.col2.y * this.m_localPosition.y));
            let lowerx : number = p1x < p2x?p1x:p2x;
            let lowery : number = p1y < p2y?p1y:p2y;
            let upperx : number = p1x > p2x?p1x:p2x;
            let uppery : number = p1y > p2y?p1y:p2y;
            aabb.lowerBound.x = (<any>Math).fround(lowerx - this.m_radius);
            aabb.lowerBound.y = (<any>Math).fround(lowery - this.m_radius);
            aabb.upperBound.x = (<any>Math).fround(upperx + this.m_radius);
            aabb.upperBound.y = (<any>Math).fround(uppery + this.m_radius);
        }

        /**
         * @see Shape#computeMass(MassData)
         * @param {org.jbox2d.collision.MassData} massData
         */
        public computeMass(massData : org.jbox2d.collision.MassData) {
            massData.mass = (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m_density * org.jbox2d.common.MathUtils.PI_$LI$()) * this.m_radius) * this.m_radius);
            massData.center.set$org_jbox2d_common_Vec2(this.m_localPosition);
            massData.I = (<any>Math).fround(massData.mass * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(0.5 * this.m_radius) * this.m_radius) + org.jbox2d.common.Vec2.dot(this.m_localPosition, this.m_localPosition))));
        }

        public getRadius() : number {
            return this.m_radius;
        }

        /**
         * Returns a copy of the local position
         * 
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public getLocalPosition() : org.jbox2d.common.Vec2 {
            return /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this.m_localPosition);
        }

        /**
         * Returns the member variable of the local position. Don't change this.
         * 
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public getMemberLocalPosition() : org.jbox2d.common.Vec2 {
            return this.m_localPosition;
        }

        public computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal : org.jbox2d.common.Vec2, offset : number, xf : org.jbox2d.common.XForm, c : org.jbox2d.common.Vec2) : number {
            let p : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(CircleShape.tlP_$LI$());
            org.jbox2d.common.XForm.mulToOut(xf, this.m_localPosition, p);
            let l : number = -((<any>Math).fround(org.jbox2d.common.Vec2.dot(normal, p) - offset));
            if(l < (<any>Math).fround(-this.m_radius + org.jbox2d.common.Settings.EPSILON)) {
                return 0;
            }
            if(l > this.m_radius) {
                c.set$org_jbox2d_common_Vec2(p);
                return (<any>Math).fround((<any>Math).fround(org.jbox2d.common.Settings.pi_$LI$() * this.m_radius) * this.m_radius);
            }
            let r2 : number = (<any>Math).fround(this.m_radius * this.m_radius);
            let l2 : number = (<any>Math).fround(l * l);
            let area : number = (<any>Math).fround((r2 * (Math.asin((<any>Math).fround(l / this.m_radius)) + (<any>Math).fround(org.jbox2d.common.Settings.pi_$LI$() / 2.0)) + (<any>Math).fround(l * org.jbox2d.common.MathUtils.sqrt((<any>Math).fround(r2 - l2)))));
            let com : number = <number>((<any>Math).fround((<any>Math).fround((<any>Math).fround(-2.0 / 3.0) * org.jbox2d.common.MathUtils.pow((<any>Math).fround(r2 - l2), 1.5)) / area));
            c.x = (<any>Math).fround(p.x + (<any>Math).fround(normal.x * com));
            c.y = (<any>Math).fround(p.y + (<any>Math).fround(normal.y * com));
            return area;
        }

        /**
         * @see Shape#computeSubmergedArea(Vec2, float, XForm, Vec2)
         * @param {org.jbox2d.common.Vec2} normal
         * @param {number} offset
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.Vec2} c
         * @return {number}
         */
        public computeSubmergedArea(normal? : any, offset? : any, xf? : any, c? : any) : any {
            if(((normal != null && normal instanceof <any>org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof <any>org.jbox2d.common.XForm) || xf === null) && ((c != null && c instanceof <any>org.jbox2d.common.Vec2) || c === null)) {
                return <any>this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, xf, c);
            } else if(((normal != null && normal instanceof <any>org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof <any>org.jbox2d.common.Vec2) || xf === null) && c === undefined) {
                return <any>this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(normal, offset, xf);
            } else throw new Error('invalid overload');
        }
    }
    CircleShape["__class"] = "org.jbox2d.collision.shapes.CircleShape";

}
namespace org.jbox2d.collision.shapes {
    /**
     * Don't use this.  Instead create using {@link Body#createShape(ShapeDef)} with an
     * {@link EdgeChainDef}, not the constructor here.
     * @see Body#createShape(ShapeDef)
     * @see EdgeChainDef
     * @param {org.jbox2d.common.Vec2} v1
     * @param {org.jbox2d.common.Vec2} v2
     * @param {org.jbox2d.collision.shapes.ShapeDef} def
     * @class
     * @extends org.jbox2d.collision.shapes.Shape
     * @author daniel
     */
    export class EdgeShape extends org.jbox2d.collision.shapes.Shape implements org.jbox2d.collision.SupportsGenericDistance {
        /*private*/ m_v1 : org.jbox2d.common.Vec2;

        /*private*/ m_v2 : org.jbox2d.common.Vec2;

        /*private*/ m_coreV1 : org.jbox2d.common.Vec2;

        /*private*/ m_coreV2 : org.jbox2d.common.Vec2;

        /*private*/ m_length : number;

        /*private*/ m_normal : org.jbox2d.common.Vec2;

        /*private*/ m_direction : org.jbox2d.common.Vec2;

        /*private*/ m_cornerDir1 : org.jbox2d.common.Vec2;

        /*private*/ m_cornerDir2 : org.jbox2d.common.Vec2;

        /*private*/ m_cornerConvex1 : boolean;

        /*private*/ m_cornerConvex2 : boolean;

        m_nextEdge : EdgeShape;

        m_prevEdge : EdgeShape;

        public constructor(v1 : org.jbox2d.common.Vec2, v2 : org.jbox2d.common.Vec2, def : org.jbox2d.collision.shapes.ShapeDef) {
            super(def);
            if(this.m_v1===undefined) this.m_v1 = null;
            if(this.m_v2===undefined) this.m_v2 = null;
            if(this.m_coreV1===undefined) this.m_coreV1 = null;
            if(this.m_coreV2===undefined) this.m_coreV2 = null;
            if(this.m_length===undefined) this.m_length = 0;
            if(this.m_normal===undefined) this.m_normal = null;
            if(this.m_direction===undefined) this.m_direction = null;
            if(this.m_cornerDir1===undefined) this.m_cornerDir1 = null;
            if(this.m_cornerDir2===undefined) this.m_cornerDir2 = null;
            if(this.m_cornerConvex1===undefined) this.m_cornerConvex1 = false;
            if(this.m_cornerConvex2===undefined) this.m_cornerConvex2 = false;
            if(this.m_nextEdge===undefined) this.m_nextEdge = null;
            if(this.m_prevEdge===undefined) this.m_prevEdge = null;
            if(!((def.type === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE))) throw new Error("Assertion error line 56: assert (def.type == ShapeType.EDGE_SHAPE);");;
            this.m_type = org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE;
            this.m_prevEdge = null;
            this.m_nextEdge = null;
            this.m_v1 = v1;
            this.m_v2 = v2;
            this.m_direction = this.m_v2.sub(this.m_v1);
            this.m_length = this.m_direction.normalize();
            this.m_normal = new org.jbox2d.common.Vec2(this.m_direction.y, -this.m_direction.x);
            this.m_coreV1 = (this.m_normal.sub(this.m_direction)).mulLocal(-org.jbox2d.common.Settings.toiSlop_$LI$()).addLocal$org_jbox2d_common_Vec2(this.m_v1);
            this.m_coreV2 = (this.m_normal.add(this.m_direction)).mulLocal(-org.jbox2d.common.Settings.toiSlop_$LI$()).addLocal$org_jbox2d_common_Vec2(this.m_v2);
            this.m_cornerDir1 = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this.m_normal);
            this.m_cornerDir2 = this.m_normal.mul(-1.0);
        }

        /**
         * @see Shape#updateSweepRadius(Vec2)
         * @param {org.jbox2d.common.Vec2} center
         */
        public updateSweepRadius(center : org.jbox2d.common.Vec2) {
            let dx : number = (<any>Math).fround(this.m_coreV1.x - center.x);
            let dy : number = (<any>Math).fround(this.m_coreV1.y - center.y);
            let d1 : number = (<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy));
            let dx2 : number = (<any>Math).fround(this.m_coreV2.x - center.x);
            let dy2 : number = (<any>Math).fround(this.m_coreV2.y - center.y);
            let d2 : number = (<any>Math).fround((<any>Math).fround(dx2 * dx2) + (<any>Math).fround(dy2 * dy2));
            this.m_sweepRadius = org.jbox2d.common.MathUtils.sqrt(d1 > d2?d1:d2);
        }

        /**
         * @see Shape#testPoint(XForm, Vec2)
         * @param {org.jbox2d.common.XForm} transform
         * @param {org.jbox2d.common.Vec2} p
         * @return {boolean}
         */
        public testPoint(transform : org.jbox2d.common.XForm, p : org.jbox2d.common.Vec2) : boolean {
            return false;
        }

        static tlR : org.jbox2d.pooling.TLVec2; public static tlR_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlR == null) EdgeShape.tlR = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlR; };

        static tlV1 : org.jbox2d.pooling.TLVec2; public static tlV1_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlV1 == null) EdgeShape.tlV1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlV1; };

        static tlD : org.jbox2d.pooling.TLVec2; public static tlD_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlD == null) EdgeShape.tlD = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlD; };

        static tlN : org.jbox2d.pooling.TLVec2; public static tlN_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlN == null) EdgeShape.tlN = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlN; };

        static tlB : org.jbox2d.pooling.TLVec2; public static tlB_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlB == null) EdgeShape.tlB = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlB; };

        /**
         * @see Shape#testSegment(XForm, RaycastResult, Segment, float)
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.RaycastResult} out
         * @param {org.jbox2d.collision.Segment} segment
         * @param {number} maxLambda
         * @return {org.jbox2d.collision.SegmentCollide}
         */
        public testSegment(xf : org.jbox2d.common.XForm, out : org.jbox2d.common.RaycastResult, segment : org.jbox2d.collision.Segment, maxLambda : number) : org.jbox2d.collision.SegmentCollide {
            let r : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlR_$LI$());
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlV1_$LI$());
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlD_$LI$());
            let n : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlN_$LI$());
            let b : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlB_$LI$());
            r.set$org_jbox2d_common_Vec2(segment.p2).subLocal(segment.p1);
            org.jbox2d.common.XForm.mulToOut(xf, this.m_v1, v1);
            org.jbox2d.common.XForm.mulToOut(xf, this.m_v2, d);
            d.subLocal(v1);
            org.jbox2d.common.Vec2.crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(d, 1.0, n);
            let k_slop : number = (<any>Math).fround(100.0 * org.jbox2d.common.Settings.EPSILON);
            let denom : number = -org.jbox2d.common.Vec2.dot(r, n);
            if(denom > k_slop) {
                b.set$org_jbox2d_common_Vec2(segment.p1).subLocal(v1);
                let a : number = org.jbox2d.common.Vec2.dot(b, n);
                if(0.0 <= a && a <= (<any>Math).fround(maxLambda * denom)) {
                    let mu2 : number = (<any>Math).fround((<any>Math).fround(-r.x * b.y) + (<any>Math).fround(r.y * b.x));
                    if((<any>Math).fround(-k_slop * denom) <= mu2 && mu2 <= (<any>Math).fround(denom * ((<any>Math).fround(1.0 + k_slop)))) {
                        a /= denom;
                        n.normalize();
                        out.lambda = a;
                        out.normal.set$org_jbox2d_common_Vec2(n);
                        return org.jbox2d.collision.SegmentCollide.HIT_COLLIDE;
                    }
                }
            }
            return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
        }

        static tlV2 : org.jbox2d.pooling.TLVec2; public static tlV2_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlV2 == null) EdgeShape.tlV2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlV2; };

        /**
         * @see Shape#computeAABB(AABB, XForm)
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.XForm} transform
         */
        public computeAABB(aabb : org.jbox2d.collision.AABB, transform : org.jbox2d.common.XForm) {
            org.jbox2d.common.XForm.mulToOut(transform, this.m_v1, aabb.lowerBound);
            let v2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlV2_$LI$());
            org.jbox2d.common.XForm.mulToOut(transform, this.m_v2, v2);
            org.jbox2d.common.Vec2.maxToOut(aabb.lowerBound, v2, aabb.upperBound);
            org.jbox2d.common.Vec2.minToOut(aabb.lowerBound, v2, aabb.lowerBound);
        }

        static tlSwept1 : org.jbox2d.pooling.TLVec2; public static tlSwept1_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlSwept1 == null) EdgeShape.tlSwept1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSwept1; };

        static tlSwept2 : org.jbox2d.pooling.TLVec2; public static tlSwept2_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlSwept2 == null) EdgeShape.tlSwept2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSwept2; };

        static tlSwept3 : org.jbox2d.pooling.TLVec2; public static tlSwept3_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlSwept3 == null) EdgeShape.tlSwept3 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSwept3; };

        static tlSwept4 : org.jbox2d.pooling.TLVec2; public static tlSwept4_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlSwept4 == null) EdgeShape.tlSwept4 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSwept4; };

        /**
         * @see Shape#computeSweptAABB(AABB, XForm, XForm)
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.XForm} transform1
         * @param {org.jbox2d.common.XForm} transform2
         */
        public computeSweptAABB(aabb : org.jbox2d.collision.AABB, transform1 : org.jbox2d.common.XForm, transform2 : org.jbox2d.common.XForm) {
            let sweptV1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlSwept1_$LI$());
            let sweptV2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlSwept2_$LI$());
            let sweptV3 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlSwept3_$LI$());
            let sweptV4 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlSwept4_$LI$());
            org.jbox2d.common.XForm.mulToOut(transform1, this.m_v1, sweptV1);
            org.jbox2d.common.XForm.mulToOut(transform1, this.m_v2, sweptV2);
            org.jbox2d.common.XForm.mulToOut(transform2, this.m_v1, sweptV3);
            org.jbox2d.common.XForm.mulToOut(transform2, this.m_v2, sweptV4);
            org.jbox2d.common.Vec2.minToOut(sweptV1, sweptV2, aabb.lowerBound);
            org.jbox2d.common.Vec2.minToOut(aabb.lowerBound, sweptV3, aabb.lowerBound);
            org.jbox2d.common.Vec2.minToOut(aabb.lowerBound, sweptV4, aabb.lowerBound);
            org.jbox2d.common.Vec2.maxToOut(sweptV1, sweptV2, aabb.upperBound);
            org.jbox2d.common.Vec2.maxToOut(aabb.upperBound, sweptV3, aabb.upperBound);
            org.jbox2d.common.Vec2.maxToOut(aabb.upperBound, sweptV4, aabb.upperBound);
        }

        /**
         * @see Shape#computeMass(MassData)
         * @param {org.jbox2d.collision.MassData} massData
         */
        public computeMass(massData : org.jbox2d.collision.MassData) {
            massData.mass = 0;
            massData.center.set$org_jbox2d_common_Vec2(this.m_v1);
            massData.I = 0;
        }

        static tlSupportV1 : org.jbox2d.pooling.TLVec2; public static tlSupportV1_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlSupportV1 == null) EdgeShape.tlSupportV1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSupportV1; };

        static tlSupportV2 : org.jbox2d.pooling.TLVec2; public static tlSupportV2_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlSupportV2 == null) EdgeShape.tlSupportV2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSupportV2; };

        /**
         * @see SupportsGenericDistance#support(Vec2, XForm, Vec2)
         * @param {org.jbox2d.common.Vec2} dest
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.Vec2} d
         */
        public support(dest : org.jbox2d.common.Vec2, xf : org.jbox2d.common.XForm, d : org.jbox2d.common.Vec2) {
            let supportV1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlSupportV1_$LI$());
            let supportV2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlSupportV2_$LI$());
            org.jbox2d.common.XForm.mulToOut(xf, this.m_coreV1, supportV1);
            org.jbox2d.common.XForm.mulToOut(xf, this.m_coreV2, supportV2);
            dest.set$org_jbox2d_common_Vec2(org.jbox2d.common.Vec2.dot(supportV1, d) > org.jbox2d.common.Vec2.dot(supportV2, d)?supportV1:supportV2);
        }

        public setPrevEdge(edge : EdgeShape, core : org.jbox2d.common.Vec2, cornerDir : org.jbox2d.common.Vec2, convex : boolean) {
            this.m_prevEdge = edge;
            this.m_coreV1.set$org_jbox2d_common_Vec2(core);
            this.m_cornerDir1.set$org_jbox2d_common_Vec2(cornerDir);
            this.m_cornerConvex1 = convex;
        }

        public setNextEdge(edge : EdgeShape, core : org.jbox2d.common.Vec2, cornerDir : org.jbox2d.common.Vec2, convex : boolean) {
            this.m_nextEdge = edge;
            this.m_coreV2.set$org_jbox2d_common_Vec2(core);
            this.m_cornerDir2.set$org_jbox2d_common_Vec2(cornerDir);
            this.m_cornerConvex2 = convex;
        }

        /**
         * Linear distance from vertex1 to vertex2
         * @return {number}
         */
        public getLength() : number {
            return this.m_length;
        }

        /**
         * Local position of vertex in parent body
         * @return {org.jbox2d.common.Vec2}
         */
        public getVertex1() : org.jbox2d.common.Vec2 {
            return this.m_v1;
        }

        /**
         * Local position of vertex in parent body
         * @return {org.jbox2d.common.Vec2}
         */
        public getVertex2() : org.jbox2d.common.Vec2 {
            return this.m_v2;
        }

        /**
         * "Core" vertex with TOI slop for b2Distance functions
         * @return {org.jbox2d.common.Vec2}
         */
        public getCoreVertex1() : org.jbox2d.common.Vec2 {
            return this.m_coreV1;
        }

        /**
         * "Core" vertex with TOI slop for b2Distance functions
         * @return {org.jbox2d.common.Vec2}
         */
        public getCoreVertex2() : org.jbox2d.common.Vec2 {
            return this.m_coreV2;
        }

        /**
         * Perpendecular unit vector point, pointing from the solid side to the empty side.
         * @return {org.jbox2d.common.Vec2}
         */
        public getNormalVector() : org.jbox2d.common.Vec2 {
            return this.m_normal;
        }

        /**
         * Parallel unit vector, pointing from vertex1 to vertex2
         * @return {org.jbox2d.common.Vec2}
         */
        public getDirectionVector() : org.jbox2d.common.Vec2 {
            return this.m_direction;
        }

        public getCorner1Vector() : org.jbox2d.common.Vec2 {
            return this.m_cornerDir1;
        }

        public getCorner2Vector() : org.jbox2d.common.Vec2 {
            return this.m_cornerDir2;
        }

        /**
         * Get the next edge in the chain.
         * @return {org.jbox2d.collision.shapes.EdgeShape}
         */
        public getNextEdge() : EdgeShape {
            return this.m_nextEdge;
        }

        /**
         * Get the previous edge in the chain.
         * @return {org.jbox2d.collision.shapes.EdgeShape}
         */
        public getPrevEdge() : EdgeShape {
            return this.m_prevEdge;
        }

        /**
         * @see SupportsGenericDistance#getFirstVertexToOut(XForm, Vec2)
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.Vec2} out
         */
        public getFirstVertexToOut(xf : org.jbox2d.common.XForm, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.XForm.mulToOut(xf, this.m_coreV1, out);
        }

        public corner1IsConvex() : boolean {
            return this.m_cornerConvex1;
        }

        public corner2IsConvex() : boolean {
            return this.m_cornerConvex2;
        }

        static tlV0 : org.jbox2d.pooling.TLVec2; public static tlV0_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlV0 == null) EdgeShape.tlV0 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlV0; };

        static tlTemp : org.jbox2d.pooling.TLVec2; public static tlTemp_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlTemp == null) EdgeShape.tlTemp = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlTemp; };

        static tlE1 : org.jbox2d.pooling.TLVec2; public static tlE1_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlE1 == null) EdgeShape.tlE1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlE1; };

        static tlE2 : org.jbox2d.pooling.TLVec2; public static tlE2_$LI$() : org.jbox2d.pooling.TLVec2 { if(EdgeShape.tlE2 == null) EdgeShape.tlE2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlE2; };

        public computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal : org.jbox2d.common.Vec2, offset : number, xf : org.jbox2d.common.XForm, c : org.jbox2d.common.Vec2) : number {
            let v0 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlV0_$LI$());
            let v1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlV1_$LI$());
            let v2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlV2_$LI$());
            let temp : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlTemp_$LI$());
            v0.set$org_jbox2d_common_Vec2(normal).mul(offset);
            org.jbox2d.common.XForm.mulToOut(xf, this.m_v1, v1);
            org.jbox2d.common.XForm.mulToOut(xf, this.m_v2, v2);
            let d1 : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(normal, v1) - offset);
            let d2 : number = (<any>Math).fround(org.jbox2d.common.Vec2.dot(normal, v2) - offset);
            if(d1 > 0.0) {
                if(d2 > 0.0) {
                    return 0.0;
                } else {
                    temp.set$org_jbox2d_common_Vec2(v2).mulLocal((<any>Math).fround(d1 / ((<any>Math).fround(d1 - d2))));
                    v1.mulLocal((<any>Math).fround(-d2 / ((<any>Math).fround(d1 - d2)))).addLocal$org_jbox2d_common_Vec2(temp);
                }
            } else {
                if(d2 > 0.0) {
                    temp.set$org_jbox2d_common_Vec2(v1).mulLocal((<any>Math).fround(-d2 / ((<any>Math).fround(d1 - d2))));
                    v2.mulLocal((<any>Math).fround(d1 / ((<any>Math).fround(d1 - d2)))).addLocal$org_jbox2d_common_Vec2(temp);
                } else {
                }
            }
            let e1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlE1_$LI$());
            let e2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(EdgeShape.tlE2_$LI$());
            let k_inv3 : number = (<any>Math).fround(1.0 / 3.0);
            c.x = (<any>Math).fround(k_inv3 * ((<any>Math).fround((<any>Math).fround(v0.x + v1.x) + v2.x)));
            c.y = (<any>Math).fround(k_inv3 * ((<any>Math).fround((<any>Math).fround(v0.y + v1.y) + v2.y)));
            e1.set$org_jbox2d_common_Vec2(v1).subLocal(v0);
            e2.set$org_jbox2d_common_Vec2(v2).subLocal(v0);
            return (<any>Math).fround(0.5 * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2));
        }

        public computeSubmergedArea(normal? : any, offset? : any, xf? : any, c? : any) : any {
            if(((normal != null && normal instanceof <any>org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof <any>org.jbox2d.common.XForm) || xf === null) && ((c != null && c instanceof <any>org.jbox2d.common.Vec2) || c === null)) {
                return <any>this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, xf, c);
            } else if(((normal != null && normal instanceof <any>org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof <any>org.jbox2d.common.Vec2) || xf === null) && c === undefined) {
                return <any>this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(normal, offset, xf);
            } else throw new Error('invalid overload');
        }
    }
    EdgeShape["__class"] = "org.jbox2d.collision.shapes.EdgeShape";
    EdgeShape["__interfaces"] = ["org.jbox2d.collision.SupportsGenericDistance"];


}
namespace org.jbox2d.collision.shapes {
    /**
     * Point shape.  Like a circle shape of zero radius, except
     * that it has a finite mass.
     * @param {org.jbox2d.collision.shapes.ShapeDef} def
     * @class
     * @extends org.jbox2d.collision.shapes.Shape
     */
    export class PointShape extends org.jbox2d.collision.shapes.Shape {
        public m_localPosition : org.jbox2d.common.Vec2;

        public m_mass : number;

        public constructor(def : org.jbox2d.collision.shapes.ShapeDef) {
            super(def);
            if(this.m_localPosition===undefined) this.m_localPosition = null;
            if(this.m_mass===undefined) this.m_mass = 0;
            if(!((def.type === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE))) throw new Error("Assertion error line 18: assert (def.type == ShapeType.POINT_SHAPE);");;
            let pointDef : org.jbox2d.collision.shapes.PointDef = <org.jbox2d.collision.shapes.PointDef>def;
            this.m_type = org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE;
            this.m_localPosition = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(pointDef.localPosition);
            this.m_mass = pointDef.mass;
        }

        static tlP : org.jbox2d.pooling.TLVec2; public static tlP_$LI$() : org.jbox2d.pooling.TLVec2 { if(PointShape.tlP == null) PointShape.tlP = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlP; };

        /**
         * @see Shape#computeAABB(AABB, XForm)
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.XForm} transform
         */
        public computeAABB(aabb : org.jbox2d.collision.AABB, transform : org.jbox2d.common.XForm) {
            let p : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointShape.tlP_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform.R, this.m_localPosition, p);
            p.add(transform.position);
            aabb.lowerBound.set$float$float((<any>Math).fround(p.x - org.jbox2d.common.Settings.EPSILON), (<any>Math).fround(p.y - org.jbox2d.common.Settings.EPSILON));
            aabb.upperBound.set$float$float((<any>Math).fround(p.x + org.jbox2d.common.Settings.EPSILON), (<any>Math).fround(p.y + org.jbox2d.common.Settings.EPSILON));
        }

        /**
         * @see Shape#computeMass(MassData)
         * @param {org.jbox2d.collision.MassData} massData
         */
        public computeMass(massData : org.jbox2d.collision.MassData) {
            massData.mass = this.m_mass;
            massData.center.set$org_jbox2d_common_Vec2(this.m_localPosition);
            massData.I = 0.0;
        }

        static tlSwept1 : org.jbox2d.pooling.TLVec2; public static tlSwept1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PointShape.tlSwept1 == null) PointShape.tlSwept1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlSwept1; };

        static tlSwept2 : org.jbox2d.pooling.TLVec2; public static tlSwept2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PointShape.tlSwept2 == null) PointShape.tlSwept2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlSwept2; };

        /**
         * @see Shape#computeSweptAABB(AABB, XForm, XForm)
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.XForm} transform1
         * @param {org.jbox2d.common.XForm} transform2
         */
        public computeSweptAABB(aabb : org.jbox2d.collision.AABB, transform1 : org.jbox2d.common.XForm, transform2 : org.jbox2d.common.XForm) {
            let sweptP1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointShape.tlSwept1_$LI$());
            let sweptP2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointShape.tlSwept2_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform2.R, this.m_localPosition, sweptP1);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform2.R, this.m_localPosition, sweptP2);
            org.jbox2d.common.Vec2.minToOut(sweptP1, sweptP2, aabb.lowerBound);
            org.jbox2d.common.Vec2.maxToOut(sweptP1, sweptP2, aabb.upperBound);
            aabb.lowerBound.x -= org.jbox2d.common.Settings.EPSILON;
            aabb.lowerBound.y -= org.jbox2d.common.Settings.EPSILON;
            aabb.upperBound.x += org.jbox2d.common.Settings.EPSILON;
            aabb.upperBound.y += org.jbox2d.common.Settings.EPSILON;
        }

        /**
         * @see Shape#testPoint(XForm, Vec2)
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.Vec2} p
         * @return {boolean}
         */
        public testPoint(xf : org.jbox2d.common.XForm, p : org.jbox2d.common.Vec2) : boolean {
            return false;
        }

        static tlS : org.jbox2d.pooling.TLVec2; public static tlS_$LI$() : org.jbox2d.pooling.TLVec2 { if(PointShape.tlS == null) PointShape.tlS = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlS; };

        static tlPosition : org.jbox2d.pooling.TLVec2; public static tlPosition_$LI$() : org.jbox2d.pooling.TLVec2 { if(PointShape.tlPosition == null) PointShape.tlPosition = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlPosition; };

        static tlR : org.jbox2d.pooling.TLVec2; public static tlR_$LI$() : org.jbox2d.pooling.TLVec2 { if(PointShape.tlR == null) PointShape.tlR = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlR; };

        /**
         * @see Shape#testSegment(XForm, RaycastResult, Segment, float)
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.RaycastResult} out
         * @param {org.jbox2d.collision.Segment} segment
         * @param {number} maxLambda
         * @return {org.jbox2d.collision.SegmentCollide}
         */
        public testSegment(xf : org.jbox2d.common.XForm, out : org.jbox2d.common.RaycastResult, segment : org.jbox2d.collision.Segment, maxLambda : number) : org.jbox2d.collision.SegmentCollide {
            let position : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointShape.tlPosition_$LI$());
            let s : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointShape.tlS_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, this.m_localPosition, position);
            position.addLocal$org_jbox2d_common_Vec2(xf.position);
            s.set$org_jbox2d_common_Vec2(segment.p1);
            s.subLocal(position);
            let b : number = org.jbox2d.common.Vec2.dot(s, s);
            if(b < 0.0) {
                return org.jbox2d.collision.SegmentCollide.STARTS_INSIDE_COLLIDE;
            }
            let r : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PointShape.tlR_$LI$());
            r.set$org_jbox2d_common_Vec2(segment.p2).subLocal(segment.p1);
            let c : number = org.jbox2d.common.Vec2.dot(s, r);
            let rr : number = org.jbox2d.common.Vec2.dot(r, r);
            let sigma : number = (<any>Math).fround((<any>Math).fround(c * c) - (<any>Math).fround(rr * b));
            if(sigma < 0.0 || rr < org.jbox2d.common.Settings.EPSILON) {
                return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
            }
            let a : number = -((<any>Math).fround(c + org.jbox2d.common.MathUtils.sqrt(sigma)));
            if(0.0 <= a && a <= (<any>Math).fround(maxLambda * rr)) {
                a /= rr;
                out.lambda = a;
                out.normal.set$org_jbox2d_common_Vec2(r).mulLocal(a).addLocal$org_jbox2d_common_Vec2(s);
                out.normal.normalize();
                return org.jbox2d.collision.SegmentCollide.HIT_COLLIDE;
            }
            return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
        }

        /**
         * @see Shape#updateSweepRadius(Vec2)
         * @param {org.jbox2d.common.Vec2} center
         */
        public updateSweepRadius(center : org.jbox2d.common.Vec2) {
            let dx : number = (<any>Math).fround(this.m_localPosition.x - center.x);
            let dy : number = (<any>Math).fround(this.m_localPosition.y - center.y);
            this.m_sweepRadius = (<any>Math).fround(org.jbox2d.common.MathUtils.sqrt((<any>Math).fround((<any>Math).fround(dx * dx) + (<any>Math).fround(dy * dy))) - org.jbox2d.common.Settings.toiSlop_$LI$());
        }

        /**
         * @return {org.jbox2d.common.Vec2} a copy of local position
         */
        public getLocalPosition() : org.jbox2d.common.Vec2 {
            return /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this.m_localPosition);
        }

        /**
         * This is the member variable for the local position.
         * Don't change this.
         * @return
         * @return {org.jbox2d.common.Vec2}
         */
        public getMemberLocalPosition() : org.jbox2d.common.Vec2 {
            return this.m_localPosition;
        }

        public getMass() : number {
            return this.m_mass;
        }
    }
    PointShape["__class"] = "org.jbox2d.collision.shapes.PointShape";

}
namespace org.jbox2d.collision.shapes {
    /**
     * A convex polygon shape.  Create using Body.createShape(ShapeDef), not the constructor here.
     * @param {org.jbox2d.collision.shapes.ShapeDef} def
     * @class
     * @extends org.jbox2d.collision.shapes.Shape
     */
    export class PolygonShape extends org.jbox2d.collision.shapes.Shape implements org.jbox2d.collision.SupportsGenericDistance {
        /**
         * Dump lots of debug information.
         */
        static m_debug : boolean = false;

        /**
         * Local position of the shape centroid in parent body frame.
         */
        public m_centroid : org.jbox2d.common.Vec2;

        /**
         * The oriented bounding box of the shape.
         */
        public m_obb : org.jbox2d.collision.OBB;

        /**
         * The vertices of the shape.  Note: use getVertexCount(), not m_vertices.length, to get number of active vertices.
         */
        public m_vertices : org.jbox2d.common.Vec2[];

        /**
         * The normals of the shape.  Note: use getVertexCount(), not m_normals.length, to get number of active normals.
         */
        public m_normals : org.jbox2d.common.Vec2[];

        /**
         * The normals of the shape.  Note: use getVertexCount(), not m_coreVertices.length, to get number of active vertices.
         */
        public m_coreVertices : org.jbox2d.common.Vec2[];

        /**
         * Number of active vertices in the shape.
         */
        public m_vertexCount : number;

        static tlEdge : org.jbox2d.pooling.TLVec2; public static tlEdge_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlEdge == null) PolygonShape.tlEdge = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlEdge; };

        static tlV : org.jbox2d.pooling.TLVec2; public static tlV_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlV == null) PolygonShape.tlV = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlV; };

        static tlD : org.jbox2d.pooling.TLVec2; public static tlD_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlD == null) PolygonShape.tlD = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlD; };

        static tlA : org.jbox2d.pooling.TLMat22; public static tlA_$LI$() : org.jbox2d.pooling.TLMat22 { if(PolygonShape.tlA == null) PolygonShape.tlA = (() => { let __o : any = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return PolygonShape.tlA; };

        public constructor(def : org.jbox2d.collision.shapes.ShapeDef) {
            super(def);
            if(this.m_centroid===undefined) this.m_centroid = null;
            if(this.m_obb===undefined) this.m_obb = null;
            if(this.m_vertices===undefined) this.m_vertices = null;
            if(this.m_normals===undefined) this.m_normals = null;
            if(this.m_coreVertices===undefined) this.m_coreVertices = null;
            if(this.m_vertexCount===undefined) this.m_vertexCount = 0;
            if(!((def.type === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE))) throw new Error("Assertion error line 60: assert (def.type == ShapeType.POLYGON_SHAPE);");;
            this.m_type = org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE;
            let poly : org.jbox2d.collision.shapes.PolygonDef = <org.jbox2d.collision.shapes.PolygonDef>def;
            this.m_vertexCount = poly.getVertexCount();
            this.m_vertices = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_vertexCount);
            this.m_normals = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_vertexCount);
            this.m_coreVertices = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.m_vertexCount);
            this.m_obb = new org.jbox2d.collision.OBB();
            if(!((3 <= this.m_vertexCount && this.m_vertexCount <= org.jbox2d.common.Settings.maxPolygonVertices))) throw new Error("Assertion error line 68: assert (3 <= m_vertexCount && m_vertexCount <= Settings.maxPolygonVertices);");;
            for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                this.m_vertices[i] = /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(/* get */poly.vertices[i]);
            };}
            let edge : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlEdge_$LI$());
            for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                let i1 : number = i;
                let i2 : number = i + 1 < this.m_vertexCount?i + 1:0;
                edge.set$org_jbox2d_common_Vec2(this.m_vertices[i2]).subLocal(this.m_vertices[i1]);
                if(!((edge.lengthSquared() > (<any>Math).fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON)))) throw new Error("Assertion error line 77: assert (edge.lengthSquared() > Settings.EPSILON * Settings.EPSILON);");;
                this.m_normals[i] = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(edge, 1.0);
                this.m_normals[i].normalize();
            };}
            if(PolygonShape.m_debug) {
                for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                    for(let j : number = 0; j < this.m_vertexCount; ++j) {{
                        if(j === i || j === (i + 1) % this.m_vertexCount) {
                            continue;
                        }
                        if(!((org.jbox2d.common.Vec2.dot(this.m_normals[i], this.m_vertices[j].sub(this.m_vertices[i])) < -org.jbox2d.common.Settings.linearSlop_$LI$()))) throw new Error("Assertion error line 87: assert (Vec2.dot(m_normals[i], m_vertices[j].sub(m_vertices[i])) < -Settings.linearSlop);");;
                    };}
                };}
                for(let i : number = 1; i < this.m_vertexCount; ++i) {{
                    let cross : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_normals[i - 1], this.m_normals[i]);
                    cross = org.jbox2d.common.MathUtils.clamp$float$float$float(cross, -1.0, 1.0);
                    let angle : number = (<any>Math).fround(Math.asin(cross));
                    if(!((angle > org.jbox2d.common.Settings.angularSlop_$LI$()))) throw new Error("Assertion error line 94: assert (angle > Settings.angularSlop);");;
                };}
            }
            this.m_centroid = PolygonShape.computeCentroid(poly.vertices);
            PolygonShape.computeOBB(this.m_obb, this.m_vertices);
            let v : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlV_$LI$());
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlD_$LI$());
            let A : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlA_$LI$());
            for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                let i1 : number = i - 1 >= 0?i - 1:this.m_vertexCount - 1;
                let i2 : number = i;
                let n1 : org.jbox2d.common.Vec2 = this.m_normals[i1];
                let n2 : org.jbox2d.common.Vec2 = this.m_normals[i2];
                v.set$org_jbox2d_common_Vec2(this.m_vertices[i]).subLocal(this.m_centroid);
                d.x = (<any>Math).fround(org.jbox2d.common.Vec2.dot(n1, v) - org.jbox2d.common.Settings.toiSlop_$LI$());
                d.y = (<any>Math).fround(org.jbox2d.common.Vec2.dot(n2, v) - org.jbox2d.common.Settings.toiSlop_$LI$());
                if((d.x < 0.0 || d.y < 0.0)) {
                    console.info("Error, polygon extents less than b2_toiSlop, dumping details: ");
                    console.info("d.x: " + d.x + "d.y: " + d.y);
                    console.info("n1: " + n1 + "; n2: " + n2);
                    console.info("v: " + v);
                }
                if(!((d.x >= 0.0))) throw new Error("Assertion error line 116: assert (d.x >= 0.0F);");;
                if(!((d.y >= 0.0))) throw new Error("Assertion error line 117: assert (d.y >= 0.0F);");;
                A.col1.x = n1.x;
                A.col2.x = n1.y;
                A.col1.y = n2.x;
                A.col2.y = n2.y;
                this.m_coreVertices[i] = A.solve(d).addLocal$org_jbox2d_common_Vec2(this.m_centroid);
            };}
            if(PolygonShape.m_debug) {
                console.info("\nDumping polygon shape...");
                console.info("Vertices: ");
                for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                    console.info(this.m_vertices[i]);
                };}
                console.info("Core Vertices: ");
                for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                    console.info(this.m_coreVertices[i]);
                };}
                console.info("Normals: ");
                for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                    console.info(this.m_normals[i]);
                };}
                console.info("Centroid: " + this.m_centroid);
            }
        }

        /**
         * @see Shape#updateSweepRadius(Vec2)
         * @param {org.jbox2d.common.Vec2} center
         */
        public updateSweepRadius(center : org.jbox2d.common.Vec2) {
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlD_$LI$());
            this.m_sweepRadius = 0.0;
            for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                d.set$org_jbox2d_common_Vec2(this.m_coreVertices[i]);
                d.subLocal(center);
                this.m_sweepRadius = org.jbox2d.common.MathUtils.max$float$float(this.m_sweepRadius, d.length());
            };}
        }

        static tlTemp : org.jbox2d.pooling.TLVec2; public static tlTemp_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlTemp == null) PolygonShape.tlTemp = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlTemp; };

        static tlPLocal : org.jbox2d.pooling.TLVec2; public static tlPLocal_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlPLocal == null) PolygonShape.tlPLocal = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlPLocal; };

        /**
         * @see Shape#testPoint(XForm, Vec2)
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.Vec2} p
         * @return {boolean}
         */
        public testPoint(xf : org.jbox2d.common.XForm, p : org.jbox2d.common.Vec2) : boolean {
            let temp : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlTemp_$LI$());
            let pLocal : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlPLocal_$LI$());
            temp.set$org_jbox2d_common_Vec2(p);
            temp.subLocal(xf.position);
            org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, temp, pLocal);
            if(PolygonShape.m_debug) {
                console.info("--testPoint debug--");
                console.info("Vertices: ");
                for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                    console.info(this.m_vertices[i]);
                };}
                console.info("pLocal: " + pLocal);
            }
            for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                temp.set$org_jbox2d_common_Vec2(pLocal);
                temp.subLocal(this.m_vertices[i]);
                let dot : number = org.jbox2d.common.Vec2.dot(this.m_normals[i], temp);
                if(dot > 0.0) {
                    return false;
                }
            };}
            return true;
        }

        static tlP1 : org.jbox2d.pooling.TLVec2; public static tlP1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlP1 == null) PolygonShape.tlP1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlP1; };

        static tlP2 : org.jbox2d.pooling.TLVec2; public static tlP2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlP2 == null) PolygonShape.tlP2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlP2; };

        /**
         * @see Shape#testSegment(XForm, RaycastResult, Segment, float)
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.RaycastResult} out
         * @param {org.jbox2d.collision.Segment} segment
         * @param {number} maxLambda
         * @return {org.jbox2d.collision.SegmentCollide}
         */
        public testSegment(xf : org.jbox2d.common.XForm, out : org.jbox2d.common.RaycastResult, segment : org.jbox2d.collision.Segment, maxLambda : number) : org.jbox2d.collision.SegmentCollide {
            let lower : number = 0.0;
            let upper : number = maxLambda;
            let p1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlP1_$LI$());
            let p2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlP2_$LI$());
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlD_$LI$());
            let temp : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlTemp_$LI$());
            p1.set$org_jbox2d_common_Vec2(segment.p1).subLocal(xf.position);
            org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, p1, p1);
            p2.set$org_jbox2d_common_Vec2(segment.p2).subLocal(xf.position);
            org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, p2, p2);
            d.set$org_jbox2d_common_Vec2(p2).subLocal(p1);
            let index : number = -1;
            for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                temp.set$org_jbox2d_common_Vec2(this.m_vertices[i]).subLocal(p1);
                let numerator : number = org.jbox2d.common.Vec2.dot(this.m_normals[i], temp);
                let denominator : number = org.jbox2d.common.Vec2.dot(this.m_normals[i], d);
                if(denominator === 0.0) {
                    if(numerator < 0.0) {
                        return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
                    }
                }
                if(denominator < 0.0 && numerator < (<any>Math).fround(lower * denominator)) {
                    lower = (<any>Math).fround(numerator / denominator);
                    index = i;
                } else if(denominator > 0.0 && numerator < (<any>Math).fround(upper * denominator)) {
                    upper = (<any>Math).fround(numerator / denominator);
                }
                if(upper < lower) {
                    return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
                }
            };}
            if(!((0.0 <= lower && lower <= maxLambda))) throw new Error("Assertion error line 235: assert (0.0F <= lower && lower <= maxLambda);");;
            if(index >= 0) {
                out.lambda = lower;
                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, this.m_normals[index], out.normal);
                return org.jbox2d.collision.SegmentCollide.HIT_COLLIDE;
            }
            out.lambda = 0.0;
            return org.jbox2d.collision.SegmentCollide.STARTS_INSIDE_COLLIDE;
        }

        static tlSupDLocal : org.jbox2d.pooling.TLVec2; public static tlSupDLocal_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlSupDLocal == null) PolygonShape.tlSupDLocal = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlSupDLocal; };

        /**
         * Get the support point in the given world direction.
         * Use the supplied transform.
         * @see SupportsGenericDistance#support(Vec2, XForm, Vec2)
         * @param {org.jbox2d.common.Vec2} dest
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.Vec2} d
         */
        public support(dest : org.jbox2d.common.Vec2, xf : org.jbox2d.common.XForm, d : org.jbox2d.common.Vec2) {
            let supportDLocal : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlSupDLocal_$LI$());
            org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, d, supportDLocal);
            let bestIndex : number = 0;
            let bestValue : number = org.jbox2d.common.Vec2.dot(this.m_coreVertices[0], supportDLocal);
            for(let i : number = 1; i < this.m_vertexCount; ++i) {{
                let value : number = org.jbox2d.common.Vec2.dot(this.m_coreVertices[i], supportDLocal);
                if(value > bestValue) {
                    bestIndex = i;
                    bestValue = value;
                }
            };}
            org.jbox2d.common.XForm.mulToOut(xf, this.m_coreVertices[bestIndex], dest);
        }

        static tlPRef : org.jbox2d.pooling.TLVec2; public static tlPRef_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlPRef == null) PolygonShape.tlPRef = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlPRef; };

        static tlE1 : org.jbox2d.pooling.TLVec2; public static tlE1_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlE1 == null) PolygonShape.tlE1 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlE1; };

        static tlE2 : org.jbox2d.pooling.TLVec2; public static tlE2_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlE2 == null) PolygonShape.tlE2 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlE2; };

        public static computeCentroid(vs : Array<org.jbox2d.common.Vec2>) : org.jbox2d.common.Vec2 {
            let count : number = /* size */(<number>vs.length);
            if(!((count >= 3))) throw new Error("Assertion error line 278: assert (count >= 3);");;
            let c : org.jbox2d.common.Vec2 = new org.jbox2d.common.Vec2();
            let area : number = 0.0;
            let pRef : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlPRef_$LI$());
            pRef.setZero();
            let inv3 : number = (<any>Math).fround(1.0 / 3.0);
            let e1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlE1_$LI$());
            let e2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlE2_$LI$());
            let p1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlP1_$LI$());
            for(let i : number = 0; i < count; ++i) {{
                p1.set$org_jbox2d_common_Vec2(pRef);
                let p2 : org.jbox2d.common.Vec2 = /* get */vs[i];
                let p3 : org.jbox2d.common.Vec2 = i + 1 < count?/* get */vs[i + 1]:/* get */vs[0];
                e1.set$org_jbox2d_common_Vec2(p2).subLocal(p1);
                e2.set$org_jbox2d_common_Vec2(p3).subLocal(p1);
                let D : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2);
                let triangleArea : number = (<any>Math).fround(0.5 * D);
                area += triangleArea;
                c.x += (<any>Math).fround((<any>Math).fround(triangleArea * inv3) * ((<any>Math).fround((<any>Math).fround(p1.x + p2.x) + p3.x)));
                c.y += (<any>Math).fround((<any>Math).fround(triangleArea * inv3) * ((<any>Math).fround((<any>Math).fround(p1.y + p2.y) + p3.y)));
            };}
            if(!((area > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 299: assert (area > Settings.EPSILON);");;
            c.mulLocal((<any>Math).fround(1.0 / area));
            return c;
        }

        static tlUX : org.jbox2d.pooling.TLVec2; public static tlUX_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlUX == null) PolygonShape.tlUX = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlUX; };

        static tlUY : org.jbox2d.pooling.TLVec2; public static tlUY_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlUY == null) PolygonShape.tlUY = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlUY; };

        static tlLower : org.jbox2d.pooling.TLVec2; public static tlLower_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlLower == null) PolygonShape.tlLower = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlLower; };

        static tlUpper : org.jbox2d.pooling.TLVec2; public static tlUpper_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlUpper == null) PolygonShape.tlUpper = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlUpper; };

        static tlR : org.jbox2d.pooling.TLVec2; public static tlR_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlR == null) PolygonShape.tlR = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlR; };

        static tlCenter : org.jbox2d.pooling.TLVec2; public static tlCenter_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlCenter == null) PolygonShape.tlCenter = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlCenter; };

        public static computeOBB(obb : org.jbox2d.collision.OBB, vs : org.jbox2d.common.Vec2[]) {
            let count : number = vs.length;
            if(!((count <= org.jbox2d.common.Settings.maxPolygonVertices))) throw new Error("Assertion error line 318: assert (count <= Settings.maxPolygonVertices);");;
            let ux : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlUX_$LI$());
            let uy : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlUY_$LI$());
            let lower : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlLower_$LI$());
            let upper : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlUpper_$LI$());
            let d : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlD_$LI$());
            let r : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlR_$LI$());
            let center : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlCenter_$LI$());
            let pRay : org.jbox2d.common.Vec2[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(org.jbox2d.common.Settings.maxPolygonVertices + 1);
            for(let i : number = 0; i < count; ++i) {{
                pRay[i] = vs[i];
            };}
            pRay[count] = pRay[0];
            let minArea : number = 3.4028235E38;
            for(let i : number = 1; i <= count; ++i) {{
                let root : org.jbox2d.common.Vec2 = pRay[i - 1];
                ux.set$org_jbox2d_common_Vec2(pRay[i]);
                ux.subLocal(root);
                let length : number = ux.normalize();
                if(!((length > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 337: assert (length > Settings.EPSILON);");;
                uy.x = -ux.y;
                uy.y = ux.x;
                lower.x = 3.4028235E38;
                lower.y = 3.4028235E38;
                upper.x = -3.4028235E38;
                upper.y = -3.4028235E38;
                for(let j : number = 0; j < count; ++j) {{
                    d.set$org_jbox2d_common_Vec2(pRay[j]);
                    d.subLocal(root);
                    r.x = org.jbox2d.common.Vec2.dot(ux, d);
                    r.y = org.jbox2d.common.Vec2.dot(uy, d);
                    org.jbox2d.common.Vec2.minToOut(lower, r, lower);
                    org.jbox2d.common.Vec2.maxToOut(upper, r, upper);
                };}
                let area : number = (<any>Math).fround(((<any>Math).fround(upper.x - lower.x)) * ((<any>Math).fround(upper.y - lower.y)));
                if(area < (<any>Math).fround(0.95 * minArea)) {
                    minArea = area;
                    obb.R.col1.set$org_jbox2d_common_Vec2(ux);
                    obb.R.col2.set$org_jbox2d_common_Vec2(uy);
                    center.set$float$float((<any>Math).fround(0.5 * ((<any>Math).fround(lower.x + upper.x))), (<any>Math).fround(0.5 * ((<any>Math).fround(lower.y + upper.y))));
                    org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(obb.R, center, obb.center);
                    obb.center.addLocal$org_jbox2d_common_Vec2(root);
                    obb.extents.x = (<any>Math).fround(0.5 * ((<any>Math).fround(upper.x - lower.x)));
                    obb.extents.y = (<any>Math).fround(0.5 * ((<any>Math).fround(upper.y - lower.y)));
                }
            };}
            if(!((minArea < 3.4028235E38))) throw new Error("Assertion error line 364: assert (minArea < Float.MAX_VALUE);");;
        }

        static tlCaabbR : org.jbox2d.pooling.TLMat22; public static tlCaabbR_$LI$() : org.jbox2d.pooling.TLMat22 { if(PolygonShape.tlCaabbR == null) PolygonShape.tlCaabbR = (() => { let __o : any = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return PolygonShape.tlCaabbR; };

        static tlCaabbH : org.jbox2d.pooling.TLVec2; public static tlCaabbH_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlCaabbH == null) PolygonShape.tlCaabbH = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlCaabbH; };

        /**
         * @see Shape#computeAABB(AABB, XForm)
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.XForm} xf
         */
        public computeAABB(aabb : org.jbox2d.collision.AABB, xf : org.jbox2d.common.XForm) {
            let caabbR : org.jbox2d.common.Mat22 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlCaabbR_$LI$());
            let caabbH : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlCaabbH_$LI$());
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(xf.R, this.m_obb.R, caabbR);
            caabbR.absLocal();
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(caabbR, this.m_obb.extents, caabbH);
            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, this.m_obb.center, aabb.lowerBound);
            aabb.lowerBound.addLocal$org_jbox2d_common_Vec2(xf.position);
            aabb.upperBound.set$org_jbox2d_common_Vec2(aabb.lowerBound);
            aabb.lowerBound.subLocal(caabbH);
            aabb.upperBound.addLocal$org_jbox2d_common_Vec2(caabbH);
        }

        static tlSwept1 : org.jbox2d.pooling.TLAABB; public static tlSwept1_$LI$() : org.jbox2d.pooling.TLAABB { if(PolygonShape.tlSwept1 == null) PolygonShape.tlSwept1 = (() => { let __o : any = new org.jbox2d.pooling.TLAABB(); __o.__delegate = new org.jbox2d.pooling.TLAABB(); return __o; })(); return PolygonShape.tlSwept1; };

        static tlSwept2 : org.jbox2d.pooling.TLAABB; public static tlSwept2_$LI$() : org.jbox2d.pooling.TLAABB { if(PolygonShape.tlSwept2 == null) PolygonShape.tlSwept2 = (() => { let __o : any = new org.jbox2d.pooling.TLAABB(); __o.__delegate = new org.jbox2d.pooling.TLAABB(); return __o; })(); return PolygonShape.tlSwept2; };

        /**
         * @see Shape#computeSweptAABB(AABB, XForm, XForm)
         * @param {org.jbox2d.collision.AABB} aabb
         * @param {org.jbox2d.common.XForm} transform1
         * @param {org.jbox2d.common.XForm} transform2
         */
        public computeSweptAABB(aabb : org.jbox2d.collision.AABB, transform1 : org.jbox2d.common.XForm, transform2 : org.jbox2d.common.XForm) {
            let sweptAABB1 : org.jbox2d.collision.AABB = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlSwept1_$LI$());
            let sweptAABB2 : org.jbox2d.collision.AABB = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlSwept2_$LI$());
            this.computeAABB(sweptAABB1, transform1);
            this.computeAABB(sweptAABB2, transform2);
            org.jbox2d.common.Vec2.minToOut(sweptAABB1.lowerBound, sweptAABB2.lowerBound, aabb.lowerBound);
            org.jbox2d.common.Vec2.maxToOut(sweptAABB1.upperBound, sweptAABB2.upperBound, aabb.upperBound);
        }

        public computeMass$org_jbox2d_collision_MassData(massData : org.jbox2d.collision.MassData) {
            this.computeMass$org_jbox2d_collision_MassData$float(massData, this.m_density);
        }

        public computeMass$org_jbox2d_collision_MassData$float(massData : org.jbox2d.collision.MassData, density : number) {
            if(!((this.m_vertexCount >= 3))) throw new Error("Assertion error line 413: assert (m_vertexCount >= 3);");;
            let center : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlCenter_$LI$());
            center.setZero();
            let area : number = 0.0;
            let I : number = 0.0;
            let pRef : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlPRef_$LI$());
            pRef.setZero();
            let k_inv3 : number = (<any>Math).fround(1.0 / 3.0);
            let e1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlE1_$LI$());
            let e2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlE2_$LI$());
            for(let i : number = 0; i < this.m_vertexCount; ++i) {{
                let p1 : org.jbox2d.common.Vec2 = pRef;
                let p2 : org.jbox2d.common.Vec2 = this.m_vertices[i];
                let p3 : org.jbox2d.common.Vec2 = i + 1 < this.m_vertexCount?this.m_vertices[i + 1]:this.m_vertices[0];
                e1.set$org_jbox2d_common_Vec2(p2);
                e1.subLocal(p1);
                e2.set$org_jbox2d_common_Vec2(p3);
                e2.subLocal(p1);
                let D : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2);
                let triangleArea : number = (<any>Math).fround(0.5 * D);
                area += triangleArea;
                center.x += (<any>Math).fround((<any>Math).fround(triangleArea * k_inv3) * ((<any>Math).fround((<any>Math).fround(p1.x + p2.x) + p3.x)));
                center.y += (<any>Math).fround((<any>Math).fround(triangleArea * k_inv3) * ((<any>Math).fround((<any>Math).fround(p1.y + p2.y) + p3.y)));
                let px : number = p1.x;
                let py : number = p1.y;
                let ex1 : number = e1.x;
                let ey1 : number = e1.y;
                let ex2 : number = e2.x;
                let ey2 : number = e2.y;
                let intx2 : number = (<any>Math).fround((<any>Math).fround(k_inv3 * ((<any>Math).fround((<any>Math).fround(0.25 * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(ex1 * ex1) + (<any>Math).fround(ex2 * ex1)) + (<any>Math).fround(ex2 * ex2)))) + ((<any>Math).fround((<any>Math).fround(px * ex1) + (<any>Math).fround(px * ex2)))))) + (<any>Math).fround((<any>Math).fround(0.5 * px) * px));
                let inty2 : number = (<any>Math).fround((<any>Math).fround(k_inv3 * ((<any>Math).fround((<any>Math).fround(0.25 * ((<any>Math).fround((<any>Math).fround((<any>Math).fround(ey1 * ey1) + (<any>Math).fround(ey2 * ey1)) + (<any>Math).fround(ey2 * ey2)))) + ((<any>Math).fround((<any>Math).fround(py * ey1) + (<any>Math).fround(py * ey2)))))) + (<any>Math).fround((<any>Math).fround(0.5 * py) * py));
                I += (<any>Math).fround(D * ((<any>Math).fround(intx2 + inty2)));
            };}
            massData.mass = (<any>Math).fround(density * area);
            if(!((area > org.jbox2d.common.Settings.EPSILON))) throw new Error("Assertion error line 447: assert (area > Settings.EPSILON);");;
            center.mulLocal((<any>Math).fround(1.0 / area));
            massData.center.set$org_jbox2d_common_Vec2(center);
            massData.I = (<any>Math).fround(I * density);
        }

        /**
         * @see Shape#computeMass(MassData)
         * @param {org.jbox2d.collision.MassData} massData
         * @param {number} density
         */
        public computeMass(massData? : any, density? : any) : any {
            if(((massData != null && massData instanceof <any>org.jbox2d.collision.MassData) || massData === null) && ((typeof density === 'number') || density === null)) {
                return <any>this.computeMass$org_jbox2d_collision_MassData$float(massData, density);
            } else if(((massData != null && massData instanceof <any>org.jbox2d.collision.MassData) || massData === null) && density === undefined) {
                return <any>this.computeMass$org_jbox2d_collision_MassData(massData);
            } else throw new Error('invalid overload');
        }

        /**
         * Get the first vertex and apply the supplied transform.
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.Vec2} out
         */
        public getFirstVertexToOut(xf : org.jbox2d.common.XForm, out : org.jbox2d.common.Vec2) {
            org.jbox2d.common.XForm.mulToOut(xf, this.m_coreVertices[0], out);
        }

        /**
         * Get the oriented bounding box relative to the parent body.
         * @return {org.jbox2d.collision.OBB}
         */
        public getOBB() : org.jbox2d.collision.OBB {
            return /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this.m_obb);
        }

        /**
         * Get the local centroid relative to the parent body.
         * @return {org.jbox2d.common.Vec2}
         */
        public getCentroid() : org.jbox2d.common.Vec2 {
            return /* clone *//* clone */((o:any) => { if(o.clone!=undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this.m_centroid);
        }

        /**
         * Get the number of vertices.
         * @return {number}
         */
        public getVertexCount() : number {
            return this.m_vertexCount;
        }

        /**
         * Get the vertices in local coordinates.
         * @return {Array}
         */
        public getVertices() : org.jbox2d.common.Vec2[] {
            return this.m_vertices;
        }

        /**
         * Get the core vertices in local coordinates. These vertices
         * represent a smaller polygon that is used for time of impact
         * computations.
         * @return {Array}
         */
        public getCoreVertices() : org.jbox2d.common.Vec2[] {
            return this.m_coreVertices;
        }

        /**
         * Get the edge normal vectors.  There is one for each vertex.
         * @return {Array}
         */
        public getNormals() : org.jbox2d.common.Vec2[] {
            return this.m_normals;
        }

        /**
         * Get the centroid and apply the supplied transform.
         * @param {org.jbox2d.common.XForm} xf
         * @return {org.jbox2d.common.Vec2}
         */
        public centroid(xf : org.jbox2d.common.XForm) : org.jbox2d.common.Vec2 {
            return org.jbox2d.common.XForm.mul(xf, this.m_centroid);
        }

        static tlNormalL : org.jbox2d.pooling.TLVec2; public static tlNormalL_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlNormalL == null) PolygonShape.tlNormalL = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlNormalL; };

        static tlMd : org.jbox2d.pooling.TLMassData; public static tlMd_$LI$() : org.jbox2d.pooling.TLMassData { if(PolygonShape.tlMd == null) PolygonShape.tlMd = (() => { let __o : any = new org.jbox2d.pooling.TLMassData(); __o.__delegate = new org.jbox2d.pooling.TLMassData(); return __o; })(); return PolygonShape.tlMd; };

        static tlIntoVec : org.jbox2d.pooling.TLVec2; public static tlIntoVec_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlIntoVec == null) PolygonShape.tlIntoVec = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlIntoVec; };

        static tlOutoVec : org.jbox2d.pooling.TLVec2; public static tlOutoVec_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlOutoVec == null) PolygonShape.tlOutoVec = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlOutoVec; };

        static tlP2b : org.jbox2d.pooling.TLVec2; public static tlP2b_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlP2b == null) PolygonShape.tlP2b = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlP2b; };

        static tlP3 : org.jbox2d.pooling.TLVec2; public static tlP3_$LI$() : org.jbox2d.pooling.TLVec2 { if(PolygonShape.tlP3 == null) PolygonShape.tlP3 = (() => { let __o : any = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlP3; };

        public computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal : org.jbox2d.common.Vec2, offset : number, xf : org.jbox2d.common.XForm, c : org.jbox2d.common.Vec2) : number {
            let normalL : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlNormalL_$LI$());
            let md : org.jbox2d.collision.MassData = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlMd_$LI$());
            org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, normal, normalL);
            let offsetL : number = (<any>Math).fround(offset - org.jbox2d.common.Vec2.dot(normal, xf.position));
            let depths : number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(org.jbox2d.common.Settings.maxPolygonVertices);
            let diveCount : number = 0;
            let intoIndex : number = -1;
            let outoIndex : number = -1;
            let lastSubmerged : boolean = false;
            let i : number = 0;
            for(i = 0; i < this.m_vertexCount; ++i) {{
                depths[i] = (<any>Math).fround(org.jbox2d.common.Vec2.dot(normalL, this.m_vertices[i]) - offsetL);
                let isSubmerged : boolean = depths[i] < -org.jbox2d.common.Settings.EPSILON;
                if(i > 0) {
                    if(isSubmerged) {
                        if(!lastSubmerged) {
                            intoIndex = i - 1;
                            diveCount++;
                        }
                    } else {
                        if(lastSubmerged) {
                            outoIndex = i - 1;
                            diveCount++;
                        }
                    }
                }
                lastSubmerged = isSubmerged;
            };}
            switch((diveCount)) {
            case 0:
                if(lastSubmerged) {
                    this.computeMass$org_jbox2d_collision_MassData$float(md, 1.0);
                    org.jbox2d.common.XForm.mulToOut(xf, md.center, c);
                    return md.mass;
                } else {
                    return 0;
                }
            case 1:
                if(intoIndex === -1) {
                    intoIndex = this.m_vertexCount - 1;
                } else {
                    outoIndex = this.m_vertexCount - 1;
                }
                break;
            }
            let intoVec : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlIntoVec_$LI$());
            let outoVec : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlOutoVec_$LI$());
            let e1 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlE1_$LI$());
            let e2 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlE2_$LI$());
            let intoIndex2 : number = (intoIndex + 1) % this.m_vertexCount;
            let outoIndex2 : number = (outoIndex + 1) % this.m_vertexCount;
            let intoLambda : number = (<any>Math).fround(((<any>Math).fround(0 - depths[intoIndex])) / ((<any>Math).fround(depths[intoIndex2] - depths[intoIndex])));
            let outoLambda : number = (<any>Math).fround(((<any>Math).fround(0 - depths[outoIndex])) / ((<any>Math).fround(depths[outoIndex2] - depths[outoIndex])));
            intoVec.set$float$float((<any>Math).fround((<any>Math).fround(this.m_vertices[intoIndex].x * ((<any>Math).fround(1 - intoLambda))) + (<any>Math).fround(this.m_vertices[intoIndex2].x * intoLambda)), (<any>Math).fround((<any>Math).fround(this.m_vertices[intoIndex].y * ((<any>Math).fround(1 - intoLambda))) + (<any>Math).fround(this.m_vertices[intoIndex2].y * intoLambda)));
            outoVec.set$float$float((<any>Math).fround((<any>Math).fround(this.m_vertices[outoIndex].x * ((<any>Math).fround(1 - outoLambda))) + (<any>Math).fround(this.m_vertices[outoIndex2].x * outoLambda)), (<any>Math).fround((<any>Math).fround(this.m_vertices[outoIndex].y * ((<any>Math).fround(1 - outoLambda))) + (<any>Math).fround(this.m_vertices[outoIndex2].y * outoLambda)));
            let area : number = 0;
            let center : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlCenter_$LI$());
            center.setZero();
            let p2b : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlP2b_$LI$()).set$org_jbox2d_common_Vec2(this.m_vertices[intoIndex2]);
            let p3 : org.jbox2d.common.Vec2 = /* get */((tlObj: any) => {    if (tlObj.___value) { return tlObj.___value }     else { return tlObj.___value = tlObj.initialValue() }   })(PolygonShape.tlP3_$LI$());
            p3.setZero();
            let k_inv3 : number = (<any>Math).fround(1.0 / 3.0);
            i = intoIndex2;
            while((i !== outoIndex2)) {{
                i = (i + 1) % this.m_vertexCount;
                if(i === outoIndex2) {
                    p3.set$org_jbox2d_common_Vec2(outoVec);
                } else {
                    p3.set$org_jbox2d_common_Vec2(this.m_vertices[i]);
                }
                {
                    e1.set$org_jbox2d_common_Vec2(p2b).subLocal(intoVec);
                    e2.set$org_jbox2d_common_Vec2(p3).subLocal(intoVec);
                    let D : number = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2);
                    let triangleArea : number = (<any>Math).fround(0.5 * D);
                    area += triangleArea;
                    center.x += (<any>Math).fround((<any>Math).fround(triangleArea * k_inv3) * ((<any>Math).fround((<any>Math).fround(intoVec.x + p2b.x) + p3.x)));
                    center.y += (<any>Math).fround((<any>Math).fround(triangleArea * k_inv3) * ((<any>Math).fround((<any>Math).fround(intoVec.y + p2b.y) + p3.y)));
                };
                p2b.set$org_jbox2d_common_Vec2(p3);
            }};
            center.x *= (<any>Math).fround(1.0 / area);
            center.y *= (<any>Math).fround(1.0 / area);
            org.jbox2d.common.XForm.mulToOut(xf, center, c);
            return area;
        }

        /**
         * @see Shape#computeSubmergedArea(Vec2, float, XForm, Vec2)
         * @param {org.jbox2d.common.Vec2} normal
         * @param {number} offset
         * @param {org.jbox2d.common.XForm} xf
         * @param {org.jbox2d.common.Vec2} c
         * @return {number}
         */
        public computeSubmergedArea(normal? : any, offset? : any, xf? : any, c? : any) : any {
            if(((normal != null && normal instanceof <any>org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof <any>org.jbox2d.common.XForm) || xf === null) && ((c != null && c instanceof <any>org.jbox2d.common.Vec2) || c === null)) {
                return <any>this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, xf, c);
            } else if(((normal != null && normal instanceof <any>org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof <any>org.jbox2d.common.Vec2) || xf === null) && c === undefined) {
                return <any>this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(normal, offset, xf);
            } else throw new Error('invalid overload');
        }
    }
    PolygonShape["__class"] = "org.jbox2d.collision.shapes.PolygonShape";
    PolygonShape["__interfaces"] = ["org.jbox2d.collision.SupportsGenericDistance"];


}

var __Function = Function;

org.jbox2d.collision.shapes.PolygonShape.tlP3_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlP2b_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlOutoVec_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlIntoVec_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlMd_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlNormalL_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlSwept2_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlSwept1_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlCaabbH_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlCaabbR_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlCenter_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlR_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlUpper_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlLower_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlUY_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlUX_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlE2_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlE1_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlPRef_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlSupDLocal_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlP2_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlP1_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlPLocal_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlTemp_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlA_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlD_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlV_$LI$();

org.jbox2d.collision.shapes.PolygonShape.tlEdge_$LI$();

org.jbox2d.collision.shapes.PointShape.tlR_$LI$();

org.jbox2d.collision.shapes.PointShape.tlPosition_$LI$();

org.jbox2d.collision.shapes.PointShape.tlS_$LI$();

org.jbox2d.collision.shapes.PointShape.tlSwept2_$LI$();

org.jbox2d.collision.shapes.PointShape.tlSwept1_$LI$();

org.jbox2d.collision.shapes.PointShape.tlP_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlE2_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlE1_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlTemp_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlV0_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlSupportV2_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlSupportV1_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlSwept4_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlSwept3_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlSwept2_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlSwept1_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlV2_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlB_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlN_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlD_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlV1_$LI$();

org.jbox2d.collision.shapes.EdgeShape.tlR_$LI$();

org.jbox2d.collision.shapes.CircleShape.tlP_$LI$();

org.jbox2d.collision.shapes.CircleShape.tlR_$LI$();

org.jbox2d.collision.shapes.CircleShape.tlPosition_$LI$();

org.jbox2d.collision.shapes.CircleShape.tlS_$LI$();

org.jbox2d.collision.shapes.CircleShape.tlCenter_$LI$();

org.jbox2d.dynamics.World.LIQUID_INT_$LI$();

org.jbox2d.dynamics.World.steps_$LI$();

org.jbox2d.dynamics.World.islands_$LI$();

org.jbox2d.dynamics.World.tlStep_$LI$();

org.jbox2d.dynamics.Island.contactSolvers_$LI$();

org.jbox2d.dynamics.joints.ConstantVolumeJoint.tlD_$LI$();

org.jbox2d.collision.BroadPhase.tlResults_$LI$();

org.jbox2d.collision.BroadPhase.tlOldValues_$LI$();

org.jbox2d.collision.BroadPhase.tlNewValues_$LI$();

org.jbox2d.collision.BroadPhase.tlIgnored_$LI$();

org.jbox2d.collision.BroadPhase.tlIndexes_$LI$();

org.jbox2d.collision.BroadPhase.tlUpperValues_$LI$();

org.jbox2d.collision.BroadPhase.tlLowerValues_$LI$();

org.jbox2d.collision.BroadPhase.NULL_EDGE_$LI$();

org.jbox2d.collision.BroadPhase.INVALID_$LI$();

org.jbox2d.dynamics.contacts.PolyAndEdgeContact.tlPersisted_$LI$();

org.jbox2d.dynamics.contacts.PolyAndEdgeContact.tlCp_$LI$();

org.jbox2d.dynamics.contacts.PolyAndEdgeContact.tlV1_$LI$();

org.jbox2d.dynamics.contacts.PolyAndEdgeContact.tlm0_$LI$();

org.jbox2d.dynamics.contacts.PolyAndCircleContact.tlPersisted_$LI$();

org.jbox2d.dynamics.contacts.PolyAndCircleContact.tlCp_$LI$();

org.jbox2d.dynamics.contacts.PolyAndCircleContact.tlV1_$LI$();

org.jbox2d.dynamics.contacts.PolyAndCircleContact.tlm0_$LI$();

org.jbox2d.dynamics.contacts.PointAndPolyContact.tlPersisted_$LI$();

org.jbox2d.dynamics.contacts.PointAndPolyContact.tlCp_$LI$();

org.jbox2d.dynamics.contacts.PointAndPolyContact.tlV1_$LI$();

org.jbox2d.dynamics.contacts.PointAndPolyContact.tlm0_$LI$();

org.jbox2d.dynamics.Body.tlXf1_$LI$();

org.jbox2d.dynamics.Body.tlCenter_$LI$();

org.jbox2d.dynamics.Body.idLock_$LI$();

org.jbox2d.collision.TOI.tlP2_$LI$();

org.jbox2d.collision.TOI.tlP1_$LI$();

org.jbox2d.collision.TOI.tlxf2_$LI$();

org.jbox2d.collision.TOI.tlxf1_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlimpulse_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlptpC_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlp2_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlp1_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlpivotForce_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlpivotCdot_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tltemp_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlK3_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlK2_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlK1_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlr2_$LI$();

org.jbox2d.dynamics.joints.RevoluteJoint.tlr1_$LI$();

org.jbox2d.dynamics.joints.PulleyJoint.tlv2_$LI$();

org.jbox2d.dynamics.joints.PulleyJoint.tlv1_$LI$();

org.jbox2d.dynamics.joints.PulleyJoint.tlP2_$LI$();

org.jbox2d.dynamics.joints.PulleyJoint.tlP1_$LI$();

org.jbox2d.dynamics.joints.PulleyJoint.tls2_$LI$();

org.jbox2d.dynamics.joints.PulleyJoint.tls1_$LI$();

org.jbox2d.dynamics.joints.PulleyJoint.tlp2_$LI$();

org.jbox2d.dynamics.joints.PulleyJoint.tlp1_$LI$();

org.jbox2d.dynamics.joints.PulleyJoint.tlr2_$LI$();

org.jbox2d.dynamics.joints.PulleyJoint.tlr1_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlreactionAx1_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlw1xR1_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlw2xR2_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlv22_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlw1xAxis_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlaxis_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tldz_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlp2z_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlp1z_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlr2z_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlr1z_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlp2_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlp1_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tltemp_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tld_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlay1Neg_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlax1Neg_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tle_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlay1_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlax1_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlr2_$LI$();

org.jbox2d.dynamics.joints.PrismaticJoint.tlr1_$LI$();

org.jbox2d.dynamics.joints.MouseJoint.tlP_$LI$();

org.jbox2d.dynamics.joints.MouseJoint.tloldForce_$LI$();

org.jbox2d.dynamics.joints.MouseJoint.tlforce_$LI$();

org.jbox2d.dynamics.joints.MouseJoint.tlCdot_$LI$();

org.jbox2d.dynamics.joints.MouseJoint.tlK2_$LI$();

org.jbox2d.dynamics.joints.MouseJoint.tlK1_$LI$();

org.jbox2d.dynamics.joints.MouseJoint.tlr_$LI$();

org.jbox2d.dynamics.joints.MouseJoint.tlanchor2_$LI$();

org.jbox2d.dynamics.joints.DistanceJoint.tlv2_$LI$();

org.jbox2d.dynamics.joints.DistanceJoint.tlv1_$LI$();

org.jbox2d.dynamics.joints.DistanceJoint.tld_$LI$();

org.jbox2d.dynamics.joints.DistanceJoint.tlP_$LI$();

org.jbox2d.dynamics.joints.DistanceJoint.tlr2_$LI$();

org.jbox2d.dynamics.joints.DistanceJoint.tlr1_$LI$();

org.jbox2d.dynamics.joints.DistanceJoint.tlReactionForce_$LI$();

org.jbox2d.dynamics.contacts.PolyContact.tlCp_$LI$();

org.jbox2d.dynamics.contacts.PolyContact.tlV1_$LI$();

org.jbox2d.dynamics.contacts.PolyContact.tlm0_$LI$();

org.jbox2d.dynamics.contacts.PointAndCircleContact.tlCp_$LI$();

org.jbox2d.dynamics.contacts.PointAndCircleContact.tlV1_$LI$();

org.jbox2d.dynamics.contacts.PointAndCircleContact.tlm0_$LI$();

org.jbox2d.dynamics.contacts.EdgeAndCircleContact.tlCp_$LI$();

org.jbox2d.dynamics.contacts.EdgeAndCircleContact.tlV1_$LI$();

org.jbox2d.dynamics.contacts.EdgeAndCircleContact.tlm0_$LI$();

org.jbox2d.dynamics.contacts.CircleContact.tlCp_$LI$();

org.jbox2d.dynamics.contacts.CircleContact.tlV1_$LI$();

org.jbox2d.dynamics.contacts.CircleContact.tlm0_$LI$();

org.jbox2d.dynamics.ContactManager.tlCp_$LI$();

org.jbox2d.dynamics.ContactManager.tlV1_$LI$();

org.jbox2d.collision.Segment.tlB_$LI$();

org.jbox2d.collision.Segment.tlN_$LI$();

org.jbox2d.collision.Segment.tlD_$LI$();

org.jbox2d.collision.Segment.tlR_$LI$();

org.jbox2d.common.OBBViewportTransform.tlInv_$LI$();

org.jbox2d.collision.shapes.Shape.tlAabb_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.localOffset_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.position_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.p2world_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.p1world_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.p2_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.p1_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.v_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.v2_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.v1_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.center_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.p_$LI$();

org.jbox2d.testbed.ProcessingDebugDraw.circlePt_$LI$();

org.jbox2d.util.nonconvex.Polygon.maxPolygonVertices_$LI$();

org.jbox2d.util.nonconvex.Polygon.COLLAPSE_DIST_SQR_$LI$();

org.jbox2d.util.nonconvex.Polygon.toiSlop_$LI$();

org.jbox2d.common.MathUtils.cosLUT_$LI$();

org.jbox2d.common.MathUtils.sinLUT_$LI$();

org.jbox2d.common.MathUtils.TWOPI_$LI$();

org.jbox2d.common.MathUtils.PI_$LI$();

org.jbox2d.common.MathUtils.__static_initialize();

org.jbox2d.collision.PairManager.TABLE_MASK_$LI$();

org.jbox2d.collision.PairManager.TABLE_CAPACITY_$LI$();

org.jbox2d.collision.PairManager.NULL_PROXY_$LI$();

org.jbox2d.collision.PairManager.NULL_PAIR_$LI$();

org.jbox2d.testbed.mathtests.SinCosTable.TWOPI_$LI$();

org.jbox2d.pooling.SingletonPool.pool_$LI$();

org.jbox2d.common.XForm.identity_$LI$();

org.jbox2d.common.XForm.__static_initialize();

org.jbox2d.common.Settings.maxAngularVelocitySquared_$LI$();

org.jbox2d.common.Settings.maxLinearVelocitySquared_$LI$();

org.jbox2d.common.Settings.toiSlop_$LI$();

org.jbox2d.common.Settings.angularSleepTolerance_$LI$();

org.jbox2d.common.Settings.linearSleepTolerance_$LI$();

org.jbox2d.common.Settings.timeToSleep_$LI$();

org.jbox2d.common.Settings.maxAngularCorrection_$LI$();

org.jbox2d.common.Settings.maxLinearCorrection_$LI$();

org.jbox2d.common.Settings.velocityThreshold_$LI$();

org.jbox2d.common.Settings.angularSlop_$LI$();

org.jbox2d.common.Settings.linearSlop_$LI$();

org.jbox2d.common.Settings.maxPairs_$LI$();

org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$();

org.jbox2d.common.Settings.pi_$LI$();

org.jbox2d.common.Color3f.RED_$LI$();

org.jbox2d.common.Color3f.GREEN_$LI$();

org.jbox2d.common.Color3f.BLUE_$LI$();

org.jbox2d.common.Color3f.BLACK_$LI$();

org.jbox2d.common.Color3f.WHITE_$LI$();

org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
